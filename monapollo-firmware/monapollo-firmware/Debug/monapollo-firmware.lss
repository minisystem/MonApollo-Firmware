
monapollo-firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001b4  00800100  00003fea  0000409e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003fea  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000222  008002b4  008002b4  00004252  2**0
                  ALLOC
  3 .eeprom       00000674  00810000  00810000  00004252  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00000bf4  00000000  00000000  000048c8  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      0000033e  00000000  00000000  000054bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 000003b8  00000000  00000000  00005800  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00007113  00000000  00000000  00005bb8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000019e5  00000000  00000000  0000cccb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000024c7  00000000  00000000  0000e6b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000e20  00000000  00000000  00010b78  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001a4d  00000000  00000000  00011998  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002fe1  00000000  00000000  000133e5  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000138  00000000  00000000  000163c6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 32 00 	jmp	0x64	; 0x64 <__ctors_end>
       4:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
       8:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
       c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      10:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      14:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      18:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      1c:	0c 94 95 03 	jmp	0x72a	; 0x72a <__vector_7>
      20:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      24:	0c 94 89 03 	jmp	0x712	; 0x712 <__vector_9>
      28:	0c 94 4a 03 	jmp	0x694	; 0x694 <__vector_10>
      2c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      30:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      34:	0c 94 b0 04 	jmp	0x960	; 0x960 <__vector_13>
      38:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      3c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      40:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      44:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      48:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      4c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      50:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      54:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      58:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      5c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      60:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>

00000064 <__ctors_end>:
      64:	11 24       	eor	r1, r1
      66:	1f be       	out	0x3f, r1	; 63
      68:	cf ef       	ldi	r28, 0xFF	; 255
      6a:	d0 e1       	ldi	r29, 0x10	; 16
      6c:	de bf       	out	0x3e, r29	; 62
      6e:	cd bf       	out	0x3d, r28	; 61

00000070 <__do_copy_data>:
      70:	12 e0       	ldi	r17, 0x02	; 2
      72:	a0 e0       	ldi	r26, 0x00	; 0
      74:	b1 e0       	ldi	r27, 0x01	; 1
      76:	ea ee       	ldi	r30, 0xEA	; 234
      78:	ff e3       	ldi	r31, 0x3F	; 63
      7a:	02 c0       	rjmp	.+4      	; 0x80 <__do_copy_data+0x10>
      7c:	05 90       	lpm	r0, Z+
      7e:	0d 92       	st	X+, r0
      80:	a4 3b       	cpi	r26, 0xB4	; 180
      82:	b1 07       	cpc	r27, r17
      84:	d9 f7       	brne	.-10     	; 0x7c <__do_copy_data+0xc>

00000086 <__do_clear_bss>:
      86:	14 e0       	ldi	r17, 0x04	; 4
      88:	a4 eb       	ldi	r26, 0xB4	; 180
      8a:	b2 e0       	ldi	r27, 0x02	; 2
      8c:	01 c0       	rjmp	.+2      	; 0x90 <.do_clear_bss_start>

0000008e <.do_clear_bss_loop>:
      8e:	1d 92       	st	X+, r1

00000090 <.do_clear_bss_start>:
      90:	a6 3d       	cpi	r26, 0xD6	; 214
      92:	b1 07       	cpc	r27, r17
      94:	e1 f7       	brne	.-8      	; 0x8e <.do_clear_bss_loop>
      96:	0e 94 e5 04 	call	0x9ca	; 0x9ca <main>
      9a:	0c 94 f3 1f 	jmp	0x3fe6	; 0x3fe6 <_exit>

0000009e <__bad_interrupt>:
      9e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a2 <setup_adc>:

void setup_adc(void)
{
	//ADCSRA |= (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0); //set ADC clock to 156.25 KHz for 20 MHz clock
	//ADCSRA |= (1<<ADPS2) | (1<<ADPS1); //set ADC clock to 312.5 KHz for 20 MHz clock
	ADCSRA |= (1<<ADPS2);// | (1<<ADPS0); //set ADC clock to 1.25 MHz for 20 MHz clock
      a2:	ea e7       	ldi	r30, 0x7A	; 122
      a4:	f0 e0       	ldi	r31, 0x00	; 0
      a6:	80 81       	ld	r24, Z
      a8:	84 60       	ori	r24, 0x04	; 4
      aa:	80 83       	st	Z, r24
	ADMUX |= (1<<REFS0); //set ADC reference to AVCC (+5V)
      ac:	ac e7       	ldi	r26, 0x7C	; 124
      ae:	b0 e0       	ldi	r27, 0x00	; 0
      b0:	8c 91       	ld	r24, X
      b2:	80 64       	ori	r24, 0x40	; 64
      b4:	8c 93       	st	X, r24
	
	DIDR0 |= 0x01; //disable digital input buffer for ADC0
      b6:	ae e7       	ldi	r26, 0x7E	; 126
      b8:	b0 e0       	ldi	r27, 0x00	; 0
      ba:	8c 91       	ld	r24, X
      bc:	81 60       	ori	r24, 0x01	; 1
      be:	8c 93       	st	X, r24
	
	ADCSRA |= (1<<ADEN); //enable ADC
      c0:	80 81       	ld	r24, Z
      c2:	80 68       	ori	r24, 0x80	; 128
      c4:	80 83       	st	Z, r24
}
      c6:	08 95       	ret

000000c8 <read_pot>:

uint16_t read_pot(struct potentiometer *pot) {
      c8:	fc 01       	movw	r30, r24
	
	DATA_BUS = pot->channel;
      ca:	83 81       	ldd	r24, Z+3	; 0x03
      cc:	8f 70       	andi	r24, 0x0F	; 15
      ce:	82 b9       	out	0x02, r24	; 2
	POT_MUX &= ~(1<<pot->mux_addr);
      d0:	aa ed       	ldi	r26, 0xDA	; 218
      d2:	b0 e0       	ldi	r27, 0x00	; 0
      d4:	4c 91       	ld	r20, X
      d6:	83 81       	ldd	r24, Z+3	; 0x03
      d8:	82 95       	swap	r24
      da:	8f 70       	andi	r24, 0x0F	; 15
      dc:	87 70       	andi	r24, 0x07	; 7
      de:	21 e0       	ldi	r18, 0x01	; 1
      e0:	30 e0       	ldi	r19, 0x00	; 0
      e2:	b9 01       	movw	r22, r18
      e4:	02 c0       	rjmp	.+4      	; 0xea <read_pot+0x22>
      e6:	66 0f       	add	r22, r22
      e8:	77 1f       	adc	r23, r23
      ea:	8a 95       	dec	r24
      ec:	e2 f7       	brpl	.-8      	; 0xe6 <read_pot+0x1e>
      ee:	cb 01       	movw	r24, r22
      f0:	80 95       	com	r24
      f2:	84 23       	and	r24, r20
      f4:	8c 93       	st	X, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
      f6:	7d e0       	ldi	r23, 0x0D	; 13
      f8:	7a 95       	dec	r23
      fa:	f1 f7       	brne	.-4      	; 0xf8 <read_pot+0x30>
      fc:	00 00       	nop
	_delay_us(2); //ADC settling time. Previously used 10 us, testing 2 us now. Now testing 1 us. See how it sounds. Nope. Needs to 2 us minimum to prevent crosstalk between multiplexer channels
	ADCSRA |= (1<<ADSC); //start ADC conversion
      fe:	aa e7       	ldi	r26, 0x7A	; 122
     100:	b0 e0       	ldi	r27, 0x00	; 0
     102:	8c 91       	ld	r24, X
     104:	80 64       	ori	r24, 0x40	; 64
     106:	8c 93       	st	X, r24
	while ((ADCSRA & (1<<ADSC))); //wait for ADC conversion to complete (13 cycles of ADC clock - 10.4 us for 1.25Mhz clock) - need to figure out what to do with this time - would interrupt be more efficient?
     108:	8c 91       	ld	r24, X
     10a:	86 fd       	sbrc	r24, 6
     10c:	fd cf       	rjmp	.-6      	; 0x108 <read_pot+0x40>
	POT_MUX |= (1<<pot->mux_addr); //disable pot multiplexer
     10e:	aa ed       	ldi	r26, 0xDA	; 218
     110:	b0 e0       	ldi	r27, 0x00	; 0
     112:	4c 91       	ld	r20, X
     114:	83 81       	ldd	r24, Z+3	; 0x03
     116:	82 95       	swap	r24
     118:	8f 70       	andi	r24, 0x0F	; 15
     11a:	87 70       	andi	r24, 0x07	; 7
     11c:	21 e0       	ldi	r18, 0x01	; 1
     11e:	30 e0       	ldi	r19, 0x00	; 0
     120:	b9 01       	movw	r22, r18
     122:	02 c0       	rjmp	.+4      	; 0x128 <read_pot+0x60>
     124:	66 0f       	add	r22, r22
     126:	77 1f       	adc	r23, r23
     128:	8a 95       	dec	r24
     12a:	e2 f7       	brpl	.-8      	; 0x124 <read_pot+0x5c>
     12c:	cb 01       	movw	r24, r22
     12e:	84 2b       	or	r24, r20
     130:	8c 93       	st	X, r24
	//note that ADSC reads HIGH as long as conversion is in progress, goes LOW when conversion is complete
			
			
	uint16_t adc_read = ADCL;
     132:	80 91 78 00 	lds	r24, 0x0078
     136:	90 e0       	ldi	r25, 0x00	; 0
	adc_read = adc_read | (ADCH <<8);
     138:	40 91 79 00 	lds	r20, 0x0079
     13c:	34 2f       	mov	r19, r20
     13e:	20 e0       	ldi	r18, 0x00	; 0
     140:	82 2b       	or	r24, r18
     142:	93 2b       	or	r25, r19
			
	return adc_read;
     144:	08 95       	ret

00000146 <update_arp_sequence>:
//#include "display.h"

struct arp arp;


void update_arp_sequence(void) {
     146:	4f 92       	push	r4
     148:	5f 92       	push	r5
     14a:	6f 92       	push	r6
     14c:	7f 92       	push	r7
     14e:	8f 92       	push	r8
     150:	9f 92       	push	r9
     152:	af 92       	push	r10
     154:	bf 92       	push	r11
     156:	cf 92       	push	r12
     158:	df 92       	push	r13
     15a:	ef 92       	push	r14
     15c:	ff 92       	push	r15
     15e:	0f 93       	push	r16
     160:	1f 93       	push	r17
     162:	cf 93       	push	r28
     164:	df 93       	push	r29
	


	arp.step_number = gate_buffer*(arp.range + 1);
     166:	90 91 88 03 	lds	r25, 0x0388
     16a:	9f 5f       	subi	r25, 0xFF	; 255
     16c:	80 91 b4 02 	lds	r24, 0x02B4
     170:	98 9f       	mul	r25, r24
     172:	80 2d       	mov	r24, r0
     174:	11 24       	eor	r1, r1
     176:	80 93 89 03 	sts	0x0389, r24
     17a:	88 24       	eor	r8, r8
     17c:	99 24       	eor	r9, r9
	//arp.step_position = 0; //would use this if note retrigger feature was added
	
	uint8_t step = 0;
	
	//set arp sequence
	for (int range = 0; range <= arp.range; range++) {
     17e:	66 24       	eor	r6, r6
     180:	77 24       	eor	r7, r7


	arp.step_number = gate_buffer*(arp.range + 1);
	//arp.step_position = 0; //would use this if note retrigger feature was added
	
	uint8_t step = 0;
     182:	ff 24       	eor	r15, r15
					break;
					
				case DOWN:
					
					 //handle min note out of range here
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
     184:	44 24       	eor	r4, r4
     186:	55 24       	eor	r5, r5
		for (int i = 0; i < gate_buffer; i++) { // NOTE < rather than <= - <= was causing extra iteration that was over incrementing step!!!!!
			
			uint8_t root_note = get_indexed_note(gate_buffer - i - 1); //need to get notes in reverse order out of note pool
			//uint8_t root_note = get_indexed_note(i);
				
			switch(arp.mode) {
     188:	0f 2e       	mov	r0, r31
     18a:	f6 e9       	ldi	r31, 0x96	; 150
     18c:	cf 2e       	mov	r12, r31
     18e:	f3 e0       	ldi	r31, 0x03	; 3
     190:	df 2e       	mov	r13, r31
     192:	f0 2d       	mov	r31, r0
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
						
						root_note += 12;
						
					}
					arp.sequence[step++].note = root_note - (range*12);
     194:	0f 2e       	mov	r0, r31
     196:	f8 e8       	ldi	r31, 0x88	; 136
     198:	af 2e       	mov	r10, r31
     19a:	f3 e0       	ldi	r31, 0x03	; 3
     19c:	bf 2e       	mov	r11, r31
     19e:	f0 2d       	mov	r31, r0
     1a0:	4a c0       	rjmp	.+148    	; 0x236 <update_arp_sequence+0xf0>
	//set arp sequence
	for (int range = 0; range <= arp.range; range++) {
			
		for (int i = 0; i < gate_buffer; i++) { // NOTE < rather than <= - <= was causing extra iteration that was over incrementing step!!!!!
			
			uint8_t root_note = get_indexed_note(gate_buffer - i - 1); //need to get notes in reverse order out of note pool
     1a2:	81 50       	subi	r24, 0x01	; 1
     1a4:	80 1b       	sub	r24, r16
     1a6:	0e 94 85 01 	call	0x30a	; 0x30a <get_indexed_note>
     1aa:	28 2f       	mov	r18, r24
			//uint8_t root_note = get_indexed_note(i);
				
			switch(arp.mode) {
     1ac:	f6 01       	movw	r30, r12
     1ae:	80 81       	ld	r24, Z
     1b0:	82 30       	cpi	r24, 0x02	; 2
     1b2:	41 f0       	breq	.+16     	; 0x1c4 <update_arp_sequence+0x7e>
     1b4:	83 30       	cpi	r24, 0x03	; 3
     1b6:	18 f4       	brcc	.+6      	; 0x1be <update_arp_sequence+0x78>
     1b8:	81 30       	cpi	r24, 0x01	; 1
     1ba:	39 f5       	brne	.+78     	; 0x20a <update_arp_sequence+0xc4>
     1bc:	0a c0       	rjmp	.+20     	; 0x1d2 <update_arp_sequence+0x8c>
     1be:	85 30       	cpi	r24, 0x05	; 5
     1c0:	20 f5       	brcc	.+72     	; 0x20a <update_arp_sequence+0xc4>
     1c2:	07 c0       	rjmp	.+14     	; 0x1d2 <update_arp_sequence+0x8c>
					break;
					
				case DOWN:
					
					 //handle min note out of range here
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
     1c4:	ce 01       	movw	r24, r28
     1c6:	82 0f       	add	r24, r18
     1c8:	91 1d       	adc	r25, r1
     1ca:	88 30       	cpi	r24, 0x08	; 8
     1cc:	91 05       	cpc	r25, r1
     1ce:	64 f0       	brlt	.+24     	; 0x1e8 <update_arp_sequence+0xa2>
     1d0:	12 c0       	rjmp	.+36     	; 0x1f6 <update_arp_sequence+0xb0>
			switch(arp.mode) {
				
				case UP:
				case UP_DOWN:
				case RANDOM:
					arp.sequence[step++].note = root_note + (range*12); //will need to handle max note out of range here
     1d2:	8f 2d       	mov	r24, r15
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	88 0f       	add	r24, r24
     1d8:	99 1f       	adc	r25, r25
     1da:	8a 0d       	add	r24, r10
     1dc:	9b 1d       	adc	r25, r11
     1de:	2e 19       	sub	r18, r14
     1e0:	fc 01       	movw	r30, r24
     1e2:	27 87       	std	Z+15, r18	; 0x0f
     1e4:	f3 94       	inc	r15
				
					break;
     1e6:	11 c0       	rjmp	.+34     	; 0x20a <update_arp_sequence+0xc4>
				case DOWN:
					
					 //handle min note out of range here
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
						
						root_note += 12;
     1e8:	24 5f       	subi	r18, 0xF4	; 244
					break;
					
				case DOWN:
					
					 //handle min note out of range here
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
     1ea:	ce 01       	movw	r24, r28
     1ec:	82 0f       	add	r24, r18
     1ee:	91 1d       	adc	r25, r1
     1f0:	88 30       	cpi	r24, 0x08	; 8
     1f2:	91 05       	cpc	r25, r1
     1f4:	cc f3       	brlt	.-14     	; 0x1e8 <update_arp_sequence+0xa2>
						
						root_note += 12;
						
					}
					arp.sequence[step++].note = root_note - (range*12);
     1f6:	8f 2d       	mov	r24, r15
     1f8:	90 e0       	ldi	r25, 0x00	; 0
     1fa:	88 0f       	add	r24, r24
     1fc:	99 1f       	adc	r25, r25
     1fe:	8a 0d       	add	r24, r10
     200:	9b 1d       	adc	r25, r11
     202:	2e 0d       	add	r18, r14
     204:	fc 01       	movw	r30, r24
     206:	27 87       	std	Z+15, r18	; 0x0f
     208:	f3 94       	inc	r15
	uint8_t step = 0;
	
	//set arp sequence
	for (int range = 0; range <= arp.range; range++) {
			
		for (int i = 0; i < gate_buffer; i++) { // NOTE < rather than <= - <= was causing extra iteration that was over incrementing step!!!!!
     20a:	0f 5f       	subi	r16, 0xFF	; 255
     20c:	1f 4f       	sbci	r17, 0xFF	; 255
     20e:	80 91 b4 02 	lds	r24, 0x02B4
     212:	28 2f       	mov	r18, r24
     214:	30 e0       	ldi	r19, 0x00	; 0
     216:	02 17       	cp	r16, r18
     218:	13 07       	cpc	r17, r19
     21a:	1c f2       	brlt	.-122    	; 0x1a2 <update_arp_sequence+0x5c>
	//arp.step_position = 0; //would use this if note retrigger feature was added
	
	uint8_t step = 0;
	
	//set arp sequence
	for (int range = 0; range <= arp.range; range++) {
     21c:	08 94       	sec
     21e:	61 1c       	adc	r6, r1
     220:	71 1c       	adc	r7, r1
     222:	84 ef       	ldi	r24, 0xF4	; 244
     224:	9f ef       	ldi	r25, 0xFF	; 255
     226:	88 0e       	add	r8, r24
     228:	99 1e       	adc	r9, r25
     22a:	f5 01       	movw	r30, r10
     22c:	80 81       	ld	r24, Z
     22e:	90 e0       	ldi	r25, 0x00	; 0
     230:	86 15       	cp	r24, r6
     232:	97 05       	cpc	r25, r7
     234:	44 f0       	brlt	.+16     	; 0x246 <update_arp_sequence+0x100>
			
		for (int i = 0; i < gate_buffer; i++) { // NOTE < rather than <= - <= was causing extra iteration that was over incrementing step!!!!!
     236:	80 91 b4 02 	lds	r24, 0x02B4
     23a:	88 23       	and	r24, r24
     23c:	79 f3       	breq	.-34     	; 0x21c <update_arp_sequence+0xd6>
//#include "display.h"

struct arp arp;


void update_arp_sequence(void) {
     23e:	e8 2c       	mov	r14, r8
					break;
					
				case DOWN:
					
					 //handle min note out of range here
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
     240:	e4 01       	movw	r28, r8
     242:	82 01       	movw	r16, r4
     244:	ae cf       	rjmp	.-164    	; 0x1a2 <update_arp_sequence+0x5c>
		//value_to_display = step;

	}
	
	
}
     246:	df 91       	pop	r29
     248:	cf 91       	pop	r28
     24a:	1f 91       	pop	r17
     24c:	0f 91       	pop	r16
     24e:	ff 90       	pop	r15
     250:	ef 90       	pop	r14
     252:	df 90       	pop	r13
     254:	cf 90       	pop	r12
     256:	bf 90       	pop	r11
     258:	af 90       	pop	r10
     25a:	9f 90       	pop	r9
     25c:	8f 90       	pop	r8
     25e:	7f 90       	pop	r7
     260:	6f 90       	pop	r6
     262:	5f 90       	pop	r5
     264:	4f 90       	pop	r4
     266:	08 95       	ret

00000268 <step_arp_note>:

void step_arp_note(void) { //updates arp note according to step position in sequence
	
	arp.current_note = arp.sequence[arp.step_position].note;
     268:	90 91 8a 03 	lds	r25, 0x038A
     26c:	a9 2f       	mov	r26, r25
     26e:	b0 e0       	ldi	r27, 0x00	; 0
     270:	e8 e8       	ldi	r30, 0x88	; 136
     272:	f3 e0       	ldi	r31, 0x03	; 3
     274:	aa 0f       	add	r26, r26
     276:	bb 1f       	adc	r27, r27
     278:	ae 0f       	add	r26, r30
     27a:	bf 1f       	adc	r27, r31
     27c:	1f 96       	adiw	r26, 0x0f	; 15
     27e:	8c 91       	ld	r24, X
     280:	1f 97       	sbiw	r26, 0x0f	; 15
     282:	85 83       	std	Z+5, r24	; 0x05
	arp.previous_note = arp.current_note;
     284:	84 83       	std	Z+4, r24	; 0x04
	
	switch (arp.mode) {
     286:	86 85       	ldd	r24, Z+14	; 0x0e
     288:	83 30       	cpi	r24, 0x03	; 3
     28a:	19 f0       	breq	.+6      	; 0x292 <step_arp_note+0x2a>
     28c:	84 30       	cpi	r24, 0x04	; 4
     28e:	99 f5       	brne	.+102    	; 0x2f6 <step_arp_note+0x8e>
     290:	28 c0       	rjmp	.+80     	; 0x2e2 <step_arp_note+0x7a>
		
		case UP_DOWN:
			
			if (arp.direction == UP) {
     292:	80 91 8b 03 	lds	r24, 0x038B
     296:	81 30       	cpi	r24, 0x01	; 1
     298:	91 f4       	brne	.+36     	; 0x2be <step_arp_note+0x56>
				arp.step_position++;	
     29a:	9f 5f       	subi	r25, 0xFF	; 255
     29c:	90 93 8a 03 	sts	0x038A, r25
				
				if (arp.step_position >= arp.step_number) {
     2a0:	80 91 89 03 	lds	r24, 0x0389
     2a4:	98 17       	cp	r25, r24
     2a6:	80 f1       	brcs	.+96     	; 0x308 <step_arp_note+0xa0>
					arp.step_position = arp.step_number == 1 ? 0 : arp.step_number - 2; //Omar handles edge case here
     2a8:	81 30       	cpi	r24, 0x01	; 1
     2aa:	11 f0       	breq	.+4      	; 0x2b0 <step_arp_note+0x48>
     2ac:	82 50       	subi	r24, 0x02	; 2
     2ae:	01 c0       	rjmp	.+2      	; 0x2b2 <step_arp_note+0x4a>
     2b0:	80 e0       	ldi	r24, 0x00	; 0
     2b2:	80 93 8a 03 	sts	0x038A, r24
					arp.direction = DOWN;
     2b6:	82 e0       	ldi	r24, 0x02	; 2
     2b8:	80 93 8b 03 	sts	0x038B, r24
     2bc:	08 95       	ret
				}				
				
			} else {
				if (arp.step_position <= 0) {
     2be:	99 23       	and	r25, r25
     2c0:	61 f4       	brne	.+24     	; 0x2da <step_arp_note+0x72>
					
					arp.step_position = arp.step_number == 1 ? 0 : 1; //Omar handles edge case here
     2c2:	81 e0       	ldi	r24, 0x01	; 1
     2c4:	90 91 89 03 	lds	r25, 0x0389
     2c8:	91 30       	cpi	r25, 0x01	; 1
     2ca:	09 f4       	brne	.+2      	; 0x2ce <step_arp_note+0x66>
     2cc:	80 e0       	ldi	r24, 0x00	; 0
     2ce:	80 93 8a 03 	sts	0x038A, r24
					arp.direction = UP;
     2d2:	81 e0       	ldi	r24, 0x01	; 1
     2d4:	80 93 8b 03 	sts	0x038B, r24
     2d8:	08 95       	ret
					
				} else {
					arp.step_position--;
     2da:	91 50       	subi	r25, 0x01	; 1
     2dc:	90 93 8a 03 	sts	0x038A, r25
     2e0:	08 95       	ret
			
			break;
			
		case RANDOM:
		
			arp.step_position = random() % arp.step_number; //maybe >> random() result to generate 8 bit value before modulo?
     2e2:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <random>
     2e6:	60 91 89 03 	lds	r22, 0x0389
     2ea:	70 e0       	ldi	r23, 0x00	; 0
     2ec:	0e 94 b6 1e 	call	0x3d6c	; 0x3d6c <__divmodhi4>
     2f0:	80 93 8a 03 	sts	0x038A, r24
		
			break;
     2f4:	08 95       	ret
			
		default:
		
			if (++arp.step_position >= arp.step_number) arp.step_position  = 0;//reset step position when at end of sequence 
     2f6:	9f 5f       	subi	r25, 0xFF	; 255
     2f8:	90 93 8a 03 	sts	0x038A, r25
     2fc:	80 91 89 03 	lds	r24, 0x0389
     300:	98 17       	cp	r25, r24
     302:	10 f0       	brcs	.+4      	; 0x308 <step_arp_note+0xa0>
     304:	10 92 8a 03 	sts	0x038A, r1
     308:	08 95       	ret

0000030a <get_indexed_note>:

static uint8_t current_note = 0; //this acts as a buffer for the current note to maintain pitch during release stage of envelopes

uint8_t get_indexed_note(uint8_t index) {
	
	return note_pool[index].note;
     30a:	e8 2f       	mov	r30, r24
     30c:	f0 e0       	ldi	r31, 0x00	; 0
     30e:	ee 0f       	add	r30, r30
     310:	ff 1f       	adc	r31, r31
     312:	e8 54       	subi	r30, 0x48	; 72
     314:	fe 4f       	sbci	r31, 0xFE	; 254
	
	
	
}
     316:	80 81       	ld	r24, Z
     318:	08 95       	ret

0000031a <get_current_note>:
uint8_t get_current_note() { //Force inline this function? Ask Omar. BUT, this could be where interpolation is calculated!
	
	uint8_t note = 0;
	if (arp.mode) {
     31a:	80 91 96 03 	lds	r24, 0x0396
     31e:	88 23       	and	r24, r24
     320:	19 f0       	breq	.+6      	; 0x328 <get_current_note+0xe>
		
		
		//do something here to determine what arp note should be
		note = arp.current_note; //yeah, like this!
     322:	80 91 8d 03 	lds	r24, 0x038D
     326:	08 95       	ret
		

		
	} else {
		
		note = current_note;
     328:	80 91 b5 02 	lds	r24, 0x02B5
				
	}
	return note;
	
}
     32c:	08 95       	ret

0000032e <new_note>:

void new_note(uint8_t note, uint8_t velocity) {
     32e:	0f 93       	push	r16
     330:	1f 93       	push	r17
     332:	cf 93       	push	r28
     334:	df 93       	push	r29
     336:	18 2f       	mov	r17, r24
     338:	06 2f       	mov	r16, r22
	
	
	//shift contents of note_pool right by one element
	memmove(note_pool + 1, note_pool, sizeof(note_pool) -sizeof(*note_pool)); //last argument: sizeof struct - sizeof one element of struct. See http://www.cplusplus.com/forum/beginner/1936/
     33a:	8a eb       	ldi	r24, 0xBA	; 186
     33c:	91 e0       	ldi	r25, 0x01	; 1
     33e:	ec 01       	movw	r28, r24
     340:	22 97       	sbiw	r28, 0x02	; 2
     342:	be 01       	movw	r22, r28
     344:	4e e0       	ldi	r20, 0x0E	; 14
     346:	50 e0       	ldi	r21, 0x00	; 0
     348:	0e 94 52 1f 	call	0x3ea4	; 0x3ea4 <memmove>
	
	//add new note to pool
	note_pool[0].note = note;
     34c:	18 83       	st	Y, r17
	note_pool[0].velocity = velocity;
     34e:	09 83       	std	Y+1, r16	; 0x01
	
	current_note = note; //set current note
     350:	10 93 b5 02 	sts	0x02B5, r17
	
} 
     354:	df 91       	pop	r29
     356:	cf 91       	pop	r28
     358:	1f 91       	pop	r17
     35a:	0f 91       	pop	r16
     35c:	08 95       	ret

0000035e <remove_note>:
void remove_note(uint8_t note){
     35e:	cf 93       	push	r28
	
	uint8_t free_slot = 0;
	uint8_t temp_note = note_pool[0].note; //holder for current note
     360:	c0 91 b8 01 	lds	r28, 0x01B8
	for (int i = 0; i <= 7; i++) { //search for note in note stack
		
		if (note_pool[i].note == note) {
     364:	c8 17       	cp	r28, r24
     366:	41 f0       	breq	.+16     	; 0x378 <remove_note+0x1a>
     368:	ea eb       	ldi	r30, 0xBA	; 186
     36a:	f1 e0       	ldi	r31, 0x01	; 1
} 
void remove_note(uint8_t note){
	
	uint8_t free_slot = 0;
	uint8_t temp_note = note_pool[0].note; //holder for current note
	for (int i = 0; i <= 7; i++) { //search for note in note stack
     36c:	41 e0       	ldi	r20, 0x01	; 1
     36e:	50 e0       	ldi	r21, 0x00	; 0
		
		if (note_pool[i].note == note) {
     370:	90 81       	ld	r25, Z
     372:	98 17       	cp	r25, r24
     374:	59 f4       	brne	.+22     	; 0x38c <remove_note+0x2e>
     376:	02 c0       	rjmp	.+4      	; 0x37c <remove_note+0x1e>
} 
void remove_note(uint8_t note){
	
	uint8_t free_slot = 0;
	uint8_t temp_note = note_pool[0].note; //holder for current note
	for (int i = 0; i <= 7; i++) { //search for note in note stack
     378:	40 e0       	ldi	r20, 0x00	; 0
     37a:	50 e0       	ldi	r21, 0x00	; 0
		
		if (note_pool[i].note == note) {
			
			note_pool[i].note = EMPTY;
     37c:	fa 01       	movw	r30, r20
     37e:	ee 0f       	add	r30, r30
     380:	ff 1f       	adc	r31, r31
     382:	e8 54       	subi	r30, 0x48	; 72
     384:	fe 4f       	sbci	r31, 0xFE	; 254
     386:	8f ef       	ldi	r24, 0xFF	; 255
     388:	80 83       	st	Z, r24
			free_slot = i;
			break;
     38a:	07 c0       	rjmp	.+14     	; 0x39a <remove_note+0x3c>
} 
void remove_note(uint8_t note){
	
	uint8_t free_slot = 0;
	uint8_t temp_note = note_pool[0].note; //holder for current note
	for (int i = 0; i <= 7; i++) { //search for note in note stack
     38c:	4f 5f       	subi	r20, 0xFF	; 255
     38e:	5f 4f       	sbci	r21, 0xFF	; 255
     390:	32 96       	adiw	r30, 0x02	; 2
     392:	48 30       	cpi	r20, 0x08	; 8
     394:	51 05       	cpc	r21, r1
     396:	61 f7       	brne	.-40     	; 0x370 <remove_note+0x12>
	current_note = note; //set current note
	
} 
void remove_note(uint8_t note){
	
	uint8_t free_slot = 0;
     398:	40 e0       	ldi	r20, 0x00	; 0
		
	}
	
	
	//now shift elements left	
	memmove(note_pool + free_slot, note_pool + free_slot + 1, sizeof(note_pool) - (sizeof(*note_pool)*(free_slot + 1)));
     39a:	50 e0       	ldi	r21, 0x00	; 0
     39c:	ca 01       	movw	r24, r20
     39e:	88 0f       	add	r24, r24
     3a0:	99 1f       	adc	r25, r25
     3a2:	bc 01       	movw	r22, r24
     3a4:	66 54       	subi	r22, 0x46	; 70
     3a6:	7e 4f       	sbci	r23, 0xFE	; 254
     3a8:	40 95       	com	r20
     3aa:	50 95       	com	r21
     3ac:	48 5f       	subi	r20, 0xF8	; 248
     3ae:	5f 4f       	sbci	r21, 0xFF	; 255
     3b0:	44 0f       	add	r20, r20
     3b2:	55 1f       	adc	r21, r21
     3b4:	88 54       	subi	r24, 0x48	; 72
     3b6:	9e 4f       	sbci	r25, 0xFE	; 254
     3b8:	0e 94 52 1f 	call	0x3ea4	; 0x3ea4 <memmove>
	note_pool[7].note = EMPTY;	
     3bc:	8f ef       	ldi	r24, 0xFF	; 255
     3be:	80 93 c6 01 	sts	0x01C6, r24
	
	//check to see if this is the last note released		
	//if it is, this might be a good place to ensure gate_buffer is empty
	if (note_pool[0].note == EMPTY) {
     3c2:	80 91 b8 01 	lds	r24, 0x01B8
     3c6:	8f 3f       	cpi	r24, 0xFF	; 255
     3c8:	19 f4       	brne	.+6      	; 0x3d0 <remove_note+0x72>
		
		current_note = temp_note; //store last note released for maintaining pitch during envelope release stage
     3ca:	c0 93 b5 02 	sts	0x02B5, r28
     3ce:	02 c0       	rjmp	.+4      	; 0x3d4 <remove_note+0x76>
		
	} else {		
		
		current_note = note_pool[0].note; //otherwise, the current note is the next one in the note stack
     3d0:	80 93 b5 02 	sts	0x02B5, r24

	}	
	
}
     3d4:	cf 91       	pop	r28
     3d6:	08 95       	ret

000003d8 <setup_system_clock>:
struct clock lfo_clock;

void setup_system_clock(void) {
	
	
	TCCR1B = (1<<CS10) | (1<<CS12) | (1<<WGM12);//TIMER1_DIVIDE_1024;
     3d8:	8d e0       	ldi	r24, 0x0D	; 13
     3da:	80 93 81 00 	sts	0x0081, r24
	TIMSK1 = (1<<OCIE1A);
     3de:	82 e0       	ldi	r24, 0x02	; 2
     3e0:	80 93 6f 00 	sts	0x006F, r24
	
	
	
}
     3e4:	08 95       	ret

000003e6 <update_clock_rate>:

void update_clock_rate(uint16_t rate) {
	
	OCR1A = rate;
     3e6:	90 93 89 00 	sts	0x0089, r25
     3ea:	80 93 88 00 	sts	0x0088, r24
	if (TCNT1 > rate) TCNT1 = rate - 1; //this prevents wrapping. setting TCNT1 = rate would cause immediate interrupt. Is that OK?
     3ee:	20 91 84 00 	lds	r18, 0x0084
     3f2:	30 91 85 00 	lds	r19, 0x0085
     3f6:	82 17       	cp	r24, r18
     3f8:	93 07       	cpc	r25, r19
     3fa:	28 f4       	brcc	.+10     	; 0x406 <update_clock_rate+0x20>
     3fc:	01 97       	sbiw	r24, 0x01	; 1
     3fe:	90 93 85 00 	sts	0x0085, r25
     402:	80 93 84 00 	sts	0x0084, r24
     406:	08 95       	ret

00000408 <set_control_voltage>:
struct control_voltage sustain_2_cv		={SUSTAIN_2,	DAC_MUX_EN3};
struct control_voltage sustain_1_cv		={SUSTAIN_1,	DAC_MUX_EN3};
struct control_voltage release_2_cv		={RELEASE_2,	DAC_MUX_EN3};
struct control_voltage release_1_cv		={RELEASE_1,	DAC_MUX_EN3};		

void set_control_voltage (struct control_voltage * cv, uint16_t value) {
     408:	dc 01       	movw	r26, r24

	DAC_BUS_LOW = value & 0b00000011111111; //mask top 6 MSBs to set low byte
     40a:	6b b9       	out	0x0b, r22	; 11
	
	DAC_BUS_HIGH = value >> 8; //shift away bottom LSBs to set high byte
     40c:	78 b9       	out	0x08, r23	; 8
	
	DAC_CTRL &= ~(1<<DAC_WR); //write DATA
     40e:	a0 98       	cbi	0x14, 0	; 20
	DAC_CTRL |= (1<<DAC_WR);	
     410:	a0 9a       	sbi	0x14, 0	; 20

	DATA_BUS = cv->channel; //set channel for DG408 multiplexer output
     412:	8c 91       	ld	r24, X
     414:	87 70       	andi	r24, 0x07	; 7
     416:	82 b9       	out	0x02, r24	; 2
     418:	66 e0       	ldi	r22, 0x06	; 6
     41a:	6a 95       	dec	r22
     41c:	f1 f7       	brne	.-4      	; 0x41a <set_control_voltage+0x12>
     41e:	00 c0       	rjmp	.+0      	; 0x420 <set_control_voltage+0x18>

	_delay_us(1); //AD5556 DAC has 0.5 us settling time. 1 us wasn't long enough for transitions from 10V to 0V
	DAC_MUX |= (1<<cv->mux_addr); //enable multiplexer
     420:	ea ed       	ldi	r30, 0xDA	; 218
     422:	f0 e0       	ldi	r31, 0x00	; 0
     424:	40 81       	ld	r20, Z
     426:	8c 91       	ld	r24, X
     428:	86 95       	lsr	r24
     42a:	86 95       	lsr	r24
     42c:	86 95       	lsr	r24
     42e:	87 70       	andi	r24, 0x07	; 7
     430:	21 e0       	ldi	r18, 0x01	; 1
     432:	30 e0       	ldi	r19, 0x00	; 0
     434:	b9 01       	movw	r22, r18
     436:	02 c0       	rjmp	.+4      	; 0x43c <set_control_voltage+0x34>
     438:	66 0f       	add	r22, r22
     43a:	77 1f       	adc	r23, r23
     43c:	8a 95       	dec	r24
     43e:	e2 f7       	brpl	.-8      	; 0x438 <set_control_voltage+0x30>
     440:	cb 01       	movw	r24, r22
     442:	84 2b       	or	r24, r20
     444:	80 83       	st	Z, r24
     446:	76 e0       	ldi	r23, 0x06	; 6
     448:	7a 95       	dec	r23
     44a:	f1 f7       	brne	.-4      	; 0x448 <set_control_voltage+0x40>
     44c:	00 c0       	rjmp	.+0      	; 0x44e <set_control_voltage+0x46>
	_delay_us(1); //wait for S&H cap to charge - need to figure out how to do this more time efficiently
	DAC_MUX &= ~(1<<cv->mux_addr); //disable multiplexer
     44e:	80 81       	ld	r24, Z
     450:	9c 91       	ld	r25, X
     452:	96 95       	lsr	r25
     454:	96 95       	lsr	r25
     456:	96 95       	lsr	r25
     458:	97 70       	andi	r25, 0x07	; 7
     45a:	02 c0       	rjmp	.+4      	; 0x460 <set_control_voltage+0x58>
     45c:	22 0f       	add	r18, r18
     45e:	33 1f       	adc	r19, r19
     460:	9a 95       	dec	r25
     462:	e2 f7       	brpl	.-8      	; 0x45c <set_control_voltage+0x54>
     464:	20 95       	com	r18
     466:	28 23       	and	r18, r24
     468:	20 83       	st	Z, r18
	
}	
     46a:	08 95       	ret

0000046c <setup_dac>:

	
void setup_dac(void) //set up DAC
{
	DDRG |= (1<<DAC_WR) | (1<<DAC_RS); //set DAC control bits as outputs
     46c:	83 b3       	in	r24, 0x13	; 19
     46e:	83 60       	ori	r24, 0x03	; 3
     470:	83 bb       	out	0x13, r24	; 19
	DDRD = 0xFF; //set DAC_BUS_LOW bits to outputs
     472:	8f ef       	ldi	r24, 0xFF	; 255
     474:	8a b9       	out	0x0a, r24	; 10
	DDRC |= 0xFF;//set DAC_BUS_HIGH bits to outputs
     476:	97 b1       	in	r25, 0x07	; 7
     478:	87 b9       	out	0x07, r24	; 7
	DDRH |= (1<<DAC_MUX_EN0) | (1<<DAC_MUX_EN1) | (1<<DAC_MUX_EN2) | (1<<DAC_MUX_EN3); //set DAC_MUX_EN pins as outputs
     47a:	e9 ed       	ldi	r30, 0xD9	; 217
     47c:	f0 e0       	ldi	r31, 0x00	; 0
     47e:	80 81       	ld	r24, Z
     480:	8f 60       	ori	r24, 0x0F	; 15
     482:	80 83       	st	Z, r24
	
	DAC_MUX &= ~((1<<DAC_MUX_EN0) | (1<<DAC_MUX_EN1) | (1<<DAC_MUX_EN2) | (1<<DAC_MUX_EN3)); //disable DG408 VDAC multiplexers
     484:	ea ed       	ldi	r30, 0xDA	; 218
     486:	f0 e0       	ldi	r31, 0x00	; 0
     488:	80 81       	ld	r24, Z
     48a:	80 7f       	andi	r24, 0xF0	; 240
     48c:	80 83       	st	Z, r24
	
	DAC_CTRL |= (1<<DAC_RS) | (1<<DAC_WR); //disable DAC
     48e:	84 b3       	in	r24, 0x14	; 20
     490:	83 60       	ori	r24, 0x03	; 3
     492:	84 bb       	out	0x14, r24	; 20
	
	DAC_CTRL &= ~(1<<DAC_RS); //reset DAC
     494:	a1 98       	cbi	0x14, 1	; 20
	DAC_CTRL |= (1<<DAC_RS);
     496:	a1 9a       	sbi	0x14, 1	; 20
	
	DAC_CTRL &= ~(1<<DAC_WR); //write DATA - falling edge then rising edge to toggle DAC bits to output register
     498:	a0 98       	cbi	0x14, 0	; 20
	DAC_CTRL |= (1<<DAC_WR);
     49a:	a0 9a       	sbi	0x14, 0	; 20
}
     49c:	08 95       	ret

0000049e <display_dec>:
#include "synth.h"



void display_dec(uint16_t number, uint8_t place)
{
     49e:	0f 93       	push	r16
     4a0:	1f 93       	push	r17
     4a2:	cf 93       	push	r28
     4a4:	df 93       	push	r29
     4a6:	cd b7       	in	r28, 0x3d	; 61
     4a8:	de b7       	in	r29, 0x3e	; 62
     4aa:	2e 97       	sbiw	r28, 0x0e	; 14
     4ac:	0f b6       	in	r0, 0x3f	; 63
     4ae:	f8 94       	cli
     4b0:	de bf       	out	0x3e, r29	; 62
     4b2:	0f be       	out	0x3f, r0	; 63
     4b4:	cd bf       	out	0x3d, r28	; 61
	
	uint8_t digit[] = {
     4b6:	28 e0       	ldi	r18, 0x08	; 8
     4b8:	29 83       	std	Y+1, r18	; 0x01
     4ba:	21 e0       	ldi	r18, 0x01	; 1
     4bc:	2a 83       	std	Y+2, r18	; 0x02
     4be:	22 e0       	ldi	r18, 0x02	; 2
     4c0:	2b 83       	std	Y+3, r18	; 0x03
     4c2:	24 e0       	ldi	r18, 0x04	; 4
     4c4:	2c 83       	std	Y+4, r18	; 0x04
		TENS,
		HUNDS,
		THOUS,
	};
	
	uint8_t dec[] = {
     4c6:	de 01       	movw	r26, r28
     4c8:	15 96       	adiw	r26, 0x05	; 5
     4ca:	e7 ee       	ldi	r30, 0xE7	; 231
     4cc:	f1 e0       	ldi	r31, 0x01	; 1
     4ce:	2a e0       	ldi	r18, 0x0A	; 10
     4d0:	01 90       	ld	r0, Z+
     4d2:	0d 92       	st	X+, r0
     4d4:	21 50       	subi	r18, 0x01	; 1
     4d6:	e1 f7       	brne	.-8      	; 0x4d0 <display_dec+0x32>
		
		
	};
	
	//clear cathode bits
	DATA_BUS = 0xFF; //set bits for cathode (current sinks, active LOW)
     4d8:	2f ef       	ldi	r18, 0xFF	; 255
     4da:	22 b9       	out	0x02, r18	; 2
	//latch data to cathode lines
	DISPLAY_PORT |= (1<<DISP_CATHODE_LATCH);
     4dc:	ea ed       	ldi	r30, 0xDA	; 218
     4de:	f0 e0       	ldi	r31, 0x00	; 0
     4e0:	20 81       	ld	r18, Z
     4e2:	20 61       	ori	r18, 0x10	; 16
     4e4:	20 83       	st	Z, r18
	DISPLAY_PORT &= ~(1<<DISP_CATHODE_LATCH);
     4e6:	20 81       	ld	r18, Z
     4e8:	2f 7e       	andi	r18, 0xEF	; 239
     4ea:	20 83       	st	Z, r18
	
	//set anode bit
	DATA_BUS = digit[place];
     4ec:	06 2f       	mov	r16, r22
     4ee:	10 e0       	ldi	r17, 0x00	; 0
     4f0:	de 01       	movw	r26, r28
     4f2:	a0 0f       	add	r26, r16
     4f4:	b1 1f       	adc	r27, r17
     4f6:	11 96       	adiw	r26, 0x01	; 1
     4f8:	2c 91       	ld	r18, X
     4fa:	11 97       	sbiw	r26, 0x01	; 1
     4fc:	22 b9       	out	0x02, r18	; 2
	//latch data to anode lines
	DISPLAY_PORT |= (1<<DISP_ANODE_LATCH);
     4fe:	20 81       	ld	r18, Z
     500:	20 62       	ori	r18, 0x20	; 32
     502:	20 83       	st	Z, r18
	DISPLAY_PORT &= ~(1<<DISP_ANODE_LATCH);
     504:	20 81       	ld	r18, Z
     506:	2f 7d       	andi	r18, 0xDF	; 223
     508:	20 83       	st	Z, r18
     50a:	48 2f       	mov	r20, r24
     50c:	59 2f       	mov	r21, r25
     50e:	87 e2       	ldi	r24, 0x27	; 39
     510:	40 31       	cpi	r20, 0x10	; 16
     512:	58 07       	cpc	r21, r24
     514:	10 f0       	brcs	.+4      	; 0x51a <display_dec+0x7c>
     516:	4f e0       	ldi	r20, 0x0F	; 15
     518:	57 e2       	ldi	r21, 0x27	; 39
	if (number > 9999) {
		number = 9999;
		}
	
	/* First division by 10 */
	q1 = (number >> 1) + (number >> 2);
     51a:	ca 01       	movw	r24, r20
     51c:	96 95       	lsr	r25
     51e:	87 95       	ror	r24
     520:	96 95       	lsr	r25
     522:	87 95       	ror	r24
     524:	9a 01       	movw	r18, r20
     526:	36 95       	lsr	r19
     528:	27 95       	ror	r18
     52a:	28 0f       	add	r18, r24
     52c:	39 1f       	adc	r19, r25
	q1 += q1 >> 4;
     52e:	c9 01       	movw	r24, r18
     530:	92 95       	swap	r25
     532:	82 95       	swap	r24
     534:	8f 70       	andi	r24, 0x0F	; 15
     536:	89 27       	eor	r24, r25
     538:	9f 70       	andi	r25, 0x0F	; 15
     53a:	89 27       	eor	r24, r25
     53c:	82 0f       	add	r24, r18
     53e:	93 1f       	adc	r25, r19
	q1 += q1 >> 8;
     540:	29 2f       	mov	r18, r25
     542:	33 27       	eor	r19, r19
     544:	82 0f       	add	r24, r18
     546:	93 1f       	adc	r25, r19
	q2 = q1 >> 3;
     548:	96 95       	lsr	r25
     54a:	87 95       	ror	r24
     54c:	96 95       	lsr	r25
     54e:	87 95       	ror	r24
     550:	96 95       	lsr	r25
     552:	87 95       	ror	r24
	r = number - q2 * 10;
     554:	28 2f       	mov	r18, r24
     556:	22 0f       	add	r18, r18
     558:	32 2f       	mov	r19, r18
     55a:	33 0f       	add	r19, r19
     55c:	33 0f       	add	r19, r19
     55e:	23 0f       	add	r18, r19
     560:	e4 2f       	mov	r30, r20
     562:	e2 1b       	sub	r30, r18
	//r = number - (((q2 << 2) + q2) << 1);
	qa = q2 + (r > 9);
     564:	61 e0       	ldi	r22, 0x01	; 1
     566:	70 e0       	ldi	r23, 0x00	; 0
     568:	ea 30       	cpi	r30, 0x0A	; 10
     56a:	10 f4       	brcc	.+4      	; 0x570 <display_dec+0xd2>
     56c:	60 e0       	ldi	r22, 0x00	; 0
     56e:	70 e0       	ldi	r23, 0x00	; 0
     570:	68 0f       	add	r22, r24
     572:	79 1f       	adc	r23, r25
	ones_place = rem[r];

	/* second division by 10 */

	q2 = (qa >> 1) + (qa >> 2);
     574:	9b 01       	movw	r18, r22
     576:	36 95       	lsr	r19
     578:	27 95       	ror	r18
     57a:	36 95       	lsr	r19
     57c:	27 95       	ror	r18
     57e:	ab 01       	movw	r20, r22
     580:	56 95       	lsr	r21
     582:	47 95       	ror	r20
     584:	24 0f       	add	r18, r20
     586:	35 1f       	adc	r19, r21
	q2 += q2 >> 4;
     588:	c9 01       	movw	r24, r18
     58a:	92 95       	swap	r25
     58c:	82 95       	swap	r24
     58e:	8f 70       	andi	r24, 0x0F	; 15
     590:	89 27       	eor	r24, r25
     592:	9f 70       	andi	r25, 0x0F	; 15
     594:	89 27       	eor	r24, r25
     596:	82 0f       	add	r24, r18
     598:	93 1f       	adc	r25, r19
	q2 += q2 >> 8;
     59a:	29 2f       	mov	r18, r25
     59c:	33 27       	eor	r19, r19
     59e:	82 0f       	add	r24, r18
     5a0:	93 1f       	adc	r25, r19
	q3 = q2 >> 3;
     5a2:	96 95       	lsr	r25
     5a4:	87 95       	ror	r24
     5a6:	96 95       	lsr	r25
     5a8:	87 95       	ror	r24
     5aa:	96 95       	lsr	r25
     5ac:	87 95       	ror	r24
	r = qa - q3 * 10;
     5ae:	98 2f       	mov	r25, r24
     5b0:	99 0f       	add	r25, r25
     5b2:	29 2f       	mov	r18, r25
     5b4:	22 0f       	add	r18, r18
     5b6:	22 0f       	add	r18, r18
     5b8:	92 0f       	add	r25, r18
     5ba:	69 1b       	sub	r22, r25
	qb = q3 + (r > 9);
     5bc:	91 e0       	ldi	r25, 0x01	; 1
     5be:	6a 30       	cpi	r22, 0x0A	; 10
     5c0:	08 f4       	brcc	.+2      	; 0x5c4 <display_dec+0x126>
     5c2:	90 e0       	ldi	r25, 0x00	; 0
     5c4:	89 0f       	add	r24, r25
	tens_place = rem[r];
     5c6:	41 ef       	ldi	r20, 0xF1	; 241
     5c8:	51 e0       	ldi	r21, 0x01	; 1
     5ca:	da 01       	movw	r26, r20
     5cc:	a6 0f       	add	r26, r22
     5ce:	b1 1d       	adc	r27, r1
     5d0:	3c 91       	ld	r19, X

	/* third division by 10 */

	q4 = (qb >> 1) + (qb >> 2);
     5d2:	28 2f       	mov	r18, r24
     5d4:	26 95       	lsr	r18
     5d6:	26 95       	lsr	r18
     5d8:	98 2f       	mov	r25, r24
     5da:	96 95       	lsr	r25
     5dc:	92 0f       	add	r25, r18
	q4 += q4 >> 4;
     5de:	29 2f       	mov	r18, r25
     5e0:	22 95       	swap	r18
     5e2:	2f 70       	andi	r18, 0x0F	; 15
     5e4:	92 0f       	add	r25, r18
	q4 = q4 >> 3;
     5e6:	96 95       	lsr	r25
     5e8:	96 95       	lsr	r25
     5ea:	96 95       	lsr	r25
	r = qb - q4 * 10;
     5ec:	29 2f       	mov	r18, r25
     5ee:	22 0f       	add	r18, r18
     5f0:	62 2f       	mov	r22, r18
     5f2:	66 0f       	add	r22, r22
     5f4:	66 0f       	add	r22, r22
     5f6:	26 0f       	add	r18, r22
     5f8:	82 1b       	sub	r24, r18
	thous_place = q4 + (r > 9);
	hunds_place = rem[r];
     5fa:	da 01       	movw	r26, r20
     5fc:	a8 0f       	add	r26, r24
     5fe:	b1 1d       	adc	r27, r1
     600:	2c 91       	ld	r18, X
	q1 += q1 >> 8;
	q2 = q1 >> 3;
	r = number - q2 * 10;
	//r = number - (((q2 << 2) + q2) << 1);
	qa = q2 + (r > 9);
	ones_place = rem[r];
     602:	4e 0f       	add	r20, r30
     604:	51 1d       	adc	r21, r1
	q4 = q4 >> 3;
	r = qb - q4 * 10;
	thous_place = q4 + (r > 9);
	hunds_place = rem[r];

	digit_index[0] = ones_place;
     606:	fa 01       	movw	r30, r20
     608:	40 81       	ld	r20, Z
     60a:	40 93 b8 02 	sts	0x02B8, r20
	digit_index[1] = tens_place;
     60e:	30 93 b9 02 	sts	0x02B9, r19
	digit_index[2] = hunds_place;
     612:	20 93 ba 02 	sts	0x02BA, r18

	q4 = (qb >> 1) + (qb >> 2);
	q4 += q4 >> 4;
	q4 = q4 >> 3;
	r = qb - q4 * 10;
	thous_place = q4 + (r > 9);
     616:	21 e0       	ldi	r18, 0x01	; 1
     618:	8a 30       	cpi	r24, 0x0A	; 10
     61a:	08 f4       	brcc	.+2      	; 0x61e <display_dec+0x180>
     61c:	20 e0       	ldi	r18, 0x00	; 0
     61e:	92 0f       	add	r25, r18
	hunds_place = rem[r];

	digit_index[0] = ones_place;
	digit_index[1] = tens_place;
	digit_index[2] = hunds_place;
	digit_index[3] = thous_place;
     620:	90 93 bb 02 	sts	0x02BB, r25

	cathode_byte = dec[digit_index[place]];
     624:	f8 01       	movw	r30, r16
     626:	e8 54       	subi	r30, 0x48	; 72
     628:	fd 4f       	sbci	r31, 0xFD	; 253
     62a:	80 81       	ld	r24, Z
     62c:	fe 01       	movw	r30, r28
     62e:	e8 0f       	add	r30, r24
     630:	f1 1d       	adc	r31, r1
     632:	85 81       	ldd	r24, Z+5	; 0x05
	
	if (current_patch.mode == EDIT) cathode_byte |= dp;
     634:	90 91 0b 03 	lds	r25, 0x030B
     638:	92 30       	cpi	r25, 0x02	; 2
     63a:	11 f4       	brne	.+4      	; 0x640 <display_dec+0x1a2>
     63c:	80 62       	ori	r24, 0x20	; 32
     63e:	03 c0       	rjmp	.+6      	; 0x646 <display_dec+0x1a8>
	if (current_patch.mode == MANUAL) cathode_byte = g; //Roland style dash for MANUAL mode. Could move this to the top as manual mode precludes the need to parse digit
     640:	91 30       	cpi	r25, 0x01	; 1
     642:	09 f4       	brne	.+2      	; 0x646 <display_dec+0x1a8>
     644:	88 e0       	ldi	r24, 0x08	; 8
	
	
	//set cathode byte
	DATA_BUS = ~(cathode_byte); //set bits for cathode (current sinks, active LOW)
     646:	80 95       	com	r24
     648:	82 b9       	out	0x02, r24	; 2
	//latch data to cathode lines
	DISPLAY_PORT |= (1<<DISP_CATHODE_LATCH);
     64a:	ea ed       	ldi	r30, 0xDA	; 218
     64c:	f0 e0       	ldi	r31, 0x00	; 0
     64e:	80 81       	ld	r24, Z
     650:	80 61       	ori	r24, 0x10	; 16
     652:	80 83       	st	Z, r24
	DISPLAY_PORT &= ~(1<<DISP_CATHODE_LATCH);
     654:	80 81       	ld	r24, Z
     656:	8f 7e       	andi	r24, 0xEF	; 239
     658:	80 83       	st	Z, r24
	
	//DATA_BUS = 0; //clear DATA_BUS before return
}
     65a:	2e 96       	adiw	r28, 0x0e	; 14
     65c:	0f b6       	in	r0, 0x3f	; 63
     65e:	f8 94       	cli
     660:	de bf       	out	0x3e, r29	; 62
     662:	0f be       	out	0x3f, r0	; 63
     664:	cd bf       	out	0x3d, r28	; 61
     666:	df 91       	pop	r29
     668:	cf 91       	pop	r28
     66a:	1f 91       	pop	r17
     66c:	0f 91       	pop	r16
     66e:	08 95       	ret

00000670 <update_display>:

void update_display(uint16_t number, uint8_t type) {
     670:	cf 93       	push	r28
	
	static uint8_t place = 0;
	

	
	if (type == DEC) {
     672:	66 23       	and	r22, r22
     674:	69 f4       	brne	.+26     	; 0x690 <update_display+0x20>

		
			
		display_dec(number, place);
     676:	c0 91 bc 02 	lds	r28, 0x02BC
     67a:	6c 2f       	mov	r22, r28
     67c:	0e 94 4f 02 	call	0x49e	; 0x49e <display_dec>
		//increment digit display place
		if (place++ == 3) //post increment
     680:	8c 2f       	mov	r24, r28
     682:	8f 5f       	subi	r24, 0xFF	; 255
     684:	80 93 bc 02 	sts	0x02BC, r24
     688:	c3 30       	cpi	r28, 0x03	; 3
     68a:	11 f4       	brne	.+4      	; 0x690 <update_display+0x20>
		{
			place = 0;
     68c:	10 92 bc 02 	sts	0x02BC, r1
		
		
	}
	
	
     690:	cf 91       	pop	r28
     692:	08 95       	ret

00000694 <__vector_10>:
#include "display.h"
#include "clock.h"
#include "assigner.h"
#include "arp.h"

ISR (TIMER0_COMP_vect) { //timer 0 output compare interrupt for tuning
     694:	1f 92       	push	r1
     696:	0f 92       	push	r0
     698:	0f b6       	in	r0, 0x3f	; 63
     69a:	0f 92       	push	r0
     69c:	11 24       	eor	r1, r1
     69e:	8f 93       	push	r24
     6a0:	9f 93       	push	r25
     6a2:	ef 93       	push	r30
     6a4:	ff 93       	push	r31
	
	OCR0A = period-1; //OCR0A counts n-1 periods - see comment in tune.c about setting OCR0A
     6a6:	80 91 80 03 	lds	r24, 0x0380
     6aa:	81 50       	subi	r24, 0x01	; 1
     6ac:	87 bd       	out	0x27, r24	; 39
	//PORTB ^= (1<<ARP_SYNC_LED); //toggle arp ARP_SYNC LED
	if (period_counter == 0) {
     6ae:	80 91 81 03 	lds	r24, 0x0381
     6b2:	88 23       	and	r24, r24
     6b4:	a1 f4       	brne	.+40     	; 0x6de <__vector_10+0x4a>
		count_finished = FALSE;
     6b6:	10 92 7e 03 	sts	0x037E, r1
		no_overflow = TRUE;
     6ba:	81 e0       	ldi	r24, 0x01	; 1
     6bc:	80 93 af 02 	sts	0x02AF, r24
		period_counter = 1; //set period counter to 1
     6c0:	80 93 81 03 	sts	0x0381, r24
		//set up 16 bit timer/counter1		
		TCCR1B |= timer1_clock; //clock /64 to run at 312.5 KHz or /8 to run at 2.5 MHz, dependent on note frequency being measured
     6c4:	e1 e8       	ldi	r30, 0x81	; 129
     6c6:	f0 e0       	ldi	r31, 0x00	; 0
     6c8:	80 81       	ld	r24, Z
     6ca:	90 91 7f 03 	lds	r25, 0x037F
     6ce:	89 2b       	or	r24, r25
     6d0:	80 83       	st	Z, r24
		TIMSK1 |= (1<<TOIE1); //enable timer1 overflow interrupt
     6d2:	ef e6       	ldi	r30, 0x6F	; 111
     6d4:	f0 e0       	ldi	r31, 0x00	; 0
     6d6:	80 81       	ld	r24, Z
     6d8:	81 60       	ori	r24, 0x01	; 1
     6da:	80 83       	st	Z, r24
     6dc:	11 c0       	rjmp	.+34     	; 0x700 <__vector_10+0x6c>
		
	} else {
		
		osc_count = TCNT1;		
     6de:	e4 e8       	ldi	r30, 0x84	; 132
     6e0:	f0 e0       	ldi	r31, 0x00	; 0
     6e2:	80 81       	ld	r24, Z
     6e4:	91 81       	ldd	r25, Z+1	; 0x01
     6e6:	90 93 7d 03 	sts	0x037D, r25
     6ea:	80 93 7c 03 	sts	0x037C, r24
		TCCR1B = 0; //turn off 16 bit timer/counter1
     6ee:	10 92 81 00 	sts	0x0081, r1
		count_finished = TRUE;
     6f2:	81 e0       	ldi	r24, 0x01	; 1
     6f4:	80 93 7e 03 	sts	0x037E, r24
		period_counter = 0;
     6f8:	10 92 81 03 	sts	0x0381, r1
		TCNT1 = 0; //reset timer/counter 1
     6fc:	11 82       	std	Z+1, r1	; 0x01
     6fe:	10 82       	st	Z, r1
	}
	
	
	
	
}
     700:	ff 91       	pop	r31
     702:	ef 91       	pop	r30
     704:	9f 91       	pop	r25
     706:	8f 91       	pop	r24
     708:	0f 90       	pop	r0
     70a:	0f be       	out	0x3f, r0	; 63
     70c:	0f 90       	pop	r0
     70e:	1f 90       	pop	r1
     710:	18 95       	reti

00000712 <__vector_9>:



ISR (TIMER1_OVF_vect) {
     712:	1f 92       	push	r1
     714:	0f 92       	push	r0
     716:	0f b6       	in	r0, 0x3f	; 63
     718:	0f 92       	push	r0
     71a:	11 24       	eor	r1, r1
	
	//during frequency counting, if timer1 overflow occurs set overflow flag
	no_overflow = FALSE;
     71c:	10 92 af 02 	sts	0x02AF, r1
	//PORTB ^= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED
	
}
     720:	0f 90       	pop	r0
     722:	0f be       	out	0x3f, r0	; 63
     724:	0f 90       	pop	r0
     726:	1f 90       	pop	r1
     728:	18 95       	reti

0000072a <__vector_7>:

ISR (TIMER1_COMPA_vect) { //output compare match for master clock
     72a:	1f 92       	push	r1
     72c:	0f 92       	push	r0
     72e:	0f b6       	in	r0, 0x3f	; 63
     730:	0f 92       	push	r0
     732:	11 24       	eor	r1, r1
     734:	2f 93       	push	r18
     736:	3f 93       	push	r19
     738:	4f 93       	push	r20
     73a:	5f 93       	push	r21
     73c:	6f 93       	push	r22
     73e:	7f 93       	push	r23
     740:	8f 93       	push	r24
     742:	9f 93       	push	r25
     744:	af 93       	push	r26
     746:	bf 93       	push	r27
     748:	ef 93       	push	r30
     74a:	ff 93       	push	r31
	//PORTB ^= (1<<ARP_SYNC_LED);
	
	if (system_clock.ppqn_counter == system_clock.divider >> 1) { //50% gate width
     74c:	80 91 d7 03 	lds	r24, 0x03D7
     750:	86 95       	lsr	r24
     752:	90 91 d8 03 	lds	r25, 0x03D8
     756:	98 17       	cp	r25, r24
     758:	51 f4       	brne	.+20     	; 0x76e <__vector_7+0x44>
				
		
		if ((arp.clock_source == INTERNAL_CLOCK) && (arp.mode)) {
     75a:	80 91 95 03 	lds	r24, 0x0395
     75e:	81 30       	cpi	r24, 0x01	; 1
     760:	31 f4       	brne	.+12     	; 0x76e <__vector_7+0x44>
     762:	80 91 96 03 	lds	r24, 0x0396
     766:	88 23       	and	r24, r24
     768:	11 f0       	breq	.+4      	; 0x76e <__vector_7+0x44>
			
			PORTF &= ~(1<<GATE); //if arp is running, turn gate off
     76a:	89 98       	cbi	0x11, 1	; 17
			PORTB &= ~ (1<<ARP_SYNC_LED); //turn off arp sync LED
     76c:	2f 98       	cbi	0x05, 7	; 5
			
		}
	}			
		
	if (++system_clock.ppqn_counter == system_clock.divider) {
     76e:	80 91 d8 03 	lds	r24, 0x03D8
     772:	8f 5f       	subi	r24, 0xFF	; 255
     774:	80 93 d8 03 	sts	0x03D8, r24
     778:	90 91 d7 03 	lds	r25, 0x03D7
     77c:	89 17       	cp	r24, r25
     77e:	91 f4       	brne	.+36     	; 0x7a4 <__vector_7+0x7a>
		
		system_clock.ppqn_counter = 0;
     780:	10 92 d8 03 	sts	0x03D8, r1
		
		if ((arp.clock_source == INTERNAL_CLOCK) && (arp.mode)) {
     784:	80 91 95 03 	lds	r24, 0x0395
     788:	81 30       	cpi	r24, 0x01	; 1
     78a:	61 f4       	brne	.+24     	; 0x7a4 <__vector_7+0x7a>
     78c:	80 91 96 03 	lds	r24, 0x0396
     790:	88 23       	and	r24, r24
     792:	41 f0       	breq	.+16     	; 0x7a4 <__vector_7+0x7a>
			
			//step arp note here based on range and note sequence from assigner	
			
			if (gate_buffer) { //if there are still notes in gate buffer
     794:	80 91 b4 02 	lds	r24, 0x02B4
     798:	88 23       	and	r24, r24
     79a:	21 f0       	breq	.+8      	; 0x7a4 <__vector_7+0x7a>
				step_arp_note(); //will need to force inline this function. It will need to be used elsewhere for arp MIDI sync.
     79c:	0e 94 34 01 	call	0x268	; 0x268 <step_arp_note>
				PORTF |= (1<<GATE);
     7a0:	89 9a       	sbi	0x11, 1	; 17
				PORTB |= (1<<ARP_SYNC_LED);
     7a2:	2f 9a       	sbi	0x05, 7	; 5
			} 
		}			
	}
	
     7a4:	ff 91       	pop	r31
     7a6:	ef 91       	pop	r30
     7a8:	bf 91       	pop	r27
     7aa:	af 91       	pop	r26
     7ac:	9f 91       	pop	r25
     7ae:	8f 91       	pop	r24
     7b0:	7f 91       	pop	r23
     7b2:	6f 91       	pop	r22
     7b4:	5f 91       	pop	r21
     7b6:	4f 91       	pop	r20
     7b8:	3f 91       	pop	r19
     7ba:	2f 91       	pop	r18
     7bc:	0f 90       	pop	r0
     7be:	0f be       	out	0x3f, r0	; 63
     7c0:	0f 90       	pop	r0
     7c2:	1f 90       	pop	r1
     7c4:	18 95       	reti

000007c6 <song_position_event>:
uint8_t switch_timer = 0;


void song_position_event(MidiDevice * device, uint8_t byte0, uint8_t byte1, uint8_t byte2) {
	
	arp.display = 42;
     7c6:	8a e2       	ldi	r24, 0x2A	; 42
     7c8:	80 93 94 03 	sts	0x0394, r24
	
}
     7cc:	08 95       	ret

000007ce <real_time_event>:
}

void real_time_event(MidiDevice * device, uint8_t real_time_byte) {
	//PORTB ^= (1<<ARP_SYNC_LED);
	//if (~(current_patch.byte_2 & (1<<LFO_KEY_SYNC) >> 1)) return; //if not in a sync mode, then retrun
	switch (real_time_byte) {
     7ce:	6a 3f       	cpi	r22, 0xFA	; 250
     7d0:	09 f4       	brne	.+2      	; 0x7d4 <real_time_event+0x6>
     7d2:	5a c0       	rjmp	.+180    	; 0x888 <real_time_event+0xba>
     7d4:	6c 3f       	cpi	r22, 0xFC	; 252
     7d6:	09 f4       	brne	.+2      	; 0x7da <real_time_event+0xc>
     7d8:	6d c0       	rjmp	.+218    	; 0x8b4 <real_time_event+0xe6>
     7da:	68 3f       	cpi	r22, 0xF8	; 248
     7dc:	09 f0       	breq	.+2      	; 0x7e0 <real_time_event+0x12>
     7de:	6d c0       	rjmp	.+218    	; 0x8ba <real_time_event+0xec>
		
		case MIDI_CLOCK:
		
			if (++midi_clock.ppqn_counter == midi_clock.divider) { //can be used for analog LFO reset and eventually for software LFO
     7e0:	80 91 e4 03 	lds	r24, 0x03E4
     7e4:	8f 5f       	subi	r24, 0xFF	; 255
     7e6:	80 93 e4 03 	sts	0x03E4, r24
     7ea:	90 91 e3 03 	lds	r25, 0x03E3
     7ee:	89 17       	cp	r24, r25
     7f0:	11 f4       	brne	.+4      	; 0x7f6 <real_time_event+0x28>
				
				//++arp.song_position;
				midi_clock.ppqn_counter = 0;
     7f2:	10 92 e4 03 	sts	0x03E4, r1
				//arp.display = arp.song_position;
			}						
			++arp.song_position;
     7f6:	80 91 90 03 	lds	r24, 0x0390
     7fa:	90 91 91 03 	lds	r25, 0x0391
     7fe:	a0 91 92 03 	lds	r26, 0x0392
     802:	b0 91 93 03 	lds	r27, 0x0393
     806:	01 96       	adiw	r24, 0x01	; 1
     808:	a1 1d       	adc	r26, r1
     80a:	b1 1d       	adc	r27, r1
     80c:	80 93 90 03 	sts	0x0390, r24
     810:	90 93 91 03 	sts	0x0391, r25
     814:	a0 93 92 03 	sts	0x0392, r26
     818:	b0 93 93 03 	sts	0x0393, r27
			if (++lfo_clock.ppqn_counter == lfo_clock.divider) {
     81c:	80 91 de 03 	lds	r24, 0x03DE
     820:	8f 5f       	subi	r24, 0xFF	; 255
     822:	80 93 de 03 	sts	0x03DE, r24
     826:	90 91 dd 03 	lds	r25, 0x03DD
     82a:	89 17       	cp	r24, r25
     82c:	21 f4       	brne	.+8      	; 0x836 <real_time_event+0x68>
				PORTB |= (1<< LFO_RESET);
     82e:	2c 9a       	sbi	0x05, 4	; 5
				//_delay_us(1); //what is minimum pulse width required for LFO reset? Will need to implement this with some other kind of delay OR OR OR - maybe a RC network to provide minimum pulse width for LFO reset????
				
				//PORTB ^= (1<<ARP_SYNC_LED);
				//register clock event - this will do something  - reset LFO or initiate LFO
				lfo_clock.ppqn_counter = 0; //reset MIDI ppqn clock	
     830:	10 92 de 03 	sts	0x03DE, r1
				PORTB &= ~(1<< LFO_RESET); //turn off LFO reset pin
     834:	2c 98       	cbi	0x05, 4	; 5
			}
			
			if (arp.mode) { //if arp is running
     836:	80 91 96 03 	lds	r24, 0x0396
     83a:	88 23       	and	r24, r24
     83c:	f1 f1       	breq	.+124    	; 0x8ba <real_time_event+0xec>
				
				//arp.ppqn_counter++;
			
				if (arp.ppqn_counter == arp.divider) {
     83e:	90 91 8e 03 	lds	r25, 0x038E
     842:	80 91 8f 03 	lds	r24, 0x038F
     846:	98 17       	cp	r25, r24
     848:	51 f4       	brne	.+20     	; 0x85e <real_time_event+0x90>
				
				
					arp.ppqn_counter = 0;
     84a:	10 92 8e 03 	sts	0x038E, r1
					if (gate_buffer) { //if there are still notes in gate buffer
     84e:	80 91 b4 02 	lds	r24, 0x02B4
     852:	88 23       	and	r24, r24
     854:	21 f0       	breq	.+8      	; 0x85e <real_time_event+0x90>
						
						step_arp_note(); //should force inline this function.
     856:	0e 94 34 01 	call	0x268	; 0x268 <step_arp_note>
						PORTF |= (1<<GATE);  
     85a:	89 9a       	sbi	0x11, 1	; 17
						PORTB |= (1<<ARP_SYNC_LED);
     85c:	2f 9a       	sbi	0x05, 7	; 5
					}	
				
				}
				
				if (arp.ppqn_counter == arp.divider - (arp.divider >> 1)) { //50% gate width
     85e:	40 91 8f 03 	lds	r20, 0x038F
     862:	20 91 8e 03 	lds	r18, 0x038E
     866:	30 e0       	ldi	r19, 0x00	; 0
     868:	84 2f       	mov	r24, r20
     86a:	90 e0       	ldi	r25, 0x00	; 0
     86c:	46 95       	lsr	r20
     86e:	84 1b       	sub	r24, r20
     870:	91 09       	sbc	r25, r1
     872:	28 17       	cp	r18, r24
     874:	39 07       	cpc	r19, r25
     876:	11 f4       	brne	.+4      	; 0x87c <real_time_event+0xae>
								
					PORTF &= ~(1<<GATE);
     878:	89 98       	cbi	0x11, 1	; 17
					PORTB &= ~ (1<<ARP_SYNC_LED); //turn off arp sync LED
     87a:	2f 98       	cbi	0x05, 7	; 5
								
				}
				arp.ppqn_counter++; //post increment means ppqn_counter is never 0, lowest is 1. Does this make sense for counting from 1 to arp.divide?
     87c:	80 91 8e 03 	lds	r24, 0x038E
     880:	8f 5f       	subi	r24, 0xFF	; 255
     882:	80 93 8e 03 	sts	0x038E, r24
     886:	08 95       	ret
			
			break;
			
		case MIDI_START:
			
			lfo_clock.ppqn_counter = 0;
     888:	10 92 de 03 	sts	0x03DE, r1
			midi_clock.ppqn_counter = 0;
     88c:	10 92 e4 03 	sts	0x03E4, r1
			arp.ppqn_counter = arp.divider;//-1; //trigger arp step on next MIDI clock tick. This -1 here is key to getting proper sync to beat clock behavior
     890:	80 91 8f 03 	lds	r24, 0x038F
     894:	80 93 8e 03 	sts	0x038E, r24
			arp.clock_source = MIDI_CLOCK;
     898:	88 ef       	ldi	r24, 0xF8	; 248
     89a:	80 93 95 03 	sts	0x0395, r24
			arp.step_position = 0; 
     89e:	10 92 8a 03 	sts	0x038A, r1
			arp.song_position = 0; //reset master song position counter
     8a2:	10 92 90 03 	sts	0x0390, r1
     8a6:	10 92 91 03 	sts	0x0391, r1
     8aa:	10 92 92 03 	sts	0x0392, r1
     8ae:	10 92 93 03 	sts	0x0393, r1
			break;
     8b2:	08 95       	ret
			
		case MIDI_STOP:
		
			arp.clock_source = INTERNAL_CLOCK; //revert to internal clock when MIDI STOP message received
     8b4:	81 e0       	ldi	r24, 0x01	; 1
     8b6:	80 93 95 03 	sts	0x0395, r24
     8ba:	08 95       	ret

000008bc <note_off_event>:
		}		
	}
	//PORTB &= ~(1<< LFO_RESET);
	
}
void note_off_event(MidiDevice * device, uint8_t status, uint8_t note, uint8_t velocity) {
     8bc:	84 2f       	mov	r24, r20
	
	remove_note(note);
     8be:	0e 94 af 01 	call	0x35e	; 0x35e <remove_note>
	gate_buffer--;
     8c2:	80 91 b4 02 	lds	r24, 0x02B4
     8c6:	81 50       	subi	r24, 0x01	; 1
     8c8:	80 93 b4 02 	sts	0x02B4, r24
	//
	if (arp.mode) {	//if arp on, update arp sequence
     8cc:	90 91 96 03 	lds	r25, 0x0396
     8d0:	99 23       	and	r25, r25
     8d2:	71 f0       	breq	.+28     	; 0x8f0 <note_off_event+0x34>
		//gate_buffer--;
		if (gate_buffer == 0) {
     8d4:	88 23       	and	r24, r24
     8d6:	49 f4       	brne	.+18     	; 0x8ea <note_off_event+0x2e>
			arp.current_note = arp.previous_note; //handle last note prevservation for release phase
     8d8:	80 91 8c 03 	lds	r24, 0x038C
     8dc:	80 93 8d 03 	sts	0x038D, r24
			//if (arp.clock_source == INTERNAL_CLOCK) arp.step_position = 0; //if arp is synced to MIDI clock, then step position is reset when MIDI START message received
			arp.step_position = 0;
     8e0:	10 92 8a 03 	sts	0x038A, r1
			arp.direction = UP; //this is to initialize UP/DOWN mode
     8e4:	81 e0       	ldi	r24, 0x01	; 1
     8e6:	80 93 8b 03 	sts	0x038B, r24
		}			
		update_arp_sequence();
     8ea:	0e 94 a3 00 	call	0x146	; 0x146 <update_arp_sequence>
     8ee:	08 95       	ret
	} else {
		
		//update_arp_sequence();
		if (gate_buffer == 0) PORTF &= ~(1<<GATE);
     8f0:	88 23       	and	r24, r24
     8f2:	09 f4       	brne	.+2      	; 0x8f6 <note_off_event+0x3a>
     8f4:	89 98       	cbi	0x11, 1	; 17
     8f6:	08 95       	ret

000008f8 <note_on_event>:
	
}



void note_on_event(MidiDevice * device, uint8_t status, uint8_t note, uint8_t velocity) {
     8f8:	84 2f       	mov	r24, r20
	
	if ((current_patch.byte_2 >> LFO_KEY_SYNC) & 1) {
     8fa:	90 91 03 03 	lds	r25, 0x0303
     8fe:	90 ff       	sbrs	r25, 0
     900:	06 c0       	rjmp	.+12     	; 0x90e <note_on_event+0x16>
		
		PORTB |= (1<< LFO_RESET);
     902:	2c 9a       	sbi	0x05, 4	; 5
     904:	96 e0       	ldi	r25, 0x06	; 6
     906:	9a 95       	dec	r25
     908:	f1 f7       	brne	.-4      	; 0x906 <note_on_event+0xe>
     90a:	00 c0       	rjmp	.+0      	; 0x90c <note_on_event+0x14>
		_delay_us(1); //what is minimum pulse width required for LFO reset?
		PORTB &= ~(1<< LFO_RESET);
     90c:	2c 98       	cbi	0x05, 4	; 5
			
	}		
	
	midi_note_number = note;
     90e:	80 93 be 02 	sts	0x02BE, r24
	if (velocity == 0) { //if velocity is 0 then it is a note off event - just call note off function rather than duplicate code here. arp will need to handle this too
     912:	22 23       	and	r18, r18
     914:	59 f4       	brne	.+22     	; 0x92c <note_on_event+0x34>
		remove_note(note);
     916:	0e 94 af 01 	call	0x35e	; 0x35e <remove_note>
		gate_buffer--;
     91a:	80 91 b4 02 	lds	r24, 0x02B4
     91e:	81 50       	subi	r24, 0x01	; 1
     920:	80 93 b4 02 	sts	0x02B4, r24
		if (gate_buffer == 0) PORTF &= ~(1<<GATE);
     924:	88 23       	and	r24, r24
     926:	91 f4       	brne	.+36     	; 0x94c <note_on_event+0x54>
     928:	89 98       	cbi	0x11, 1	; 17
     92a:	08 95       	ret
				
	} else {
		
		new_note(note, velocity);  
     92c:	62 2f       	mov	r22, r18
     92e:	0e 94 97 01 	call	0x32e	; 0x32e <new_note>
		
		gate_buffer++;
     932:	80 91 b4 02 	lds	r24, 0x02B4
     936:	8f 5f       	subi	r24, 0xFF	; 255
     938:	80 93 b4 02 	sts	0x02B4, r24
		if (arp.mode) { //if arp is off, handle gate
     93c:	80 91 96 03 	lds	r24, 0x0396
     940:	88 23       	and	r24, r24
     942:	19 f0       	breq	.+6      	; 0x94a <note_on_event+0x52>
			//new_note(note, velocity);
			//gate_buffer++; //increment gate_buffer
			//arp.display = arp.ppqn_counter;
			update_arp_sequence();
     944:	0e 94 a3 00 	call	0x146	; 0x146 <update_arp_sequence>
     948:	08 95       	ret
				//arp.ppqn_counter = arp.divider; //reset ppqn counter to trigger arp step. This should implement KEY SYNC but messes up over all beat sync to master
				//ok, if note on comes on an arp divider beat, then it needs to be triggered, but if it isn't on a divider beat, then it shouldn't be triggered, right?	
				//arp.step_position = 0; //reset step position when new note arrives? Have a look here to get into nitty gritty details of arp sync behaviour: http://lauterzeit.com/arp_lfo_seq_sync/
			//}			
		} else {
			PORTF |= (1<<GATE); //if arp is OFF then turn on gate. Otherwise arpeggiator handles GATE
     94a:	89 9a       	sbi	0x11, 1	; 17
     94c:	08 95       	ret

0000094e <setup_midi_usart>:

void setup_midi_usart(void)
{
    uint16_t ubbr_value = 39; //20MHz/(16*31250 BAUD) - 1
    //write ubbr_value to H and L UBBR1 registers:
    UBRR0L = (unsigned char) ubbr_value;
     94e:	87 e2       	ldi	r24, 0x27	; 39
     950:	80 93 c4 00 	sts	0x00C4, r24
    UBRR0H = (unsigned char) (ubbr_value >> 8);
     954:	10 92 c5 00 	sts	0x00C5, r1
	
	UCSR0B = (1<<RXEN0)|(1<<TXEN0) | (1<<RXCIE0);
     958:	88 e9       	ldi	r24, 0x98	; 152
     95a:	80 93 c1 00 	sts	0x00C1, r24
	//UCSR0C |= (0<<UMSEL0)|(0<<UMSEL01)|(0<<UPM01)|(0<<UPM00)|(0<<USBS0)|(0<<UCSZ02)|(1<<UCSZ01)|(1<<UCSZ00);  	
}
     95e:	08 95       	ret

00000960 <__vector_13>:



ISR (USART_RX_vect) { // USART receive interrupt
     960:	1f 92       	push	r1
     962:	0f 92       	push	r0
     964:	0f b6       	in	r0, 0x3f	; 63
     966:	0f 92       	push	r0
     968:	11 24       	eor	r1, r1
     96a:	2f 93       	push	r18
     96c:	3f 93       	push	r19
     96e:	4f 93       	push	r20
     970:	5f 93       	push	r21
     972:	6f 93       	push	r22
     974:	7f 93       	push	r23
     976:	8f 93       	push	r24
     978:	9f 93       	push	r25
     97a:	af 93       	push	r26
     97c:	bf 93       	push	r27
     97e:	ef 93       	push	r30
     980:	ff 93       	push	r31
     982:	cf 93       	push	r28
     984:	df 93       	push	r29
     986:	0f 92       	push	r0
     988:	cd b7       	in	r28, 0x3d	; 61
     98a:	de b7       	in	r29, 0x3e	; 62
	//PORTB ^= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED 
	uint8_t inByte = UDR0;
     98c:	80 91 c6 00 	lds	r24, 0x00C6
     990:	89 83       	std	Y+1, r24	; 0x01
	midi_device_input(&midi_device, 1, &inByte); 
     992:	89 ee       	ldi	r24, 0xE9	; 233
     994:	93 e0       	ldi	r25, 0x03	; 3
     996:	61 e0       	ldi	r22, 0x01	; 1
     998:	ae 01       	movw	r20, r28
     99a:	4f 5f       	subi	r20, 0xFF	; 255
     99c:	5f 4f       	sbci	r21, 0xFF	; 255
     99e:	0e 94 7f 1a 	call	0x34fe	; 0x34fe <midi_device_input>
	//calling a function in an interrupt is inefficient according to AVR C guidelines
	// so this function should maybe be inlined in main loop if inByte is made volatile	
	//***HOWEVER***, xnor-midi example code has this function being called from USART_RX_vect ISR  	
}
     9a2:	0f 90       	pop	r0
     9a4:	df 91       	pop	r29
     9a6:	cf 91       	pop	r28
     9a8:	ff 91       	pop	r31
     9aa:	ef 91       	pop	r30
     9ac:	bf 91       	pop	r27
     9ae:	af 91       	pop	r26
     9b0:	9f 91       	pop	r25
     9b2:	8f 91       	pop	r24
     9b4:	7f 91       	pop	r23
     9b6:	6f 91       	pop	r22
     9b8:	5f 91       	pop	r21
     9ba:	4f 91       	pop	r20
     9bc:	3f 91       	pop	r19
     9be:	2f 91       	pop	r18
     9c0:	0f 90       	pop	r0
     9c2:	0f be       	out	0x3f, r0	; 63
     9c4:	0f 90       	pop	r0
     9c6:	1f 90       	pop	r1
     9c8:	18 95       	reti

000009ca <main>:


int main(void)
{
	//turn off JTAG so all outputs of PORTC can be used
	MCUCR = (1<<JTD);
     9ca:	c0 e8       	ldi	r28, 0x80	; 128
     9cc:	c5 bf       	out	0x35, r28	; 53
	MCUCR = (1<<JTD);
     9ce:	c5 bf       	out	0x35, r28	; 53
		
	//SET PORTB PIN 7 (PB7) as OUTPUT
	DDRB |= (1<<ARP_SYNC_LED);
     9d0:	27 9a       	sbi	0x04, 7	; 4
	
	DDRB |= (1<< LFO_RESET); //set LFO reset as output. This affects LFO rate and TRI balance - needed to trim both rate and balance.
     9d2:	24 9a       	sbi	0x04, 4	; 4
	//PORTB |= (1<< LFO_RESET);
	
	
	DDRF |= (1<<GATE); //set gate as output
     9d4:	81 9a       	sbi	0x10, 1	; 16
	//PORTF |= (1<<GATE); //turn gate on for testing
	
	DDRG |= (1<<TUNE_SELECT); //set tune select bit as output on PORTG
     9d6:	9a 9a       	sbi	0x13, 2	; 19
	PORTG &= ~(1<<TUNE_SELECT); //set tune select bit to 0 to select VCF/VCA output for oscillator tuning
     9d8:	a2 98       	cbi	0x14, 2	; 20
	//PORTG |= (1<<TUNE_SELECT);
	
	setup_spi(); 
     9da:	0e 94 47 08 	call	0x108e	; 0x108e <setup_spi>
	
	DDRH |= (1<<POTMUX_EN0) | (1<<POTMUX_EN1); //set POTMUX_EN pins as outputs
     9de:	a9 ed       	ldi	r26, 0xD9	; 217
     9e0:	b0 e0       	ldi	r27, 0x00	; 0
     9e2:	8c 91       	ld	r24, X
     9e4:	80 6c       	ori	r24, 0xC0	; 192
     9e6:	8c 93       	st	X, r24
	POT_MUX |= (1<<POTMUX_EN0) | (1<<POTMUX_EN1); //set POTMUX_EN pins HIGH (active LOW)
     9e8:	ea ed       	ldi	r30, 0xDA	; 218
     9ea:	f0 e0       	ldi	r31, 0x00	; 0
     9ec:	80 81       	ld	r24, Z
     9ee:	80 6c       	ori	r24, 0xC0	; 192
     9f0:	80 83       	st	Z, r24
	//POT_MUX |= (1<<POTMUX_EN1);
	
	//set up LED display
	DDRA |= 0b11111111; //set all lines or DATA_BUS to outputs
     9f2:	81 b1       	in	r24, 0x01	; 1
     9f4:	8f ef       	ldi	r24, 0xFF	; 255
     9f6:	81 b9       	out	0x01, r24	; 1
	DATA_BUS |= 0b11111111; //set all DATA_BUS lines to HIGH (cathodes OFF)
     9f8:	92 b1       	in	r25, 0x02	; 2
     9fa:	82 b9       	out	0x02, r24	; 2
	DDRH |= (1<<DISP_CATHODE_LATCH) | (1<<DISP_ANODE_LATCH); //set display latches to outputs
     9fc:	8c 91       	ld	r24, X
     9fe:	80 63       	ori	r24, 0x30	; 48
     a00:	8c 93       	st	X, r24
	DISPLAY_PORT &= ~(1<<DISP_ANODE_LATCH | 1<< DISP_CATHODE_LATCH); //set DISP latches to LOW (inactive)
     a02:	80 81       	ld	r24, Z
     a04:	8f 7c       	andi	r24, 0xCF	; 207
     a06:	80 83       	st	Z, r24
	
	//set up switch port
	DDRF &= ~(1<<BMOD_SW); //set BMOD_SW pin as input
     a08:	82 98       	cbi	0x10, 2	; 16
	
	//set up LFO DEMUX LATCH
	DDRJ |= (1<<LFO_SW_LATCH); //set LFO_SW_LATCH pin as output
     a0a:	ec ed       	ldi	r30, 0xDC	; 220
     a0c:	f0 e0       	ldi	r31, 0x00	; 0
     a0e:	80 81       	ld	r24, Z
     a10:	80 62       	ori	r24, 0x20	; 32
     a12:	80 83       	st	Z, r24
	DATA_BUS = LFO_TRI_ADDR;
     a14:	12 b8       	out	0x02, r1	; 2
	LFO_LATCH_PORT |= (1<<LFO_SW_LATCH);
     a16:	ed ed       	ldi	r30, 0xDD	; 221
     a18:	f0 e0       	ldi	r31, 0x00	; 0
     a1a:	80 81       	ld	r24, Z
     a1c:	80 62       	ori	r24, 0x20	; 32
     a1e:	80 83       	st	Z, r24
	LFO_LATCH_PORT &= ~(1<<LFO_SW_LATCH);
     a20:	80 81       	ld	r24, Z
     a22:	8f 7d       	andi	r24, 0xDF	; 223
     a24:	80 83       	st	Z, r24
	DATA_BUS = 0;
     a26:	12 b8       	out	0x02, r1	; 2
	current_patch.byte_2 = (1<<LFO_TRI);
     a28:	c0 93 03 03 	sts	0x0303, r28
	
	//setup ADC
    setup_adc();		
     a2c:	0e 94 51 00 	call	0xa2	; 0xa2 <setup_adc>
	//setup DAC
	setup_dac();
     a30:	0e 94 36 02 	call	0x46c	; 0x46c <setup_dac>
	
	//setup MIDI
	//initialize MIDI device
	midi_device_init(&midi_device);
     a34:	c9 ee       	ldi	r28, 0xE9	; 233
     a36:	d3 e0       	ldi	r29, 0x03	; 3
     a38:	ce 01       	movw	r24, r28
     a3a:	0e 94 4e 1a 	call	0x349c	; 0x349c <midi_device_init>
	//register callbacks
	midi_register_noteon_callback(&midi_device, note_on_event);
     a3e:	ce 01       	movw	r24, r28
     a40:	6c e7       	ldi	r22, 0x7C	; 124
     a42:	74 e0       	ldi	r23, 0x04	; 4
     a44:	0e 94 16 1a 	call	0x342c	; 0x342c <midi_register_noteon_callback>
	midi_register_noteoff_callback(&midi_device, note_off_event);
     a48:	ce 01       	movw	r24, r28
     a4a:	6e e5       	ldi	r22, 0x5E	; 94
     a4c:	74 e0       	ldi	r23, 0x04	; 4
     a4e:	0e 94 1a 1a 	call	0x3434	; 0x3434 <midi_register_noteoff_callback>
	midi_register_realtime_callback(&midi_device, real_time_event);
     a52:	ce 01       	movw	r24, r28
     a54:	67 ee       	ldi	r22, 0xE7	; 231
     a56:	73 e0       	ldi	r23, 0x03	; 3
     a58:	0e 94 3a 1a 	call	0x3474	; 0x3474 <midi_register_realtime_callback>
	midi_register_songposition_callback(&midi_device, song_position_event);
     a5c:	ce 01       	movw	r24, r28
     a5e:	63 ee       	ldi	r22, 0xE3	; 227
     a60:	73 e0       	ldi	r23, 0x03	; 3
     a62:	0e 94 26 1a 	call	0x344c	; 0x344c <midi_register_songposition_callback>
	//setup MIDI USART
	setup_midi_usart();
     a66:	0e 94 a7 04 	call	0x94e	; 0x94e <setup_midi_usart>
	
	update_spi(); //initial update of SPI - will eventual be useful for picking up special power up switch holds
     a6a:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <update_spi>
	
	
	current_patch.number = 1;
     a6e:	c1 e0       	ldi	r28, 0x01	; 1
     a70:	c0 93 07 03 	sts	0x0307, r28
		
	sei(); //enable global interrupts
     a74:	78 94       	sei

	
	//eeprom_update_word((uint16_t*)109, test_word);
	//value_to_display = eeprom_read_word((uint16_t*)109);
	
	load_tuning_tables();
     a76:	0e 94 7c 16 	call	0x2cf8	; 0x2cf8 <load_tuning_tables>
	//value_to_display = vco1_init_cv;
	//set_one_volt_per_octave(); //overwrite tuning tables with 1V/octave data for calibration purposes
	//set initial switch states
	//switch_states.byte0 = (1<<VCO1_PULSE_SW) | (1<<VCO2_PULSE_SW);
	//current_patch.byte_4 = (1<<VCO1_32F) | (1<<VCO2_32F);
	load_patch(1);
     a7a:	81 e0       	ldi	r24, 0x01	; 1
     a7c:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <load_patch>
	
	setup_system_clock();
     a80:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <setup_system_clock>
	//update_clock_speed(244);
	system_clock.divider = 24;
     a84:	88 e1       	ldi	r24, 0x18	; 24
     a86:	80 93 d7 03 	sts	0x03D7, r24
	midi_clock.divider = 6;//this is for MIDI beat clock which is /6 MIDI ppqn clock or 16th notes
     a8a:	86 e0       	ldi	r24, 0x06	; 6
     a8c:	80 93 e3 03 	sts	0x03E3, r24
	arp.step_position = 0; //initialize step position
     a90:	10 92 8a 03 	sts	0x038A, r1
	arp.clock_source = INTERNAL_CLOCK;
     a94:	c0 93 95 03 	sts	0x0395, r28
	arp.mode = OFF;
     a98:	10 92 96 03 	sts	0x0396, r1
	arp.ppqn_counter = 1;
     a9c:	c0 93 8e 03 	sts	0x038E, r28

	while(1)
	{	
		
		
		midi_device_process(&midi_device); //this needs to be called 'frequently' in order for MIDI to work
     aa0:	09 ee       	ldi	r16, 0xE9	; 233
     aa2:	13 e0       	ldi	r17, 0x03	; 3
		if (switch_timer++ == 5)
		{
			switch_timer = 0;
			switch_press = 0; //reset global switch press flag
			//read switches directly connected to MCU	
			switch_states.byte2 ^= read_switch_port(); //toggle switch states
     aa4:	0f 2e       	mov	r0, r31
     aa6:	f4 e8       	ldi	r31, 0x84	; 132
     aa8:	ef 2e       	mov	r14, r31
     aaa:	f3 e0       	ldi	r31, 0x03	; 3
     aac:	ff 2e       	mov	r15, r31
     aae:	f0 2d       	mov	r31, r0
			switch_states.byte2 |= (current_patch.mode == MANUAL) << PROG_MANUAL_SW; //if MANUAL then don't toggle switch
     ab0:	0f 2e       	mov	r0, r31
     ab2:	fb e0       	ldi	r31, 0x0B	; 11
     ab4:	cf 2e       	mov	r12, r31
     ab6:	f3 e0       	ldi	r31, 0x03	; 3
     ab8:	df 2e       	mov	r13, r31
     aba:	f0 2d       	mov	r31, r0
			//switch_states.byte2 |= (current_patch.mode == WRITE) << PROG_WRITE_SW; //if WRITE then don't toggle switch
			update_spi();
			if (switch_press) { 
				update_patch();
				if (current_patch.mode == MEMORY) current_patch.mode = EDIT; //change mode to EDIT if non-program switch is detected
     abc:	bb 24       	eor	r11, r11
     abe:	68 94       	set
     ac0:	b1 f8       	bld	r11, 1
		{
			switch_timer = 0;
			switch_press = 0; //reset global switch press flag
			//read switches directly connected to MCU	
			switch_states.byte2 ^= read_switch_port(); //toggle switch states
			switch_states.byte2 |= (current_patch.mode == MANUAL) << PROG_MANUAL_SW; //if MANUAL then don't toggle switch
     ac2:	d0 e8       	ldi	r29, 0x80	; 128

	while(1)
	{	
		
		
		midi_device_process(&midi_device); //this needs to be called 'frequently' in order for MIDI to work
     ac4:	c8 01       	movw	r24, r16
     ac6:	0e 94 a9 1c 	call	0x3952	; 0x3952 <midi_device_process>
		//value_to_display = vco1_init_cv;
		//PORTB |= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED
		update_display(value_to_display, DEC); //maybe move this into switch_timer loop. Probably doesn't need to be updated this frequently
     aca:	80 91 fd 01 	lds	r24, 0x01FD
     ace:	90 91 fe 01 	lds	r25, 0x01FE
     ad2:	60 e0       	ldi	r22, 0x00	; 0
     ad4:	0e 94 38 03 	call	0x670	; 0x670 <update_display>
		//PORTB &= ~(1<<ARP_SYNC_LED);
		 	
		//scan_pots_and_update_control_voltages();
		scan_pots();
     ad8:	0e 94 9b 05 	call	0xb36	; 0xb36 <scan_pots>
		update_control_voltages();
     adc:	0e 94 28 06 	call	0xc50	; 0xc50 <update_control_voltages>
			
		//do SPI read/write every 5 loops. This is quite clumsy. Not sure yet how to better implement it
		if (switch_timer++ == 5)
     ae0:	80 91 bd 02 	lds	r24, 0x02BD
     ae4:	98 2f       	mov	r25, r24
     ae6:	9f 5f       	subi	r25, 0xFF	; 255
     ae8:	90 93 bd 02 	sts	0x02BD, r25
     aec:	85 30       	cpi	r24, 0x05	; 5
     aee:	51 f7       	brne	.-44     	; 0xac4 <main+0xfa>
		{
			switch_timer = 0;
     af0:	10 92 bd 02 	sts	0x02BD, r1
			switch_press = 0; //reset global switch press flag
     af4:	10 92 c5 02 	sts	0x02C5, r1
			//read switches directly connected to MCU	
			switch_states.byte2 ^= read_switch_port(); //toggle switch states
     af8:	f7 01       	movw	r30, r14
     afa:	c0 81       	ld	r28, Z
     afc:	0e 94 30 17 	call	0x2e60	; 0x2e60 <read_switch_port>
     b00:	8c 27       	eor	r24, r28
			switch_states.byte2 |= (current_patch.mode == MANUAL) << PROG_MANUAL_SW; //if MANUAL then don't toggle switch
     b02:	f6 01       	movw	r30, r12
     b04:	90 81       	ld	r25, Z
     b06:	91 30       	cpi	r25, 0x01	; 1
     b08:	11 f4       	brne	.+4      	; 0xb0e <main+0x144>
     b0a:	cd 2f       	mov	r28, r29
     b0c:	01 c0       	rjmp	.+2      	; 0xb10 <main+0x146>
     b0e:	c0 e0       	ldi	r28, 0x00	; 0
     b10:	c8 2b       	or	r28, r24
     b12:	f7 01       	movw	r30, r14
     b14:	c0 83       	st	Z, r28
			//switch_states.byte2 |= (current_patch.mode == WRITE) << PROG_WRITE_SW; //if WRITE then don't toggle switch
			update_spi();
     b16:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <update_spi>
			if (switch_press) { 
     b1a:	80 91 c5 02 	lds	r24, 0x02C5
     b1e:	88 23       	and	r24, r24
     b20:	39 f0       	breq	.+14     	; 0xb30 <main+0x166>
				update_patch();
     b22:	0e 94 f9 0f 	call	0x1ff2	; 0x1ff2 <update_patch>
				if (current_patch.mode == MEMORY) current_patch.mode = EDIT; //change mode to EDIT if non-program switch is detected
     b26:	f6 01       	movw	r30, r12
     b28:	80 81       	ld	r24, Z
     b2a:	88 23       	and	r24, r24
     b2c:	09 f4       	brne	.+2      	; 0xb30 <main+0x166>
     b2e:	b0 82       	st	Z, r11
			}				
			update_patch_programmer();	
     b30:	0e 94 86 10 	call	0x210c	; 0x210c <update_patch_programmer>
     b34:	c7 cf       	rjmp	.-114    	; 0xac4 <main+0xfa>

00000b36 <scan_pots>:

uint8_t midi_note_number = 0; //store incoming MIDI note here for pitch lookup table

volatile uint16_t value_to_display = 79; //global to hold display value
	
void scan_pots(void) { //should probably move this to adc.c
     b36:	bf 92       	push	r11
     b38:	cf 92       	push	r12
     b3a:	df 92       	push	r13
     b3c:	ef 92       	push	r14
     b3e:	ff 92       	push	r15
     b40:	0f 93       	push	r16
     b42:	1f 93       	push	r17
     b44:	cf 93       	push	r28
     b46:	df 93       	push	r29
     b48:	c0 e0       	ldi	r28, 0x00	; 0
     b4a:	d1 e0       	ldi	r29, 0x01	; 1
     b4c:	06 ec       	ldi	r16, 0xC6	; 198
     b4e:	12 e0       	ldi	r17, 0x02	; 2
     b50:	0f 2e       	mov	r0, r31
     b52:	fc e3       	ldi	r31, 0x3C	; 60
     b54:	cf 2e       	mov	r12, r31
     b56:	dd 24       	eor	r13, r13
     b58:	f0 2d       	mov	r31, r0
     b5a:	cc 0e       	add	r12, r28
     b5c:	dd 1e       	adc	r13, r29
		//what happens next depends on mode. if pot is locked, then the value of the pot is not written to the current patch unless it is different from the pot's locked value
		
		uint8_t delta_pot = pot_id[i]->locked_value - ((pot_id[i]->value >> 2)); //quick and dirty subtraction, where unsigned delta pot will overflow if value > locked value. see below
		
		
		if ((current_patch.mode == MANUAL) || (pot_id[i]->locked == 0)) { //if in manual mode or pot is already unlocked
     b5e:	0f 2e       	mov	r0, r31
     b60:	fb e0       	ldi	r31, 0x0B	; 11
     b62:	ef 2e       	mov	r14, r31
     b64:	f3 e0       	ldi	r31, 0x03	; 3
     b66:	ff 2e       	mov	r15, r31
     b68:	f0 2d       	mov	r31, r0
		//} else if ((((pot_id[i]->value >> 2) != pot_id[i]->locked_value)) && (pot_id[i]->locked == 1)) { //need to figure out delta threshold here. 10 bit to 8 bit resolution should be enough???
			
		} else if (((delta_pot > 2) && (delta_pot < 253)) && (pot_id[i]->locked == 1)) { //set a threshold of +/- 3 for pot change  		  		  	
			*(patch_value + i) = pot_id[i]->value;
			pot_id[i]->locked = 0; //unlock pot
			current_patch.mode = EDIT;
     b6a:	bb 24       	eor	r11, r11
     b6c:	68 94       	set
     b6e:	b1 f8       	bld	r11, 1
	
	uint16_t *patch_value = &(current_patch.vco2_mix); //pointer to first element of current_patch struct
	//scan 30 parameter pots
	for (int i = 0; i <= NUM_POTS; i++) {
		
		adc_value = read_pot(pot_id[i]);
     b70:	88 81       	ld	r24, Y
     b72:	99 81       	ldd	r25, Y+1	; 0x01
     b74:	0e 94 64 00 	call	0xc8	; 0xc8 <read_pot>
     b78:	90 93 c0 02 	sts	0x02C0, r25
     b7c:	80 93 bf 02 	sts	0x02BF, r24
		adc_change = adc_value - pot_id[i]->value;
     b80:	e8 81       	ld	r30, Y
     b82:	f9 81       	ldd	r31, Y+1	; 0x01
     b84:	40 81       	ld	r20, Z
     b86:	21 81       	ldd	r18, Z+1	; 0x01
     b88:	52 2f       	mov	r21, r18
     b8a:	53 70       	andi	r21, 0x03	; 3
     b8c:	84 1b       	sub	r24, r20
     b8e:	95 0b       	sbc	r25, r21
		pot_id[i]->value = pot_id[i]->value + (adc_change >> 2);
     b90:	95 95       	asr	r25
     b92:	87 95       	ror	r24
     b94:	95 95       	asr	r25
     b96:	87 95       	ror	r24
     b98:	84 0f       	add	r24, r20
     b9a:	95 1f       	adc	r25, r21
     b9c:	80 83       	st	Z, r24
     b9e:	89 2f       	mov	r24, r25
     ba0:	83 70       	andi	r24, 0x03	; 3
     ba2:	2c 7f       	andi	r18, 0xFC	; 252
     ba4:	28 2b       	or	r18, r24
     ba6:	21 83       	std	Z+1, r18	; 0x01
		//what happens next depends on mode. if pot is locked, then the value of the pot is not written to the current patch unless it is different from the pot's locked value
		
		uint8_t delta_pot = pot_id[i]->locked_value - ((pot_id[i]->value >> 2)); //quick and dirty subtraction, where unsigned delta pot will overflow if value > locked value. see below
     ba8:	e9 91       	ld	r30, Y+
     baa:	f9 91       	ld	r31, Y+
     bac:	92 81       	ldd	r25, Z+2	; 0x02
     bae:	20 81       	ld	r18, Z
     bb0:	81 81       	ldd	r24, Z+1	; 0x01
     bb2:	38 2f       	mov	r19, r24
     bb4:	33 70       	andi	r19, 0x03	; 3
		
		
		if ((current_patch.mode == MANUAL) || (pot_id[i]->locked == 0)) { //if in manual mode or pot is already unlocked
     bb6:	d7 01       	movw	r26, r14
     bb8:	8c 91       	ld	r24, X
     bba:	81 30       	cpi	r24, 0x01	; 1
     bbc:	19 f0       	breq	.+6      	; 0xbc4 <scan_pots+0x8e>
     bbe:	83 81       	ldd	r24, Z+3	; 0x03
     bc0:	88 23       	and	r24, r24
     bc2:	24 f0       	brlt	.+8      	; 0xbcc <scan_pots+0x96>
			
			*(patch_value + i) = pot_id[i]->value; //this is a hacked way of indexing the patch structure. Depends on order of pots in pot array being the same as order of parameters in patch struct
     bc4:	f8 01       	movw	r30, r16
     bc6:	31 83       	std	Z+1, r19	; 0x01
     bc8:	20 83       	st	Z, r18
     bca:	14 c0       	rjmp	.+40     	; 0xbf4 <scan_pots+0xbe>
		adc_value = read_pot(pot_id[i]);
		adc_change = adc_value - pot_id[i]->value;
		pot_id[i]->value = pot_id[i]->value + (adc_change >> 2);
		//what happens next depends on mode. if pot is locked, then the value of the pot is not written to the current patch unless it is different from the pot's locked value
		
		uint8_t delta_pot = pot_id[i]->locked_value - ((pot_id[i]->value >> 2)); //quick and dirty subtraction, where unsigned delta pot will overflow if value > locked value. see below
     bcc:	49 2f       	mov	r20, r25
     bce:	43 50       	subi	r20, 0x03	; 3
     bd0:	c9 01       	movw	r24, r18
     bd2:	95 95       	asr	r25
     bd4:	87 95       	ror	r24
     bd6:	95 95       	asr	r25
     bd8:	87 95       	ror	r24
			
			*(patch_value + i) = pot_id[i]->value; //this is a hacked way of indexing the patch structure. Depends on order of pots in pot array being the same as order of parameters in patch struct
			
		//} else if ((((pot_id[i]->value >> 2) != pot_id[i]->locked_value)) && (pot_id[i]->locked == 1)) { //need to figure out delta threshold here. 10 bit to 8 bit resolution should be enough???
			
		} else if (((delta_pot > 2) && (delta_pot < 253)) && (pot_id[i]->locked == 1)) { //set a threshold of +/- 3 for pot change  		  		  	
     bda:	94 2f       	mov	r25, r20
     bdc:	98 1b       	sub	r25, r24
     bde:	9a 3f       	cpi	r25, 0xFA	; 250
     be0:	48 f4       	brcc	.+18     	; 0xbf4 <scan_pots+0xbe>
			*(patch_value + i) = pot_id[i]->value;
     be2:	d8 01       	movw	r26, r16
     be4:	11 96       	adiw	r26, 0x01	; 1
     be6:	3c 93       	st	X, r19
     be8:	2e 93       	st	-X, r18
			pot_id[i]->locked = 0; //unlock pot
     bea:	83 81       	ldd	r24, Z+3	; 0x03
     bec:	8f 77       	andi	r24, 0x7F	; 127
     bee:	83 83       	std	Z+3, r24	; 0x03
			current_patch.mode = EDIT;
     bf0:	f7 01       	movw	r30, r14
     bf2:	b0 82       	st	Z, r11
     bf4:	0e 5f       	subi	r16, 0xFE	; 254
     bf6:	1f 4f       	sbci	r17, 0xFF	; 255

	int adc_change = 0;
	
	uint16_t *patch_value = &(current_patch.vco2_mix); //pointer to first element of current_patch struct
	//scan 30 parameter pots
	for (int i = 0; i <= NUM_POTS; i++) {
     bf8:	cc 15       	cp	r28, r12
     bfa:	dd 05       	cpc	r29, r13
     bfc:	09 f0       	breq	.+2      	; 0xc00 <scan_pots+0xca>
     bfe:	b8 cf       	rjmp	.-144    	; 0xb70 <scan_pots+0x3a>
		
	}
	
	
	//scan volume pot
	adc_value = read_pot(&volume_pot);
     c00:	8c e7       	ldi	r24, 0x7C	; 124
     c02:	91 e0       	ldi	r25, 0x01	; 1
     c04:	0e 94 64 00 	call	0xc8	; 0xc8 <read_pot>
     c08:	90 93 c0 02 	sts	0x02C0, r25
     c0c:	80 93 bf 02 	sts	0x02BF, r24
	adc_change = adc_value - volume_pot.value;
     c10:	20 91 7c 01 	lds	r18, 0x017C
     c14:	40 91 7d 01 	lds	r20, 0x017D
     c18:	34 2f       	mov	r19, r20
     c1a:	33 70       	andi	r19, 0x03	; 3
     c1c:	82 1b       	sub	r24, r18
     c1e:	93 0b       	sbc	r25, r19
	volume_pot.value = volume_pot.value + (adc_change >> 2);
     c20:	95 95       	asr	r25
     c22:	87 95       	ror	r24
     c24:	95 95       	asr	r25
     c26:	87 95       	ror	r24
     c28:	28 0f       	add	r18, r24
     c2a:	39 1f       	adc	r19, r25
     c2c:	20 93 7c 01 	sts	0x017C, r18
     c30:	83 2f       	mov	r24, r19
     c32:	83 70       	andi	r24, 0x03	; 3
     c34:	4c 7f       	andi	r20, 0xFC	; 252
     c36:	48 2b       	or	r20, r24
     c38:	40 93 7d 01 	sts	0x017D, r20
	
}
     c3c:	df 91       	pop	r29
     c3e:	cf 91       	pop	r28
     c40:	1f 91       	pop	r17
     c42:	0f 91       	pop	r16
     c44:	ff 90       	pop	r15
     c46:	ef 90       	pop	r14
     c48:	df 90       	pop	r13
     c4a:	cf 90       	pop	r12
     c4c:	bf 90       	pop	r11
     c4e:	08 95       	ret

00000c50 <update_control_voltages>:

void update_control_voltages(void) { //keep everything updated in the current order of pots. Probably arbitrary, but try to minimize change from old CV update to new CV update
     c50:	cf 93       	push	r28
     c52:	df 93       	push	r29
	
	set_control_voltage(&vco2_mix_cv, (current_patch.vco2_mix << 4));
     c54:	60 91 c6 02 	lds	r22, 0x02C6
     c58:	70 91 c7 02 	lds	r23, 0x02C7
     c5c:	62 95       	swap	r22
     c5e:	72 95       	swap	r23
     c60:	70 7f       	andi	r23, 0xF0	; 240
     c62:	76 27       	eor	r23, r22
     c64:	60 7f       	andi	r22, 0xF0	; 240
     c66:	76 27       	eor	r23, r22
     c68:	84 ee       	ldi	r24, 0xE4	; 228
     c6a:	91 e0       	ldi	r25, 0x01	; 1
     c6c:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&vco1_mix_cv, (current_patch.vco1_mix << 4));
     c70:	60 91 c8 02 	lds	r22, 0x02C8
     c74:	70 91 c9 02 	lds	r23, 0x02C9
     c78:	62 95       	swap	r22
     c7a:	72 95       	swap	r23
     c7c:	70 7f       	andi	r23, 0xF0	; 240
     c7e:	76 27       	eor	r23, r22
     c80:	60 7f       	andi	r22, 0xF0	; 240
     c82:	76 27       	eor	r23, r22
     c84:	83 ee       	ldi	r24, 0xE3	; 227
     c86:	91 e0       	ldi	r25, 0x01	; 1
     c88:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pitch_eg2_cv, (current_patch.pitch_eg2 << 3)); //1/4 scale
     c8c:	60 91 ca 02 	lds	r22, 0x02CA
     c90:	70 91 cb 02 	lds	r23, 0x02CB
     c94:	66 0f       	add	r22, r22
     c96:	77 1f       	adc	r23, r23
     c98:	66 0f       	add	r22, r22
     c9a:	77 1f       	adc	r23, r23
     c9c:	66 0f       	add	r22, r22
     c9e:	77 1f       	adc	r23, r23
     ca0:	82 ee       	ldi	r24, 0xE2	; 226
     ca2:	91 e0       	ldi	r25, 0x01	; 1
     ca4:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pitch_vco2_cv, (current_patch.pitch_vco2 << 4));
     ca8:	60 91 cc 02 	lds	r22, 0x02CC
     cac:	70 91 cd 02 	lds	r23, 0x02CD
     cb0:	62 95       	swap	r22
     cb2:	72 95       	swap	r23
     cb4:	70 7f       	andi	r23, 0xF0	; 240
     cb6:	76 27       	eor	r23, r22
     cb8:	60 7f       	andi	r22, 0xF0	; 240
     cba:	76 27       	eor	r23, r22
     cbc:	87 eb       	ldi	r24, 0xB7	; 183
     cbe:	92 e0       	ldi	r25, 0x02	; 2
     cc0:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pitch_lfo_cv, (current_patch.pitch_lfo << 3)); // 1/4 scale
     cc4:	60 91 ce 02 	lds	r22, 0x02CE
     cc8:	70 91 cf 02 	lds	r23, 0x02CF
     ccc:	66 0f       	add	r22, r22
     cce:	77 1f       	adc	r23, r23
     cd0:	66 0f       	add	r22, r22
     cd2:	77 1f       	adc	r23, r23
     cd4:	66 0f       	add	r22, r22
     cd6:	77 1f       	adc	r23, r23
     cd8:	81 ee       	ldi	r24, 0xE1	; 225
     cda:	91 e0       	ldi	r25, 0x01	; 1
     cdc:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pwm_lfo_cv, (current_patch.pwm_lfo) << 4);
     ce0:	60 91 d0 02 	lds	r22, 0x02D0
     ce4:	70 91 d1 02 	lds	r23, 0x02D1
     ce8:	62 95       	swap	r22
     cea:	72 95       	swap	r23
     cec:	70 7f       	andi	r23, 0xF0	; 240
     cee:	76 27       	eor	r23, r22
     cf0:	60 7f       	andi	r22, 0xF0	; 240
     cf2:	76 27       	eor	r23, r22
     cf4:	80 ee       	ldi	r24, 0xE0	; 224
     cf6:	91 e0       	ldi	r25, 0x01	; 1
     cf8:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pwm_eg2_cv, (current_patch.pwm_eg2) << 4);
     cfc:	60 91 d2 02 	lds	r22, 0x02D2
     d00:	70 91 d3 02 	lds	r23, 0x02D3
     d04:	62 95       	swap	r22
     d06:	72 95       	swap	r23
     d08:	70 7f       	andi	r23, 0xF0	; 240
     d0a:	76 27       	eor	r23, r22
     d0c:	60 7f       	andi	r22, 0xF0	; 240
     d0e:	76 27       	eor	r23, r22
     d10:	8f ed       	ldi	r24, 0xDF	; 223
     d12:	91 e0       	ldi	r25, 0x01	; 1
     d14:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&vco1_pw_cv, (current_patch.vco1_pw) << 4);
     d18:	60 91 d4 02 	lds	r22, 0x02D4
     d1c:	70 91 d5 02 	lds	r23, 0x02D5
     d20:	62 95       	swap	r22
     d22:	72 95       	swap	r23
     d24:	70 7f       	andi	r23, 0xF0	; 240
     d26:	76 27       	eor	r23, r22
     d28:	60 7f       	andi	r22, 0xF0	; 240
     d2a:	76 27       	eor	r23, r22
     d2c:	8e ed       	ldi	r24, 0xDE	; 222
     d2e:	91 e0       	ldi	r25, 0x01	; 1
     d30:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	
	int tune_offset = 512 - current_patch.tune; //master tune offset
     d34:	80 91 d8 02 	lds	r24, 0x02D8
     d38:	90 91 d9 02 	lds	r25, 0x02D9
     d3c:	c0 e0       	ldi	r28, 0x00	; 0
     d3e:	d2 e0       	ldi	r29, 0x02	; 2
     d40:	c8 1b       	sub	r28, r24
     d42:	d9 0b       	sbc	r29, r25
	
	int fine_offset = 512 - current_patch.fine; //fine tune offset
     d44:	60 91 77 03 	lds	r22, 0x0377
     d48:	70 91 78 03 	lds	r23, 0x0378
     d4c:	60 50       	subi	r22, 0x00	; 0
     d4e:	7e 4f       	sbci	r23, 0xFE	; 254
	
	set_control_voltage(&fine_cv, vco2_init_cv + tune_offset + fine_offset);
     d50:	80 91 d6 02 	lds	r24, 0x02D6
     d54:	90 91 d7 02 	lds	r25, 0x02D7
     d58:	68 1b       	sub	r22, r24
     d5a:	79 0b       	sbc	r23, r25
     d5c:	6c 0f       	add	r22, r28
     d5e:	7d 1f       	adc	r23, r29
     d60:	8d ed       	ldi	r24, 0xDD	; 221
     d62:	91 e0       	ldi	r25, 0x01	; 1
     d64:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&tune_cv, vco1_init_cv + tune_offset);
     d68:	60 91 79 03 	lds	r22, 0x0379
     d6c:	70 91 7a 03 	lds	r23, 0x037A
     d70:	6c 0f       	add	r22, r28
     d72:	7d 1f       	adc	r23, r29
     d74:	8c ed       	ldi	r24, 0xDC	; 220
     d76:	91 e0       	ldi	r25, 0x01	; 1
     d78:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	
	set_control_voltage(&lfo_rate_cv, (current_patch.lfo_rate) << 4);
     d7c:	60 91 da 02 	lds	r22, 0x02DA
     d80:	70 91 db 02 	lds	r23, 0x02DB
     d84:	62 95       	swap	r22
     d86:	72 95       	swap	r23
     d88:	70 7f       	andi	r23, 0xF0	; 240
     d8a:	76 27       	eor	r23, r22
     d8c:	60 7f       	andi	r22, 0xF0	; 240
     d8e:	76 27       	eor	r23, r22
     d90:	8b ed       	ldi	r24, 0xDB	; 219
     d92:	91 e0       	ldi	r25, 0x01	; 1
     d94:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&glide_cv, (current_patch.glide) << 4);
     d98:	60 91 de 02 	lds	r22, 0x02DE
     d9c:	70 91 df 02 	lds	r23, 0x02DF
     da0:	62 95       	swap	r22
     da2:	72 95       	swap	r23
     da4:	70 7f       	andi	r23, 0xF0	; 240
     da6:	76 27       	eor	r23, r22
     da8:	60 7f       	andi	r22, 0xF0	; 240
     daa:	76 27       	eor	r23, r22
     dac:	8a ed       	ldi	r24, 0xDA	; 218
     dae:	91 e0       	ldi	r25, 0x01	; 1
     db0:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&amp_lfo_cv, (current_patch.amp_lfo) << 4);
     db4:	60 91 e0 02 	lds	r22, 0x02E0
     db8:	70 91 e1 02 	lds	r23, 0x02E1
     dbc:	62 95       	swap	r22
     dbe:	72 95       	swap	r23
     dc0:	70 7f       	andi	r23, 0xF0	; 240
     dc2:	76 27       	eor	r23, r22
     dc4:	60 7f       	andi	r22, 0xF0	; 240
     dc6:	76 27       	eor	r23, r22
     dc8:	89 ed       	ldi	r24, 0xD9	; 217
     dca:	91 e0       	ldi	r25, 0x01	; 1
     dcc:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&volume_cv, (volume_pot.value << 4)); //volume level not a patch parameter
     dd0:	60 91 7c 01 	lds	r22, 0x017C
     dd4:	80 91 7d 01 	lds	r24, 0x017D
     dd8:	78 2f       	mov	r23, r24
     dda:	73 70       	andi	r23, 0x03	; 3
     ddc:	62 95       	swap	r22
     dde:	72 95       	swap	r23
     de0:	70 7f       	andi	r23, 0xF0	; 240
     de2:	76 27       	eor	r23, r22
     de4:	60 7f       	andi	r22, 0xF0	; 240
     de6:	76 27       	eor	r23, r22
     de8:	88 ed       	ldi	r24, 0xD8	; 216
     dea:	91 e0       	ldi	r25, 0x01	; 1
     dec:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&vco2_pw_cv, (current_patch.vco2_pw) << 4);	
     df0:	60 91 e2 02 	lds	r22, 0x02E2
     df4:	70 91 e3 02 	lds	r23, 0x02E3
     df8:	62 95       	swap	r22
     dfa:	72 95       	swap	r23
     dfc:	70 7f       	andi	r23, 0xF0	; 240
     dfe:	76 27       	eor	r23, r22
     e00:	60 7f       	andi	r22, 0xF0	; 240
     e02:	76 27       	eor	r23, r22
     e04:	87 ed       	ldi	r24, 0xD7	; 215
     e06:	91 e0       	ldi	r25, 0x01	; 1
     e08:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	
	set_control_voltage(&fil_eg2_cv, (current_patch.fil_eg2) << 4);
     e0c:	60 91 e4 02 	lds	r22, 0x02E4
     e10:	70 91 e5 02 	lds	r23, 0x02E5
     e14:	62 95       	swap	r22
     e16:	72 95       	swap	r23
     e18:	70 7f       	andi	r23, 0xF0	; 240
     e1a:	76 27       	eor	r23, r22
     e1c:	60 7f       	andi	r22, 0xF0	; 240
     e1e:	76 27       	eor	r23, r22
     e20:	86 ed       	ldi	r24, 0xD6	; 214
     e22:	91 e0       	ldi	r25, 0x01	; 1
     e24:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&res_cv, (current_patch.res) << 4);
     e28:	60 91 e6 02 	lds	r22, 0x02E6
     e2c:	70 91 e7 02 	lds	r23, 0x02E7
     e30:	62 95       	swap	r22
     e32:	72 95       	swap	r23
     e34:	70 7f       	andi	r23, 0xF0	; 240
     e36:	76 27       	eor	r23, r22
     e38:	60 7f       	andi	r22, 0xF0	; 240
     e3a:	76 27       	eor	r23, r22
     e3c:	85 ed       	ldi	r24, 0xD5	; 213
     e3e:	91 e0       	ldi	r25, 0x01	; 1
     e40:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	
	//this next bit should be separated out, but leave it here for now while testing decoupled adc/dac read/write
	uint8_t note = get_current_note(); //get current note from assigner
     e44:	0e 94 8d 01 	call	0x31a	; 0x31a <get_current_note>
     e48:	c8 2f       	mov	r28, r24
	if (note < 8) note = 8; //init_cv gives VCO range from MIDI note 8 to MIDI note 127+. If you don't set notes <8 to 8 then you get array out of bounds problems. Should find a better way to handle this.
     e4a:	88 30       	cpi	r24, 0x08	; 8
     e4c:	08 f4       	brcc	.+2      	; 0xe50 <update_control_voltages+0x200>
     e4e:	c8 e0       	ldi	r28, 0x08	; 8
	//value_to_display = current_patch.number + 100*(arp.sequence[arp.step_position].note); //100*note;
	//value_to_display = arp.sequence[arp.step_position].note;
	//uint8_t arp_note = arp.sequence[arp.step_position].note;
	//if (arp_note == EMPTY) arp_note = 0;
	value_to_display = current_patch.number + 100*arp.display;
     e50:	60 91 07 03 	lds	r22, 0x0307
     e54:	40 91 94 03 	lds	r20, 0x0394
     e58:	50 e0       	ldi	r21, 0x00	; 0
     e5a:	24 e6       	ldi	r18, 0x64	; 100
     e5c:	30 e0       	ldi	r19, 0x00	; 0
     e5e:	42 9f       	mul	r20, r18
     e60:	c0 01       	movw	r24, r0
     e62:	43 9f       	mul	r20, r19
     e64:	90 0d       	add	r25, r0
     e66:	52 9f       	mul	r21, r18
     e68:	90 0d       	add	r25, r0
     e6a:	11 24       	eor	r1, r1
     e6c:	86 0f       	add	r24, r22
     e6e:	91 1d       	adc	r25, r1
     e70:	90 93 fe 01 	sts	0x01FE, r25
     e74:	80 93 fd 01 	sts	0x01FD, r24
		
	uint16_t interpolated_pitch_cv = 0; //holder for interpolated pitch values
	
	interpolated_pitch_cv = interpolate_pitch_cv(note-8, filter_pitch_table); //subtract 8 from note because filter pitch is calibrated so that 0V is E, 20.6 Hz
     e78:	8c 2f       	mov	r24, r28
     e7a:	88 50       	subi	r24, 0x08	; 8
     e7c:	63 e1       	ldi	r22, 0x13	; 19
     e7e:	73 e0       	ldi	r23, 0x03	; 3
     e80:	0e 94 a5 16 	call	0x2d4a	; 0x2d4a <interpolate_pitch_cv>
	//note that product of key_track and interpolated_pitch_cv needs to be cast as uint32t - otherwise product is evaluated incorrectly
	uint16_t divided_pitch_cv = ((uint32_t)current_patch.key_track*interpolated_pitch_cv) >> 10;
     e84:	bc 01       	movw	r22, r24
     e86:	80 e0       	ldi	r24, 0x00	; 0
     e88:	90 e0       	ldi	r25, 0x00	; 0
     e8a:	20 91 ea 02 	lds	r18, 0x02EA
     e8e:	30 91 eb 02 	lds	r19, 0x02EB
     e92:	40 e0       	ldi	r20, 0x00	; 0
     e94:	50 e0       	ldi	r21, 0x00	; 0
     e96:	0e 94 83 1e 	call	0x3d06	; 0x3d06 <__mulsi3>
     e9a:	dc 01       	movw	r26, r24
     e9c:	cb 01       	movw	r24, r22
     e9e:	07 2e       	mov	r0, r23
     ea0:	7a e0       	ldi	r23, 0x0A	; 10
     ea2:	b6 95       	lsr	r27
     ea4:	a7 95       	ror	r26
     ea6:	97 95       	ror	r25
     ea8:	87 95       	ror	r24
     eaa:	7a 95       	dec	r23
     eac:	d1 f7       	brne	.-12     	; 0xea2 <update_control_voltages+0x252>
     eae:	70 2d       	mov	r23, r0
	uint16_t filter_cutoff_cv = divided_pitch_cv + (current_patch.cutoff << 4); //filter cutoff CV is the sum of filter cutoff pot and key track amount.
     eb0:	60 91 e8 02 	lds	r22, 0x02E8
     eb4:	70 91 e9 02 	lds	r23, 0x02E9
     eb8:	62 95       	swap	r22
     eba:	72 95       	swap	r23
     ebc:	70 7f       	andi	r23, 0xF0	; 240
     ebe:	76 27       	eor	r23, r22
     ec0:	60 7f       	andi	r22, 0xF0	; 240
     ec2:	76 27       	eor	r23, r22
     ec4:	86 0f       	add	r24, r22
     ec6:	97 1f       	adc	r25, r23
	if (filter_cutoff_cv > MAX) filter_cutoff_cv = MAX; //make sure there is no overflow/wrap by capping max
	set_control_voltage(&cutoff_cv, filter_cutoff_cv);	
     ec8:	bc 01       	movw	r22, r24
     eca:	80 e4       	ldi	r24, 0x40	; 64
     ecc:	60 30       	cpi	r22, 0x00	; 0
     ece:	78 07       	cpc	r23, r24
     ed0:	10 f0       	brcs	.+4      	; 0xed6 <update_control_voltages+0x286>
     ed2:	6f ef       	ldi	r22, 0xFF	; 255
     ed4:	7f e3       	ldi	r23, 0x3F	; 63
     ed6:	84 ed       	ldi	r24, 0xD4	; 212
     ed8:	91 e0       	ldi	r25, 0x01	; 1
     eda:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	
	set_control_voltage(&fil_vco2_cv, (current_patch.fil_vco2) << 4);
     ede:	60 91 ec 02 	lds	r22, 0x02EC
     ee2:	70 91 ed 02 	lds	r23, 0x02ED
     ee6:	62 95       	swap	r22
     ee8:	72 95       	swap	r23
     eea:	70 7f       	andi	r23, 0xF0	; 240
     eec:	76 27       	eor	r23, r22
     eee:	60 7f       	andi	r22, 0xF0	; 240
     ef0:	76 27       	eor	r23, r22
     ef2:	82 ed       	ldi	r24, 0xD2	; 210
     ef4:	91 e0       	ldi	r25, 0x01	; 1
     ef6:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&fil_lfo_cv, (current_patch.fil_lfo) << 4);
     efa:	60 91 ee 02 	lds	r22, 0x02EE
     efe:	70 91 ef 02 	lds	r23, 0x02EF
     f02:	62 95       	swap	r22
     f04:	72 95       	swap	r23
     f06:	70 7f       	andi	r23, 0xF0	; 240
     f08:	76 27       	eor	r23, r22
     f0a:	60 7f       	andi	r22, 0xF0	; 240
     f0c:	76 27       	eor	r23, r22
     f0e:	81 ed       	ldi	r24, 0xD1	; 209
     f10:	91 e0       	ldi	r25, 0x01	; 1
     f12:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&noise_mix_cv, (current_patch.noise_mix) << 4);
     f16:	60 91 f0 02 	lds	r22, 0x02F0
     f1a:	70 91 f1 02 	lds	r23, 0x02F1
     f1e:	62 95       	swap	r22
     f20:	72 95       	swap	r23
     f22:	70 7f       	andi	r23, 0xF0	; 240
     f24:	76 27       	eor	r23, r22
     f26:	60 7f       	andi	r22, 0xF0	; 240
     f28:	76 27       	eor	r23, r22
     f2a:	80 ed       	ldi	r24, 0xD0	; 208
     f2c:	91 e0       	ldi	r25, 0x01	; 1
     f2e:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&attack_2_cv, (current_patch.attack_2) << 4);
     f32:	60 91 f2 02 	lds	r22, 0x02F2
     f36:	70 91 f3 02 	lds	r23, 0x02F3
     f3a:	62 95       	swap	r22
     f3c:	72 95       	swap	r23
     f3e:	70 7f       	andi	r23, 0xF0	; 240
     f40:	76 27       	eor	r23, r22
     f42:	60 7f       	andi	r22, 0xF0	; 240
     f44:	76 27       	eor	r23, r22
     f46:	8f ec       	ldi	r24, 0xCF	; 207
     f48:	91 e0       	ldi	r25, 0x01	; 1
     f4a:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&attack_1_cv, (current_patch.attack_1) << 4);
     f4e:	60 91 f4 02 	lds	r22, 0x02F4
     f52:	70 91 f5 02 	lds	r23, 0x02F5
     f56:	62 95       	swap	r22
     f58:	72 95       	swap	r23
     f5a:	70 7f       	andi	r23, 0xF0	; 240
     f5c:	76 27       	eor	r23, r22
     f5e:	60 7f       	andi	r22, 0xF0	; 240
     f60:	76 27       	eor	r23, r22
     f62:	8e ec       	ldi	r24, 0xCE	; 206
     f64:	91 e0       	ldi	r25, 0x01	; 1
     f66:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&decay_2_cv, (current_patch.decay_2) << 4);
     f6a:	60 91 f6 02 	lds	r22, 0x02F6
     f6e:	70 91 f7 02 	lds	r23, 0x02F7
     f72:	62 95       	swap	r22
     f74:	72 95       	swap	r23
     f76:	70 7f       	andi	r23, 0xF0	; 240
     f78:	76 27       	eor	r23, r22
     f7a:	60 7f       	andi	r22, 0xF0	; 240
     f7c:	76 27       	eor	r23, r22
     f7e:	8d ec       	ldi	r24, 0xCD	; 205
     f80:	91 e0       	ldi	r25, 0x01	; 1
     f82:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&decay_1_cv, (current_patch.decay_1) << 4);
     f86:	60 91 f8 02 	lds	r22, 0x02F8
     f8a:	70 91 f9 02 	lds	r23, 0x02F9
     f8e:	62 95       	swap	r22
     f90:	72 95       	swap	r23
     f92:	70 7f       	andi	r23, 0xF0	; 240
     f94:	76 27       	eor	r23, r22
     f96:	60 7f       	andi	r22, 0xF0	; 240
     f98:	76 27       	eor	r23, r22
     f9a:	8c ec       	ldi	r24, 0xCC	; 204
     f9c:	91 e0       	ldi	r25, 0x01	; 1
     f9e:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&sustain_1_cv, (current_patch.sustain_1) << 4);
     fa2:	60 91 fc 02 	lds	r22, 0x02FC
     fa6:	70 91 fd 02 	lds	r23, 0x02FD
     faa:	62 95       	swap	r22
     fac:	72 95       	swap	r23
     fae:	70 7f       	andi	r23, 0xF0	; 240
     fb0:	76 27       	eor	r23, r22
     fb2:	60 7f       	andi	r22, 0xF0	; 240
     fb4:	76 27       	eor	r23, r22
     fb6:	8a ec       	ldi	r24, 0xCA	; 202
     fb8:	91 e0       	ldi	r25, 0x01	; 1
     fba:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&sustain_2_cv, (current_patch.sustain_2) << 4);
     fbe:	60 91 fa 02 	lds	r22, 0x02FA
     fc2:	70 91 fb 02 	lds	r23, 0x02FB
     fc6:	62 95       	swap	r22
     fc8:	72 95       	swap	r23
     fca:	70 7f       	andi	r23, 0xF0	; 240
     fcc:	76 27       	eor	r23, r22
     fce:	60 7f       	andi	r22, 0xF0	; 240
     fd0:	76 27       	eor	r23, r22
     fd2:	8b ec       	ldi	r24, 0xCB	; 203
     fd4:	91 e0       	ldi	r25, 0x01	; 1
     fd6:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&release_1_cv, (current_patch.release_1) << 4);
     fda:	60 91 00 03 	lds	r22, 0x0300
     fde:	70 91 01 03 	lds	r23, 0x0301
     fe2:	62 95       	swap	r22
     fe4:	72 95       	swap	r23
     fe6:	70 7f       	andi	r23, 0xF0	; 240
     fe8:	76 27       	eor	r23, r22
     fea:	60 7f       	andi	r22, 0xF0	; 240
     fec:	76 27       	eor	r23, r22
     fee:	88 ec       	ldi	r24, 0xC8	; 200
     ff0:	91 e0       	ldi	r25, 0x01	; 1
     ff2:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&release_2_cv, (current_patch.release_2) << 4);
     ff6:	60 91 fe 02 	lds	r22, 0x02FE
     ffa:	70 91 ff 02 	lds	r23, 0x02FF
     ffe:	62 95       	swap	r22
    1000:	72 95       	swap	r23
    1002:	70 7f       	andi	r23, 0xF0	; 240
    1004:	76 27       	eor	r23, r22
    1006:	60 7f       	andi	r22, 0xF0	; 240
    1008:	76 27       	eor	r23, r22
    100a:	89 ec       	ldi	r24, 0xC9	; 201
    100c:	91 e0       	ldi	r25, 0x01	; 1
    100e:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>

	//set VCO1 and VCO2 pitch control voltages. Remember, set_control_voltage() is expecting a pointer to a control_voltage struct
	//that contains the control_voltage multiplexer channel and the multiplexer address
	

	uint8_t vco1_note = transpose_note(note, VCO1); //transpose
    1012:	8c 2f       	mov	r24, r28
    1014:	6f e0       	ldi	r22, 0x0F	; 15
    1016:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <transpose_note>

	interpolated_pitch_cv = interpolate_pitch_cv(vco1_note, vco1_pitch_table);
    101a:	65 e5       	ldi	r22, 0x55	; 85
    101c:	73 e0       	ldi	r23, 0x03	; 3
    101e:	0e 94 a5 16 	call	0x2d4a	; 0x2d4a <interpolate_pitch_cv>
    1022:	bc 01       	movw	r22, r24
	
	//value_to_display = interpolated_pitch_cv;
	
	set_control_voltage(&vco1_pitch_cv, interpolated_pitch_cv);
    1024:	86 ee       	ldi	r24, 0xE6	; 230
    1026:	91 e0       	ldi	r25, 0x01	; 1
    1028:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	
	uint8_t vco2_note = transpose_note(note, VCO2);
    102c:	8c 2f       	mov	r24, r28
    102e:	60 ef       	ldi	r22, 0xF0	; 240
    1030:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <transpose_note>
	
	interpolated_pitch_cv = interpolate_pitch_cv(vco2_note, vco2_pitch_table);
    1034:	63 e3       	ldi	r22, 0x33	; 51
    1036:	73 e0       	ldi	r23, 0x03	; 3
    1038:	0e 94 a5 16 	call	0x2d4a	; 0x2d4a <interpolate_pitch_cv>
    103c:	bc 01       	movw	r22, r24
	
	set_control_voltage(&vco2_pitch_cv, interpolated_pitch_cv);
    103e:	85 ee       	ldi	r24, 0xE5	; 229
    1040:	91 e0       	ldi	r25, 0x01	; 1
    1042:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
		
	DAC_CTRL &= ~(1<<DAC_RS); //reset DAC
    1046:	a1 98       	cbi	0x14, 1	; 20
	DAC_CTRL |= (1<<DAC_RS);
    1048:	a1 9a       	sbi	0x14, 1	; 20
	
	system_clock.rate = (1023 - arp_rate_pot.value) + 244;    
    104a:	20 91 88 01 	lds	r18, 0x0188
    104e:	80 91 89 01 	lds	r24, 0x0189
    1052:	38 2f       	mov	r19, r24
    1054:	33 70       	andi	r19, 0x03	; 3
    1056:	83 ef       	ldi	r24, 0xF3	; 243
    1058:	94 e0       	ldi	r25, 0x04	; 4
    105a:	82 1b       	sub	r24, r18
    105c:	93 0b       	sbc	r25, r19
    105e:	90 93 da 03 	sts	0x03DA, r25
    1062:	80 93 d9 03 	sts	0x03D9, r24
	
	if (system_clock.rate != system_clock.previous_rate) {
    1066:	20 91 db 03 	lds	r18, 0x03DB
    106a:	30 91 dc 03 	lds	r19, 0x03DC
    106e:	82 17       	cp	r24, r18
    1070:	93 07       	cpc	r25, r19
    1072:	11 f0       	breq	.+4      	; 0x1078 <update_control_voltages+0x428>
		
		update_clock_rate(system_clock.rate);
    1074:	0e 94 f3 01 	call	0x3e6	; 0x3e6 <update_clock_rate>
	
	}
	
	system_clock.previous_rate = system_clock.rate;
    1078:	80 91 d9 03 	lds	r24, 0x03D9
    107c:	90 91 da 03 	lds	r25, 0x03DA
    1080:	90 93 dc 03 	sts	0x03DC, r25
    1084:	80 93 db 03 	sts	0x03DB, r24
	
}			
    1088:	df 91       	pop	r29
    108a:	cf 91       	pop	r28
    108c:	08 95       	ret

0000108e <setup_spi>:
void setup_spi(void) {
	
		//SET SPI_DATA_OUT and SPI_CLK and SPI_SW_LATCH pins as outputs
		//also set Slave Select (PB0) as output just to ensure it doesn't interfere with SPI communication (currently floating)
		//ACTUALLY, Slave Select ***MUST*** be set as output. Leaving it floating without setting its data direction bit breaks SPI!
		DDRB |= (SPI_DATA_OUT | SPI_CLK | SPI_SW_LATCH |(1<<PB0));
    108e:	84 b1       	in	r24, 0x04	; 4
    1090:	87 62       	ori	r24, 0x27	; 39
    1092:	84 b9       	out	0x04, r24	; 4
		
		//SET SPI_EN and LED_LATCH and VCO_SW_LATCH and EG2_POL pins as outputs
		DDRJ |= (SPI_EN | LED_LATCH | (1<<VCO_SW_LATCH) | (1<<EG2_POL));
    1094:	ec ed       	ldi	r30, 0xDC	; 220
    1096:	f0 e0       	ldi	r31, 0x00	; 0
    1098:	80 81       	ld	r24, Z
    109a:	8c 65       	ori	r24, 0x5C	; 92
    109c:	80 83       	st	Z, r24
		
		//SET SPI_DATA_OUT and SPI_CLK and SPI_SW_LATCH outputs LOW
		SPI_PORT &= ~(SPI_DATA_OUT | SPI_CLK | SPI_SW_LATCH);
    109e:	85 b1       	in	r24, 0x05	; 5
    10a0:	89 7d       	andi	r24, 0xD9	; 217
    10a2:	85 b9       	out	0x05, r24	; 5
		
		//SET SPI_EN LOW (active) and LED_LATCH LOW (active)
		SPI_LATCH_PORT &= ~(SPI_EN | LED_LATCH);
    10a4:	ed ed       	ldi	r30, 0xDD	; 221
    10a6:	f0 e0       	ldi	r31, 0x00	; 0
    10a8:	80 81       	ld	r24, Z
    10aa:	83 7f       	andi	r24, 0xF3	; 243
    10ac:	80 83       	st	Z, r24
		
		//SET UP SPI
		SPCR = (1<<SPE) | (1<<MSTR); //Start SPI as MASTER
    10ae:	80 e5       	ldi	r24, 0x50	; 80
    10b0:	8c bd       	out	0x2c, r24	; 44
		
		//Pull LED_LATCH LOW
		SPI_LATCH_PORT &= ~LED_LATCH;
    10b2:	80 81       	ld	r24, Z
    10b4:	87 7f       	andi	r24, 0xF7	; 247
    10b6:	80 83       	st	Z, r24
		
		
		//Toggle LED_LATCH to shift data to 74HC595 shift register outputs
		
		SPI_LATCH_PORT &= ~LED_LATCH;
    10b8:	80 81       	ld	r24, Z
    10ba:	87 7f       	andi	r24, 0xF7	; 247
    10bc:	80 83       	st	Z, r24
		SPI_LATCH_PORT |= LED_LATCH;
    10be:	80 81       	ld	r24, Z
    10c0:	88 60       	ori	r24, 0x08	; 8
    10c2:	80 83       	st	Z, r24
		
		//set EG2 POL
		EG2_POL_PORT &= ~(1 << EG2_POL); //0 for normal, 1 for inverted
    10c4:	80 81       	ld	r24, Z
    10c6:	8f 7e       	andi	r24, 0xEF	; 239
    10c8:	80 83       	st	Z, r24
	
}
    10ca:	08 95       	ret

000010cc <spi_shift_byte>:

uint8_t spi_shift_byte(uint8_t byte) { //shifts out byte for LED data and simultaneously reads switch data
	
	SPDR = byte;
    10cc:	8e bd       	out	0x2e, r24	; 46
	while (!(SPSR & (1<<SPIF)));
    10ce:	0d b4       	in	r0, 0x2d	; 45
    10d0:	07 fe       	sbrs	r0, 7
    10d2:	fd cf       	rjmp	.-6      	; 0x10ce <spi_shift_byte+0x2>
	return SPDR;
    10d4:	8e b5       	in	r24, 0x2e	; 46
	
}
    10d6:	08 95       	ret

000010d8 <update_spi>:

void update_spi(void) {
	
			SPI_PORT |= SPI_SW_LATCH;
    10d8:	2d 9a       	sbi	0x05, 5	; 5
			
			//SHIFT 5th BYTE				
			//Read SPDR for switch data shifted in from 74XX165 U14 and write LED data to LED latch 5
			spi_sw_byte0_current_state = spi_shift_byte(current_patch.byte_5);
    10da:	80 91 06 03 	lds	r24, 0x0306
    10de:	0e 94 66 08 	call	0x10cc	; 0x10cc <spi_shift_byte>
			switch_press |= spi_sw_byte0_current_state; //set switch press global flag
    10e2:	90 91 c5 02 	lds	r25, 0x02C5
    10e6:	98 2b       	or	r25, r24
    10e8:	90 93 c5 02 	sts	0x02C5, r25
			spi_sw_byte0_current_state ^= spi_sw_byte0_previous_state;
    10ec:	20 91 c3 02 	lds	r18, 0x02C3
    10f0:	98 2f       	mov	r25, r24
    10f2:	92 27       	eor	r25, r18
			spi_sw_byte0_previous_state ^= spi_sw_byte0_current_state;
    10f4:	89 2f       	mov	r24, r25
    10f6:	82 27       	eor	r24, r18
    10f8:	80 93 c3 02 	sts	0x02C3, r24
			spi_sw_byte0_current_state &= spi_sw_byte0_previous_state;
    10fc:	89 23       	and	r24, r25
    10fe:	80 93 c4 02 	sts	0x02C4, r24
			
			//toggle switch state		
			switch_states.byte0 ^= spi_sw_byte0_current_state; //Omar's solution.
    1102:	90 91 82 03 	lds	r25, 0x0382
    1106:	89 27       	eor	r24, r25
    1108:	80 93 82 03 	sts	0x0382, r24
			//Now read SPDR for switch data shifted in from 74XX165 (U9)
			//uint8_t spi_data = (1<<VCO2_32F | 1<<VCO1_32F); //turn on 32' octave LEDs as default 
			
			uint8_t spi_data = current_patch.byte_4;
					
			spi_sw_byte1_current_state = spi_shift_byte(spi_data);
    110c:	80 91 05 03 	lds	r24, 0x0305
    1110:	0e 94 66 08 	call	0x10cc	; 0x10cc <spi_shift_byte>
			switch_press |= spi_sw_byte1_current_state;
    1114:	90 91 c5 02 	lds	r25, 0x02C5
    1118:	98 2b       	or	r25, r24
    111a:	90 93 c5 02 	sts	0x02C5, r25
			spi_sw_byte1_current_state ^= spi_sw_byte1_previous_state;
    111e:	20 91 c1 02 	lds	r18, 0x02C1
    1122:	98 2f       	mov	r25, r24
    1124:	92 27       	eor	r25, r18
			spi_sw_byte1_previous_state ^= spi_sw_byte1_current_state;
    1126:	89 2f       	mov	r24, r25
    1128:	82 27       	eor	r24, r18
    112a:	80 93 c1 02 	sts	0x02C1, r24
			spi_sw_byte1_current_state &= spi_sw_byte1_previous_state;
    112e:	89 23       	and	r24, r25
    1130:	80 93 c2 02 	sts	0x02C2, r24
			
			//toggle switch state
			switch_states.byte1 ^= spi_sw_byte1_current_state; //Omar's solution.			
    1134:	90 91 83 03 	lds	r25, 0x0383
    1138:	89 27       	eor	r24, r25
    113a:	80 93 83 03 	sts	0x0383, r24
							
			//SHIFT 3th BYTE
			spi_shift_byte(current_patch.byte_3);
    113e:	80 91 04 03 	lds	r24, 0x0304
    1142:	0e 94 66 08 	call	0x10cc	; 0x10cc <spi_shift_byte>

			//SHIFT 2th BYTE
			spi_shift_byte(current_patch.byte_2);
    1146:	80 91 03 03 	lds	r24, 0x0303
    114a:	0e 94 66 08 	call	0x10cc	; 0x10cc <spi_shift_byte>
			
			//SHIFT 1st BYTE	//eventually need to parse this elsewhere		
			spi_data =	//((switch_states.byte1 >> ARP_MODE_SW) & 1) << ARP_MODE | 
    114e:	80 91 0b 03 	lds	r24, 0x030B
    1152:	83 30       	cpi	r24, 0x03	; 3
    1154:	11 f4       	brne	.+4      	; 0x115a <__stack+0x5b>
    1156:	20 e8       	ldi	r18, 0x80	; 128
    1158:	01 c0       	rjmp	.+2      	; 0x115c <__stack+0x5d>
    115a:	20 e0       	ldi	r18, 0x00	; 0
						//((switch_states.byte2 >> PROG_WRITE_SW) & 1) << PROG_WRITE | 
						((current_patch.mode == WRITE) << PROG_WRITE) | //hack to light PROG WRITE LED only when in WRITE mode
						//((switch_states.byte2 >> EG2_INV_SW) &1 ) << EG2_INV |
						((switch_states.byte2 >> PROG_MANUAL_SW &1) << PROG_MANUAL) |
    115c:	80 91 84 03 	lds	r24, 0x0384
    1160:	88 1f       	adc	r24, r24
    1162:	88 27       	eor	r24, r24
    1164:	88 1f       	adc	r24, r24
    1166:	82 95       	swap	r24
    1168:	88 0f       	add	r24, r24
    116a:	88 0f       	add	r24, r24
    116c:	80 7c       	andi	r24, 0xC0	; 192

			//SHIFT 2th BYTE
			spi_shift_byte(current_patch.byte_2);
			
			//SHIFT 1st BYTE	//eventually need to parse this elsewhere		
			spi_data =	//((switch_states.byte1 >> ARP_MODE_SW) & 1) << ARP_MODE | 
    116e:	90 91 02 03 	lds	r25, 0x0302
    1172:	89 2b       	or	r24, r25
						((current_patch.mode == WRITE) << PROG_WRITE) | //hack to light PROG WRITE LED only when in WRITE mode
						//((switch_states.byte2 >> EG2_INV_SW) &1 ) << EG2_INV |
						((switch_states.byte2 >> PROG_MANUAL_SW &1) << PROG_MANUAL) |
						((current_patch.byte_1)); 			
			//Wait for SPI shift to complete
			spi_shift_byte(spi_data);
    1174:	82 2b       	or	r24, r18
    1176:	0e 94 66 08 	call	0x10cc	; 0x10cc <spi_shift_byte>
			
			//Toggle LED_LATCH to shift data to 74HC595 shift register outputs
			
			SPI_LATCH_PORT &= ~LED_LATCH;
    117a:	ed ed       	ldi	r30, 0xDD	; 221
    117c:	f0 e0       	ldi	r31, 0x00	; 0
    117e:	80 81       	ld	r24, Z
    1180:	87 7f       	andi	r24, 0xF7	; 247
    1182:	80 83       	st	Z, r24
			SPI_LATCH_PORT |= LED_LATCH;
    1184:	80 81       	ld	r24, Z
    1186:	88 60       	ori	r24, 0x08	; 8
    1188:	80 83       	st	Z, r24
			
			//clear SPI_SW_LATCH
			SPI_PORT &= ~SPI_SW_LATCH;
    118a:	2d 98       	cbi	0x05, 5	; 5
			
			

	
    118c:	08 95       	ret

0000118e <lock_pots>:
		LFO_PULSE_ADDR,
		LFO_RNDM_ADDR
	};
	

void lock_pots(void) { //run this every time new patch is loaded to lock pots and store locked values
    118e:	a0 e0       	ldi	r26, 0x00	; 0
    1190:	b1 e0       	ldi	r27, 0x01	; 1
    1192:	9d 01       	movw	r18, r26
    1194:	24 5c       	subi	r18, 0xC4	; 196
    1196:	3f 4f       	sbci	r19, 0xFF	; 255

for (int i = 0; i <= NUM_POTS; i++) {
	
	pot_id[i]->locked_value = (pot_id[i]->value) >> 2;
    1198:	ed 91       	ld	r30, X+
    119a:	fc 91       	ld	r31, X
    119c:	11 97       	sbiw	r26, 0x01	; 1
    119e:	80 81       	ld	r24, Z
    11a0:	41 81       	ldd	r20, Z+1	; 0x01
    11a2:	94 2f       	mov	r25, r20
    11a4:	93 70       	andi	r25, 0x03	; 3
    11a6:	95 95       	asr	r25
    11a8:	87 95       	ror	r24
    11aa:	95 95       	asr	r25
    11ac:	87 95       	ror	r24
    11ae:	82 83       	std	Z+2, r24	; 0x02
	pot_id[i]->locked = 1;
    11b0:	ed 91       	ld	r30, X+
    11b2:	fd 91       	ld	r31, X+
    11b4:	83 81       	ldd	r24, Z+3	; 0x03
    11b6:	80 68       	ori	r24, 0x80	; 128
    11b8:	83 83       	std	Z+3, r24	; 0x03
	};
	

void lock_pots(void) { //run this every time new patch is loaded to lock pots and store locked values

for (int i = 0; i <= NUM_POTS; i++) {
    11ba:	a2 17       	cp	r26, r18
    11bc:	b3 07       	cpc	r27, r19
    11be:	61 f7       	brne	.-40     	; 0x1198 <lock_pots+0xa>
	pot_id[i]->locked_value = (pot_id[i]->value) >> 2;
	pot_id[i]->locked = 1;
	
}

}
    11c0:	08 95       	ret

000011c2 <unlock_pots>:

void unlock_pots(void) {
    11c2:	e0 e0       	ldi	r30, 0x00	; 0
    11c4:	f1 e0       	ldi	r31, 0x01	; 1
    11c6:	cf 01       	movw	r24, r30
    11c8:	cc 96       	adiw	r24, 0x3c	; 60
	
	for (int i = 0; i <= NUM_POTS; i++) {
		
		pot_id[i]->locked = 0;
    11ca:	a1 91       	ld	r26, Z+
    11cc:	b1 91       	ld	r27, Z+
    11ce:	13 96       	adiw	r26, 0x03	; 3
    11d0:	2c 91       	ld	r18, X
    11d2:	13 97       	sbiw	r26, 0x03	; 3
    11d4:	2f 77       	andi	r18, 0x7F	; 127
    11d6:	13 96       	adiw	r26, 0x03	; 3
    11d8:	2c 93       	st	X, r18
    11da:	13 97       	sbiw	r26, 0x03	; 3

}

void unlock_pots(void) {
	
	for (int i = 0; i <= NUM_POTS; i++) {
    11dc:	e8 17       	cp	r30, r24
    11de:	f9 07       	cpc	r31, r25
    11e0:	a1 f7       	brne	.-24     	; 0x11ca <unlock_pots+0x8>
		
		pot_id[i]->locked = 0;
		
	}
	
}			
    11e2:	08 95       	ret

000011e4 <save_patch>:
	
	
void save_patch(uint8_t patch_number) {
    11e4:	1f 93       	push	r17
    11e6:	cf 93       	push	r28
    11e8:	df 93       	push	r29
    11ea:	cd b7       	in	r28, 0x3d	; 61
    11ec:	de b7       	in	r29, 0x3e	; 62
    11ee:	ab 97       	sbiw	r28, 0x2b	; 43
    11f0:	0f b6       	in	r0, 0x3f	; 63
    11f2:	f8 94       	cli
    11f4:	de bf       	out	0x3e, r29	; 62
    11f6:	0f be       	out	0x3f, r0	; 63
    11f8:	cd bf       	out	0x3d, r28	; 61
    11fa:	18 2f       	mov	r17, r24
	
	struct eeprom_patch patch_to_save;
	//because of bit fields in eeprom patch struct, a temporary eeprom patch needs to be filled with current_patch values and then saved to memory.
	
	patch_to_save.vco2_pw = current_patch.vco2_pw;
    11fc:	e2 ee       	ldi	r30, 0xE2	; 226
    11fe:	f2 e0       	ldi	r31, 0x02	; 2
    1200:	20 91 e2 02 	lds	r18, 0x02E2
    1204:	82 2f       	mov	r24, r18
    1206:	82 95       	swap	r24
    1208:	80 7f       	andi	r24, 0xF0	; 240
    120a:	22 95       	swap	r18
    120c:	2f 70       	andi	r18, 0x0F	; 15
    120e:	90 91 e3 02 	lds	r25, 0x02E3
    1212:	93 70       	andi	r25, 0x03	; 3
    1214:	92 95       	swap	r25
    1216:	90 7f       	andi	r25, 0xF0	; 240
	patch_to_save.vco1_mix = current_patch.vco1_mix;
    1218:	df 01       	movw	r26, r30
    121a:	5a 97       	sbiw	r26, 0x1a	; 26
    121c:	3c 91       	ld	r19, X
    121e:	53 2f       	mov	r21, r19
    1220:	55 0f       	add	r21, r21
    1222:	55 0f       	add	r21, r21
    1224:	4a 81       	ldd	r20, Y+2	; 0x02
    1226:	43 70       	andi	r20, 0x03	; 3
    1228:	45 2b       	or	r20, r21
    122a:	4a 83       	std	Y+2, r20	; 0x02
    122c:	63 2f       	mov	r22, r19
    122e:	62 95       	swap	r22
    1230:	66 95       	lsr	r22
    1232:	66 95       	lsr	r22
    1234:	63 70       	andi	r22, 0x03	; 3
    1236:	11 96       	adiw	r26, 0x01	; 1
    1238:	4c 91       	ld	r20, X
    123a:	43 70       	andi	r20, 0x03	; 3
    123c:	44 0f       	add	r20, r20
    123e:	44 0f       	add	r20, r20
	patch_to_save.pitch_eg2 = current_patch.pitch_eg2;
    1240:	df 01       	movw	r26, r30
    1242:	58 97       	sbiw	r26, 0x18	; 24
    1244:	3c 91       	ld	r19, X
    1246:	53 2f       	mov	r21, r19
    1248:	52 95       	swap	r21
    124a:	50 7f       	andi	r21, 0xF0	; 240
    124c:	46 2b       	or	r20, r22
    124e:	45 2b       	or	r20, r21
    1250:	4b 83       	std	Y+3, r20	; 0x03
    1252:	63 2f       	mov	r22, r19
    1254:	62 95       	swap	r22
    1256:	6f 70       	andi	r22, 0x0F	; 15
    1258:	11 96       	adiw	r26, 0x01	; 1
    125a:	4c 91       	ld	r20, X
    125c:	43 70       	andi	r20, 0x03	; 3
    125e:	42 95       	swap	r20
    1260:	40 7f       	andi	r20, 0xF0	; 240
	patch_to_save.pitch_vco2 = current_patch.pitch_vco2;
    1262:	df 01       	movw	r26, r30
    1264:	56 97       	sbiw	r26, 0x16	; 22
    1266:	3c 91       	ld	r19, X
    1268:	53 2f       	mov	r21, r19
    126a:	52 95       	swap	r21
    126c:	55 0f       	add	r21, r21
    126e:	55 0f       	add	r21, r21
    1270:	50 7c       	andi	r21, 0xC0	; 192
    1272:	46 2b       	or	r20, r22
    1274:	45 2b       	or	r20, r21
    1276:	4c 83       	std	Y+4, r20	; 0x04
    1278:	11 96       	adiw	r26, 0x01	; 1
    127a:	4c 91       	ld	r20, X
    127c:	42 95       	swap	r20
    127e:	44 0f       	add	r20, r20
    1280:	44 0f       	add	r20, r20
    1282:	40 7c       	andi	r20, 0xC0	; 192
    1284:	36 95       	lsr	r19
    1286:	36 95       	lsr	r19
    1288:	34 2b       	or	r19, r20
    128a:	3d 83       	std	Y+5, r19	; 0x05
	patch_to_save.pitch_lfo = current_patch.pitch_lfo;
    128c:	df 01       	movw	r26, r30
    128e:	54 97       	sbiw	r26, 0x14	; 20
    1290:	3c 91       	ld	r19, X
    1292:	3e 83       	std	Y+6, r19	; 0x06
    1294:	11 96       	adiw	r26, 0x01	; 1
    1296:	4c 91       	ld	r20, X
	patch_to_save.pwm_lfo = current_patch.pwm_lfo;
    1298:	df 01       	movw	r26, r30
    129a:	52 97       	sbiw	r26, 0x12	; 18
    129c:	3c 91       	ld	r19, X
    129e:	53 2f       	mov	r21, r19
    12a0:	55 0f       	add	r21, r21
    12a2:	55 0f       	add	r21, r21
    12a4:	43 70       	andi	r20, 0x03	; 3
    12a6:	45 2b       	or	r20, r21
    12a8:	4f 83       	std	Y+7, r20	; 0x07
    12aa:	63 2f       	mov	r22, r19
    12ac:	62 95       	swap	r22
    12ae:	66 95       	lsr	r22
    12b0:	66 95       	lsr	r22
    12b2:	63 70       	andi	r22, 0x03	; 3
    12b4:	11 96       	adiw	r26, 0x01	; 1
    12b6:	4c 91       	ld	r20, X
    12b8:	43 70       	andi	r20, 0x03	; 3
    12ba:	44 0f       	add	r20, r20
    12bc:	44 0f       	add	r20, r20
	patch_to_save.pwm_eg2 = current_patch.pwm_eg2;
    12be:	df 01       	movw	r26, r30
    12c0:	50 97       	sbiw	r26, 0x10	; 16
    12c2:	3c 91       	ld	r19, X
    12c4:	53 2f       	mov	r21, r19
    12c6:	52 95       	swap	r21
    12c8:	50 7f       	andi	r21, 0xF0	; 240
    12ca:	46 2b       	or	r20, r22
    12cc:	45 2b       	or	r20, r21
    12ce:	48 87       	std	Y+8, r20	; 0x08
    12d0:	63 2f       	mov	r22, r19
    12d2:	62 95       	swap	r22
    12d4:	6f 70       	andi	r22, 0x0F	; 15
    12d6:	11 96       	adiw	r26, 0x01	; 1
    12d8:	4c 91       	ld	r20, X
    12da:	43 70       	andi	r20, 0x03	; 3
    12dc:	42 95       	swap	r20
    12de:	40 7f       	andi	r20, 0xF0	; 240
	patch_to_save.vco1_pw = current_patch.vco1_pw;
    12e0:	df 01       	movw	r26, r30
    12e2:	1e 97       	sbiw	r26, 0x0e	; 14
    12e4:	3c 91       	ld	r19, X
    12e6:	53 2f       	mov	r21, r19
    12e8:	52 95       	swap	r21
    12ea:	55 0f       	add	r21, r21
    12ec:	55 0f       	add	r21, r21
    12ee:	50 7c       	andi	r21, 0xC0	; 192
    12f0:	46 2b       	or	r20, r22
    12f2:	45 2b       	or	r20, r21
    12f4:	49 87       	std	Y+9, r20	; 0x09
    12f6:	11 96       	adiw	r26, 0x01	; 1
    12f8:	4c 91       	ld	r20, X
    12fa:	42 95       	swap	r20
    12fc:	44 0f       	add	r20, r20
    12fe:	44 0f       	add	r20, r20
    1300:	40 7c       	andi	r20, 0xC0	; 192
    1302:	36 95       	lsr	r19
    1304:	36 95       	lsr	r19
    1306:	34 2b       	or	r19, r20
    1308:	3a 87       	std	Y+10, r19	; 0x0a
	patch_to_save.fine = current_patch.fine;
    130a:	df 01       	movw	r26, r30
    130c:	1c 97       	sbiw	r26, 0x0c	; 12
    130e:	3c 91       	ld	r19, X
    1310:	3b 87       	std	Y+11, r19	; 0x0b
    1312:	11 96       	adiw	r26, 0x01	; 1
    1314:	4c 91       	ld	r20, X
	patch_to_save.tune = current_patch.tune; //probably shouldn't save master tune value. Like volume, it is a parameter that doesn't apply to a patch.
    1316:	df 01       	movw	r26, r30
    1318:	1a 97       	sbiw	r26, 0x0a	; 10
    131a:	3c 91       	ld	r19, X
    131c:	53 2f       	mov	r21, r19
    131e:	55 0f       	add	r21, r21
    1320:	55 0f       	add	r21, r21
    1322:	43 70       	andi	r20, 0x03	; 3
    1324:	45 2b       	or	r20, r21
    1326:	4c 87       	std	Y+12, r20	; 0x0c
    1328:	63 2f       	mov	r22, r19
    132a:	62 95       	swap	r22
    132c:	66 95       	lsr	r22
    132e:	66 95       	lsr	r22
    1330:	63 70       	andi	r22, 0x03	; 3
    1332:	11 96       	adiw	r26, 0x01	; 1
    1334:	4c 91       	ld	r20, X
    1336:	43 70       	andi	r20, 0x03	; 3
    1338:	44 0f       	add	r20, r20
    133a:	44 0f       	add	r20, r20
	patch_to_save.lfo_rate = current_patch.lfo_rate;
    133c:	df 01       	movw	r26, r30
    133e:	18 97       	sbiw	r26, 0x08	; 8
    1340:	3c 91       	ld	r19, X
    1342:	53 2f       	mov	r21, r19
    1344:	52 95       	swap	r21
    1346:	50 7f       	andi	r21, 0xF0	; 240
    1348:	46 2b       	or	r20, r22
    134a:	45 2b       	or	r20, r21
    134c:	4d 87       	std	Y+13, r20	; 0x0d
    134e:	63 2f       	mov	r22, r19
    1350:	62 95       	swap	r22
    1352:	6f 70       	andi	r22, 0x0F	; 15
    1354:	11 96       	adiw	r26, 0x01	; 1
    1356:	4c 91       	ld	r20, X
    1358:	43 70       	andi	r20, 0x03	; 3
    135a:	42 95       	swap	r20
    135c:	40 7f       	andi	r20, 0xF0	; 240
	patch_to_save.arp_rate = current_patch.arp_rate;
    135e:	df 01       	movw	r26, r30
    1360:	16 97       	sbiw	r26, 0x06	; 6
    1362:	3c 91       	ld	r19, X
    1364:	53 2f       	mov	r21, r19
    1366:	52 95       	swap	r21
    1368:	55 0f       	add	r21, r21
    136a:	55 0f       	add	r21, r21
    136c:	50 7c       	andi	r21, 0xC0	; 192
    136e:	46 2b       	or	r20, r22
    1370:	45 2b       	or	r20, r21
    1372:	4e 87       	std	Y+14, r20	; 0x0e
    1374:	11 96       	adiw	r26, 0x01	; 1
    1376:	4c 91       	ld	r20, X
    1378:	42 95       	swap	r20
    137a:	44 0f       	add	r20, r20
    137c:	44 0f       	add	r20, r20
    137e:	40 7c       	andi	r20, 0xC0	; 192
    1380:	36 95       	lsr	r19
    1382:	36 95       	lsr	r19
    1384:	34 2b       	or	r19, r20
    1386:	3f 87       	std	Y+15, r19	; 0x0f
	patch_to_save.glide	= current_patch.glide;
    1388:	df 01       	movw	r26, r30
    138a:	14 97       	sbiw	r26, 0x04	; 4
    138c:	3c 91       	ld	r19, X
    138e:	38 8b       	std	Y+16, r19	; 0x10
    1390:	11 96       	adiw	r26, 0x01	; 1
    1392:	4c 91       	ld	r20, X
	patch_to_save.amp_lfo = current_patch.amp_lfo;
    1394:	df 01       	movw	r26, r30
    1396:	12 97       	sbiw	r26, 0x02	; 2
    1398:	3c 91       	ld	r19, X
    139a:	53 2f       	mov	r21, r19
    139c:	55 0f       	add	r21, r21
    139e:	55 0f       	add	r21, r21
    13a0:	43 70       	andi	r20, 0x03	; 3
    13a2:	45 2b       	or	r20, r21
    13a4:	49 8b       	std	Y+17, r20	; 0x11
    13a6:	32 95       	swap	r19
    13a8:	36 95       	lsr	r19
    13aa:	36 95       	lsr	r19
    13ac:	33 70       	andi	r19, 0x03	; 3
    13ae:	11 96       	adiw	r26, 0x01	; 1
    13b0:	4c 91       	ld	r20, X
    13b2:	43 70       	andi	r20, 0x03	; 3
    13b4:	44 0f       	add	r20, r20
    13b6:	44 0f       	add	r20, r20
    13b8:	83 2b       	or	r24, r19
    13ba:	84 2b       	or	r24, r20
    13bc:	8a 8b       	std	Y+18, r24	; 0x12
	patch_to_save.vco2_pw = current_patch.vco2_pw;
	
	patch_to_save.fil_eg2 = current_patch.fil_eg2;
    13be:	80 91 e4 02 	lds	r24, 0x02E4
    13c2:	38 2f       	mov	r19, r24
    13c4:	32 95       	swap	r19
    13c6:	33 0f       	add	r19, r19
    13c8:	33 0f       	add	r19, r19
    13ca:	30 7c       	andi	r19, 0xC0	; 192
    13cc:	92 2b       	or	r25, r18
    13ce:	93 2b       	or	r25, r19
    13d0:	9b 8b       	std	Y+19, r25	; 0x13
    13d2:	93 81       	ldd	r25, Z+3	; 0x03
    13d4:	92 95       	swap	r25
    13d6:	99 0f       	add	r25, r25
    13d8:	99 0f       	add	r25, r25
    13da:	90 7c       	andi	r25, 0xC0	; 192
    13dc:	86 95       	lsr	r24
    13de:	86 95       	lsr	r24
    13e0:	89 2b       	or	r24, r25
    13e2:	8c 8b       	std	Y+20, r24	; 0x14
	patch_to_save.res = current_patch.res;
    13e4:	80 91 e6 02 	lds	r24, 0x02E6
    13e8:	8d 8b       	std	Y+21, r24	; 0x15
    13ea:	95 81       	ldd	r25, Z+5	; 0x05
	patch_to_save.cutoff = current_patch.cutoff;
    13ec:	80 91 e8 02 	lds	r24, 0x02E8
    13f0:	28 2f       	mov	r18, r24
    13f2:	22 0f       	add	r18, r18
    13f4:	22 0f       	add	r18, r18
    13f6:	93 70       	andi	r25, 0x03	; 3
    13f8:	92 2b       	or	r25, r18
    13fa:	9e 8b       	std	Y+22, r25	; 0x16
    13fc:	38 2f       	mov	r19, r24
    13fe:	32 95       	swap	r19
    1400:	36 95       	lsr	r19
    1402:	36 95       	lsr	r19
    1404:	33 70       	andi	r19, 0x03	; 3
    1406:	97 81       	ldd	r25, Z+7	; 0x07
    1408:	93 70       	andi	r25, 0x03	; 3
    140a:	99 0f       	add	r25, r25
    140c:	99 0f       	add	r25, r25
	patch_to_save.key_track = current_patch.key_track;
    140e:	80 91 ea 02 	lds	r24, 0x02EA
    1412:	28 2f       	mov	r18, r24
    1414:	22 95       	swap	r18
    1416:	20 7f       	andi	r18, 0xF0	; 240
    1418:	93 2b       	or	r25, r19
    141a:	92 2b       	or	r25, r18
    141c:	9f 8b       	std	Y+23, r25	; 0x17
    141e:	38 2f       	mov	r19, r24
    1420:	32 95       	swap	r19
    1422:	3f 70       	andi	r19, 0x0F	; 15
    1424:	91 85       	ldd	r25, Z+9	; 0x09
    1426:	93 70       	andi	r25, 0x03	; 3
    1428:	92 95       	swap	r25
    142a:	90 7f       	andi	r25, 0xF0	; 240
	patch_to_save.fil_vco2 = current_patch.fil_vco2;
    142c:	80 91 ec 02 	lds	r24, 0x02EC
    1430:	28 2f       	mov	r18, r24
    1432:	22 95       	swap	r18
    1434:	22 0f       	add	r18, r18
    1436:	22 0f       	add	r18, r18
    1438:	20 7c       	andi	r18, 0xC0	; 192
    143a:	93 2b       	or	r25, r19
    143c:	92 2b       	or	r25, r18
    143e:	98 8f       	std	Y+24, r25	; 0x18
    1440:	93 85       	ldd	r25, Z+11	; 0x0b
    1442:	92 95       	swap	r25
    1444:	99 0f       	add	r25, r25
    1446:	99 0f       	add	r25, r25
    1448:	90 7c       	andi	r25, 0xC0	; 192
    144a:	86 95       	lsr	r24
    144c:	86 95       	lsr	r24
    144e:	89 2b       	or	r24, r25
    1450:	89 8f       	std	Y+25, r24	; 0x19
	patch_to_save.fil_lfo = current_patch.fil_lfo;
    1452:	80 91 ee 02 	lds	r24, 0x02EE
    1456:	8a 8f       	std	Y+26, r24	; 0x1a
    1458:	95 85       	ldd	r25, Z+13	; 0x0d
	patch_to_save.noise_mix = current_patch.noise_mix;
    145a:	80 91 f0 02 	lds	r24, 0x02F0
    145e:	28 2f       	mov	r18, r24
    1460:	22 0f       	add	r18, r18
    1462:	22 0f       	add	r18, r18
    1464:	93 70       	andi	r25, 0x03	; 3
    1466:	92 2b       	or	r25, r18
    1468:	9b 8f       	std	Y+27, r25	; 0x1b
    146a:	38 2f       	mov	r19, r24
    146c:	32 95       	swap	r19
    146e:	36 95       	lsr	r19
    1470:	36 95       	lsr	r19
    1472:	33 70       	andi	r19, 0x03	; 3
    1474:	97 85       	ldd	r25, Z+15	; 0x0f
    1476:	93 70       	andi	r25, 0x03	; 3
    1478:	99 0f       	add	r25, r25
    147a:	99 0f       	add	r25, r25
	patch_to_save.attack_2 = current_patch.attack_2;
    147c:	80 91 f2 02 	lds	r24, 0x02F2
    1480:	28 2f       	mov	r18, r24
    1482:	22 95       	swap	r18
    1484:	20 7f       	andi	r18, 0xF0	; 240
    1486:	93 2b       	or	r25, r19
    1488:	92 2b       	or	r25, r18
    148a:	9c 8f       	std	Y+28, r25	; 0x1c
    148c:	38 2f       	mov	r19, r24
    148e:	32 95       	swap	r19
    1490:	3f 70       	andi	r19, 0x0F	; 15
    1492:	91 89       	ldd	r25, Z+17	; 0x11
    1494:	93 70       	andi	r25, 0x03	; 3
    1496:	92 95       	swap	r25
    1498:	90 7f       	andi	r25, 0xF0	; 240
	patch_to_save.attack_1 = current_patch.attack_1;
    149a:	80 91 f4 02 	lds	r24, 0x02F4
    149e:	28 2f       	mov	r18, r24
    14a0:	22 95       	swap	r18
    14a2:	22 0f       	add	r18, r18
    14a4:	22 0f       	add	r18, r18
    14a6:	20 7c       	andi	r18, 0xC0	; 192
    14a8:	93 2b       	or	r25, r19
    14aa:	92 2b       	or	r25, r18
    14ac:	9d 8f       	std	Y+29, r25	; 0x1d
    14ae:	93 89       	ldd	r25, Z+19	; 0x13
    14b0:	92 95       	swap	r25
    14b2:	99 0f       	add	r25, r25
    14b4:	99 0f       	add	r25, r25
    14b6:	90 7c       	andi	r25, 0xC0	; 192
    14b8:	86 95       	lsr	r24
    14ba:	86 95       	lsr	r24
    14bc:	89 2b       	or	r24, r25
    14be:	8e 8f       	std	Y+30, r24	; 0x1e
	patch_to_save.decay_2 = current_patch.decay_2;
    14c0:	80 91 f6 02 	lds	r24, 0x02F6
    14c4:	8f 8f       	std	Y+31, r24	; 0x1f
    14c6:	95 89       	ldd	r25, Z+21	; 0x15
	patch_to_save.decay_1 = current_patch.decay_1;
    14c8:	80 91 f8 02 	lds	r24, 0x02F8
    14cc:	28 2f       	mov	r18, r24
    14ce:	22 0f       	add	r18, r18
    14d0:	22 0f       	add	r18, r18
    14d2:	93 70       	andi	r25, 0x03	; 3
    14d4:	92 2b       	or	r25, r18
    14d6:	98 a3       	lds	r25, 0x58
    14d8:	38 2f       	mov	r19, r24
    14da:	32 95       	swap	r19
    14dc:	36 95       	lsr	r19
    14de:	36 95       	lsr	r19
    14e0:	33 70       	andi	r19, 0x03	; 3
    14e2:	97 89       	ldd	r25, Z+23	; 0x17
    14e4:	93 70       	andi	r25, 0x03	; 3
    14e6:	99 0f       	add	r25, r25
    14e8:	99 0f       	add	r25, r25
	patch_to_save.sustain_2 = current_patch.sustain_2;
    14ea:	80 91 fa 02 	lds	r24, 0x02FA
    14ee:	28 2f       	mov	r18, r24
    14f0:	22 95       	swap	r18
    14f2:	20 7f       	andi	r18, 0xF0	; 240
    14f4:	93 2b       	or	r25, r19
    14f6:	92 2b       	or	r25, r18
    14f8:	99 a3       	lds	r25, 0x59
    14fa:	38 2f       	mov	r19, r24
    14fc:	32 95       	swap	r19
    14fe:	3f 70       	andi	r19, 0x0F	; 15
    1500:	91 8d       	ldd	r25, Z+25	; 0x19
    1502:	93 70       	andi	r25, 0x03	; 3
    1504:	92 95       	swap	r25
    1506:	90 7f       	andi	r25, 0xF0	; 240
	patch_to_save.sustain_1 = current_patch.sustain_1;
    1508:	80 91 fc 02 	lds	r24, 0x02FC
    150c:	28 2f       	mov	r18, r24
    150e:	22 95       	swap	r18
    1510:	22 0f       	add	r18, r18
    1512:	22 0f       	add	r18, r18
    1514:	20 7c       	andi	r18, 0xC0	; 192
    1516:	93 2b       	or	r25, r19
    1518:	92 2b       	or	r25, r18
    151a:	9a a3       	lds	r25, 0x5a
    151c:	93 8d       	ldd	r25, Z+27	; 0x1b
    151e:	92 95       	swap	r25
    1520:	99 0f       	add	r25, r25
    1522:	99 0f       	add	r25, r25
    1524:	90 7c       	andi	r25, 0xC0	; 192
    1526:	86 95       	lsr	r24
    1528:	86 95       	lsr	r24
    152a:	89 2b       	or	r24, r25
    152c:	8b a3       	lds	r24, 0x5b
	patch_to_save.release_2 = current_patch.release_2;
    152e:	80 91 fe 02 	lds	r24, 0x02FE
    1532:	8c a3       	lds	r24, 0x5c
    1534:	95 8d       	ldd	r25, Z+29	; 0x1d
	patch_to_save.release_1 = current_patch.release_1;
    1536:	80 91 00 03 	lds	r24, 0x0300
    153a:	28 2f       	mov	r18, r24
    153c:	22 0f       	add	r18, r18
    153e:	22 0f       	add	r18, r18
    1540:	93 70       	andi	r25, 0x03	; 3
    1542:	92 2b       	or	r25, r18
    1544:	9d a3       	lds	r25, 0x5d
    1546:	82 95       	swap	r24
    1548:	86 95       	lsr	r24
    154a:	86 95       	lsr	r24
    154c:	83 70       	andi	r24, 0x03	; 3
    154e:	2e a1       	lds	r18, 0x4e
    1550:	20 7f       	andi	r18, 0xF0	; 240
    1552:	97 8d       	ldd	r25, Z+31	; 0x1f
    1554:	93 70       	andi	r25, 0x03	; 3
    1556:	99 0f       	add	r25, r25
    1558:	99 0f       	add	r25, r25
    155a:	82 2b       	or	r24, r18
    155c:	89 2b       	or	r24, r25
    155e:	8e a3       	lds	r24, 0x5e
	
		
	patch_to_save.byte_1 = current_patch.byte_1;
    1560:	80 91 02 03 	lds	r24, 0x0302
    1564:	8f a3       	lds	r24, 0x5f
	patch_to_save.byte_2 = current_patch.byte_2;
    1566:	80 91 03 03 	lds	r24, 0x0303
    156a:	88 a7       	lds	r24, 0x78
	patch_to_save.byte_3 = current_patch.byte_3;
    156c:	80 91 04 03 	lds	r24, 0x0304
    1570:	89 a7       	lds	r24, 0x79
	patch_to_save.byte_4 = current_patch.byte_4;
    1572:	80 91 05 03 	lds	r24, 0x0305
    1576:	8a a7       	lds	r24, 0x7a
	patch_to_save.byte_5 = current_patch.byte_5;
    1578:	80 91 06 03 	lds	r24, 0x0306
    157c:	8b a7       	lds	r24, 0x7b
	
	
	lock_pots();
    157e:	0e 94 c7 08 	call	0x118e	; 0x118e <lock_pots>
	//if (current_patch.mode == MANUAL) switch_states.byte2 &= ~(1<< PROG_MANUAL_SW); //if in MANUAL mode, turn off MANUAL LED
	switch_states.byte2 &= ~(1<< PROG_MANUAL_SW);
    1582:	80 91 84 03 	lds	r24, 0x0384
    1586:	8f 77       	andi	r24, 0x7F	; 127
    1588:	80 93 84 03 	sts	0x0384, r24
	current_patch.mode = MEMORY;
    158c:	10 92 0b 03 	sts	0x030B, r1
	
	eeprom_update_block((const void*)&patch_to_save, (void*)&patch_memory[patch_number], sizeof(patch_to_save));
    1590:	21 2f       	mov	r18, r17
    1592:	30 e0       	ldi	r19, 0x00	; 0
    1594:	8b e2       	ldi	r24, 0x2B	; 43
    1596:	90 e0       	ldi	r25, 0x00	; 0
    1598:	28 9f       	mul	r18, r24
    159a:	b0 01       	movw	r22, r0
    159c:	29 9f       	mul	r18, r25
    159e:	70 0d       	add	r23, r0
    15a0:	38 9f       	mul	r19, r24
    15a2:	70 0d       	add	r23, r0
    15a4:	11 24       	eor	r1, r1
    15a6:	60 50       	subi	r22, 0x00	; 0
    15a8:	70 40       	sbci	r23, 0x00	; 0
    15aa:	ce 01       	movw	r24, r28
    15ac:	01 96       	adiw	r24, 0x01	; 1
    15ae:	4b e2       	ldi	r20, 0x2B	; 43
    15b0:	50 e0       	ldi	r21, 0x00	; 0
    15b2:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <__eeupd_block_m6450a>
}	
    15b6:	ab 96       	adiw	r28, 0x2b	; 43
    15b8:	0f b6       	in	r0, 0x3f	; 63
    15ba:	f8 94       	cli
    15bc:	de bf       	out	0x3e, r29	; 62
    15be:	0f be       	out	0x3f, r0	; 63
    15c0:	cd bf       	out	0x3d, r28	; 61
    15c2:	df 91       	pop	r29
    15c4:	cf 91       	pop	r28
    15c6:	1f 91       	pop	r17
    15c8:	08 95       	ret

000015ca <load_patch>:
	
void load_patch(uint8_t patch_number) {
    15ca:	1f 93       	push	r17
    15cc:	cf 93       	push	r28
    15ce:	df 93       	push	r29
    15d0:	cd b7       	in	r28, 0x3d	; 61
    15d2:	de b7       	in	r29, 0x3e	; 62
    15d4:	c3 54       	subi	r28, 0x43	; 67
    15d6:	d0 40       	sbci	r29, 0x00	; 0
    15d8:	0f b6       	in	r0, 0x3f	; 63
    15da:	f8 94       	cli
    15dc:	de bf       	out	0x3e, r29	; 62
    15de:	0f be       	out	0x3f, r0	; 63
    15e0:	cd bf       	out	0x3d, r28	; 61
	
	struct eeprom_patch loaded_patch;
	//because of bit fields in eeprom patch struct, a temporary eeprom patch needs to be filled with current_patch values and then saved to memory.
	eeprom_read_block((void*)&loaded_patch, (const void*)&patch_memory[patch_number], sizeof(loaded_patch));
    15e2:	90 e0       	ldi	r25, 0x00	; 0
    15e4:	2b e2       	ldi	r18, 0x2B	; 43
    15e6:	30 e0       	ldi	r19, 0x00	; 0
    15e8:	82 9f       	mul	r24, r18
    15ea:	b0 01       	movw	r22, r0
    15ec:	83 9f       	mul	r24, r19
    15ee:	70 0d       	add	r23, r0
    15f0:	92 9f       	mul	r25, r18
    15f2:	70 0d       	add	r23, r0
    15f4:	11 24       	eor	r1, r1
    15f6:	60 50       	subi	r22, 0x00	; 0
    15f8:	70 40       	sbci	r23, 0x00	; 0
    15fa:	ce 01       	movw	r24, r28
    15fc:	01 96       	adiw	r24, 0x01	; 1
    15fe:	4b e2       	ldi	r20, 0x2B	; 43
    1600:	50 e0       	ldi	r21, 0x00	; 0
    1602:	0e 94 64 1f 	call	0x3ec8	; 0x3ec8 <__eerd_block_m6450a>
	
	
	
	current_patch.vco2_pw = loaded_patch.vco2_pw;
    1606:	e2 ee       	ldi	r30, 0xE2	; 226
    1608:	f2 e0       	ldi	r31, 0x02	; 2
    160a:	8a 89       	ldd	r24, Y+18	; 0x12
    160c:	28 2f       	mov	r18, r24
    160e:	22 95       	swap	r18
    1610:	2f 70       	andi	r18, 0x0F	; 15
    1612:	9b 89       	ldd	r25, Y+19	; 0x13
    1614:	39 2f       	mov	r19, r25
    1616:	32 95       	swap	r19
    1618:	30 7f       	andi	r19, 0xF0	; 240
    161a:	32 2b       	or	r19, r18
    161c:	29 2f       	mov	r18, r25
    161e:	22 95       	swap	r18
    1620:	2f 70       	andi	r18, 0x0F	; 15
    1622:	23 70       	andi	r18, 0x03	; 3
    1624:	30 93 e2 02 	sts	0x02E2, r19
    1628:	20 93 e3 02 	sts	0x02E3, r18
	current_patch.vco1_mix = loaded_patch.vco1_mix;
    162c:	df 01       	movw	r26, r30
    162e:	5a 97       	sbiw	r26, 0x1a	; 26
    1630:	4a 81       	ldd	r20, Y+2	; 0x02
    1632:	46 95       	lsr	r20
    1634:	46 95       	lsr	r20
    1636:	2b 81       	ldd	r18, Y+3	; 0x03
    1638:	32 2f       	mov	r19, r18
    163a:	32 95       	swap	r19
    163c:	33 0f       	add	r19, r19
    163e:	33 0f       	add	r19, r19
    1640:	30 7c       	andi	r19, 0xC0	; 192
    1642:	43 2b       	or	r20, r19
    1644:	32 2f       	mov	r19, r18
    1646:	36 95       	lsr	r19
    1648:	36 95       	lsr	r19
    164a:	33 70       	andi	r19, 0x03	; 3
    164c:	4c 93       	st	X, r20
    164e:	11 96       	adiw	r26, 0x01	; 1
    1650:	3c 93       	st	X, r19
	current_patch.pitch_eg2 = loaded_patch.pitch_eg2;
    1652:	df 01       	movw	r26, r30
    1654:	58 97       	sbiw	r26, 0x18	; 24
    1656:	32 2f       	mov	r19, r18
    1658:	32 95       	swap	r19
    165a:	3f 70       	andi	r19, 0x0F	; 15
    165c:	2c 81       	ldd	r18, Y+4	; 0x04
    165e:	42 2f       	mov	r20, r18
    1660:	42 95       	swap	r20
    1662:	40 7f       	andi	r20, 0xF0	; 240
    1664:	43 2b       	or	r20, r19
    1666:	32 2f       	mov	r19, r18
    1668:	32 95       	swap	r19
    166a:	3f 70       	andi	r19, 0x0F	; 15
    166c:	33 70       	andi	r19, 0x03	; 3
    166e:	4c 93       	st	X, r20
    1670:	11 96       	adiw	r26, 0x01	; 1
    1672:	3c 93       	st	X, r19
	current_patch.pitch_vco2 = loaded_patch.pitch_vco2;
    1674:	df 01       	movw	r26, r30
    1676:	56 97       	sbiw	r26, 0x16	; 22
    1678:	22 95       	swap	r18
    167a:	26 95       	lsr	r18
    167c:	26 95       	lsr	r18
    167e:	23 70       	andi	r18, 0x03	; 3
    1680:	3d 81       	ldd	r19, Y+5	; 0x05
    1682:	43 2f       	mov	r20, r19
    1684:	44 0f       	add	r20, r20
    1686:	44 0f       	add	r20, r20
    1688:	24 2b       	or	r18, r20
    168a:	32 95       	swap	r19
    168c:	36 95       	lsr	r19
    168e:	36 95       	lsr	r19
    1690:	33 70       	andi	r19, 0x03	; 3
    1692:	2c 93       	st	X, r18
    1694:	11 96       	adiw	r26, 0x01	; 1
    1696:	3c 93       	st	X, r19
	current_patch.pitch_lfo = loaded_patch.pitch_lfo;
    1698:	df 01       	movw	r26, r30
    169a:	54 97       	sbiw	r26, 0x14	; 20
    169c:	4e 81       	ldd	r20, Y+6	; 0x06
    169e:	2f 81       	ldd	r18, Y+7	; 0x07
    16a0:	32 2f       	mov	r19, r18
    16a2:	33 70       	andi	r19, 0x03	; 3
    16a4:	4c 93       	st	X, r20
    16a6:	11 96       	adiw	r26, 0x01	; 1
    16a8:	3c 93       	st	X, r19
	current_patch.pwm_lfo = loaded_patch.pwm_lfo;
    16aa:	df 01       	movw	r26, r30
    16ac:	52 97       	sbiw	r26, 0x12	; 18
    16ae:	32 2f       	mov	r19, r18
    16b0:	36 95       	lsr	r19
    16b2:	36 95       	lsr	r19
    16b4:	28 85       	ldd	r18, Y+8	; 0x08
    16b6:	42 2f       	mov	r20, r18
    16b8:	42 95       	swap	r20
    16ba:	44 0f       	add	r20, r20
    16bc:	44 0f       	add	r20, r20
    16be:	40 7c       	andi	r20, 0xC0	; 192
    16c0:	43 2b       	or	r20, r19
    16c2:	32 2f       	mov	r19, r18
    16c4:	36 95       	lsr	r19
    16c6:	36 95       	lsr	r19
    16c8:	33 70       	andi	r19, 0x03	; 3
    16ca:	4c 93       	st	X, r20
    16cc:	11 96       	adiw	r26, 0x01	; 1
    16ce:	3c 93       	st	X, r19
	current_patch.pwm_eg2 = loaded_patch.pwm_eg2;
    16d0:	df 01       	movw	r26, r30
    16d2:	50 97       	sbiw	r26, 0x10	; 16
    16d4:	32 2f       	mov	r19, r18
    16d6:	32 95       	swap	r19
    16d8:	3f 70       	andi	r19, 0x0F	; 15
    16da:	29 85       	ldd	r18, Y+9	; 0x09
    16dc:	42 2f       	mov	r20, r18
    16de:	42 95       	swap	r20
    16e0:	40 7f       	andi	r20, 0xF0	; 240
    16e2:	43 2b       	or	r20, r19
    16e4:	32 2f       	mov	r19, r18
    16e6:	32 95       	swap	r19
    16e8:	3f 70       	andi	r19, 0x0F	; 15
    16ea:	33 70       	andi	r19, 0x03	; 3
    16ec:	4c 93       	st	X, r20
    16ee:	11 96       	adiw	r26, 0x01	; 1
    16f0:	3c 93       	st	X, r19
	current_patch.vco1_pw = loaded_patch.vco1_pw;
    16f2:	df 01       	movw	r26, r30
    16f4:	1e 97       	sbiw	r26, 0x0e	; 14
    16f6:	22 95       	swap	r18
    16f8:	26 95       	lsr	r18
    16fa:	26 95       	lsr	r18
    16fc:	23 70       	andi	r18, 0x03	; 3
    16fe:	3a 85       	ldd	r19, Y+10	; 0x0a
    1700:	43 2f       	mov	r20, r19
    1702:	44 0f       	add	r20, r20
    1704:	44 0f       	add	r20, r20
    1706:	24 2b       	or	r18, r20
    1708:	32 95       	swap	r19
    170a:	36 95       	lsr	r19
    170c:	36 95       	lsr	r19
    170e:	33 70       	andi	r19, 0x03	; 3
    1710:	2c 93       	st	X, r18
    1712:	11 96       	adiw	r26, 0x01	; 1
    1714:	3c 93       	st	X, r19
	current_patch.fine = loaded_patch.fine;
    1716:	df 01       	movw	r26, r30
    1718:	1c 97       	sbiw	r26, 0x0c	; 12
    171a:	4b 85       	ldd	r20, Y+11	; 0x0b
    171c:	2c 85       	ldd	r18, Y+12	; 0x0c
    171e:	32 2f       	mov	r19, r18
    1720:	33 70       	andi	r19, 0x03	; 3
    1722:	4c 93       	st	X, r20
    1724:	11 96       	adiw	r26, 0x01	; 1
    1726:	3c 93       	st	X, r19
	current_patch.tune = loaded_patch.tune; //probably shouldn't save master tune value. Like volume, it is a parameter that doesn't apply to a patch.
    1728:	df 01       	movw	r26, r30
    172a:	1a 97       	sbiw	r26, 0x0a	; 10
    172c:	32 2f       	mov	r19, r18
    172e:	36 95       	lsr	r19
    1730:	36 95       	lsr	r19
    1732:	2d 85       	ldd	r18, Y+13	; 0x0d
    1734:	42 2f       	mov	r20, r18
    1736:	42 95       	swap	r20
    1738:	44 0f       	add	r20, r20
    173a:	44 0f       	add	r20, r20
    173c:	40 7c       	andi	r20, 0xC0	; 192
    173e:	43 2b       	or	r20, r19
    1740:	32 2f       	mov	r19, r18
    1742:	36 95       	lsr	r19
    1744:	36 95       	lsr	r19
    1746:	33 70       	andi	r19, 0x03	; 3
    1748:	4c 93       	st	X, r20
    174a:	11 96       	adiw	r26, 0x01	; 1
    174c:	3c 93       	st	X, r19
	current_patch.lfo_rate = loaded_patch.lfo_rate;
    174e:	df 01       	movw	r26, r30
    1750:	18 97       	sbiw	r26, 0x08	; 8
    1752:	32 2f       	mov	r19, r18
    1754:	32 95       	swap	r19
    1756:	3f 70       	andi	r19, 0x0F	; 15
    1758:	2e 85       	ldd	r18, Y+14	; 0x0e
    175a:	42 2f       	mov	r20, r18
    175c:	42 95       	swap	r20
    175e:	40 7f       	andi	r20, 0xF0	; 240
    1760:	43 2b       	or	r20, r19
    1762:	32 2f       	mov	r19, r18
    1764:	32 95       	swap	r19
    1766:	3f 70       	andi	r19, 0x0F	; 15
    1768:	33 70       	andi	r19, 0x03	; 3
    176a:	4c 93       	st	X, r20
    176c:	11 96       	adiw	r26, 0x01	; 1
    176e:	3c 93       	st	X, r19
	current_patch.arp_rate = loaded_patch.arp_rate;
    1770:	df 01       	movw	r26, r30
    1772:	16 97       	sbiw	r26, 0x06	; 6
    1774:	22 95       	swap	r18
    1776:	26 95       	lsr	r18
    1778:	26 95       	lsr	r18
    177a:	23 70       	andi	r18, 0x03	; 3
    177c:	3f 85       	ldd	r19, Y+15	; 0x0f
    177e:	43 2f       	mov	r20, r19
    1780:	44 0f       	add	r20, r20
    1782:	44 0f       	add	r20, r20
    1784:	24 2b       	or	r18, r20
    1786:	32 95       	swap	r19
    1788:	36 95       	lsr	r19
    178a:	36 95       	lsr	r19
    178c:	33 70       	andi	r19, 0x03	; 3
    178e:	2c 93       	st	X, r18
    1790:	11 96       	adiw	r26, 0x01	; 1
    1792:	3c 93       	st	X, r19
	current_patch.glide	= loaded_patch.glide;
    1794:	df 01       	movw	r26, r30
    1796:	14 97       	sbiw	r26, 0x04	; 4
    1798:	48 89       	ldd	r20, Y+16	; 0x10
    179a:	29 89       	ldd	r18, Y+17	; 0x11
    179c:	32 2f       	mov	r19, r18
    179e:	33 70       	andi	r19, 0x03	; 3
    17a0:	4c 93       	st	X, r20
    17a2:	11 96       	adiw	r26, 0x01	; 1
    17a4:	3c 93       	st	X, r19
	current_patch.amp_lfo = loaded_patch.amp_lfo;
    17a6:	df 01       	movw	r26, r30
    17a8:	12 97       	sbiw	r26, 0x02	; 2
    17aa:	26 95       	lsr	r18
    17ac:	26 95       	lsr	r18
    17ae:	38 2f       	mov	r19, r24
    17b0:	32 95       	swap	r19
    17b2:	33 0f       	add	r19, r19
    17b4:	33 0f       	add	r19, r19
    17b6:	30 7c       	andi	r19, 0xC0	; 192
    17b8:	23 2b       	or	r18, r19
    17ba:	86 95       	lsr	r24
    17bc:	86 95       	lsr	r24
    17be:	83 70       	andi	r24, 0x03	; 3
    17c0:	2c 93       	st	X, r18
    17c2:	11 96       	adiw	r26, 0x01	; 1
    17c4:	8c 93       	st	X, r24
	current_patch.vco2_pw = loaded_patch.vco2_pw;
	
	current_patch.fil_eg2 = loaded_patch.fil_eg2;
    17c6:	92 95       	swap	r25
    17c8:	96 95       	lsr	r25
    17ca:	96 95       	lsr	r25
    17cc:	93 70       	andi	r25, 0x03	; 3
    17ce:	8c 89       	ldd	r24, Y+20	; 0x14
    17d0:	28 2f       	mov	r18, r24
    17d2:	22 0f       	add	r18, r18
    17d4:	22 0f       	add	r18, r18
    17d6:	92 2b       	or	r25, r18
    17d8:	82 95       	swap	r24
    17da:	86 95       	lsr	r24
    17dc:	86 95       	lsr	r24
    17de:	83 70       	andi	r24, 0x03	; 3
    17e0:	90 93 e4 02 	sts	0x02E4, r25
    17e4:	83 83       	std	Z+3, r24	; 0x03
	current_patch.res = loaded_patch.res;
    17e6:	2d 89       	ldd	r18, Y+21	; 0x15
    17e8:	8e 89       	ldd	r24, Y+22	; 0x16
    17ea:	98 2f       	mov	r25, r24
    17ec:	93 70       	andi	r25, 0x03	; 3
    17ee:	20 93 e6 02 	sts	0x02E6, r18
    17f2:	95 83       	std	Z+5, r25	; 0x05
	current_patch.cutoff = loaded_patch.cutoff;
    17f4:	98 2f       	mov	r25, r24
    17f6:	96 95       	lsr	r25
    17f8:	96 95       	lsr	r25
    17fa:	8f 89       	ldd	r24, Y+23	; 0x17
    17fc:	28 2f       	mov	r18, r24
    17fe:	22 95       	swap	r18
    1800:	22 0f       	add	r18, r18
    1802:	22 0f       	add	r18, r18
    1804:	20 7c       	andi	r18, 0xC0	; 192
    1806:	29 2b       	or	r18, r25
    1808:	98 2f       	mov	r25, r24
    180a:	96 95       	lsr	r25
    180c:	96 95       	lsr	r25
    180e:	93 70       	andi	r25, 0x03	; 3
    1810:	20 93 e8 02 	sts	0x02E8, r18
    1814:	97 83       	std	Z+7, r25	; 0x07
	current_patch.key_track = loaded_patch.key_track;
    1816:	98 2f       	mov	r25, r24
    1818:	92 95       	swap	r25
    181a:	9f 70       	andi	r25, 0x0F	; 15
    181c:	88 8d       	ldd	r24, Y+24	; 0x18
    181e:	28 2f       	mov	r18, r24
    1820:	22 95       	swap	r18
    1822:	20 7f       	andi	r18, 0xF0	; 240
    1824:	29 2b       	or	r18, r25
    1826:	98 2f       	mov	r25, r24
    1828:	92 95       	swap	r25
    182a:	9f 70       	andi	r25, 0x0F	; 15
    182c:	93 70       	andi	r25, 0x03	; 3
    182e:	20 93 ea 02 	sts	0x02EA, r18
    1832:	91 87       	std	Z+9, r25	; 0x09
	current_patch.fil_vco2 = loaded_patch.fil_vco2;
    1834:	82 95       	swap	r24
    1836:	86 95       	lsr	r24
    1838:	86 95       	lsr	r24
    183a:	83 70       	andi	r24, 0x03	; 3
    183c:	99 8d       	ldd	r25, Y+25	; 0x19
    183e:	29 2f       	mov	r18, r25
    1840:	22 0f       	add	r18, r18
    1842:	22 0f       	add	r18, r18
    1844:	82 2b       	or	r24, r18
    1846:	92 95       	swap	r25
    1848:	96 95       	lsr	r25
    184a:	96 95       	lsr	r25
    184c:	93 70       	andi	r25, 0x03	; 3
    184e:	80 93 ec 02 	sts	0x02EC, r24
    1852:	93 87       	std	Z+11, r25	; 0x0b
	current_patch.fil_lfo = loaded_patch.fil_lfo;
    1854:	2a 8d       	ldd	r18, Y+26	; 0x1a
    1856:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1858:	98 2f       	mov	r25, r24
    185a:	93 70       	andi	r25, 0x03	; 3
    185c:	20 93 ee 02 	sts	0x02EE, r18
    1860:	95 87       	std	Z+13, r25	; 0x0d
	current_patch.noise_mix = loaded_patch.noise_mix;
    1862:	98 2f       	mov	r25, r24
    1864:	96 95       	lsr	r25
    1866:	96 95       	lsr	r25
    1868:	8c 8d       	ldd	r24, Y+28	; 0x1c
    186a:	28 2f       	mov	r18, r24
    186c:	22 95       	swap	r18
    186e:	22 0f       	add	r18, r18
    1870:	22 0f       	add	r18, r18
    1872:	20 7c       	andi	r18, 0xC0	; 192
    1874:	29 2b       	or	r18, r25
    1876:	98 2f       	mov	r25, r24
    1878:	96 95       	lsr	r25
    187a:	96 95       	lsr	r25
    187c:	93 70       	andi	r25, 0x03	; 3
    187e:	20 93 f0 02 	sts	0x02F0, r18
    1882:	97 87       	std	Z+15, r25	; 0x0f
	current_patch.attack_2 = loaded_patch.attack_2;
    1884:	98 2f       	mov	r25, r24
    1886:	92 95       	swap	r25
    1888:	9f 70       	andi	r25, 0x0F	; 15
    188a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    188c:	28 2f       	mov	r18, r24
    188e:	22 95       	swap	r18
    1890:	20 7f       	andi	r18, 0xF0	; 240
    1892:	29 2b       	or	r18, r25
    1894:	98 2f       	mov	r25, r24
    1896:	92 95       	swap	r25
    1898:	9f 70       	andi	r25, 0x0F	; 15
    189a:	93 70       	andi	r25, 0x03	; 3
    189c:	20 93 f2 02 	sts	0x02F2, r18
    18a0:	91 8b       	std	Z+17, r25	; 0x11
	current_patch.attack_1 = loaded_patch.attack_1;
    18a2:	82 95       	swap	r24
    18a4:	86 95       	lsr	r24
    18a6:	86 95       	lsr	r24
    18a8:	83 70       	andi	r24, 0x03	; 3
    18aa:	9e 8d       	ldd	r25, Y+30	; 0x1e
    18ac:	29 2f       	mov	r18, r25
    18ae:	22 0f       	add	r18, r18
    18b0:	22 0f       	add	r18, r18
    18b2:	82 2b       	or	r24, r18
    18b4:	92 95       	swap	r25
    18b6:	96 95       	lsr	r25
    18b8:	96 95       	lsr	r25
    18ba:	93 70       	andi	r25, 0x03	; 3
    18bc:	80 93 f4 02 	sts	0x02F4, r24
    18c0:	93 8b       	std	Z+19, r25	; 0x13
	current_patch.decay_2 = loaded_patch.decay_2;
    18c2:	2f 8d       	ldd	r18, Y+31	; 0x1f
    18c4:	88 a1       	lds	r24, 0x48
    18c6:	98 2f       	mov	r25, r24
    18c8:	93 70       	andi	r25, 0x03	; 3
    18ca:	20 93 f6 02 	sts	0x02F6, r18
    18ce:	95 8b       	std	Z+21, r25	; 0x15
	current_patch.decay_1 = loaded_patch.decay_1;
    18d0:	98 2f       	mov	r25, r24
    18d2:	96 95       	lsr	r25
    18d4:	96 95       	lsr	r25
    18d6:	89 a1       	lds	r24, 0x49
    18d8:	28 2f       	mov	r18, r24
    18da:	22 95       	swap	r18
    18dc:	22 0f       	add	r18, r18
    18de:	22 0f       	add	r18, r18
    18e0:	20 7c       	andi	r18, 0xC0	; 192
    18e2:	29 2b       	or	r18, r25
    18e4:	98 2f       	mov	r25, r24
    18e6:	96 95       	lsr	r25
    18e8:	96 95       	lsr	r25
    18ea:	93 70       	andi	r25, 0x03	; 3
    18ec:	20 93 f8 02 	sts	0x02F8, r18
    18f0:	97 8b       	std	Z+23, r25	; 0x17
	current_patch.sustain_2 = loaded_patch.sustain_2;
    18f2:	98 2f       	mov	r25, r24
    18f4:	92 95       	swap	r25
    18f6:	9f 70       	andi	r25, 0x0F	; 15
    18f8:	8a a1       	lds	r24, 0x4a
    18fa:	28 2f       	mov	r18, r24
    18fc:	22 95       	swap	r18
    18fe:	20 7f       	andi	r18, 0xF0	; 240
    1900:	29 2b       	or	r18, r25
    1902:	98 2f       	mov	r25, r24
    1904:	92 95       	swap	r25
    1906:	9f 70       	andi	r25, 0x0F	; 15
    1908:	93 70       	andi	r25, 0x03	; 3
    190a:	20 93 fa 02 	sts	0x02FA, r18
    190e:	91 8f       	std	Z+25, r25	; 0x19
	current_patch.sustain_1 = loaded_patch.sustain_1;
    1910:	82 95       	swap	r24
    1912:	86 95       	lsr	r24
    1914:	86 95       	lsr	r24
    1916:	83 70       	andi	r24, 0x03	; 3
    1918:	9b a1       	lds	r25, 0x4b
    191a:	29 2f       	mov	r18, r25
    191c:	22 0f       	add	r18, r18
    191e:	22 0f       	add	r18, r18
    1920:	82 2b       	or	r24, r18
    1922:	92 95       	swap	r25
    1924:	96 95       	lsr	r25
    1926:	96 95       	lsr	r25
    1928:	93 70       	andi	r25, 0x03	; 3
    192a:	80 93 fc 02 	sts	0x02FC, r24
    192e:	93 8f       	std	Z+27, r25	; 0x1b
	current_patch.release_2 = loaded_patch.release_2;
    1930:	2c a1       	lds	r18, 0x4c
    1932:	8d a1       	lds	r24, 0x4d
    1934:	98 2f       	mov	r25, r24
    1936:	93 70       	andi	r25, 0x03	; 3
    1938:	20 93 fe 02 	sts	0x02FE, r18
    193c:	95 8f       	std	Z+29, r25	; 0x1d
	current_patch.release_1 = loaded_patch.release_1;
    193e:	98 2f       	mov	r25, r24
    1940:	96 95       	lsr	r25
    1942:	96 95       	lsr	r25
    1944:	8e a1       	lds	r24, 0x4e
    1946:	28 2f       	mov	r18, r24
    1948:	22 95       	swap	r18
    194a:	22 0f       	add	r18, r18
    194c:	22 0f       	add	r18, r18
    194e:	20 7c       	andi	r18, 0xC0	; 192
    1950:	29 2b       	or	r18, r25
    1952:	86 95       	lsr	r24
    1954:	86 95       	lsr	r24
    1956:	98 2f       	mov	r25, r24
    1958:	93 70       	andi	r25, 0x03	; 3
    195a:	20 93 00 03 	sts	0x0300, r18
    195e:	97 8f       	std	Z+31, r25	; 0x1f
	
	
	current_patch.byte_1 = loaded_patch.byte_1;
    1960:	7f a1       	lds	r23, 0x4f
    1962:	70 93 02 03 	sts	0x0302, r23
	current_patch.byte_2 = loaded_patch.byte_2;
    1966:	68 a5       	lds	r22, 0x68
    1968:	60 93 03 03 	sts	0x0303, r22
	current_patch.byte_3 = loaded_patch.byte_3;
    196c:	89 a5       	lds	r24, 0x69
    196e:	80 93 04 03 	sts	0x0304, r24
	current_patch.byte_4 = loaded_patch.byte_4;
    1972:	9a a5       	lds	r25, 0x6a
    1974:	90 93 05 03 	sts	0x0305, r25
	current_patch.byte_5 = loaded_patch.byte_5;
    1978:	1b a5       	lds	r17, 0x6b
    197a:	10 93 06 03 	sts	0x0306, r17
	
	//using De Bruijn sequence to determine which bit is set. For alphabet size k = 2 (binary - 0 and 1) and n = 3. 2^3 = 8. The minimum number of bits required to represent the 5 octave positions
	uint8_t vco1_lookup[] = {7, 2, 5, 0, 6, 4, 3, 1}; // *modified* De Bruijn lookup table for octave number, see: http://stackoverflow.com/questions/14429661/determine-which-single-bit-in-the-byte-is-set
    197e:	de 01       	movw	r26, r28
    1980:	9c 96       	adiw	r26, 0x2c	; 44
    1982:	ef ef       	ldi	r30, 0xFF	; 255
    1984:	f1 e0       	ldi	r31, 0x01	; 1
    1986:	28 e0       	ldi	r18, 0x08	; 8
    1988:	01 90       	ld	r0, Z+
    198a:	0d 92       	st	X+, r0
    198c:	21 50       	subi	r18, 0x01	; 1
    198e:	e1 f7       	brne	.-8      	; 0x1988 <load_patch+0x3be>
	//lookup table modified from standard 8 bit De Bruijn sequence to handle non sequential order of octave LEDs in byte_4
	uint8_t vco1_bitfield = current_patch.byte_4 & 0b00011111; //clear top 3 bits, which are used for VCO2 octave lookup - probably don't need to clear these bits
    1990:	e9 2f       	mov	r30, r25
    1992:	ef 71       	andi	r30, 0x1F	; 31
	uint8_t bit_index = ((vco1_bitfield*0x1D) >> 4) & 0x7;	//0x1D 0b11101 is the De Bruijn sequence for 8 bits 
    1994:	f0 e0       	ldi	r31, 0x00	; 0
    1996:	9f 01       	movw	r18, r30
    1998:	22 0f       	add	r18, r18
    199a:	33 1f       	adc	r19, r19
    199c:	22 0f       	add	r18, r18
    199e:	33 1f       	adc	r19, r19
    19a0:	a9 01       	movw	r20, r18
    19a2:	44 0f       	add	r20, r20
    19a4:	55 1f       	adc	r21, r21
    19a6:	44 0f       	add	r20, r20
    19a8:	55 1f       	adc	r21, r21
    19aa:	44 0f       	add	r20, r20
    19ac:	55 1f       	adc	r21, r21
    19ae:	42 1b       	sub	r20, r18
    19b0:	53 0b       	sbc	r21, r19
    19b2:	4e 0f       	add	r20, r30
    19b4:	5f 1f       	adc	r21, r31
    19b6:	55 95       	asr	r21
    19b8:	47 95       	ror	r20
    19ba:	55 95       	asr	r21
    19bc:	47 95       	ror	r20
    19be:	55 95       	asr	r21
    19c0:	47 95       	ror	r20
    19c2:	55 95       	asr	r21
    19c4:	47 95       	ror	r20
    19c6:	47 70       	andi	r20, 0x07	; 7
	octave_index.vco1 = vco1_lookup[bit_index];	
    19c8:	fe 01       	movw	r30, r28
    19ca:	e4 0f       	add	r30, r20
    19cc:	f1 1d       	adc	r31, r1
    19ce:	24 a5       	lds	r18, 0x64
    19d0:	20 93 0c 03 	sts	0x030C, r18
	
	uint8_t vco2_lookup[] = {7, 4, 5, 3, 6, 2, 1, 0}; 
    19d4:	de 01       	movw	r26, r28
    19d6:	d4 96       	adiw	r26, 0x34	; 52
    19d8:	e7 e0       	ldi	r30, 0x07	; 7
    19da:	f2 e0       	ldi	r31, 0x02	; 2
    19dc:	28 e0       	ldi	r18, 0x08	; 8
    19de:	01 90       	ld	r0, Z+
    19e0:	0d 92       	st	X+, r0
    19e2:	21 50       	subi	r18, 0x01	; 1
    19e4:	e1 f7       	brne	.-8      	; 0x19de <load_patch+0x414>
																																				 //bit order 4   3    2    1   0
	uint8_t vco2_bitfield = ((current_patch.byte_4 & 0b11100000) >> 3) | (current_patch.byte_3 & 0b00000011); //combine  all VCO2 octave bits into one byte: 8', 16', 32', 4', 2'
    19e6:	29 2f       	mov	r18, r25
    19e8:	30 e0       	ldi	r19, 0x00	; 0
    19ea:	20 7e       	andi	r18, 0xE0	; 224
    19ec:	30 70       	andi	r19, 0x00	; 0
    19ee:	35 95       	asr	r19
    19f0:	27 95       	ror	r18
    19f2:	35 95       	asr	r19
    19f4:	27 95       	ror	r18
    19f6:	35 95       	asr	r19
    19f8:	27 95       	ror	r18
    19fa:	83 70       	andi	r24, 0x03	; 3
    19fc:	28 2b       	or	r18, r24
	bit_index = ((vco2_bitfield*0x1D) >> 4) & 0x7;																								     //index 2   1    0    3   4
    19fe:	42 2f       	mov	r20, r18
    1a00:	50 e0       	ldi	r21, 0x00	; 0
    1a02:	ca 01       	movw	r24, r20
    1a04:	88 0f       	add	r24, r24
    1a06:	99 1f       	adc	r25, r25
    1a08:	88 0f       	add	r24, r24
    1a0a:	99 1f       	adc	r25, r25
    1a0c:	9c 01       	movw	r18, r24
    1a0e:	22 0f       	add	r18, r18
    1a10:	33 1f       	adc	r19, r19
    1a12:	22 0f       	add	r18, r18
    1a14:	33 1f       	adc	r19, r19
    1a16:	22 0f       	add	r18, r18
    1a18:	33 1f       	adc	r19, r19
    1a1a:	28 1b       	sub	r18, r24
    1a1c:	39 0b       	sbc	r19, r25
    1a1e:	42 0f       	add	r20, r18
    1a20:	53 1f       	adc	r21, r19
    1a22:	ca 01       	movw	r24, r20
    1a24:	95 95       	asr	r25
    1a26:	87 95       	ror	r24
    1a28:	95 95       	asr	r25
    1a2a:	87 95       	ror	r24
    1a2c:	95 95       	asr	r25
    1a2e:	87 95       	ror	r24
    1a30:	95 95       	asr	r25
    1a32:	87 95       	ror	r24
    1a34:	87 70       	andi	r24, 0x07	; 7
	octave_index.vco2 = vco2_lookup[bit_index];
    1a36:	fe 01       	movw	r30, r28
    1a38:	e8 0f       	add	r30, r24
    1a3a:	f1 1d       	adc	r31, r1
    1a3c:	84 a9       	sts	0x44, r24
    1a3e:	80 93 0d 03 	sts	0x030D, r24
	
	uint8_t lfo_lookup[] = {0, 0, 2, 2, 1, 3, 3, 1}; //bits 7, 5, 4, 6 are irrelevant here. Complier seems to be reformatting this table???
    1a42:	de 01       	movw	r26, r28
    1a44:	dc 96       	adiw	r26, 0x3c	; 60
    1a46:	ef e0       	ldi	r30, 0x0F	; 15
    1a48:	f2 e0       	ldi	r31, 0x02	; 2
    1a4a:	88 e0       	ldi	r24, 0x08	; 8
    1a4c:	01 90       	ld	r0, Z+
    1a4e:	0d 92       	st	X+, r0
    1a50:	81 50       	subi	r24, 0x01	; 1
    1a52:	e1 f7       	brne	.-8      	; 0x1a4c <load_patch+0x482>
	uint8_t lfo_bitfield = current_patch.byte_2 & 0b11110000; //shave off 4 LSBs. Really could use 4 bit De Bruijn sequence here
    1a54:	60 7f       	andi	r22, 0xF0	; 240
	bit_index = ((lfo_bitfield*0x1D) >> 4) & 0x7;
    1a56:	46 2f       	mov	r20, r22
    1a58:	50 e0       	ldi	r21, 0x00	; 0
    1a5a:	ca 01       	movw	r24, r20
    1a5c:	88 0f       	add	r24, r24
    1a5e:	99 1f       	adc	r25, r25
    1a60:	88 0f       	add	r24, r24
    1a62:	99 1f       	adc	r25, r25
    1a64:	9c 01       	movw	r18, r24
    1a66:	22 0f       	add	r18, r18
    1a68:	33 1f       	adc	r19, r19
    1a6a:	22 0f       	add	r18, r18
    1a6c:	33 1f       	adc	r19, r19
    1a6e:	22 0f       	add	r18, r18
    1a70:	33 1f       	adc	r19, r19
    1a72:	28 1b       	sub	r18, r24
    1a74:	39 0b       	sbc	r19, r25
    1a76:	42 0f       	add	r20, r18
    1a78:	53 1f       	adc	r21, r19
    1a7a:	ca 01       	movw	r24, r20
    1a7c:	95 95       	asr	r25
    1a7e:	87 95       	ror	r24
    1a80:	95 95       	asr	r25
    1a82:	87 95       	ror	r24
    1a84:	95 95       	asr	r25
    1a86:	87 95       	ror	r24
    1a88:	95 95       	asr	r25
    1a8a:	87 95       	ror	r24
    1a8c:	87 70       	andi	r24, 0x07	; 7
	lfo_shape_index = lfo_lookup[bit_index];
    1a8e:	fe 01       	movw	r30, r28
    1a90:	e8 0f       	add	r30, r24
    1a92:	f1 1d       	adc	r31, r1
    1a94:	84 ad       	sts	0x64, r24
    1a96:	80 93 0e 03 	sts	0x030E, r24
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1a9a:	21 2f       	mov	r18, r17
    1a9c:	26 95       	lsr	r18
    1a9e:	27 95       	ror	r18
    1aa0:	22 27       	eor	r18, r18
    1aa2:	27 95       	ror	r18
    1aa4:	81 2f       	mov	r24, r17
    1aa6:	81 70       	andi	r24, 0x01	; 1
    1aa8:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
    1aaa:	81 2f       	mov	r24, r17
    1aac:	86 95       	lsr	r24
    1aae:	86 95       	lsr	r24
    1ab0:	90 e0       	ldi	r25, 0x00	; 0
    1ab2:	81 70       	andi	r24, 0x01	; 1
    1ab4:	90 70       	andi	r25, 0x00	; 0
    1ab6:	88 0f       	add	r24, r24
    1ab8:	99 1f       	adc	r25, r25
    1aba:	88 0f       	add	r24, r24
    1abc:	99 1f       	adc	r25, r25
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1abe:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
							((current_patch.byte_5 >> VCO1_TRI) & 1) << VCO1_TRI_SW |
    1ac0:	81 2f       	mov	r24, r17
    1ac2:	86 95       	lsr	r24
    1ac4:	86 95       	lsr	r24
    1ac6:	86 95       	lsr	r24
    1ac8:	90 e0       	ldi	r25, 0x00	; 0
    1aca:	81 70       	andi	r24, 0x01	; 1
    1acc:	90 70       	andi	r25, 0x00	; 0
    1ace:	88 0f       	add	r24, r24
    1ad0:	99 1f       	adc	r25, r25
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1ad2:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
							((current_patch.byte_5 >> VCO1_TRI) & 1) << VCO1_TRI_SW |
							((current_patch.byte_5 >> VCO1_PULSE) & 1) << VCO1_PULSE_SW |
							((current_patch.byte_5 >> VCO2_SAW) & 1) << VCO2_SAW_SW |
    1ad4:	81 2f       	mov	r24, r17
    1ad6:	82 95       	swap	r24
    1ad8:	8f 70       	andi	r24, 0x0F	; 15
    1ada:	90 e0       	ldi	r25, 0x00	; 0
    1adc:	81 70       	andi	r24, 0x01	; 1
    1ade:	90 70       	andi	r25, 0x00	; 0
    1ae0:	82 95       	swap	r24
    1ae2:	92 95       	swap	r25
    1ae4:	90 7f       	andi	r25, 0xF0	; 240
    1ae6:	98 27       	eor	r25, r24
    1ae8:	80 7f       	andi	r24, 0xF0	; 240
    1aea:	98 27       	eor	r25, r24
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1aec:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
							((current_patch.byte_5 >> VCO1_TRI) & 1) << VCO1_TRI_SW |
							((current_patch.byte_5 >> VCO1_PULSE) & 1) << VCO1_PULSE_SW |
							((current_patch.byte_5 >> VCO2_SAW) & 1) << VCO2_SAW_SW |
							((current_patch.byte_5 >> VCO2_TRI) & 1) << VCO2_TRI_SW |
    1aee:	81 2f       	mov	r24, r17
    1af0:	82 95       	swap	r24
    1af2:	86 95       	lsr	r24
    1af4:	87 70       	andi	r24, 0x07	; 7
    1af6:	90 e0       	ldi	r25, 0x00	; 0
    1af8:	81 70       	andi	r24, 0x01	; 1
    1afa:	90 70       	andi	r25, 0x00	; 0
    1afc:	88 0f       	add	r24, r24
    1afe:	99 1f       	adc	r25, r25
    1b00:	82 95       	swap	r24
    1b02:	92 95       	swap	r25
    1b04:	90 7f       	andi	r25, 0xF0	; 240
    1b06:	98 27       	eor	r25, r24
    1b08:	80 7f       	andi	r24, 0xF0	; 240
    1b0a:	98 27       	eor	r25, r24
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1b0c:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
							((current_patch.byte_5 >> VCO1_TRI) & 1) << VCO1_TRI_SW |
							((current_patch.byte_5 >> VCO1_PULSE) & 1) << VCO1_PULSE_SW |
							((current_patch.byte_5 >> VCO2_SAW) & 1) << VCO2_SAW_SW |
							((current_patch.byte_5 >> VCO2_TRI) & 1) << VCO2_TRI_SW |
							((current_patch.byte_5 >> VCO2_PULSE) & 1) << VCO2_PULSE_SW;
    1b0e:	81 2f       	mov	r24, r17
    1b10:	82 95       	swap	r24
    1b12:	86 95       	lsr	r24
    1b14:	86 95       	lsr	r24
    1b16:	83 70       	andi	r24, 0x03	; 3
    1b18:	90 e0       	ldi	r25, 0x00	; 0
    1b1a:	81 70       	andi	r24, 0x01	; 1
    1b1c:	90 70       	andi	r25, 0x00	; 0
    1b1e:	00 24       	eor	r0, r0
    1b20:	96 95       	lsr	r25
    1b22:	87 95       	ror	r24
    1b24:	07 94       	ror	r0
    1b26:	96 95       	lsr	r25
    1b28:	87 95       	ror	r24
    1b2a:	07 94       	ror	r0
    1b2c:	98 2f       	mov	r25, r24
    1b2e:	80 2d       	mov	r24, r0
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1b30:	82 2b       	or	r24, r18
    1b32:	80 93 82 03 	sts	0x0382, r24
							((current_patch.byte_5 >> VCO2_PULSE) & 1) << VCO2_PULSE_SW;
							
	switch_states.byte2 &= 0b11110011; //preserve PROG switches states, clear BMOD and EG2 states
	
	switch_states.byte2 |=	((current_patch.byte_5 >> BMOD) & 1) << BMOD_SW |
							((current_patch.byte_1 >> EG2_INV) & 1) << EG2_INV_SW;	
    1b36:	87 2f       	mov	r24, r23
    1b38:	90 e0       	ldi	r25, 0x00	; 0
    1b3a:	81 70       	andi	r24, 0x01	; 1
    1b3c:	90 70       	andi	r25, 0x00	; 0
    1b3e:	88 0f       	add	r24, r24
    1b40:	99 1f       	adc	r25, r25
    1b42:	88 0f       	add	r24, r24
    1b44:	99 1f       	adc	r25, r25
    1b46:	88 0f       	add	r24, r24
    1b48:	99 1f       	adc	r25, r25
							((current_patch.byte_5 >> VCO1_PULSE) & 1) << VCO1_PULSE_SW |
							((current_patch.byte_5 >> VCO2_SAW) & 1) << VCO2_SAW_SW |
							((current_patch.byte_5 >> VCO2_TRI) & 1) << VCO2_TRI_SW |
							((current_patch.byte_5 >> VCO2_PULSE) & 1) << VCO2_PULSE_SW;
							
	switch_states.byte2 &= 0b11110011; //preserve PROG switches states, clear BMOD and EG2 states
    1b4a:	90 91 84 03 	lds	r25, 0x0384
    1b4e:	93 7f       	andi	r25, 0xF3	; 243
	
	switch_states.byte2 |=	((current_patch.byte_5 >> BMOD) & 1) << BMOD_SW |
    1b50:	89 2b       	or	r24, r25
    1b52:	11 1f       	adc	r17, r17
    1b54:	11 27       	eor	r17, r17
    1b56:	11 1f       	adc	r17, r17
    1b58:	11 0f       	add	r17, r17
    1b5a:	11 0f       	add	r17, r17
    1b5c:	81 2b       	or	r24, r17
    1b5e:	80 93 84 03 	sts	0x0384, r24
													
	//spi_sw_byte0_current_state = spi_sw_byte0_previous_state = switch_states.byte0;
	//
	//spi_sw_byte1_current_state = spi_sw_byte1_previous_state = switch_states.byte1;						
			
	lock_pots();
    1b62:	0e 94 c7 08 	call	0x118e	; 0x118e <lock_pots>
	
	//if (current_patch.mode == MANUAL) switch_states.byte2 &= ~(1<< PROG_MANUAL_SW); //if in MANUAL mode, turn off MANUAL LED
	switch_states.byte2 &= ~(1<<PROG_MANUAL_SW);
    1b66:	80 91 84 03 	lds	r24, 0x0384
    1b6a:	8f 77       	andi	r24, 0x7F	; 127
    1b6c:	80 93 84 03 	sts	0x0384, r24
	
	current_patch.mode = MEMORY;
    1b70:	10 92 0b 03 	sts	0x030B, r1
	
}
    1b74:	cd 5b       	subi	r28, 0xBD	; 189
    1b76:	df 4f       	sbci	r29, 0xFF	; 255
    1b78:	0f b6       	in	r0, 0x3f	; 63
    1b7a:	f8 94       	cli
    1b7c:	de bf       	out	0x3e, r29	; 62
    1b7e:	0f be       	out	0x3f, r0	; 63
    1b80:	cd bf       	out	0x3d, r28	; 61
    1b82:	df 91       	pop	r29
    1b84:	cf 91       	pop	r28
    1b86:	1f 91       	pop	r17
    1b88:	08 95       	ret

00001b8a <transpose_note>:

uint8_t transpose_note (uint8_t note, uint8_t vco) {
	
	uint8_t n = 0;
	
	n = octave_index.vco1;
    1b8a:	90 91 0c 03 	lds	r25, 0x030C
	if (vco == VCO2) n = octave_index.vco2;
    1b8e:	60 3f       	cpi	r22, 0xF0	; 240
    1b90:	11 f4       	brne	.+4      	; 0x1b96 <transpose_note+0xc>
    1b92:	90 91 0d 03 	lds	r25, 0x030D

	note = (n*12) + note; //calculate MIDI note after octave addition
    1b96:	29 2f       	mov	r18, r25
    1b98:	22 0f       	add	r18, r18
    1b9a:	92 0f       	add	r25, r18
    1b9c:	99 0f       	add	r25, r25
    1b9e:	99 0f       	add	r25, r25
    1ba0:	89 0f       	add	r24, r25
			
		note = 136;
			
	}
		
	return note;	
    1ba2:	89 38       	cpi	r24, 0x89	; 137
    1ba4:	08 f0       	brcs	.+2      	; 0x1ba8 <transpose_note+0x1e>
    1ba6:	88 e8       	ldi	r24, 0x88	; 136
	
}
    1ba8:	08 95       	ret

00001baa <update_octave_range>:

void update_octave_range(void) {
	
	if ((switch_states.byte0 >> VCO1_OCTAVE_UP_SW) & 1) {
    1baa:	80 91 82 03 	lds	r24, 0x0382
    1bae:	98 2f       	mov	r25, r24
    1bb0:	96 95       	lsr	r25
    1bb2:	96 95       	lsr	r25
    1bb4:	96 95       	lsr	r25
    1bb6:	90 ff       	sbrs	r25, 0
    1bb8:	0e c0       	rjmp	.+28     	; 0x1bd6 <update_octave_range+0x2c>
		
		if (++octave_index.vco1 == 5) octave_index.vco1 = 4;
    1bba:	90 91 0c 03 	lds	r25, 0x030C
    1bbe:	9f 5f       	subi	r25, 0xFF	; 255
    1bc0:	90 93 0c 03 	sts	0x030C, r25
    1bc4:	95 30       	cpi	r25, 0x05	; 5
    1bc6:	19 f4       	brne	.+6      	; 0x1bce <update_octave_range+0x24>
    1bc8:	94 e0       	ldi	r25, 0x04	; 4
    1bca:	90 93 0c 03 	sts	0x030C, r25
		switch_states.byte0 ^= (1<<VCO1_OCTAVE_UP_SW); //toggle switch state bit
    1bce:	98 e0       	ldi	r25, 0x08	; 8
    1bd0:	89 27       	eor	r24, r25
    1bd2:	80 93 82 03 	sts	0x0382, r24
		
	}
	
	if ((switch_states.byte1 >> VCO1_OCTAVE_DOWN_SW) & 1) { //this didn't work initially because VCO1_OCTAVE_DOWN_SW pull down resistor wasn't installed on PCB!!!
    1bd6:	80 91 83 03 	lds	r24, 0x0383
    1bda:	98 2f       	mov	r25, r24
    1bdc:	96 95       	lsr	r25
    1bde:	96 95       	lsr	r25
    1be0:	96 95       	lsr	r25
    1be2:	90 ff       	sbrs	r25, 0
    1be4:	0b c0       	rjmp	.+22     	; 0x1bfc <update_octave_range+0x52>
	
		if (octave_index.vco1 == 0) {} else {octave_index.vco1--;}
    1be6:	90 91 0c 03 	lds	r25, 0x030C
    1bea:	99 23       	and	r25, r25
    1bec:	19 f0       	breq	.+6      	; 0x1bf4 <update_octave_range+0x4a>
    1bee:	91 50       	subi	r25, 0x01	; 1
    1bf0:	90 93 0c 03 	sts	0x030C, r25
		switch_states.byte1 ^= (1<<VCO1_OCTAVE_DOWN_SW);
    1bf4:	98 e0       	ldi	r25, 0x08	; 8
    1bf6:	89 27       	eor	r24, r25
    1bf8:	80 93 83 03 	sts	0x0383, r24

	}
	
	current_patch.byte_4 = 0; //clear the whole damn byte as all bits are set below
	current_patch.byte_4 |= (1<<vco1_octave[octave_index.vco1]); //set octave	
    1bfc:	80 91 0c 03 	lds	r24, 0x030C
    1c00:	e1 e2       	ldi	r30, 0x21	; 33
    1c02:	f2 e0       	ldi	r31, 0x02	; 2
    1c04:	e8 0f       	add	r30, r24
    1c06:	f1 1d       	adc	r31, r1
    1c08:	81 e0       	ldi	r24, 0x01	; 1
    1c0a:	90 e0       	ldi	r25, 0x00	; 0
    1c0c:	00 80       	ld	r0, Z
    1c0e:	02 c0       	rjmp	.+4      	; 0x1c14 <update_octave_range+0x6a>
    1c10:	88 0f       	add	r24, r24
    1c12:	99 1f       	adc	r25, r25
    1c14:	0a 94       	dec	r0
    1c16:	e2 f7       	brpl	.-8      	; 0x1c10 <update_octave_range+0x66>
    1c18:	58 2f       	mov	r21, r24
    1c1a:	80 93 05 03 	sts	0x0305, r24
	
	if ((switch_states.byte1 >> VCO2_OCTAVE_UP_SW) & 1) {
    1c1e:	90 91 83 03 	lds	r25, 0x0383
    1c22:	29 2f       	mov	r18, r25
    1c24:	26 95       	lsr	r18
    1c26:	26 95       	lsr	r18
    1c28:	20 ff       	sbrs	r18, 0
    1c2a:	0e c0       	rjmp	.+28     	; 0x1c48 <update_octave_range+0x9e>
		
		if (++octave_index.vco2 == 5) octave_index.vco2 = 4;
    1c2c:	80 91 0d 03 	lds	r24, 0x030D
    1c30:	8f 5f       	subi	r24, 0xFF	; 255
    1c32:	80 93 0d 03 	sts	0x030D, r24
    1c36:	85 30       	cpi	r24, 0x05	; 5
    1c38:	19 f4       	brne	.+6      	; 0x1c40 <update_octave_range+0x96>
    1c3a:	84 e0       	ldi	r24, 0x04	; 4
    1c3c:	80 93 0d 03 	sts	0x030D, r24
		switch_states.byte1 ^= (1<<VCO2_OCTAVE_UP_SW); //toggle switch state bit		
    1c40:	84 e0       	ldi	r24, 0x04	; 4
    1c42:	98 27       	eor	r25, r24
    1c44:	90 93 83 03 	sts	0x0383, r25
	}	
	
	if ((switch_states.byte1 >> VCO2_OCTAVE_DOWN_SW) & 1) {
    1c48:	90 91 83 03 	lds	r25, 0x0383
    1c4c:	29 2f       	mov	r18, r25
    1c4e:	26 95       	lsr	r18
    1c50:	20 ff       	sbrs	r18, 0
    1c52:	0b c0       	rjmp	.+22     	; 0x1c6a <update_octave_range+0xc0>
		
		if (octave_index.vco2 == 0) {} else {octave_index.vco2--;}
    1c54:	80 91 0d 03 	lds	r24, 0x030D
    1c58:	88 23       	and	r24, r24
    1c5a:	19 f0       	breq	.+6      	; 0x1c62 <update_octave_range+0xb8>
    1c5c:	81 50       	subi	r24, 0x01	; 1
    1c5e:	80 93 0d 03 	sts	0x030D, r24
		switch_states.byte1 ^= (1<<VCO2_OCTAVE_DOWN_SW);
    1c62:	82 e0       	ldi	r24, 0x02	; 2
    1c64:	98 27       	eor	r25, r24
    1c66:	90 93 83 03 	sts	0x0383, r25
		
	}
			
	current_patch.byte_3 &= 0b11111100; //clear bottom 2 bits for patch byte_3, which are for VCO2 2' and 4'
    1c6a:	40 91 04 03 	lds	r20, 0x0304
    1c6e:	4c 7f       	andi	r20, 0xFC	; 252
    1c70:	40 93 04 03 	sts	0x0304, r20
	
	if (octave_index.vco2 > 2) { //VCO2 2' and 4' LEDs are on LED latch 3
    1c74:	90 91 0d 03 	lds	r25, 0x030D
    1c78:	93 30       	cpi	r25, 0x03	; 3
    1c7a:	88 f0       	brcs	.+34     	; 0x1c9e <update_octave_range+0xf4>

						
		current_patch.byte_3 |= (1<<vco2_octave[octave_index.vco2]);	
    1c7c:	ec e1       	ldi	r30, 0x1C	; 28
    1c7e:	f2 e0       	ldi	r31, 0x02	; 2
    1c80:	e9 0f       	add	r30, r25
    1c82:	f1 1d       	adc	r31, r1
    1c84:	21 e0       	ldi	r18, 0x01	; 1
    1c86:	30 e0       	ldi	r19, 0x00	; 0
    1c88:	c9 01       	movw	r24, r18
    1c8a:	00 80       	ld	r0, Z
    1c8c:	02 c0       	rjmp	.+4      	; 0x1c92 <update_octave_range+0xe8>
    1c8e:	88 0f       	add	r24, r24
    1c90:	99 1f       	adc	r25, r25
    1c92:	0a 94       	dec	r0
    1c94:	e2 f7       	brpl	.-8      	; 0x1c8e <update_octave_range+0xe4>
    1c96:	84 2b       	or	r24, r20
    1c98:	80 93 04 03 	sts	0x0304, r24
    1c9c:	08 95       	ret
				
	} else { //VCO2 8', 16' and 32' are on LED latch 4
		
		current_patch.byte_4 |= (1<<vco2_octave[octave_index.vco2]); //set octave
    1c9e:	ec e1       	ldi	r30, 0x1C	; 28
    1ca0:	f2 e0       	ldi	r31, 0x02	; 2
    1ca2:	e9 0f       	add	r30, r25
    1ca4:	f1 1d       	adc	r31, r1
    1ca6:	21 e0       	ldi	r18, 0x01	; 1
    1ca8:	30 e0       	ldi	r19, 0x00	; 0
    1caa:	c9 01       	movw	r24, r18
    1cac:	00 80       	ld	r0, Z
    1cae:	02 c0       	rjmp	.+4      	; 0x1cb4 <update_octave_range+0x10a>
    1cb0:	88 0f       	add	r24, r24
    1cb2:	99 1f       	adc	r25, r25
    1cb4:	0a 94       	dec	r0
    1cb6:	e2 f7       	brpl	.-8      	; 0x1cb0 <update_octave_range+0x106>
    1cb8:	85 2b       	or	r24, r21
    1cba:	80 93 05 03 	sts	0x0305, r24
    1cbe:	08 95       	ret

00001cc0 <update_lfo_shape>:
	
}	
	
void update_lfo_shape(void) {

	if ((switch_states.byte1 >> LFO_SHAPE_SW) & 1) {
    1cc0:	80 91 83 03 	lds	r24, 0x0383
    1cc4:	88 23       	and	r24, r24
    1cc6:	64 f4       	brge	.+24     	; 0x1ce0 <update_lfo_shape+0x20>
	
		switch_states.byte1 ^= (1<<LFO_SHAPE_SW); //toggle switch state
    1cc8:	80 58       	subi	r24, 0x80	; 128
    1cca:	80 93 83 03 	sts	0x0383, r24
		if (++lfo_shape_index == 5) lfo_shape_index = 0;
    1cce:	80 91 0e 03 	lds	r24, 0x030E
    1cd2:	8f 5f       	subi	r24, 0xFF	; 255
    1cd4:	80 93 0e 03 	sts	0x030E, r24
    1cd8:	85 30       	cpi	r24, 0x05	; 5
    1cda:	11 f4       	brne	.+4      	; 0x1ce0 <update_lfo_shape+0x20>
    1cdc:	10 92 0e 03 	sts	0x030E, r1
	}
	
	current_patch.byte_2 &= 0b00001111; //clear top 4 bits
	current_patch.byte_2 |= 1 << lfo[lfo_shape_index].led_addr;
    1ce0:	e0 91 0e 03 	lds	r30, 0x030E
    1ce4:	f0 e0       	ldi	r31, 0x00	; 0
    1ce6:	ee 0f       	add	r30, r30
    1ce8:	ff 1f       	adc	r31, r31
    1cea:	ea 5d       	subi	r30, 0xDA	; 218
    1cec:	fd 4f       	sbci	r31, 0xFD	; 253
    1cee:	81 e0       	ldi	r24, 0x01	; 1
    1cf0:	90 e0       	ldi	r25, 0x00	; 0
    1cf2:	01 80       	ldd	r0, Z+1	; 0x01
    1cf4:	02 c0       	rjmp	.+4      	; 0x1cfa <update_lfo_shape+0x3a>
    1cf6:	88 0f       	add	r24, r24
    1cf8:	99 1f       	adc	r25, r25
    1cfa:	0a 94       	dec	r0
    1cfc:	e2 f7       	brpl	.-8      	; 0x1cf6 <update_lfo_shape+0x36>
	
		switch_states.byte1 ^= (1<<LFO_SHAPE_SW); //toggle switch state
		if (++lfo_shape_index == 5) lfo_shape_index = 0;
	}
	
	current_patch.byte_2 &= 0b00001111; //clear top 4 bits
    1cfe:	90 91 03 03 	lds	r25, 0x0303
    1d02:	9f 70       	andi	r25, 0x0F	; 15
	current_patch.byte_2 |= 1 << lfo[lfo_shape_index].led_addr;
    1d04:	89 2b       	or	r24, r25
    1d06:	80 93 03 03 	sts	0x0303, r24
	DATA_BUS = lfo[lfo_shape_index].waveform_addr;
    1d0a:	80 81       	ld	r24, Z
    1d0c:	82 b9       	out	0x02, r24	; 2
	LFO_LATCH_PORT |= (1<<LFO_SW_LATCH);
    1d0e:	ed ed       	ldi	r30, 0xDD	; 221
    1d10:	f0 e0       	ldi	r31, 0x00	; 0
    1d12:	80 81       	ld	r24, Z
    1d14:	80 62       	ori	r24, 0x20	; 32
    1d16:	80 83       	st	Z, r24
	LFO_LATCH_PORT &= ~(1<<LFO_SW_LATCH);
    1d18:	80 81       	ld	r24, Z
    1d1a:	8f 7d       	andi	r24, 0xDF	; 223
    1d1c:	80 83       	st	Z, r24
	
}		
    1d1e:	08 95       	ret

00001d20 <update_lfo_sync>:
	
void update_lfo_sync(void) {
	
	static uint8_t lfo_sync_mode = 0;
	
	if ((switch_states.byte1 >> LFO_SYNC_SW) & 1) {
    1d20:	80 91 83 03 	lds	r24, 0x0383
    1d24:	80 ff       	sbrs	r24, 0
    1d26:	0f c0       	rjmp	.+30     	; 0x1d46 <update_lfo_sync+0x26>
			
		switch_states.byte1 ^= (1<<LFO_SYNC_SW); //toggle switch state
    1d28:	91 e0       	ldi	r25, 0x01	; 1
    1d2a:	89 27       	eor	r24, r25
    1d2c:	80 93 83 03 	sts	0x0383, r24
		if (++lfo_sync_mode == 5) lfo_sync_mode = 0;
    1d30:	80 91 0f 03 	lds	r24, 0x030F
    1d34:	8f 5f       	subi	r24, 0xFF	; 255
    1d36:	80 93 0f 03 	sts	0x030F, r24
    1d3a:	85 30       	cpi	r24, 0x05	; 5
    1d3c:	11 f4       	brne	.+4      	; 0x1d42 <update_lfo_sync+0x22>
    1d3e:	10 92 0f 03 	sts	0x030F, r1
		lfo_clock.ppqn_counter = 0; //reset counter
    1d42:	10 92 de 03 	sts	0x03DE, r1
	}
	
	current_patch.byte_2 &= 0b11110000; //clear bottom 4 bits
    1d46:	60 91 03 03 	lds	r22, 0x0303
    1d4a:	60 7f       	andi	r22, 0xF0	; 240
    1d4c:	60 93 03 03 	sts	0x0303, r22
	if (lfo_sync_mode) current_patch.byte_2 |= (1<<(lfo_sync_mode -1)); //this allows an off state when lfo_sync_mode = 0;
    1d50:	20 91 0f 03 	lds	r18, 0x030F
    1d54:	22 23       	and	r18, r18
    1d56:	71 f0       	breq	.+28     	; 0x1d74 <update_lfo_sync+0x54>
    1d58:	30 e0       	ldi	r19, 0x00	; 0
    1d5a:	21 50       	subi	r18, 0x01	; 1
    1d5c:	30 40       	sbci	r19, 0x00	; 0
    1d5e:	41 e0       	ldi	r20, 0x01	; 1
    1d60:	50 e0       	ldi	r21, 0x00	; 0
    1d62:	ca 01       	movw	r24, r20
    1d64:	02 c0       	rjmp	.+4      	; 0x1d6a <update_lfo_sync+0x4a>
    1d66:	88 0f       	add	r24, r24
    1d68:	99 1f       	adc	r25, r25
    1d6a:	2a 95       	dec	r18
    1d6c:	e2 f7       	brpl	.-8      	; 0x1d66 <update_lfo_sync+0x46>
    1d6e:	86 2b       	or	r24, r22
    1d70:	80 93 03 03 	sts	0x0303, r24
	
	//now parse out clock divide from patch byte_2
	switch (current_patch.byte_2 & 0b00001111) {
    1d74:	80 91 03 03 	lds	r24, 0x0303
    1d78:	90 e0       	ldi	r25, 0x00	; 0
    1d7a:	8f 70       	andi	r24, 0x0F	; 15
    1d7c:	90 70       	andi	r25, 0x00	; 0
    1d7e:	82 30       	cpi	r24, 0x02	; 2
    1d80:	91 05       	cpc	r25, r1
    1d82:	89 f0       	breq	.+34     	; 0x1da6 <update_lfo_sync+0x86>
    1d84:	83 30       	cpi	r24, 0x03	; 3
    1d86:	91 05       	cpc	r25, r1
    1d88:	24 f4       	brge	.+8      	; 0x1d92 <update_lfo_sync+0x72>
    1d8a:	81 30       	cpi	r24, 0x01	; 1
    1d8c:	91 05       	cpc	r25, r1
    1d8e:	b9 f4       	brne	.+46     	; 0x1dbe <update_lfo_sync+0x9e>
    1d90:	07 c0       	rjmp	.+14     	; 0x1da0 <update_lfo_sync+0x80>
    1d92:	84 30       	cpi	r24, 0x04	; 4
    1d94:	91 05       	cpc	r25, r1
    1d96:	59 f0       	breq	.+22     	; 0x1dae <update_lfo_sync+0x8e>
    1d98:	88 30       	cpi	r24, 0x08	; 8
    1d9a:	91 05       	cpc	r25, r1
    1d9c:	81 f4       	brne	.+32     	; 0x1dbe <update_lfo_sync+0x9e>
    1d9e:	0b c0       	rjmp	.+22     	; 0x1db6 <update_lfo_sync+0x96>
		
		case 0b0001:
			lfo_clock.divider = 0; //key sync mode - need to turn midi sync off here. How?
    1da0:	10 92 dd 03 	sts	0x03DD, r1
			
			break;
    1da4:	08 95       	ret
			
		case 0b0010: //turn these case conditions into constants. #define 0b0010 DIV_24
			lfo_clock.divider = 24; //1:4
    1da6:	88 e1       	ldi	r24, 0x18	; 24
    1da8:	80 93 dd 03 	sts	0x03DD, r24
			break;
    1dac:	08 95       	ret
			
		case 0b0100:
			lfo_clock.divider = 12; //1:8
    1dae:	8c e0       	ldi	r24, 0x0C	; 12
    1db0:	80 93 dd 03 	sts	0x03DD, r24
			break;
    1db4:	08 95       	ret
			
		case 0b1000:
			lfo_clock.divider = 6; //1:16	 		
    1db6:	86 e0       	ldi	r24, 0x06	; 6
    1db8:	80 93 dd 03 	sts	0x03DD, r24
			break;
    1dbc:	08 95       	ret
		
		default:
			lfo_clock.divider = 0; //need to turn midi sync off here. How?
    1dbe:	10 92 dd 03 	sts	0x03DD, r1
    1dc2:	08 95       	ret

00001dc4 <update_arp_sync>:

void update_arp_sync(void) {
	
	static uint8_t arp_sync_mode = 0;
	
	if ((switch_states.byte1 >> ARP_SYNC_SW) & 1) {
    1dc4:	80 91 83 03 	lds	r24, 0x0383
    1dc8:	98 2f       	mov	r25, r24
    1dca:	92 95       	swap	r25
    1dcc:	96 95       	lsr	r25
    1dce:	96 95       	lsr	r25
    1dd0:	93 70       	andi	r25, 0x03	; 3
    1dd2:	90 ff       	sbrs	r25, 0
    1dd4:	6c c0       	rjmp	.+216    	; 0x1eae <update_arp_sync+0xea>
		
		switch_states.byte1 ^= (1<<ARP_SYNC_SW); //toggle switch state
    1dd6:	90 e4       	ldi	r25, 0x40	; 64
    1dd8:	89 27       	eor	r24, r25
    1dda:	80 93 83 03 	sts	0x0383, r24
		if (++arp_sync_mode == 5) arp_sync_mode = 0;
    1dde:	80 91 10 03 	lds	r24, 0x0310
    1de2:	8f 5f       	subi	r24, 0xFF	; 255
    1de4:	80 93 10 03 	sts	0x0310, r24
    1de8:	85 30       	cpi	r24, 0x05	; 5
    1dea:	11 f4       	brne	.+4      	; 0x1df0 <update_arp_sync+0x2c>
    1dec:	10 92 10 03 	sts	0x0310, r1
		//if (arp.clock_source == MIDI_CLOCK) arp.ppqn_counter = 0;//arp.ppqn_counter >> 1; //need to take into account current ppqn count and and new divider value.
		//arp.ppqn_counter = arp.ppqn_counter >> 1;//0; //try this at least to get rid of weird ppqn counter overflow that occurs when changing sync modes.
		current_patch.byte_3 &= 0b11000011; //clear middle 4 bits
    1df0:	60 91 04 03 	lds	r22, 0x0304
    1df4:	63 7c       	andi	r22, 0xC3	; 195
    1df6:	60 93 04 03 	sts	0x0304, r22
		if (arp_sync_mode) current_patch.byte_3 |= 1<<(arp_sync_mode + 1); //this allows an off state when arp_sync_mode = 0. Is that what's really needed?
    1dfa:	20 91 10 03 	lds	r18, 0x0310
    1dfe:	22 23       	and	r18, r18
    1e00:	71 f0       	breq	.+28     	; 0x1e1e <update_arp_sync+0x5a>
    1e02:	30 e0       	ldi	r19, 0x00	; 0
    1e04:	2f 5f       	subi	r18, 0xFF	; 255
    1e06:	3f 4f       	sbci	r19, 0xFF	; 255
    1e08:	41 e0       	ldi	r20, 0x01	; 1
    1e0a:	50 e0       	ldi	r21, 0x00	; 0
    1e0c:	ca 01       	movw	r24, r20
    1e0e:	02 c0       	rjmp	.+4      	; 0x1e14 <update_arp_sync+0x50>
    1e10:	88 0f       	add	r24, r24
    1e12:	99 1f       	adc	r25, r25
    1e14:	2a 95       	dec	r18
    1e16:	e2 f7       	brpl	.-8      	; 0x1e10 <update_arp_sync+0x4c>
    1e18:	86 2b       	or	r24, r22
    1e1a:	80 93 04 03 	sts	0x0304, r24
			
		switch (current_patch.byte_3 & 0b00111100) {
    1e1e:	80 91 04 03 	lds	r24, 0x0304
    1e22:	90 e0       	ldi	r25, 0x00	; 0
    1e24:	8c 73       	andi	r24, 0x3C	; 60
    1e26:	90 70       	andi	r25, 0x00	; 0
    1e28:	88 30       	cpi	r24, 0x08	; 8
    1e2a:	91 05       	cpc	r25, r1
    1e2c:	a1 f0       	breq	.+40     	; 0x1e56 <update_arp_sync+0x92>
    1e2e:	89 30       	cpi	r24, 0x09	; 9
    1e30:	91 05       	cpc	r25, r1
    1e32:	24 f4       	brge	.+8      	; 0x1e3c <update_arp_sync+0x78>
    1e34:	84 30       	cpi	r24, 0x04	; 4
    1e36:	91 05       	cpc	r25, r1
    1e38:	01 f5       	brne	.+64     	; 0x1e7a <update_arp_sync+0xb6>
    1e3a:	07 c0       	rjmp	.+14     	; 0x1e4a <update_arp_sync+0x86>
    1e3c:	80 31       	cpi	r24, 0x10	; 16
    1e3e:	91 05       	cpc	r25, r1
    1e40:	81 f0       	breq	.+32     	; 0x1e62 <update_arp_sync+0x9e>
    1e42:	80 32       	cpi	r24, 0x20	; 32
    1e44:	91 05       	cpc	r25, r1
    1e46:	c9 f4       	brne	.+50     	; 0x1e7a <update_arp_sync+0xb6>
    1e48:	12 c0       	rjmp	.+36     	; 0x1e6e <update_arp_sync+0xaa>
				
			case 0b00000100:
			system_clock.divider = arp.divider = 48; //1:2
    1e4a:	80 e3       	ldi	r24, 0x30	; 48
    1e4c:	80 93 8f 03 	sts	0x038F, r24
    1e50:	80 93 d7 03 	sts	0x03D7, r24
			break;
    1e54:	17 c0       	rjmp	.+46     	; 0x1e84 <update_arp_sync+0xc0>
				
			case 0b00001000:
			system_clock.divider = arp.divider = 24; //1:4
    1e56:	88 e1       	ldi	r24, 0x18	; 24
    1e58:	80 93 8f 03 	sts	0x038F, r24
    1e5c:	80 93 d7 03 	sts	0x03D7, r24
				
			break;
    1e60:	11 c0       	rjmp	.+34     	; 0x1e84 <update_arp_sync+0xc0>
				
			case 0b00010000:
			system_clock.divider = arp.divider = 12; //1:8
    1e62:	8c e0       	ldi	r24, 0x0C	; 12
    1e64:	80 93 8f 03 	sts	0x038F, r24
    1e68:	80 93 d7 03 	sts	0x03D7, r24
			break;
    1e6c:	0b c0       	rjmp	.+22     	; 0x1e84 <update_arp_sync+0xc0>
				
			case 0b00100000:
			system_clock.divider = arp.divider = 6; //1:16
    1e6e:	86 e0       	ldi	r24, 0x06	; 6
    1e70:	80 93 8f 03 	sts	0x038F, r24
    1e74:	80 93 d7 03 	sts	0x03D7, r24
			break;
    1e78:	05 c0       	rjmp	.+10     	; 0x1e84 <update_arp_sync+0xc0>
				
			default:
			system_clock.divider = arp.divider = 3; //1:32 - this is a hack - no LEDs lighted
    1e7a:	83 e0       	ldi	r24, 0x03	; 3
    1e7c:	80 93 8f 03 	sts	0x038F, r24
    1e80:	80 93 d7 03 	sts	0x03D7, r24
				
		}
		
		//uint32_t total_ppqn = (uint32_t)arp.song_position*6;
		arp.ppqn_counter = (arp.song_position % arp.divider);// + 1;
    1e84:	20 91 8f 03 	lds	r18, 0x038F
    1e88:	30 e0       	ldi	r19, 0x00	; 0
    1e8a:	40 e0       	ldi	r20, 0x00	; 0
    1e8c:	50 e0       	ldi	r21, 0x00	; 0
    1e8e:	60 91 90 03 	lds	r22, 0x0390
    1e92:	70 91 91 03 	lds	r23, 0x0391
    1e96:	80 91 92 03 	lds	r24, 0x0392
    1e9a:	90 91 93 03 	lds	r25, 0x0393
    1e9e:	0e 94 c9 1e 	call	0x3d92	; 0x3d92 <__udivmodsi4>
    1ea2:	60 93 8e 03 	sts	0x038E, r22
		arp.display = arp.ppqn_counter;
    1ea6:	60 93 94 03 	sts	0x0394, r22
			
		//OK, now need to modify this to maintain phase with beat clock
		system_clock.ppqn_counter = 0;	//same applies to system clock ppqn counter
    1eaa:	10 92 d8 03 	sts	0x03D8, r1
    1eae:	08 95       	ret

00001eb0 <update_arp_range>:

void update_arp_range(void) {
	
	static uint8_t arp_range = 0;
	
	if ((switch_states.byte1 == (1<<ARP_RANGE_SW)) & 1) {
    1eb0:	80 91 83 03 	lds	r24, 0x0383
    1eb4:	80 31       	cpi	r24, 0x10	; 16
    1eb6:	69 f4       	brne	.+26     	; 0x1ed2 <update_arp_range+0x22>
		
		switch_states.byte1 ^= (1<<ARP_RANGE_SW); //toggle switch bit
    1eb8:	10 92 83 03 	sts	0x0383, r1
		
		if (++arp_range == 4) arp_range = 0;
    1ebc:	80 91 11 03 	lds	r24, 0x0311
    1ec0:	8f 5f       	subi	r24, 0xFF	; 255
    1ec2:	80 93 11 03 	sts	0x0311, r24
    1ec6:	84 30       	cpi	r24, 0x04	; 4
    1ec8:	11 f4       	brne	.+4      	; 0x1ece <update_arp_range+0x1e>
    1eca:	10 92 11 03 	sts	0x0311, r1
		arp.step_position = 0; //reset step position if range changes
    1ece:	10 92 8a 03 	sts	0x038A, r1
						
	}
	
	//arp range LEDs 3 and 2 are in byte_3, bits 7 and 6, respectively. arp range LED 1 is bit 1 of byte_1
	
	current_patch.byte_1 &= ~(1<<ARP_RANGE_1); //clear arp range 1 LED
    1ed2:	80 91 02 03 	lds	r24, 0x0302
    1ed6:	8d 7f       	andi	r24, 0xFD	; 253
    1ed8:	80 93 02 03 	sts	0x0302, r24
	current_patch.byte_3 &= 0b00111111; //clear bits 6 and7, arp range 3 and 2
    1edc:	80 91 04 03 	lds	r24, 0x0304
    1ee0:	8f 73       	andi	r24, 0x3F	; 63
    1ee2:	80 93 04 03 	sts	0x0304, r24
	
	arp.range = arp_range;
    1ee6:	80 91 11 03 	lds	r24, 0x0311
    1eea:	80 93 88 03 	sts	0x0388, r24
	
	update_arp_sequence(); //update sequence with new settings
    1eee:	0e 94 a3 00 	call	0x146	; 0x146 <update_arp_sequence>
	
	switch (arp_range) { //this just updates LEDs. no struct to handle arp range yet
    1ef2:	80 91 11 03 	lds	r24, 0x0311
    1ef6:	82 30       	cpi	r24, 0x02	; 2
    1ef8:	51 f0       	breq	.+20     	; 0x1f0e <update_arp_range+0x5e>
    1efa:	83 30       	cpi	r24, 0x03	; 3
    1efc:	71 f0       	breq	.+28     	; 0x1f1a <update_arp_range+0x6a>
    1efe:	81 30       	cpi	r24, 0x01	; 1
    1f00:	89 f4       	brne	.+34     	; 0x1f24 <update_arp_range+0x74>
			
			break;
			
		case 1:
		
			current_patch.byte_1 |= (1<<ARP_RANGE_1); //set range 1 LED. LED was in the wrong way!
    1f02:	80 91 02 03 	lds	r24, 0x0302
    1f06:	82 60       	ori	r24, 0x02	; 2
    1f08:	80 93 02 03 	sts	0x0302, r24
			break;
    1f0c:	08 95       	ret
			
		case 2:
		
			current_patch.byte_3 |= (1<<ARP_RANGE_2);		
    1f0e:	80 91 04 03 	lds	r24, 0x0304
    1f12:	80 64       	ori	r24, 0x40	; 64
    1f14:	80 93 04 03 	sts	0x0304, r24
			break;
    1f18:	08 95       	ret
			
			
		case 3: 
			
			current_patch.byte_3 |= (1<<ARP_RANGE_3);
    1f1a:	80 91 04 03 	lds	r24, 0x0304
    1f1e:	80 68       	ori	r24, 0x80	; 128
    1f20:	80 93 04 03 	sts	0x0304, r24
    1f24:	08 95       	ret

00001f26 <update_arp_mode>:

void update_arp_mode(void) {

	static uint8_t arp_mode = 0;
	
	if ((switch_states.byte1 >> ARP_MODE_SW) & 1) {
    1f26:	80 91 83 03 	lds	r24, 0x0383
    1f2a:	98 2f       	mov	r25, r24
    1f2c:	92 95       	swap	r25
    1f2e:	96 95       	lsr	r25
    1f30:	97 70       	andi	r25, 0x07	; 7
    1f32:	90 ff       	sbrs	r25, 0
    1f34:	28 c0       	rjmp	.+80     	; 0x1f86 <update_arp_mode+0x60>
		
		switch_states.byte1 ^= (1<<ARP_MODE_SW); //toggle switch state
    1f36:	90 e2       	ldi	r25, 0x20	; 32
    1f38:	89 27       	eor	r24, r25
    1f3a:	80 93 83 03 	sts	0x0383, r24
		if (arp_mode == 0) {
    1f3e:	80 91 12 03 	lds	r24, 0x0312
    1f42:	88 23       	and	r24, r24
    1f44:	b9 f4       	brne	.+46     	; 0x1f74 <update_arp_mode+0x4e>
			
			update_arp_sequence(); //if arp mode is OFF it's about to be turned on, so update arp_sequence
    1f46:	0e 94 a3 00 	call	0x146	; 0x146 <update_arp_sequence>
			//arp.ppqn_counter = ((arp.song_position*6) % arp.divider);// +1; //not sure about the +1 here - may
			arp.ppqn_counter = (arp.song_position % arp.divider);// + 1;
    1f4a:	20 91 8f 03 	lds	r18, 0x038F
    1f4e:	30 e0       	ldi	r19, 0x00	; 0
    1f50:	40 e0       	ldi	r20, 0x00	; 0
    1f52:	50 e0       	ldi	r21, 0x00	; 0
    1f54:	60 91 90 03 	lds	r22, 0x0390
    1f58:	70 91 91 03 	lds	r23, 0x0391
    1f5c:	80 91 92 03 	lds	r24, 0x0392
    1f60:	90 91 93 03 	lds	r25, 0x0393
    1f64:	0e 94 c9 1e 	call	0x3d92	; 0x3d92 <__udivmodsi4>
    1f68:	60 93 8e 03 	sts	0x038E, r22
			arp.display = arp.ppqn_counter;
    1f6c:	60 93 94 03 	sts	0x0394, r22
			arp.step_position = 0;
    1f70:	10 92 8a 03 	sts	0x038A, r1
			//now need to set arp.ppqn_counter and arp.step_position based on arp.song_position
			//arp.step_position = //do something to calculate arp step position based on calculated ppqn_counter. Is there enough information to calculate this???
		
		}			
		if (++arp_mode == 5) arp_mode = 0;
    1f74:	80 91 12 03 	lds	r24, 0x0312
    1f78:	8f 5f       	subi	r24, 0xFF	; 255
    1f7a:	80 93 12 03 	sts	0x0312, r24
    1f7e:	85 30       	cpi	r24, 0x05	; 5
    1f80:	11 f4       	brne	.+4      	; 0x1f86 <update_arp_mode+0x60>
    1f82:	10 92 12 03 	sts	0x0312, r1
		
	}

	//if (arp.clock_source != MIDI_CLOCK) arp.clock_source = INTERNAL_CLOCK;	

	current_patch.byte_1 &= 0b11000011; //clear middle 4 bits UP, DOWN, RANDOM, MODE correspond to bits 6>>2
    1f86:	90 91 02 03 	lds	r25, 0x0302
    1f8a:	93 7c       	andi	r25, 0xC3	; 195
    1f8c:	90 93 02 03 	sts	0x0302, r25
	
	switch(arp_mode) {
    1f90:	80 91 12 03 	lds	r24, 0x0312
    1f94:	81 30       	cpi	r24, 0x01	; 1
    1f96:	79 f0       	breq	.+30     	; 0x1fb6 <update_arp_mode+0x90>
    1f98:	81 30       	cpi	r24, 0x01	; 1
    1f9a:	28 f0       	brcs	.+10     	; 0x1fa6 <update_arp_mode+0x80>
    1f9c:	82 30       	cpi	r24, 0x02	; 2
    1f9e:	91 f0       	breq	.+36     	; 0x1fc4 <update_arp_mode+0x9e>
    1fa0:	83 30       	cpi	r24, 0x03	; 3
    1fa2:	f1 f4       	brne	.+60     	; 0x1fe0 <update_arp_mode+0xba>
    1fa4:	16 c0       	rjmp	.+44     	; 0x1fd2 <update_arp_mode+0xac>
		
		case 0:
		
			//turn arp off
			arp.mode = OFF;
    1fa6:	10 92 96 03 	sts	0x0396, r1
			if (gate_buffer == 0) PORTF &= ~(1<<GATE); //turn gate off.
    1faa:	80 91 b4 02 	lds	r24, 0x02B4
    1fae:	88 23       	and	r24, r24
    1fb0:	e9 f4       	brne	.+58     	; 0x1fec <update_arp_mode+0xc6>
    1fb2:	89 98       	cbi	0x11, 1	; 17
    1fb4:	1b c0       	rjmp	.+54     	; 0x1fec <update_arp_mode+0xc6>
			break;
			
		case 1:
		
			current_patch.byte_1 |= (1<<ARP_MODE_UP) | (1<<ARP_ON);
    1fb6:	94 62       	ori	r25, 0x24	; 36
    1fb8:	90 93 02 03 	sts	0x0302, r25
			arp.mode = UP;
    1fbc:	81 e0       	ldi	r24, 0x01	; 1
    1fbe:	80 93 96 03 	sts	0x0396, r24
			break;	
    1fc2:	14 c0       	rjmp	.+40     	; 0x1fec <update_arp_mode+0xc6>
		
		case 2:
			current_patch.byte_1 |= (1<<ARP_MODE_DN) | (1<<ARP_ON);
    1fc4:	94 61       	ori	r25, 0x14	; 20
    1fc6:	90 93 02 03 	sts	0x0302, r25
			arp.mode = DOWN;
    1fca:	82 e0       	ldi	r24, 0x02	; 2
    1fcc:	80 93 96 03 	sts	0x0396, r24
			break;
    1fd0:	0d c0       	rjmp	.+26     	; 0x1fec <update_arp_mode+0xc6>
			
		case 3:
			current_patch.byte_1 |= (1<<ARP_MODE_UP) | (1<<ARP_MODE_DN) | (1<<ARP_ON);
    1fd2:	94 63       	ori	r25, 0x34	; 52
    1fd4:	90 93 02 03 	sts	0x0302, r25
			arp.mode = UP_DOWN;
    1fd8:	83 e0       	ldi	r24, 0x03	; 3
    1fda:	80 93 96 03 	sts	0x0396, r24
			break;
    1fde:	06 c0       	rjmp	.+12     	; 0x1fec <update_arp_mode+0xc6>
			
		default:
			current_patch.byte_1 |= (1<<ARP_MODE_RD) | (1<<ARP_ON);
    1fe0:	9c 60       	ori	r25, 0x0C	; 12
    1fe2:	90 93 02 03 	sts	0x0302, r25
			arp.mode = RANDOM;
    1fe6:	84 e0       	ldi	r24, 0x04	; 4
    1fe8:	80 93 96 03 	sts	0x0396, r24
			
					
		
	}
	
	update_arp_sequence(); //update arp sequence with new mode
    1fec:	0e 94 a3 00 	call	0x146	; 0x146 <update_arp_sequence>
	



}
    1ff0:	08 95       	ret

00001ff2 <update_patch>:
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    1ff2:	90 91 82 03 	lds	r25, 0x0382
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
							((switch_states.byte0 >> VCO1_PULSE_SW) & 1) << VCO1_PULSE |
							((switch_states.byte0 >> VCO2_SAW_SW) & 1) << VCO2_SAW |
							((switch_states.byte0 >> VCO2_TRI_SW) & 1) << VCO2_TRI |
							((switch_states.byte0 >> VCO2_PULSE_SW) & 1) << VCO2_PULSE |
							((switch_states.byte2 >> BMOD_SW) & 1) << BMOD;
    1ff6:	80 91 84 03 	lds	r24, 0x0384
    1ffa:	86 95       	lsr	r24
    1ffc:	86 95       	lsr	r24
    1ffe:	68 2f       	mov	r22, r24
    2000:	67 95       	ror	r22
    2002:	66 27       	eor	r22, r22
    2004:	67 95       	ror	r22
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    2006:	29 2f       	mov	r18, r25
    2008:	21 70       	andi	r18, 0x01	; 1
    200a:	26 2b       	or	r18, r22
    200c:	69 2f       	mov	r22, r25
    200e:	66 1f       	adc	r22, r22
    2010:	66 27       	eor	r22, r22
    2012:	66 1f       	adc	r22, r22
    2014:	66 0f       	add	r22, r22
    2016:	62 2b       	or	r22, r18
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
    2018:	29 2f       	mov	r18, r25
    201a:	26 95       	lsr	r18
    201c:	26 95       	lsr	r18
    201e:	30 e0       	ldi	r19, 0x00	; 0
    2020:	21 70       	andi	r18, 0x01	; 1
    2022:	30 70       	andi	r19, 0x00	; 0
    2024:	d9 01       	movw	r26, r18
    2026:	aa 0f       	add	r26, r26
    2028:	bb 1f       	adc	r27, r27
    202a:	aa 0f       	add	r26, r26
    202c:	bb 1f       	adc	r27, r27
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    202e:	6a 2b       	or	r22, r26
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
    2030:	a9 2f       	mov	r26, r25
    2032:	a6 95       	lsr	r26
    2034:	b0 e0       	ldi	r27, 0x00	; 0
    2036:	a1 70       	andi	r26, 0x01	; 1
    2038:	b0 70       	andi	r27, 0x00	; 0
    203a:	fd 01       	movw	r30, r26
    203c:	ee 0f       	add	r30, r30
    203e:	ff 1f       	adc	r31, r31
    2040:	ee 0f       	add	r30, r30
    2042:	ff 1f       	adc	r31, r31
    2044:	ee 0f       	add	r30, r30
    2046:	ff 1f       	adc	r31, r31
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    2048:	a6 2f       	mov	r26, r22
    204a:	ae 2b       	or	r26, r30
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
							((switch_states.byte0 >> VCO1_PULSE_SW) & 1) << VCO1_PULSE |
							((switch_states.byte0 >> VCO2_SAW_SW) & 1) << VCO2_SAW |
    204c:	e9 2f       	mov	r30, r25
    204e:	e2 95       	swap	r30
    2050:	ef 70       	andi	r30, 0x0F	; 15
    2052:	f0 e0       	ldi	r31, 0x00	; 0
    2054:	e1 70       	andi	r30, 0x01	; 1
    2056:	f0 70       	andi	r31, 0x00	; 0
    2058:	bf 01       	movw	r22, r30
    205a:	62 95       	swap	r22
    205c:	72 95       	swap	r23
    205e:	70 7f       	andi	r23, 0xF0	; 240
    2060:	76 27       	eor	r23, r22
    2062:	60 7f       	andi	r22, 0xF0	; 240
    2064:	76 27       	eor	r23, r22
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    2066:	ea 2f       	mov	r30, r26
    2068:	e6 2b       	or	r30, r22
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
							((switch_states.byte0 >> VCO1_PULSE_SW) & 1) << VCO1_PULSE |
							((switch_states.byte0 >> VCO2_SAW_SW) & 1) << VCO2_SAW |
							((switch_states.byte0 >> VCO2_TRI_SW) & 1) << VCO2_TRI |
    206a:	69 2f       	mov	r22, r25
    206c:	62 95       	swap	r22
    206e:	66 95       	lsr	r22
    2070:	67 70       	andi	r22, 0x07	; 7
    2072:	70 e0       	ldi	r23, 0x00	; 0
    2074:	61 70       	andi	r22, 0x01	; 1
    2076:	70 70       	andi	r23, 0x00	; 0
    2078:	ab 01       	movw	r20, r22
    207a:	44 0f       	add	r20, r20
    207c:	55 1f       	adc	r21, r21
    207e:	42 95       	swap	r20
    2080:	52 95       	swap	r21
    2082:	50 7f       	andi	r21, 0xF0	; 240
    2084:	54 27       	eor	r21, r20
    2086:	40 7f       	andi	r20, 0xF0	; 240
    2088:	54 27       	eor	r21, r20
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    208a:	6e 2f       	mov	r22, r30
    208c:	64 2b       	or	r22, r20
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
							((switch_states.byte0 >> VCO1_PULSE_SW) & 1) << VCO1_PULSE |
							((switch_states.byte0 >> VCO2_SAW_SW) & 1) << VCO2_SAW |
							((switch_states.byte0 >> VCO2_TRI_SW) & 1) << VCO2_TRI |
							((switch_states.byte0 >> VCO2_PULSE_SW) & 1) << VCO2_PULSE |
    208e:	49 2f       	mov	r20, r25
    2090:	42 95       	swap	r20
    2092:	46 95       	lsr	r20
    2094:	46 95       	lsr	r20
    2096:	43 70       	andi	r20, 0x03	; 3
    2098:	50 e0       	ldi	r21, 0x00	; 0
    209a:	41 70       	andi	r20, 0x01	; 1
    209c:	50 70       	andi	r21, 0x00	; 0
    209e:	9a 01       	movw	r18, r20
    20a0:	00 24       	eor	r0, r0
    20a2:	36 95       	lsr	r19
    20a4:	27 95       	ror	r18
    20a6:	07 94       	ror	r0
    20a8:	36 95       	lsr	r19
    20aa:	27 95       	ror	r18
    20ac:	07 94       	ror	r0
    20ae:	32 2f       	mov	r19, r18
    20b0:	20 2d       	mov	r18, r0
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    20b2:	26 2b       	or	r18, r22
    20b4:	20 93 06 03 	sts	0x0306, r18
			
	//update analog switch latch:
	//need to incorporate BMOD_LATCH_BIT switch state into data byte sent to analog switch latch
	//3rd switch bit is VCO1_OCTAVE_UP_SW state, which isn't used by analog switch latch
	uint8_t analog_sw_byte = switch_states.byte0;
	uint8_t BMOD_SW_ON = (switch_states.byte2 >> BMOD_SW) & 1;
    20b8:	81 70       	andi	r24, 0x01	; 1
	analog_sw_byte ^= (-BMOD_SW_ON ^ analog_sw_byte) & (1<<3);//set third bit dependent on BMOD switch state
    20ba:	81 95       	neg	r24
    20bc:	89 27       	eor	r24, r25
    20be:	88 70       	andi	r24, 0x08	; 8
	update_analog_switch_latch(analog_sw_byte);
    20c0:	89 27       	eor	r24, r25
    20c2:	0e 94 60 17 	call	0x2ec0	; 0x2ec0 <update_analog_switch_latch>
					
	//set EG2 INV bit. This changes the nth bit to x from: http://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit-in-c-c
	//need to make sure this doesn't interfere with anything else on this port
	uint8_t EG2_INV_ON = (switch_states.byte2 >> EG2_INV_SW) & 1;	
	EG2_POL_PORT ^= (-EG2_INV_ON ^ EG2_POL_PORT) & (1<<EG2_POL);
    20c6:	ed ed       	ldi	r30, 0xDD	; 221
    20c8:	f0 e0       	ldi	r31, 0x00	; 0
    20ca:	20 81       	ld	r18, Z
	analog_sw_byte ^= (-BMOD_SW_ON ^ analog_sw_byte) & (1<<3);//set third bit dependent on BMOD switch state
	update_analog_switch_latch(analog_sw_byte);
					
	//set EG2 INV bit. This changes the nth bit to x from: http://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit-in-c-c
	//need to make sure this doesn't interfere with anything else on this port
	uint8_t EG2_INV_ON = (switch_states.byte2 >> EG2_INV_SW) & 1;	
    20cc:	90 91 84 03 	lds	r25, 0x0384
    20d0:	96 95       	lsr	r25
    20d2:	96 95       	lsr	r25
    20d4:	96 95       	lsr	r25
    20d6:	91 70       	andi	r25, 0x01	; 1
	EG2_POL_PORT ^= (-EG2_INV_ON ^ EG2_POL_PORT) & (1<<EG2_POL);
    20d8:	91 95       	neg	r25
    20da:	80 81       	ld	r24, Z
    20dc:	89 27       	eor	r24, r25
    20de:	80 71       	andi	r24, 0x10	; 16
    20e0:	82 27       	eor	r24, r18
    20e2:	80 83       	st	Z, r24
	current_patch.byte_1 ^= (-EG2_INV_ON ^ current_patch.byte_1) & (1 << EG2_INV); //don't forget to set it in patch or it won't be saved!
    20e4:	e2 e0       	ldi	r30, 0x02	; 2
    20e6:	f3 e0       	ldi	r31, 0x03	; 3
    20e8:	80 81       	ld	r24, Z
    20ea:	98 27       	eor	r25, r24
    20ec:	91 70       	andi	r25, 0x01	; 1
    20ee:	89 27       	eor	r24, r25
    20f0:	80 83       	st	Z, r24
	
	//parse octave switch data
	update_octave_range();
    20f2:	0e 94 d5 0d 	call	0x1baa	; 0x1baa <update_octave_range>
	
	//parse LFO data
	update_lfo_shape();
    20f6:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <update_lfo_shape>
	
	//parse LFO sync data
	update_lfo_sync();
    20fa:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <update_lfo_sync>

	//update arp settings
	update_arp_sync();
    20fe:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <update_arp_sync>
	update_arp_range();
    2102:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <update_arp_range>
	update_arp_mode();
    2106:	0e 94 93 0f 	call	0x1f26	; 0x1f26 <update_arp_mode>
	//update_patch_programmer();		
				

		
	
}
    210a:	08 95       	ret

0000210c <update_patch_programmer>:





void update_patch_programmer(void) { //maybe best to use a switch/case statement here instead of a series of if/elses?
    210c:	cf 93       	push	r28
    210e:	df 93       	push	r29
	
	if (current_patch.mode == CAL) //temporary tune button hack by pressing and holding PROG DOWN switch
    2110:	90 91 0b 03 	lds	r25, 0x030B
    2114:	95 30       	cpi	r25, 0x05	; 5
    2116:	01 f5       	brne	.+64     	; 0x2158 <update_patch_programmer+0x4c>
	{
		
		
		//TURN OFF LFO OUTPUT
		DATA_BUS = 0b00000111; //turn off LFO waveform
    2118:	87 e0       	ldi	r24, 0x07	; 7
    211a:	82 b9       	out	0x02, r24	; 2
		LFO_LATCH_PORT |= (1<<LFO_SW_LATCH);
    211c:	cd ed       	ldi	r28, 0xDD	; 221
    211e:	d0 e0       	ldi	r29, 0x00	; 0
    2120:	88 81       	ld	r24, Y
    2122:	80 62       	ori	r24, 0x20	; 32
    2124:	88 83       	st	Y, r24
		LFO_LATCH_PORT &= ~(1<<LFO_SW_LATCH);
    2126:	88 81       	ld	r24, Y
    2128:	8f 7d       	andi	r24, 0xDF	; 223
    212a:	88 83       	st	Y, r24
		DATA_BUS = 0;
    212c:	12 b8       	out	0x02, r1	; 2
		
		tune();
    212e:	0e 94 03 17 	call	0x2e06	; 0x2e06 <tune>
		
		DATA_BUS = LFO_TRI_ADDR;
    2132:	12 b8       	out	0x02, r1	; 2
		LFO_LATCH_PORT |= (1<<LFO_SW_LATCH);
    2134:	88 81       	ld	r24, Y
    2136:	80 62       	ori	r24, 0x20	; 32
    2138:	88 83       	st	Y, r24
		LFO_LATCH_PORT &= ~(1<<LFO_SW_LATCH);
    213a:	88 81       	ld	r24, Y
    213c:	8f 7d       	andi	r24, 0xDF	; 223
    213e:	88 83       	st	Y, r24
		DATA_BUS = 0;
    2140:	12 b8       	out	0x02, r1	; 2
		current_patch.byte_2 &= 0b00001111; //clear top 4 bits
    2142:	80 91 03 03 	lds	r24, 0x0303
    2146:	8f 70       	andi	r24, 0x0F	; 15
		current_patch.byte_2 |= (1<<LFO_TRI);
    2148:	80 68       	ori	r24, 0x80	; 128
    214a:	80 93 03 03 	sts	0x0303, r24
		
		setup_system_clock(); //restore system clock settings
    214e:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <setup_system_clock>

		current_patch.mode = MEMORY;
    2152:	10 92 0b 03 	sts	0x030B, r1
		
		return;
    2156:	63 c0       	rjmp	.+198    	; 0x221e <update_patch_programmer+0x112>
		
	}
	

	
	if ((switch_states.byte2>> PROG_UP_SW) & 1) {
    2158:	80 91 84 03 	lds	r24, 0x0384
    215c:	28 2f       	mov	r18, r24
    215e:	22 95       	swap	r18
    2160:	26 95       	lsr	r18
    2162:	26 95       	lsr	r18
    2164:	23 70       	andi	r18, 0x03	; 3
    2166:	20 ff       	sbrs	r18, 0
    2168:	15 c0       	rjmp	.+42     	; 0x2194 <update_patch_programmer+0x88>
		
		switch_states.byte2 ^= (1<<PROG_UP_SW); //toggle switch state bit
    216a:	20 e4       	ldi	r18, 0x40	; 64
    216c:	82 27       	eor	r24, r18
    216e:	80 93 84 03 	sts	0x0384, r24
		
		if (++current_patch.number == NUM_PATCHES + 1) {			
    2172:	80 91 07 03 	lds	r24, 0x0307
    2176:	8f 5f       	subi	r24, 0xFF	; 255
    2178:	80 93 07 03 	sts	0x0307, r24
    217c:	85 32       	cpi	r24, 0x25	; 37
    217e:	21 f4       	brne	.+8      	; 0x2188 <update_patch_programmer+0x7c>
			
			current_patch.number = NUM_PATCHES; //max patch number
    2180:	84 e2       	ldi	r24, 0x24	; 36
    2182:	80 93 07 03 	sts	0x0307, r24
    2186:	06 c0       	rjmp	.+12     	; 0x2194 <update_patch_programmer+0x88>
		
					
		} else if (current_patch.mode != WRITE) { //load next patch if not in WRITE mode
    2188:	93 30       	cpi	r25, 0x03	; 3
    218a:	21 f0       	breq	.+8      	; 0x2194 <update_patch_programmer+0x88>
			
			load_patch(current_patch.number);
    218c:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <load_patch>
			update_patch();
    2190:	0e 94 f9 0f 	call	0x1ff2	; 0x1ff2 <update_patch>
			
		}		
		
	}
	
	if ((switch_states.byte2 >> PROG_DOWN_SW) & 1) {
    2194:	80 91 84 03 	lds	r24, 0x0384
    2198:	98 2f       	mov	r25, r24
    219a:	92 95       	swap	r25
    219c:	96 95       	lsr	r25
    219e:	97 70       	andi	r25, 0x07	; 7
    21a0:	90 ff       	sbrs	r25, 0
    21a2:	15 c0       	rjmp	.+42     	; 0x21ce <update_patch_programmer+0xc2>
	
		switch_states.byte2 ^= (1<<PROG_DOWN_SW); //toggle switch state bit
    21a4:	90 e2       	ldi	r25, 0x20	; 32
    21a6:	89 27       	eor	r24, r25
    21a8:	80 93 84 03 	sts	0x0384, r24

		if (current_patch.number == 1) {} else {current_patch.number--;}
    21ac:	80 91 07 03 	lds	r24, 0x0307
    21b0:	81 30       	cpi	r24, 0x01	; 1
    21b2:	19 f0       	breq	.+6      	; 0x21ba <update_patch_programmer+0xae>
    21b4:	81 50       	subi	r24, 0x01	; 1
    21b6:	80 93 07 03 	sts	0x0307, r24
		
		if (current_patch.mode != WRITE) {
    21ba:	80 91 0b 03 	lds	r24, 0x030B
    21be:	83 30       	cpi	r24, 0x03	; 3
    21c0:	31 f0       	breq	.+12     	; 0x21ce <update_patch_programmer+0xc2>
			
			load_patch(current_patch.number); 
    21c2:	80 91 07 03 	lds	r24, 0x0307
    21c6:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <load_patch>
			update_patch();
    21ca:	0e 94 f9 0f 	call	0x1ff2	; 0x1ff2 <update_patch>
		}			
	}
	
	
	if ((switch_states.byte2 >> PROG_WRITE_SW) & 1) {
    21ce:	80 91 84 03 	lds	r24, 0x0384
    21d2:	98 2f       	mov	r25, r24
    21d4:	92 95       	swap	r25
    21d6:	9f 70       	andi	r25, 0x0F	; 15
    21d8:	90 ff       	sbrs	r25, 0
    21da:	15 c0       	rjmp	.+42     	; 0x2206 <update_patch_programmer+0xfa>
		
		switch_states.byte2 ^= (1<<PROG_WRITE_SW);
    21dc:	90 e1       	ldi	r25, 0x10	; 16
    21de:	89 27       	eor	r24, r25
    21e0:	80 93 84 03 	sts	0x0384, r24
		if (current_patch.mode != WRITE) {
    21e4:	90 91 0b 03 	lds	r25, 0x030B
    21e8:	93 30       	cpi	r25, 0x03	; 3
    21ea:	49 f0       	breq	.+18     	; 0x21fe <update_patch_programmer+0xf2>
			switch_states.byte2 &= ~(1<< PROG_MANUAL_SW); //turn off manual mode
    21ec:	8f 77       	andi	r24, 0x7F	; 127
    21ee:	80 93 84 03 	sts	0x0384, r24
			current_patch.mode = WRITE;
    21f2:	83 e0       	ldi	r24, 0x03	; 3
    21f4:	80 93 0b 03 	sts	0x030B, r24
			lock_pots();
    21f8:	0e 94 c7 08 	call	0x118e	; 0x118e <lock_pots>
    21fc:	04 c0       	rjmp	.+8      	; 0x2206 <update_patch_programmer+0xfa>
			
			
		} else {
			
			save_patch(current_patch.number); //write the patch
    21fe:	80 91 07 03 	lds	r24, 0x0307
    2202:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <save_patch>
		//save_patch(current_patch.number);
		
		
	}
	
	if (((switch_states.byte2 >> PROG_MANUAL_SW) & 1)) {
    2206:	80 91 84 03 	lds	r24, 0x0384
    220a:	88 23       	and	r24, r24
    220c:	44 f4       	brge	.+16     	; 0x221e <update_patch_programmer+0x112>
			
		switch_states.byte2 |= (1<< PROG_MANUAL_SW);
    220e:	80 68       	ori	r24, 0x80	; 128
    2210:	80 93 84 03 	sts	0x0384, r24
		current_patch.mode = MANUAL;
    2214:	81 e0       	ldi	r24, 0x01	; 1
    2216:	80 93 0b 03 	sts	0x030B, r24
		unlock_pots();
    221a:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <unlock_pots>
	}
	//value_to_display = current_patch.number;	
	//value_to_display = vco1_init_cv>>1;
	
	
}	
    221e:	df 91       	pop	r29
    2220:	cf 91       	pop	r28
    2222:	08 95       	ret

00002224 <initialize_voice_for_tuning>:
	

void initialize_voice_for_tuning(void) { //this function sets all CVs required for oscillator tuning
	

	set_control_voltage(&volume_cv, MIN); //turn volume all the way down
    2224:	88 ed       	ldi	r24, 0xD8	; 216
    2226:	91 e0       	ldi	r25, 0x01	; 1
    2228:	60 e0       	ldi	r22, 0x00	; 0
    222a:	70 e0       	ldi	r23, 0x00	; 0
    222c:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off all pitch modulation
	set_control_voltage(&pitch_lfo_cv, MIN);
    2230:	81 ee       	ldi	r24, 0xE1	; 225
    2232:	91 e0       	ldi	r25, 0x01	; 1
    2234:	60 e0       	ldi	r22, 0x00	; 0
    2236:	70 e0       	ldi	r23, 0x00	; 0
    2238:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pitch_eg2_cv, MIN);
    223c:	82 ee       	ldi	r24, 0xE2	; 226
    223e:	91 e0       	ldi	r25, 0x01	; 1
    2240:	60 e0       	ldi	r22, 0x00	; 0
    2242:	70 e0       	ldi	r23, 0x00	; 0
    2244:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pitch_vco2_cv, MIN);
    2248:	87 eb       	ldi	r24, 0xB7	; 183
    224a:	92 e0       	ldi	r25, 0x02	; 2
    224c:	60 e0       	ldi	r22, 0x00	; 0
    224e:	70 e0       	ldi	r23, 0x00	; 0
    2250:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off glide
	set_control_voltage(&glide_cv, MIN);
    2254:	8a ed       	ldi	r24, 0xDA	; 218
    2256:	91 e0       	ldi	r25, 0x01	; 1
    2258:	60 e0       	ldi	r22, 0x00	; 0
    225a:	70 e0       	ldi	r23, 0x00	; 0
    225c:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off all pulse width modulation
	set_control_voltage(&pwm_eg2_cv, MIN);
    2260:	8f ed       	ldi	r24, 0xDF	; 223
    2262:	91 e0       	ldi	r25, 0x01	; 1
    2264:	60 e0       	ldi	r22, 0x00	; 0
    2266:	70 e0       	ldi	r23, 0x00	; 0
    2268:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pwm_lfo_cv, MIN);
    226c:	80 ee       	ldi	r24, 0xE0	; 224
    226e:	91 e0       	ldi	r25, 0x01	; 1
    2270:	60 e0       	ldi	r22, 0x00	; 0
    2272:	70 e0       	ldi	r23, 0x00	; 0
    2274:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off all filter modulation
	set_control_voltage(&fil_lfo_cv, MIN);
    2278:	81 ed       	ldi	r24, 0xD1	; 209
    227a:	91 e0       	ldi	r25, 0x01	; 1
    227c:	60 e0       	ldi	r22, 0x00	; 0
    227e:	70 e0       	ldi	r23, 0x00	; 0
    2280:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&fil_eg2_cv, MIN);
    2284:	86 ed       	ldi	r24, 0xD6	; 214
    2286:	91 e0       	ldi	r25, 0x01	; 1
    2288:	60 e0       	ldi	r22, 0x00	; 0
    228a:	70 e0       	ldi	r23, 0x00	; 0
    228c:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&fil_vco2_cv, MIN);
    2290:	82 ed       	ldi	r24, 0xD2	; 210
    2292:	91 e0       	ldi	r25, 0x01	; 1
    2294:	60 e0       	ldi	r22, 0x00	; 0
    2296:	70 e0       	ldi	r23, 0x00	; 0
    2298:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&key_track_cv, MIN);
    229c:	83 ed       	ldi	r24, 0xD3	; 211
    229e:	91 e0       	ldi	r25, 0x01	; 1
    22a0:	60 e0       	ldi	r22, 0x00	; 0
    22a2:	70 e0       	ldi	r23, 0x00	; 0
    22a4:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//open filter with no resonance
	set_control_voltage(&cutoff_cv, MAX);
    22a8:	84 ed       	ldi	r24, 0xD4	; 212
    22aa:	91 e0       	ldi	r25, 0x01	; 1
    22ac:	6f ef       	ldi	r22, 0xFF	; 255
    22ae:	7f e3       	ldi	r23, 0x3F	; 63
    22b0:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&res_cv, MIN);
    22b4:	85 ed       	ldi	r24, 0xD5	; 213
    22b6:	91 e0       	ldi	r25, 0x01	; 1
    22b8:	60 e0       	ldi	r22, 0x00	; 0
    22ba:	70 e0       	ldi	r23, 0x00	; 0
    22bc:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off VCA LFO modulation
	set_control_voltage(&amp_lfo_cv, MIN);
    22c0:	89 ed       	ldi	r24, 0xD9	; 217
    22c2:	91 e0       	ldi	r25, 0x01	; 1
    22c4:	60 e0       	ldi	r22, 0x00	; 0
    22c6:	70 e0       	ldi	r23, 0x00	; 0
    22c8:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//initialize VCA envelope
	set_control_voltage(&attack_1_cv, MIN);
    22cc:	8e ec       	ldi	r24, 0xCE	; 206
    22ce:	91 e0       	ldi	r25, 0x01	; 1
    22d0:	60 e0       	ldi	r22, 0x00	; 0
    22d2:	70 e0       	ldi	r23, 0x00	; 0
    22d4:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&decay_1_cv, MIN);
    22d8:	8c ec       	ldi	r24, 0xCC	; 204
    22da:	91 e0       	ldi	r25, 0x01	; 1
    22dc:	60 e0       	ldi	r22, 0x00	; 0
    22de:	70 e0       	ldi	r23, 0x00	; 0
    22e0:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&sustain_1_cv, MAX);
    22e4:	8a ec       	ldi	r24, 0xCA	; 202
    22e6:	91 e0       	ldi	r25, 0x01	; 1
    22e8:	6f ef       	ldi	r22, 0xFF	; 255
    22ea:	7f e3       	ldi	r23, 0x3F	; 63
    22ec:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&release_1_cv, MIN);
    22f0:	88 ec       	ldi	r24, 0xC8	; 200
    22f2:	91 e0       	ldi	r25, 0x01	; 1
    22f4:	60 e0       	ldi	r22, 0x00	; 0
    22f6:	70 e0       	ldi	r23, 0x00	; 0
    22f8:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off noise
	set_control_voltage(&noise_mix_cv, MIN);
    22fc:	80 ed       	ldi	r24, 0xD0	; 208
    22fe:	91 e0       	ldi	r25, 0x01	; 1
    2300:	60 e0       	ldi	r22, 0x00	; 0
    2302:	70 e0       	ldi	r23, 0x00	; 0
    2304:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&vco1_mix_cv, MIN);
    2308:	83 ee       	ldi	r24, 0xE3	; 227
    230a:	91 e0       	ldi	r25, 0x01	; 1
    230c:	60 e0       	ldi	r22, 0x00	; 0
    230e:	70 e0       	ldi	r23, 0x00	; 0
    2310:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&vco2_mix_cv, MIN);
    2314:	84 ee       	ldi	r24, 0xE4	; 228
    2316:	91 e0       	ldi	r25, 0x01	; 1
    2318:	60 e0       	ldi	r22, 0x00	; 0
    231a:	70 e0       	ldi	r23, 0x00	; 0
    231c:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
}	
    2320:	08 95       	ret

00002322 <set_vco_init_cv>:
	
uint16_t set_vco_init_cv(uint8_t vco, uint16_t base_reference) { 
    2322:	2f 92       	push	r2
    2324:	3f 92       	push	r3
    2326:	4f 92       	push	r4
    2328:	5f 92       	push	r5
    232a:	6f 92       	push	r6
    232c:	7f 92       	push	r7
    232e:	8f 92       	push	r8
    2330:	9f 92       	push	r9
    2332:	af 92       	push	r10
    2334:	bf 92       	push	r11
    2336:	cf 92       	push	r12
    2338:	df 92       	push	r13
    233a:	ef 92       	push	r14
    233c:	ff 92       	push	r15
    233e:	0f 93       	push	r16
    2340:	1f 93       	push	r17
    2342:	cf 93       	push	r28
    2344:	df 93       	push	r29
    2346:	cd b7       	in	r28, 0x3d	; 61
    2348:	de b7       	in	r29, 0x3e	; 62
    234a:	2c 97       	sbiw	r28, 0x0c	; 12
    234c:	0f b6       	in	r0, 0x3f	; 63
    234e:	f8 94       	cli
    2350:	de bf       	out	0x3e, r29	; 62
    2352:	0f be       	out	0x3f, r0	; 63
    2354:	cd bf       	out	0x3d, r28	; 61
    2356:	18 2f       	mov	r17, r24
    2358:	78 87       	std	Y+8, r23	; 0x08
    235a:	6f 83       	std	Y+7, r22	; 0x07

	uint16_t init_cv = 0;
	timer1_clock |= (1<<CS11) | (1<<CS10);
    235c:	80 91 7f 03 	lds	r24, 0x037F
    2360:	83 60       	ori	r24, 0x03	; 3
    2362:	80 93 7f 03 	sts	0x037F, r24
	 
	//TO DO: disable UART so MIDI data doesn't interrupt tuning
	
	//setup control voltages	
	initialize_voice_for_tuning();
    2366:	0e 94 12 11 	call	0x2224	; 0x2224 <initialize_voice_for_tuning>
	struct control_voltage *vco_init_cv;
	struct control_voltage *vco_mix_cv;
	struct control_voltage *vco_pw_cv;
	struct control_voltage *vco_pitch_cv;

	count_finished = FALSE;
    236a:	10 92 7e 03 	sts	0x037E, r1
	
	if (vco == VCO1) { //turn on VCO1 pulse
    236e:	1f 30       	cpi	r17, 0x0F	; 15
    2370:	e9 f4       	brne	.+58     	; 0x23ac <set_vco_init_cv+0x8a>
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
		vco_mix_cv = &vco1_mix_cv;
		vco_pw_cv = &vco1_pw_cv;
		vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
    2372:	0f 2e       	mov	r0, r31
    2374:	f6 ee       	ldi	r31, 0xE6	; 230
    2376:	4f 2e       	mov	r4, r31
    2378:	f1 e0       	ldi	r31, 0x01	; 1
    237a:	5f 2e       	mov	r5, r31
    237c:	f0 2d       	mov	r31, r0
	if (vco == VCO1) { //turn on VCO1 pulse
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
		vco_mix_cv = &vco1_mix_cv;
		vco_pw_cv = &vco1_pw_cv;
    237e:	0f 2e       	mov	r0, r31
    2380:	fe ed       	ldi	r31, 0xDE	; 222
    2382:	2f 2e       	mov	r2, r31
    2384:	f1 e0       	ldi	r31, 0x01	; 1
    2386:	3f 2e       	mov	r3, r31
    2388:	f0 2d       	mov	r31, r0
	
	if (vco == VCO1) { //turn on VCO1 pulse
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
		vco_mix_cv = &vco1_mix_cv;
    238a:	23 ee       	ldi	r18, 0xE3	; 227
    238c:	31 e0       	ldi	r19, 0x01	; 1
    238e:	3a 83       	std	Y+2, r19	; 0x02
    2390:	29 83       	std	Y+1, r18	; 0x01
	count_finished = FALSE;
	
	if (vco == VCO1) { //turn on VCO1 pulse
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
    2392:	0f 2e       	mov	r0, r31
    2394:	fc ed       	ldi	r31, 0xDC	; 220
    2396:	ef 2e       	mov	r14, r31
    2398:	f1 e0       	ldi	r31, 0x01	; 1
    239a:	ff 2e       	mov	r15, r31
    239c:	f0 2d       	mov	r31, r0
		vco_mix_cv = &vco1_mix_cv;
		vco_pw_cv = &vco1_pw_cv;
		vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
		reference_count = base_reference;//38222; //make this an argument passed to function
		vco_display_num = 1;
		eeprom_addr = &vco1_init_cv_eeprom;
    239e:	82 e7       	ldi	r24, 0x72	; 114
    23a0:	96 e0       	ldi	r25, 0x06	; 6
    23a2:	9a 87       	std	Y+10, r25	; 0x0a
    23a4:	89 87       	std	Y+9, r24	; 0x09

	count_finished = FALSE;
	
	if (vco == VCO1) { //turn on VCO1 pulse
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
    23a6:	81 e0       	ldi	r24, 0x01	; 1
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
		vco_mix_cv = &vco1_mix_cv;
		vco_pw_cv = &vco1_pw_cv;
		vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
		reference_count = base_reference;//38222; //make this an argument passed to function
		vco_display_num = 1;
    23a8:	11 e0       	ldi	r17, 0x01	; 1
    23aa:	1c c0       	rjmp	.+56     	; 0x23e4 <set_vco_init_cv+0xc2>
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
		vco_mix_cv = &vco2_mix_cv;
		vco_pw_cv = &vco2_pw_cv;
		vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
    23ac:	0f 2e       	mov	r0, r31
    23ae:	f5 ee       	ldi	r31, 0xE5	; 229
    23b0:	4f 2e       	mov	r4, r31
    23b2:	f1 e0       	ldi	r31, 0x01	; 1
    23b4:	5f 2e       	mov	r5, r31
    23b6:	f0 2d       	mov	r31, r0
	} else { //turn on VCO2 pulse	
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
		vco_mix_cv = &vco2_mix_cv;
		vco_pw_cv = &vco2_pw_cv;
    23b8:	0f 2e       	mov	r0, r31
    23ba:	f7 ed       	ldi	r31, 0xD7	; 215
    23bc:	2f 2e       	mov	r2, r31
    23be:	f1 e0       	ldi	r31, 0x01	; 1
    23c0:	3f 2e       	mov	r3, r31
    23c2:	f0 2d       	mov	r31, r0
		
	} else { //turn on VCO2 pulse	
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
		vco_mix_cv = &vco2_mix_cv;
    23c4:	e4 ee       	ldi	r30, 0xE4	; 228
    23c6:	f1 e0       	ldi	r31, 0x01	; 1
    23c8:	fa 83       	std	Y+2, r31	; 0x02
    23ca:	e9 83       	std	Y+1, r30	; 0x01
		eeprom_addr = &vco1_init_cv_eeprom;
		
	} else { //turn on VCO2 pulse	
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
    23cc:	0f 2e       	mov	r0, r31
    23ce:	fd ed       	ldi	r31, 0xDD	; 221
    23d0:	ef 2e       	mov	r14, r31
    23d2:	f1 e0       	ldi	r31, 0x01	; 1
    23d4:	ff 2e       	mov	r15, r31
    23d6:	f0 2d       	mov	r31, r0
		vco_mix_cv = &vco2_mix_cv;
		vco_pw_cv = &vco2_pw_cv;
		vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
		reference_count = base_reference;
		vco_display_num = 2;
		eeprom_addr = &vco2_init_cv_eeprom;
    23d8:	20 e7       	ldi	r18, 0x70	; 112
    23da:	36 e0       	ldi	r19, 0x06	; 6
    23dc:	3a 87       	std	Y+10, r19	; 0x0a
    23de:	29 87       	std	Y+9, r18	; 0x09
		vco_display_num = 1;
		eeprom_addr = &vco1_init_cv_eeprom;
		
	} else { //turn on VCO2 pulse	
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
    23e0:	80 e4       	ldi	r24, 0x40	; 64
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
		vco_mix_cv = &vco2_mix_cv;
		vco_pw_cv = &vco2_pw_cv;
		vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
		reference_count = base_reference;
		vco_display_num = 2;
    23e2:	12 e0       	ldi	r17, 0x02	; 2
		eeprom_addr = &vco2_init_cv_eeprom;
	}
	
	//latch switch data
	DATA_BUS = switch_byte;
    23e4:	82 b9       	out	0x02, r24	; 2
	VCO_SW_LATCH_PORT |= (1<<VCO_SW_LATCH);
    23e6:	ed ed       	ldi	r30, 0xDD	; 221
    23e8:	f0 e0       	ldi	r31, 0x00	; 0
    23ea:	80 81       	ld	r24, Z
    23ec:	80 64       	ori	r24, 0x40	; 64
    23ee:	80 83       	st	Z, r24
	//_delay_us(1); //why is this delay here????
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    23f0:	80 81       	ld	r24, Z
    23f2:	8f 7b       	andi	r24, 0xBF	; 191
    23f4:	80 83       	st	Z, r24
	DATA_BUS = 0;
    23f6:	12 b8       	out	0x02, r1	; 2

	PORTF |= (1<<GATE); //turn gate on
    23f8:	89 9a       	sbi	0x11, 1	; 17
	
	//set up timer/counter0 to be clocked by T0 input
	
	TCCR0A |= (1<<CS02) | (1<<CS01) | (1<<CS00) | (1<<WGM01); //clocked by external T0 pin, rising edge + clear timer on compare match
    23fa:	84 b5       	in	r24, 0x24	; 36
    23fc:	8f 60       	ori	r24, 0x0F	; 15
    23fe:	84 bd       	out	0x24, r24	; 36
	OCR0A = 1; //output compare register - set to number of periods to be counted. OCR0A needs to be set to (periods_to_be_counted - 1)
    2400:	81 e0       	ldi	r24, 0x01	; 1
    2402:	87 bd       	out	0x27, r24	; 39
	//set OCR0A to 1 here means first ISR interrupt will occur after 2 periods, it is then set to 0 to count only single periods
	//for reasons I don't understand yet, starting with OCR0A set to 0 results in a multi-second delay before first compare match ISR is called ***ACTUALLY, THIS MAY BE RELATED TO LEAVING Timer0 RUNNING. COULD TRY TO SET OCR0A TO 0 NOW and SEE IF IT WORKS
	TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt	
    2404:	ee e6       	ldi	r30, 0x6E	; 110
    2406:	f0 e0       	ldi	r31, 0x00	; 0
    2408:	90 81       	ld	r25, Z
    240a:	92 60       	ori	r25, 0x02	; 2
    240c:	90 83       	st	Z, r25
	period = 1; //only counting 1 period 
    240e:	80 93 80 03 	sts	0x0380, r24
	for (int dac_bit = 13; dac_bit >= 0; dac_bit--) {
    2412:	8d e0       	ldi	r24, 0x0D	; 13
    2414:	90 e0       	ldi	r25, 0x00	; 0
    2416:	9c 83       	std	Y+4, r25	; 0x04
    2418:	8b 83       	std	Y+3, r24	; 0x03
		count_finished = FALSE;
		period_counter = 0;
		//TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
		//enable watchdog timer
		//WDTCR |= (1<<WDP2) | (1<<WDP1) | (1<<WDP0) | (1<<WDE)| (1<<WDCE);
		wdt_enable(WDTO_2S);
    241a:	0f e0       	ldi	r16, 0x0F	; 15
			
			update_display(vco_display_num, DEC);
		
			set_control_voltage(vco_init_cv, init_cv);
			set_control_voltage(vco_pw_cv, MAX);
			set_control_voltage(&volume_cv, MIN);
    241c:	0f 2e       	mov	r0, r31
    241e:	f8 ed       	ldi	r31, 0xD8	; 216
    2420:	cf 2e       	mov	r12, r31
    2422:	f1 e0       	ldi	r31, 0x01	; 1
    2424:	df 2e       	mov	r13, r31
    2426:	f0 2d       	mov	r31, r0
			set_control_voltage(&cutoff_cv, MAX);
    2428:	0f 2e       	mov	r0, r31
    242a:	f4 ed       	ldi	r31, 0xD4	; 212
    242c:	af 2e       	mov	r10, r31
    242e:	f1 e0       	ldi	r31, 0x01	; 1
    2430:	bf 2e       	mov	r11, r31
    2432:	f0 2d       	mov	r31, r0
			set_control_voltage(&sustain_1_cv, MAX);
    2434:	0f 2e       	mov	r0, r31
    2436:	fa ec       	ldi	r31, 0xCA	; 202
    2438:	8f 2e       	mov	r8, r31
    243a:	f1 e0       	ldi	r31, 0x01	; 1
    243c:	9f 2e       	mov	r9, r31
    243e:	f0 2d       	mov	r31, r0
			set_control_voltage(&sustain_2_cv, MAX); //can't remember is EG1 for VCA or EG2????
    2440:	0f 2e       	mov	r0, r31
    2442:	fb ec       	ldi	r31, 0xCB	; 203
    2444:	6f 2e       	mov	r6, r31
    2446:	f1 e0       	ldi	r31, 0x01	; 1
    2448:	7f 2e       	mov	r7, r31
    244a:	f0 2d       	mov	r31, r0
		//WDTCR = 0x00;
		wdt_disable();
		//remember that as INIT_CV goes up, pitch goes down, so looking for osc_count >= reference_count instead of <= as is the case for normal oscillator tuning
		//similarily, OR no_overflow == FALSE *not* AND no_overflow == FALSE to clear bits that make initial pitch too low
		if ((osc_count > reference_count)  || (no_overflow == FALSE)) init_cv &= ~(1 << dac_bit);
		no_overflow = TRUE;
    244c:	e0 e0       	ldi	r30, 0x00	; 0
    244e:	f0 e0       	ldi	r31, 0x00	; 0
    2450:	fc 87       	std	Y+12, r31	; 0x0c
    2452:	eb 87       	std	Y+11, r30	; 0x0b
	//for reasons I don't understand yet, starting with OCR0A set to 0 results in a multi-second delay before first compare match ISR is called ***ACTUALLY, THIS MAY BE RELATED TO LEAVING Timer0 RUNNING. COULD TRY TO SET OCR0A TO 0 NOW and SEE IF IT WORKS
	TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt	
	period = 1; //only counting 1 period 
	for (int dac_bit = 13; dac_bit >= 0; dac_bit--) {
	
		init_cv |= (1<<dac_bit);
    2454:	21 e0       	ldi	r18, 0x01	; 1
    2456:	30 e0       	ldi	r19, 0x00	; 0
    2458:	0b 80       	ldd	r0, Y+3	; 0x03
    245a:	02 c0       	rjmp	.+4      	; 0x2460 <set_vco_init_cv+0x13e>
    245c:	22 0f       	add	r18, r18
    245e:	33 1f       	adc	r19, r19
    2460:	0a 94       	dec	r0
    2462:	e2 f7       	brpl	.-8      	; 0x245c <set_vco_init_cv+0x13a>
    2464:	3e 83       	std	Y+6, r19	; 0x06
    2466:	2d 83       	std	Y+5, r18	; 0x05
    2468:	8b 85       	ldd	r24, Y+11	; 0x0b
    246a:	9c 85       	ldd	r25, Y+12	; 0x0c
    246c:	82 2b       	or	r24, r18
    246e:	93 2b       	or	r25, r19
    2470:	9c 87       	std	Y+12, r25	; 0x0c
    2472:	8b 87       	std	Y+11, r24	; 0x0b
		
		set_control_voltage(vco_init_cv, init_cv);
    2474:	c7 01       	movw	r24, r14
    2476:	6b 85       	ldd	r22, Y+11	; 0x0b
    2478:	7c 85       	ldd	r23, Y+12	; 0x0c
    247a:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
		
		
		count_finished = FALSE;
    247e:	10 92 7e 03 	sts	0x037E, r1
		period_counter = 0;
    2482:	10 92 81 03 	sts	0x0381, r1
		//TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
		//enable watchdog timer
		//WDTCR |= (1<<WDP2) | (1<<WDP1) | (1<<WDP0) | (1<<WDE)| (1<<WDCE);
		wdt_enable(WDTO_2S);
    2486:	e8 e1       	ldi	r30, 0x18	; 24
    2488:	f0 e0       	ldi	r31, 0x00	; 0
    248a:	0f b6       	in	r0, 0x3f	; 63
    248c:	f8 94       	cli
    248e:	a8 95       	wdr
    2490:	e0 93 60 00 	sts	0x0060, r30
    2494:	0f be       	out	0x3f, r0	; 63
    2496:	00 93 60 00 	sts	0x0060, r16
		while (count_finished == FALSE) { //need to have a watchdog timer here to escape while loop if it takes too long
    249a:	80 91 7e 03 	lds	r24, 0x037E
    249e:	88 23       	and	r24, r24
    24a0:	91 f5       	brne	.+100    	; 0x2506 <set_vco_init_cv+0x1e4>
			
			update_display(vco_display_num, DEC);
    24a2:	81 2f       	mov	r24, r17
    24a4:	90 e0       	ldi	r25, 0x00	; 0
    24a6:	60 e0       	ldi	r22, 0x00	; 0
    24a8:	0e 94 38 03 	call	0x670	; 0x670 <update_display>
		
			set_control_voltage(vco_init_cv, init_cv);
    24ac:	c7 01       	movw	r24, r14
    24ae:	6b 85       	ldd	r22, Y+11	; 0x0b
    24b0:	7c 85       	ldd	r23, Y+12	; 0x0c
    24b2:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
			set_control_voltage(vco_pw_cv, MAX);
    24b6:	c1 01       	movw	r24, r2
    24b8:	6f ef       	ldi	r22, 0xFF	; 255
    24ba:	7f e3       	ldi	r23, 0x3F	; 63
    24bc:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
			set_control_voltage(&volume_cv, MIN);
    24c0:	c6 01       	movw	r24, r12
    24c2:	60 e0       	ldi	r22, 0x00	; 0
    24c4:	70 e0       	ldi	r23, 0x00	; 0
    24c6:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
			set_control_voltage(&cutoff_cv, MAX);
    24ca:	c5 01       	movw	r24, r10
    24cc:	6f ef       	ldi	r22, 0xFF	; 255
    24ce:	7f e3       	ldi	r23, 0x3F	; 63
    24d0:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
			set_control_voltage(&sustain_1_cv, MAX);
    24d4:	c4 01       	movw	r24, r8
    24d6:	6f ef       	ldi	r22, 0xFF	; 255
    24d8:	7f e3       	ldi	r23, 0x3F	; 63
    24da:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
			set_control_voltage(&sustain_2_cv, MAX); //can't remember is EG1 for VCA or EG2????
    24de:	c3 01       	movw	r24, r6
    24e0:	6f ef       	ldi	r22, 0xFF	; 255
    24e2:	7f e3       	ldi	r23, 0x3F	; 63
    24e4:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
			set_control_voltage(vco_mix_cv, MAX);
    24e8:	89 81       	ldd	r24, Y+1	; 0x01
    24ea:	9a 81       	ldd	r25, Y+2	; 0x02
    24ec:	6f ef       	ldi	r22, 0xFF	; 255
    24ee:	7f e3       	ldi	r23, 0x3F	; 63
    24f0:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
			set_control_voltage(vco_pitch_cv, 0);	
    24f4:	c2 01       	movw	r24, r4
    24f6:	60 e0       	ldi	r22, 0x00	; 0
    24f8:	70 e0       	ldi	r23, 0x00	; 0
    24fa:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
		period_counter = 0;
		//TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
		//enable watchdog timer
		//WDTCR |= (1<<WDP2) | (1<<WDP1) | (1<<WDP0) | (1<<WDE)| (1<<WDCE);
		wdt_enable(WDTO_2S);
		while (count_finished == FALSE) { //need to have a watchdog timer here to escape while loop if it takes too long
    24fe:	80 91 7e 03 	lds	r24, 0x037E
    2502:	88 23       	and	r24, r24
    2504:	71 f2       	breq	.-100    	; 0x24a2 <set_vco_init_cv+0x180>
			
		}
		//turn off watchdog timer
		//WDTCR |= (1<<WDCE) | (1<<WDE);
		//WDTCR = 0x00;
		wdt_disable();
    2506:	98 e1       	ldi	r25, 0x18	; 24
    2508:	0f b6       	in	r0, 0x3f	; 63
    250a:	f8 94       	cli
    250c:	90 93 60 00 	sts	0x0060, r25
    2510:	10 92 60 00 	sts	0x0060, r1
    2514:	0f be       	out	0x3f, r0	; 63
		//remember that as INIT_CV goes up, pitch goes down, so looking for osc_count >= reference_count instead of <= as is the case for normal oscillator tuning
		//similarily, OR no_overflow == FALSE *not* AND no_overflow == FALSE to clear bits that make initial pitch too low
		if ((osc_count > reference_count)  || (no_overflow == FALSE)) init_cv &= ~(1 << dac_bit);
    2516:	80 91 7c 03 	lds	r24, 0x037C
    251a:	90 91 7d 03 	lds	r25, 0x037D
    251e:	ef 81       	ldd	r30, Y+7	; 0x07
    2520:	f8 85       	ldd	r31, Y+8	; 0x08
    2522:	e8 17       	cp	r30, r24
    2524:	f9 07       	cpc	r31, r25
    2526:	20 f0       	brcs	.+8      	; 0x2530 <set_vco_init_cv+0x20e>
    2528:	80 91 af 02 	lds	r24, 0x02AF
    252c:	88 23       	and	r24, r24
    252e:	51 f4       	brne	.+20     	; 0x2544 <set_vco_init_cv+0x222>
    2530:	8d 81       	ldd	r24, Y+5	; 0x05
    2532:	9e 81       	ldd	r25, Y+6	; 0x06
    2534:	80 95       	com	r24
    2536:	90 95       	com	r25
    2538:	2b 85       	ldd	r18, Y+11	; 0x0b
    253a:	3c 85       	ldd	r19, Y+12	; 0x0c
    253c:	28 23       	and	r18, r24
    253e:	39 23       	and	r19, r25
    2540:	3c 87       	std	Y+12, r19	; 0x0c
    2542:	2b 87       	std	Y+11, r18	; 0x0b
		no_overflow = TRUE;
    2544:	31 e0       	ldi	r19, 0x01	; 1
    2546:	30 93 af 02 	sts	0x02AF, r19
	OCR0A = 1; //output compare register - set to number of periods to be counted. OCR0A needs to be set to (periods_to_be_counted - 1)
	//set OCR0A to 1 here means first ISR interrupt will occur after 2 periods, it is then set to 0 to count only single periods
	//for reasons I don't understand yet, starting with OCR0A set to 0 results in a multi-second delay before first compare match ISR is called ***ACTUALLY, THIS MAY BE RELATED TO LEAVING Timer0 RUNNING. COULD TRY TO SET OCR0A TO 0 NOW and SEE IF IT WORKS
	TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt	
	period = 1; //only counting 1 period 
	for (int dac_bit = 13; dac_bit >= 0; dac_bit--) {
    254a:	8b 81       	ldd	r24, Y+3	; 0x03
    254c:	9c 81       	ldd	r25, Y+4	; 0x04
    254e:	01 97       	sbiw	r24, 0x01	; 1
    2550:	9c 83       	std	Y+4, r25	; 0x04
    2552:	8b 83       	std	Y+3, r24	; 0x03
    2554:	ef ef       	ldi	r30, 0xFF	; 255
    2556:	8f 3f       	cpi	r24, 0xFF	; 255
    2558:	9e 07       	cpc	r25, r30
    255a:	09 f0       	breq	.+2      	; 0x255e <set_vco_init_cv+0x23c>
    255c:	7b cf       	rjmp	.-266    	; 0x2454 <set_vco_init_cv+0x132>
    255e:	2b 85       	ldd	r18, Y+11	; 0x0b
    2560:	3c 85       	ldd	r19, Y+12	; 0x0c
    2562:	3e 83       	std	Y+6, r19	; 0x06
    2564:	2d 83       	std	Y+5, r18	; 0x05
		no_overflow = TRUE;
		
	}		
	
	//none of these help with clicking when returning from this function and starting to read pots	
	set_control_voltage(&release_1_cv, MIN); //this will hopefully reduce popping after returning from initializing pitch CV
    2566:	88 ec       	ldi	r24, 0xC8	; 200
    2568:	91 e0       	ldi	r25, 0x01	; 1
    256a:	60 e0       	ldi	r22, 0x00	; 0
    256c:	70 e0       	ldi	r23, 0x00	; 0
    256e:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&release_2_cv, MIN);
    2572:	89 ec       	ldi	r24, 0xC9	; 201
    2574:	91 e0       	ldi	r25, 0x01	; 1
    2576:	60 e0       	ldi	r22, 0x00	; 0
    2578:	70 e0       	ldi	r23, 0x00	; 0
    257a:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&cutoff_cv, MIN);
    257e:	84 ed       	ldi	r24, 0xD4	; 212
    2580:	91 e0       	ldi	r25, 0x01	; 1
    2582:	60 e0       	ldi	r22, 0x00	; 0
    2584:	70 e0       	ldi	r23, 0x00	; 0
    2586:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&volume_cv, MIN);
    258a:	88 ed       	ldi	r24, 0xD8	; 216
    258c:	91 e0       	ldi	r25, 0x01	; 1
    258e:	60 e0       	ldi	r22, 0x00	; 0
    2590:	70 e0       	ldi	r23, 0x00	; 0
    2592:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
		
	PORTF &= ~(1<<GATE); //turn gate off
    2596:	89 98       	cbi	0x11, 1	; 17
	
	TIMSK0 &= ~(1<<OCIE0A); //turn off compare match A interrupt
    2598:	ee e6       	ldi	r30, 0x6E	; 110
    259a:	f0 e0       	ldi	r31, 0x00	; 0
    259c:	80 81       	ld	r24, Z
    259e:	8d 7f       	andi	r24, 0xFD	; 253
    25a0:	80 83       	st	Z, r24
	TCCR0A = 0; //turn off timer0 period timer
    25a2:	14 bc       	out	0x24, r1	; 36
	//} else {
		//
		//eeprom_update_word(&vco2_init_cv_eeprom, init_cv);
	//}				
		
	eeprom_update_word(eeprom_addr, init_cv);
    25a4:	89 85       	ldd	r24, Y+9	; 0x09
    25a6:	9a 85       	ldd	r25, Y+10	; 0x0a
    25a8:	6d 81       	ldd	r22, Y+5	; 0x05
    25aa:	7e 81       	ldd	r23, Y+6	; 0x06
    25ac:	0e 94 9b 1f 	call	0x3f36	; 0x3f36 <__eeupd_word_m6450a>
	//value_to_display = eeprom_read_word(&vco1_init_cv_eeprom);	

	
	return init_cv;
	
}
    25b0:	8d 81       	ldd	r24, Y+5	; 0x05
    25b2:	9e 81       	ldd	r25, Y+6	; 0x06
    25b4:	2c 96       	adiw	r28, 0x0c	; 12
    25b6:	0f b6       	in	r0, 0x3f	; 63
    25b8:	f8 94       	cli
    25ba:	de bf       	out	0x3e, r29	; 62
    25bc:	0f be       	out	0x3f, r0	; 63
    25be:	cd bf       	out	0x3d, r28	; 61
    25c0:	df 91       	pop	r29
    25c2:	cf 91       	pop	r28
    25c4:	1f 91       	pop	r17
    25c6:	0f 91       	pop	r16
    25c8:	ff 90       	pop	r15
    25ca:	ef 90       	pop	r14
    25cc:	df 90       	pop	r13
    25ce:	cf 90       	pop	r12
    25d0:	bf 90       	pop	r11
    25d2:	af 90       	pop	r10
    25d4:	9f 90       	pop	r9
    25d6:	8f 90       	pop	r8
    25d8:	7f 90       	pop	r7
    25da:	6f 90       	pop	r6
    25dc:	5f 90       	pop	r5
    25de:	4f 90       	pop	r4
    25e0:	3f 90       	pop	r3
    25e2:	2f 90       	pop	r2
    25e4:	08 95       	ret

000025e6 <tune_8ths>:



void tune_8ths(uint8_t vco) {
    25e6:	2f 92       	push	r2
    25e8:	3f 92       	push	r3
    25ea:	4f 92       	push	r4
    25ec:	5f 92       	push	r5
    25ee:	6f 92       	push	r6
    25f0:	7f 92       	push	r7
    25f2:	8f 92       	push	r8
    25f4:	9f 92       	push	r9
    25f6:	af 92       	push	r10
    25f8:	bf 92       	push	r11
    25fa:	cf 92       	push	r12
    25fc:	df 92       	push	r13
    25fe:	ef 92       	push	r14
    2600:	ff 92       	push	r15
    2602:	0f 93       	push	r16
    2604:	1f 93       	push	r17
    2606:	cf 93       	push	r28
    2608:	df 93       	push	r29
    260a:	cd b7       	in	r28, 0x3d	; 61
    260c:	de b7       	in	r29, 0x3e	; 62
    260e:	c0 54       	subi	r28, 0x40	; 64
    2610:	d0 40       	sbci	r29, 0x00	; 0
    2612:	0f b6       	in	r0, 0x3f	; 63
    2614:	f8 94       	cli
    2616:	de bf       	out	0x3e, r29	; 62
    2618:	0f be       	out	0x3f, r0	; 63
    261a:	cd bf       	out	0x3d, r28	; 61
    261c:	08 2f       	mov	r16, r24
		uint8_t period;
		uint16_t count;
	
		};

	struct pitch_reference reference[16] = 
    261e:	de 01       	movw	r26, r28
    2620:	11 96       	adiw	r26, 0x01	; 1
    2622:	e0 e3       	ldi	r30, 0x30	; 48
    2624:	f2 e0       	ldi	r31, 0x02	; 2
    2626:	80 e3       	ldi	r24, 0x30	; 48
    2628:	01 90       	ld	r0, Z+
    262a:	0d 92       	st	X+, r0
    262c:	81 50       	subi	r24, 0x01	; 1
    262e:	e1 f7       	brne	.-8      	; 0x2628 <tune_8ths+0x42>
	
		//to do:
		//disable UART so MIDI data doesn't interrupt tuning
	
		//setup control voltages	
		initialize_voice_for_tuning();
    2630:	0e 94 12 11 	call	0x2224	; 0x2224 <initialize_voice_for_tuning>
		struct control_voltage *vco_init_cv;
		struct control_voltage *vco_mix_cv;
		struct control_voltage *vco_pw_cv;
		struct control_voltage *vco_pitch_cv;	

		if (vco == VCO1) { //set up parameters for VCO1 tuning
    2634:	0f 30       	cpi	r16, 0x0F	; 15
    2636:	11 f5       	brne	.+68     	; 0x267c <tune_8ths+0x96>
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
			vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 1; //allows second digit to display VCO being tuned
			init_cv = vco1_init_cv;
    2638:	40 90 79 03 	lds	r4, 0x0379
    263c:	50 90 7a 03 	lds	r5, 0x037A
			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
			vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
    2640:	0f 2e       	mov	r0, r31
    2642:	f6 ee       	ldi	r31, 0xE6	; 230
    2644:	8f 2e       	mov	r8, r31
    2646:	f1 e0       	ldi	r31, 0x01	; 1
    2648:	9f 2e       	mov	r9, r31
    264a:	f0 2d       	mov	r31, r0

			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
    264c:	0f 2e       	mov	r0, r31
    264e:	fe ed       	ldi	r31, 0xDE	; 222
    2650:	2f 2e       	mov	r2, r31
    2652:	f1 e0       	ldi	r31, 0x01	; 1
    2654:	3f 2e       	mov	r3, r31
    2656:	f0 2d       	mov	r31, r0
		if (vco == VCO1) { //set up parameters for VCO1 tuning

			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
    2658:	23 ee       	ldi	r18, 0xE3	; 227
    265a:	31 e0       	ldi	r19, 0x01	; 1
    265c:	3a ab       	sts	0x5a, r19
    265e:	29 ab       	sts	0x59, r18

		if (vco == VCO1) { //set up parameters for VCO1 tuning

			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
    2660:	0f 2e       	mov	r0, r31
    2662:	fc ed       	ldi	r31, 0xDC	; 220
    2664:	6f 2e       	mov	r6, r31
    2666:	f1 e0       	ldi	r31, 0x01	; 1
    2668:	7f 2e       	mov	r7, r31
    266a:	f0 2d       	mov	r31, r0
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
			vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 1; //allows second digit to display VCO being tuned
			init_cv = vco1_init_cv;
			vco_pitch_table = vco1_pitch_table;
    266c:	05 e5       	ldi	r16, 0x55	; 85
    266e:	13 e0       	ldi	r17, 0x03	; 3
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
			vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 1; //allows second digit to display VCO being tuned
    2670:	cc 24       	eor	r12, r12
    2672:	c3 94       	inc	r12
		struct control_voltage *vco_pitch_cv;	

		if (vco == VCO1) { //set up parameters for VCO1 tuning

			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
    2674:	ee 24       	eor	r14, r14
    2676:	68 94       	set
    2678:	e1 f8       	bld	r14, 1
    267a:	22 c0       	rjmp	.+68     	; 0x26c0 <tune_8ths+0xda>
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
			vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 2; //allows second digit to display VCO being tuned
			init_cv = vco2_init_cv;
    267c:	40 90 77 03 	lds	r4, 0x0377
    2680:	50 90 78 03 	lds	r5, 0x0378
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
			vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
    2684:	0f 2e       	mov	r0, r31
    2686:	f5 ee       	ldi	r31, 0xE5	; 229
    2688:	8f 2e       	mov	r8, r31
    268a:	f1 e0       	ldi	r31, 0x01	; 1
    268c:	9f 2e       	mov	r9, r31
    268e:	f0 2d       	mov	r31, r0
		
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
    2690:	0f 2e       	mov	r0, r31
    2692:	f7 ed       	ldi	r31, 0xD7	; 215
    2694:	2f 2e       	mov	r2, r31
    2696:	f1 e0       	ldi	r31, 0x01	; 1
    2698:	3f 2e       	mov	r3, r31
    269a:	f0 2d       	mov	r31, r0
		} else { //set up parameters for VCO2 tuning
		
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
    269c:	44 ee       	ldi	r20, 0xE4	; 228
    269e:	51 e0       	ldi	r21, 0x01	; 1
    26a0:	5a ab       	sts	0x5a, r21
    26a2:	49 ab       	sts	0x59, r20
		
		} else { //set up parameters for VCO2 tuning
		
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
    26a4:	0f 2e       	mov	r0, r31
    26a6:	fd ed       	ldi	r31, 0xDD	; 221
    26a8:	6f 2e       	mov	r6, r31
    26aa:	f1 e0       	ldi	r31, 0x01	; 1
    26ac:	7f 2e       	mov	r7, r31
    26ae:	f0 2d       	mov	r31, r0
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
			vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 2; //allows second digit to display VCO being tuned
			init_cv = vco2_init_cv;
			vco_pitch_table = vco2_pitch_table;
    26b0:	03 e3       	ldi	r16, 0x33	; 51
    26b2:	13 e0       	ldi	r17, 0x03	; 3
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
			vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 2; //allows second digit to display VCO being tuned
    26b4:	cc 24       	eor	r12, r12
    26b6:	68 94       	set
    26b8:	c1 f8       	bld	r12, 1
		
		
		} else { //set up parameters for VCO2 tuning
		
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
    26ba:	ee 24       	eor	r14, r14
    26bc:	68 94       	set
    26be:	e5 f8       	bld	r14, 5
		}
	


		//set VCO init offset CV
		set_control_voltage(vco_init_cv, init_cv);
    26c0:	c3 01       	movw	r24, r6
    26c2:	b2 01       	movw	r22, r4
    26c4:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
		
	
		//latch switch data
		DATA_BUS = switch_byte;
    26c8:	e2 b8       	out	0x02, r14	; 2
		VCO_SW_LATCH_PORT |= (1<<VCO_SW_LATCH);
    26ca:	ed ed       	ldi	r30, 0xDD	; 221
    26cc:	f0 e0       	ldi	r31, 0x00	; 0
    26ce:	80 81       	ld	r24, Z
    26d0:	80 64       	ori	r24, 0x40	; 64
    26d2:	80 83       	st	Z, r24
		//_delay_us(1); //why is this delay here????
		VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    26d4:	80 81       	ld	r24, Z
    26d6:	8f 7b       	andi	r24, 0xBF	; 191
    26d8:	80 83       	st	Z, r24
		DATA_BUS = 0;
    26da:	12 b8       	out	0x02, r1	; 2

		PORTF |= (1<<GATE); //turn gate on
    26dc:	89 9a       	sbi	0x11, 1	; 17
			
		period = 1; //need to initialize to minimum period number here
    26de:	81 e0       	ldi	r24, 0x01	; 1
    26e0:	80 93 80 03 	sts	0x0380, r24
		
		compare_match_counter = 0;	
    26e4:	10 92 7b 03 	sts	0x037B, r1
			
				//enable watchdog timer
				wdt_enable(WDTO_2S);
				while (count_finished == FALSE) {
					//update_display(vco_number + period + (compare_match_counter>>4)*100, DEC);
					update_display(vco_number*100 + period, DEC);//
    26e8:	8c 2d       	mov	r24, r12
    26ea:	90 e0       	ldi	r25, 0x00	; 0
    26ec:	24 e6       	ldi	r18, 0x64	; 100
    26ee:	30 e0       	ldi	r19, 0x00	; 0
    26f0:	82 9f       	mul	r24, r18
    26f2:	d0 01       	movw	r26, r0
    26f4:	83 9f       	mul	r24, r19
    26f6:	b0 0d       	add	r27, r0
    26f8:	92 9f       	mul	r25, r18
    26fa:	b0 0d       	add	r27, r0
    26fc:	11 24       	eor	r1, r1
    26fe:	bc ab       	sts	0x5c, r27
    2700:	ab ab       	sts	0x5b, r26
    2702:	fe 01       	movw	r30, r28
    2704:	31 96       	adiw	r30, 0x01	; 1
    2706:	fc af       	sts	0x7c, r31
    2708:	eb af       	sts	0x7b, r30
	
}



void tune_8ths(uint8_t vco) {
    270a:	98 01       	movw	r18, r16
    270c:	2e 5f       	subi	r18, 0xFE	; 254
    270e:	3f 4f       	sbci	r19, 0xFF	; 255
    2710:	21 96       	adiw	r28, 0x01	; 1
    2712:	3f af       	sts	0x7f, r19
    2714:	2e af       	sts	0x7e, r18
    2716:	21 97       	sbiw	r28, 0x01	; 1
		PORTF |= (1<<GATE); //turn gate on
			
		period = 1; //need to initialize to minimum period number here
		
		compare_match_counter = 0;	
		for (int note_number = 0; note_number <= 15; note_number++) 
    2718:	1e ae       	sts	0xbe, r17
    271a:	1d ae       	sts	0xbd, r17
					//not sure what's really necessary here - definitely pitch and init_cv, but what else?
					set_control_voltage(vco_init_cv, init_cv);
					set_control_voltage(vco_pitch_cv, osc_pitch_cv);
					//set_control_voltage(&pitch_lfo_cv, MIN);
					//set_control_voltage(vco_pw_cv, MAX); //not necessary as SAW is being used to clock comparator
					set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
    271c:	0f 2e       	mov	r0, r31
    271e:	f8 ed       	ldi	r31, 0xD8	; 216
    2720:	ef 2e       	mov	r14, r31
    2722:	f1 e0       	ldi	r31, 0x01	; 1
    2724:	ff 2e       	mov	r15, r31
    2726:	f0 2d       	mov	r31, r0
					set_control_voltage(&cutoff_cv, MAX);
    2728:	0f 2e       	mov	r0, r31
    272a:	f4 ed       	ldi	r31, 0xD4	; 212
    272c:	cf 2e       	mov	r12, r31
    272e:	f1 e0       	ldi	r31, 0x01	; 1
    2730:	df 2e       	mov	r13, r31
    2732:	f0 2d       	mov	r31, r0
					//set_control_voltage(&res_cv, MIN);
					set_control_voltage(&sustain_1_cv, MAX);
    2734:	0f 2e       	mov	r0, r31
    2736:	fa ec       	ldi	r31, 0xCA	; 202
    2738:	af 2e       	mov	r10, r31
    273a:	f1 e0       	ldi	r31, 0x01	; 1
    273c:	bf 2e       	mov	r11, r31
    273e:	f0 2d       	mov	r31, r0
	
}



void tune_8ths(uint8_t vco) {
    2740:	eb ad       	sts	0x6b, r30
    2742:	fc ad       	sts	0x6c, r31
		period = 1; //need to initialize to minimum period number here
		
		compare_match_counter = 0;	
		for (int note_number = 0; note_number <= 15; note_number++) 
			{
			period = reference[note_number].period;
    2744:	80 81       	ld	r24, Z
    2746:	80 93 80 03 	sts	0x0380, r24
			//period timer needs to be initialized here and turned off after each note's SAR to prevent glitching caused by leaving timer0 running
			TCCR0A |= (1<<CS02) | (1<<CS01) | (1<<CS00) | (1<<WGM01); //clocked by external T0 pin, rising edge + clear timer on compare match
    274a:	84 b5       	in	r24, 0x24	; 36
    274c:	8f 60       	ori	r24, 0x0F	; 15
    274e:	84 bd       	out	0x24, r24	; 36
			OCR0A = 1; //output compare register - set to number of periods to be counted. OCR0A needs to be set to (periods_to_be_counted - 1) ***COULD PROBABLY CHANGE THIS TO 0 NOW*** - NOPE. NEEDS TO BE 1!!!
    2750:	81 e0       	ldi	r24, 0x01	; 1
    2752:	87 bd       	out	0x27, r24	; 39
			//TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
			TCNT0 = 0; //make sure timer/counter0 is actually 0. 
    2754:	16 bc       	out	0x26, r1	; 38
			
			if (note_number <= 2) {
    2756:	4d ad       	sts	0x6d, r20
    2758:	5e ad       	sts	0x6e, r21
    275a:	43 30       	cpi	r20, 0x03	; 3
    275c:	51 05       	cpc	r21, r1
    275e:	24 f4       	brge	.+8      	; 0x2768 <tune_8ths+0x182>
	
				//set timer/counter1 to /64 0.3125 MHz
				timer1_clock = (1<<CS11) | (1<<CS10);
    2760:	83 e0       	ldi	r24, 0x03	; 3
    2762:	80 93 7f 03 	sts	0x037F, r24
    2766:	03 c0       	rjmp	.+6      	; 0x276e <tune_8ths+0x188>
	
			} else {
	
				//set timer/counter1 to /8 2.5 MHz
				timer1_clock = (1<<CS11);
    2768:	82 e0       	ldi	r24, 0x02	; 2
    276a:	80 93 7f 03 	sts	0x037F, r24
	
			}
			//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
			uint16_t reference_count = reference[note_number].count;
    276e:	81 81       	ldd	r24, Z+1	; 0x01
    2770:	92 81       	ldd	r25, Z+2	; 0x02
    2772:	9a af       	sts	0x7a, r25
    2774:	89 af       	sts	0x79, r24
			uint16_t osc_pitch_cv = 0;
			for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
    2776:	ad e0       	ldi	r26, 0x0D	; 13
    2778:	b0 e0       	ldi	r27, 0x00	; 0
    277a:	be ab       	sts	0x5e, r27
    277c:	ad ab       	sts	0x5d, r26
				timer1_clock = (1<<CS11);
	
			}
			//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
			uint16_t reference_count = reference[note_number].count;
			uint16_t osc_pitch_cv = 0;
    277e:	00 e0       	ldi	r16, 0x00	; 0
    2780:	10 e0       	ldi	r17, 0x00	; 0
			for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
				
				osc_pitch_cv |= (1<<dac_bit);
    2782:	e1 e0       	ldi	r30, 0x01	; 1
    2784:	f0 e0       	ldi	r31, 0x00	; 0
    2786:	0d a8       	sts	0x8d, r16
    2788:	02 c0       	rjmp	.+4      	; 0x278e <tune_8ths+0x1a8>
    278a:	ee 0f       	add	r30, r30
    278c:	ff 1f       	adc	r31, r31
    278e:	0a 94       	dec	r0
    2790:	e2 f7       	brpl	.-8      	; 0x278a <tune_8ths+0x1a4>
    2792:	f8 af       	sts	0x78, r31
    2794:	ef ab       	sts	0x5f, r30
    2796:	0e 2b       	or	r16, r30
    2798:	1f 2b       	or	r17, r31
				TIMSK0 &= ~(1<<OCIE0A); //turn off output compare match A interrupt
    279a:	ae e6       	ldi	r26, 0x6E	; 110
    279c:	b0 e0       	ldi	r27, 0x00	; 0
    279e:	8c 91       	ld	r24, X
    27a0:	8d 7f       	andi	r24, 0xFD	; 253
    27a2:	8c 93       	st	X, r24
				set_control_voltage(vco_pitch_cv, osc_pitch_cv);
    27a4:	c4 01       	movw	r24, r8
    27a6:	b8 01       	movw	r22, r16
    27a8:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    27ac:	e3 ef       	ldi	r30, 0xF3	; 243
    27ae:	f1 e0       	ldi	r31, 0x01	; 1
    27b0:	31 97       	sbiw	r30, 0x01	; 1
    27b2:	f1 f7       	brne	.-4      	; 0x27b0 <tune_8ths+0x1ca>
    27b4:	00 c0       	rjmp	.+0      	; 0x27b6 <tune_8ths+0x1d0>
    27b6:	00 00       	nop
				_delay_ms(2); //add delay here to allow pitch to slew to its final value
				TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
    27b8:	ae e6       	ldi	r26, 0x6E	; 110
    27ba:	b0 e0       	ldi	r27, 0x00	; 0
    27bc:	8c 91       	ld	r24, X
    27be:	82 60       	ori	r24, 0x02	; 2
    27c0:	8c 93       	st	X, r24
				//TCNT0 = 0;
				
				count_finished = FALSE;
    27c2:	10 92 7e 03 	sts	0x037E, r1
				period_counter = 0;
    27c6:	10 92 81 03 	sts	0x0381, r1
			
				//enable watchdog timer
				wdt_enable(WDTO_2S);
    27ca:	e8 e1       	ldi	r30, 0x18	; 24
    27cc:	f0 e0       	ldi	r31, 0x00	; 0
    27ce:	2f e0       	ldi	r18, 0x0F	; 15
    27d0:	0f b6       	in	r0, 0x3f	; 63
    27d2:	f8 94       	cli
    27d4:	a8 95       	wdr
    27d6:	e0 93 60 00 	sts	0x0060, r30
    27da:	0f be       	out	0x3f, r0	; 63
    27dc:	20 93 60 00 	sts	0x0060, r18
				while (count_finished == FALSE) {
    27e0:	80 91 7e 03 	lds	r24, 0x037E
    27e4:	88 23       	and	r24, r24
    27e6:	81 f5       	brne	.+96     	; 0x2848 <tune_8ths+0x262>
					//update_display(vco_number + period + (compare_match_counter>>4)*100, DEC);
					update_display(vco_number*100 + period, DEC);//
    27e8:	80 91 80 03 	lds	r24, 0x0380
    27ec:	4b a9       	sts	0x4b, r20
    27ee:	5c a9       	sts	0x4c, r21
    27f0:	48 0f       	add	r20, r24
    27f2:	51 1d       	adc	r21, r1
    27f4:	ca 01       	movw	r24, r20
    27f6:	60 e0       	ldi	r22, 0x00	; 0
    27f8:	0e 94 38 03 	call	0x670	; 0x670 <update_display>
					//update_display(value_to_display, DEC);	
					//need to have a watchdog timer here to escape while loop if it takes too long
				
					//not sure what's really necessary here - definitely pitch and init_cv, but what else?
					set_control_voltage(vco_init_cv, init_cv);
    27fc:	c3 01       	movw	r24, r6
    27fe:	b2 01       	movw	r22, r4
    2800:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
					set_control_voltage(vco_pitch_cv, osc_pitch_cv);
    2804:	c4 01       	movw	r24, r8
    2806:	b8 01       	movw	r22, r16
    2808:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
					//set_control_voltage(&pitch_lfo_cv, MIN);
					//set_control_voltage(vco_pw_cv, MAX); //not necessary as SAW is being used to clock comparator
					set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
    280c:	c7 01       	movw	r24, r14
    280e:	60 e0       	ldi	r22, 0x00	; 0
    2810:	70 e0       	ldi	r23, 0x00	; 0
    2812:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
					set_control_voltage(&cutoff_cv, MAX);
    2816:	c6 01       	movw	r24, r12
    2818:	6f ef       	ldi	r22, 0xFF	; 255
    281a:	7f e3       	ldi	r23, 0x3F	; 63
    281c:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
					//set_control_voltage(&res_cv, MIN);
					set_control_voltage(&sustain_1_cv, MAX);
    2820:	c5 01       	movw	r24, r10
    2822:	6f ef       	ldi	r22, 0xFF	; 255
    2824:	7f e3       	ldi	r23, 0x3F	; 63
    2826:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
					//set_control_voltage(&attack_1_cv, MIN); //keep attack at minimum
					set_control_voltage(vco_pw_cv, 8192);
    282a:	c1 01       	movw	r24, r2
    282c:	60 e0       	ldi	r22, 0x00	; 0
    282e:	70 e2       	ldi	r23, 0x20	; 32
    2830:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
					set_control_voltage(vco_mix_cv, MAX);
    2834:	89 a9       	sts	0x49, r24
    2836:	9a a9       	sts	0x4a, r25
    2838:	6f ef       	ldi	r22, 0xFF	; 255
    283a:	7f e3       	ldi	r23, 0x3F	; 63
    283c:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
				count_finished = FALSE;
				period_counter = 0;
			
				//enable watchdog timer
				wdt_enable(WDTO_2S);
				while (count_finished == FALSE) {
    2840:	80 91 7e 03 	lds	r24, 0x037E
    2844:	88 23       	and	r24, r24
    2846:	81 f2       	breq	.-96     	; 0x27e8 <tune_8ths+0x202>

			
			
				}							
				//turn off watchdog timer
				wdt_disable();
    2848:	58 e1       	ldi	r21, 0x18	; 24
    284a:	0f b6       	in	r0, 0x3f	; 63
    284c:	f8 94       	cli
    284e:	50 93 60 00 	sts	0x0060, r21
    2852:	10 92 60 00 	sts	0x0060, r1
    2856:	0f be       	out	0x3f, r0	; 63
				//Omar changed this from <= to < which makes sense. <= was an error because if it's equal you don't want to clear the bit
				if ((osc_count <= reference_count) && (no_overflow == TRUE)) osc_pitch_cv &= ~(1<<dac_bit);
    2858:	80 91 7c 03 	lds	r24, 0x037C
    285c:	90 91 7d 03 	lds	r25, 0x037D
    2860:	a9 ad       	sts	0x69, r26
    2862:	ba ad       	sts	0x6a, r27
    2864:	a8 17       	cp	r26, r24
    2866:	b9 07       	cpc	r27, r25
    2868:	50 f0       	brcs	.+20     	; 0x287e <tune_8ths+0x298>
    286a:	80 91 af 02 	lds	r24, 0x02AF
    286e:	81 30       	cpi	r24, 0x01	; 1
    2870:	31 f4       	brne	.+12     	; 0x287e <tune_8ths+0x298>
    2872:	8f a9       	sts	0x4f, r24
    2874:	98 ad       	sts	0x68, r25
    2876:	80 95       	com	r24
    2878:	90 95       	com	r25
    287a:	08 23       	and	r16, r24
    287c:	19 23       	and	r17, r25
				
				if (osc_count == reference_count && no_overflow == TRUE) {
    287e:	80 91 7c 03 	lds	r24, 0x037C
    2882:	90 91 7d 03 	lds	r25, 0x037D
    2886:	e9 ad       	sts	0x69, r30
    2888:	fa ad       	sts	0x6a, r31
    288a:	8e 17       	cp	r24, r30
    288c:	9f 07       	cpc	r25, r31
    288e:	21 f4       	brne	.+8      	; 0x2898 <tune_8ths+0x2b2>
    2890:	80 91 af 02 	lds	r24, 0x02AF
    2894:	81 30       	cpi	r24, 0x01	; 1
    2896:	71 f0       	breq	.+28     	; 0x28b4 <tune_8ths+0x2ce>
					break;	//if you hit the reference count then get out of here		
				}				
				no_overflow = TRUE;
    2898:	f1 e0       	ldi	r31, 0x01	; 1
    289a:	f0 93 af 02 	sts	0x02AF, r31
	
			}
			//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
			uint16_t reference_count = reference[note_number].count;
			uint16_t osc_pitch_cv = 0;
			for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
    289e:	2d a9       	sts	0x4d, r18
    28a0:	3e a9       	sts	0x4e, r19
    28a2:	21 50       	subi	r18, 0x01	; 1
    28a4:	30 40       	sbci	r19, 0x00	; 0
    28a6:	3e ab       	sts	0x5e, r19
    28a8:	2d ab       	sts	0x5d, r18
    28aa:	4f ef       	ldi	r20, 0xFF	; 255
    28ac:	2f 3f       	cpi	r18, 0xFF	; 255
    28ae:	34 07       	cpc	r19, r20
    28b0:	09 f0       	breq	.+2      	; 0x28b4 <tune_8ths+0x2ce>
    28b2:	67 cf       	rjmp	.-306    	; 0x2782 <tune_8ths+0x19c>
			
			
			}
		
			//vco_pitch_table[octave*12 + note_number] = osc_pitch_cv; //store the note control voltage in the pitch table
			*(vco_pitch_table + (note_number+1)) = osc_pitch_cv;		
    28b4:	21 96       	adiw	r28, 0x01	; 1
    28b6:	ae ad       	sts	0x6e, r26
    28b8:	bf ad       	sts	0x6f, r27
    28ba:	21 97       	sbiw	r28, 0x01	; 1
    28bc:	0d 93       	st	X+, r16
    28be:	1d 93       	st	X+, r17
    28c0:	21 96       	adiw	r28, 0x01	; 1
    28c2:	bf af       	sts	0x7f, r27
    28c4:	ae af       	sts	0x7e, r26
    28c6:	21 97       	sbiw	r28, 0x01	; 1
			
			//need to turn timer off here. This seems to have stopped periodic glitching of first note of first VCO tuned.
			TIMSK0 &= ~(1<<OCIE0A); //turn off timer0 compare match A interrupt
    28c8:	ee e6       	ldi	r30, 0x6E	; 110
    28ca:	f0 e0       	ldi	r31, 0x00	; 0
    28cc:	80 81       	ld	r24, Z
    28ce:	8d 7f       	andi	r24, 0xFD	; 253
    28d0:	80 83       	st	Z, r24
			TCCR0A = 0; //turn off timer0
    28d2:	14 bc       	out	0x24, r1	; 36
		PORTF |= (1<<GATE); //turn gate on
			
		period = 1; //need to initialize to minimum period number here
		
		compare_match_counter = 0;	
		for (int note_number = 0; note_number <= 15; note_number++) 
    28d4:	2d ad       	sts	0x6d, r18
    28d6:	3e ad       	sts	0x6e, r19
    28d8:	2f 5f       	subi	r18, 0xFF	; 255
    28da:	3f 4f       	sbci	r19, 0xFF	; 255
    28dc:	3e af       	sts	0x7e, r19
    28de:	2d af       	sts	0x7d, r18
    28e0:	4b ad       	sts	0x6b, r20
    28e2:	5c ad       	sts	0x6c, r21
    28e4:	4d 5f       	subi	r20, 0xFD	; 253
    28e6:	5f 4f       	sbci	r21, 0xFF	; 255
    28e8:	5c af       	sts	0x7c, r21
    28ea:	4b af       	sts	0x7b, r20
    28ec:	20 31       	cpi	r18, 0x10	; 16
    28ee:	31 05       	cpc	r19, r1
    28f0:	09 f0       	breq	.+2      	; 0x28f4 <tune_8ths+0x30e>
    28f2:	26 cf       	rjmp	.-436    	; 0x2740 <tune_8ths+0x15a>
		}
	
		
		//eeprom_update_block((const void*)vco_pitch_table, (void*)vco_pitch_table_eeprom, sizeof(vco_pitch_table));
		//vco_pitch_table[0] = 0;
		PORTF &= ~(1<<GATE); //turn gate off
    28f4:	89 98       	cbi	0x11, 1	; 17
		
		
	
	
	}
    28f6:	c0 5c       	subi	r28, 0xC0	; 192
    28f8:	df 4f       	sbci	r29, 0xFF	; 255
    28fa:	0f b6       	in	r0, 0x3f	; 63
    28fc:	f8 94       	cli
    28fe:	de bf       	out	0x3e, r29	; 62
    2900:	0f be       	out	0x3f, r0	; 63
    2902:	cd bf       	out	0x3d, r28	; 61
    2904:	df 91       	pop	r29
    2906:	cf 91       	pop	r28
    2908:	1f 91       	pop	r17
    290a:	0f 91       	pop	r16
    290c:	ff 90       	pop	r15
    290e:	ef 90       	pop	r14
    2910:	df 90       	pop	r13
    2912:	cf 90       	pop	r12
    2914:	bf 90       	pop	r11
    2916:	af 90       	pop	r10
    2918:	9f 90       	pop	r9
    291a:	8f 90       	pop	r8
    291c:	7f 90       	pop	r7
    291e:	6f 90       	pop	r6
    2920:	5f 90       	pop	r5
    2922:	4f 90       	pop	r4
    2924:	3f 90       	pop	r3
    2926:	2f 90       	pop	r2
    2928:	08 95       	ret

0000292a <tune_filter>:
	
void tune_filter(void) {
    292a:	2f 92       	push	r2
    292c:	3f 92       	push	r3
    292e:	4f 92       	push	r4
    2930:	5f 92       	push	r5
    2932:	6f 92       	push	r6
    2934:	7f 92       	push	r7
    2936:	8f 92       	push	r8
    2938:	9f 92       	push	r9
    293a:	af 92       	push	r10
    293c:	bf 92       	push	r11
    293e:	cf 92       	push	r12
    2940:	df 92       	push	r13
    2942:	ef 92       	push	r14
    2944:	ff 92       	push	r15
    2946:	0f 93       	push	r16
    2948:	1f 93       	push	r17
    294a:	cf 93       	push	r28
    294c:	df 93       	push	r29
    294e:	cd b7       	in	r28, 0x3d	; 61
    2950:	de b7       	in	r29, 0x3e	; 62
    2952:	e9 97       	sbiw	r28, 0x39	; 57
    2954:	0f b6       	in	r0, 0x3f	; 63
    2956:	f8 94       	cli
    2958:	de bf       	out	0x3e, r29	; 62
    295a:	0f be       	out	0x3f, r0	; 63
    295c:	cd bf       	out	0x3d, r28	; 61
		uint8_t period;
		uint16_t count;
		
	};

	struct pitch_reference reference[15] =
    295e:	de 01       	movw	r26, r28
    2960:	11 96       	adiw	r26, 0x01	; 1
    2962:	e0 e6       	ldi	r30, 0x60	; 96
    2964:	f2 e0       	ldi	r31, 0x02	; 2
    2966:	8d e2       	ldi	r24, 0x2D	; 45
    2968:	01 90       	ld	r0, Z+
    296a:	0d 92       	st	X+, r0
    296c:	81 50       	subi	r24, 0x01	; 1
    296e:	e1 f7       	brne	.-8      	; 0x2968 <tune_filter+0x3e>
		
	};

	
	//initialize CVs for filter tuning
	set_control_voltage(&volume_cv, MIN); //turn volume all the way down
    2970:	88 ed       	ldi	r24, 0xD8	; 216
    2972:	91 e0       	ldi	r25, 0x01	; 1
    2974:	60 e0       	ldi	r22, 0x00	; 0
    2976:	70 e0       	ldi	r23, 0x00	; 0
    2978:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off all pitch modulation
	set_control_voltage(&pitch_lfo_cv, MIN);
    297c:	81 ee       	ldi	r24, 0xE1	; 225
    297e:	91 e0       	ldi	r25, 0x01	; 1
    2980:	60 e0       	ldi	r22, 0x00	; 0
    2982:	70 e0       	ldi	r23, 0x00	; 0
    2984:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pitch_eg2_cv, MIN);
    2988:	82 ee       	ldi	r24, 0xE2	; 226
    298a:	91 e0       	ldi	r25, 0x01	; 1
    298c:	60 e0       	ldi	r22, 0x00	; 0
    298e:	70 e0       	ldi	r23, 0x00	; 0
    2990:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pitch_vco2_cv, MIN);
    2994:	87 eb       	ldi	r24, 0xB7	; 183
    2996:	92 e0       	ldi	r25, 0x02	; 2
    2998:	60 e0       	ldi	r22, 0x00	; 0
    299a:	70 e0       	ldi	r23, 0x00	; 0
    299c:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off glide
	set_control_voltage(&glide_cv, MIN);
    29a0:	8a ed       	ldi	r24, 0xDA	; 218
    29a2:	91 e0       	ldi	r25, 0x01	; 1
    29a4:	60 e0       	ldi	r22, 0x00	; 0
    29a6:	70 e0       	ldi	r23, 0x00	; 0
    29a8:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off all pulse width modulation
	set_control_voltage(&pwm_eg2_cv, MIN);
    29ac:	8f ed       	ldi	r24, 0xDF	; 223
    29ae:	91 e0       	ldi	r25, 0x01	; 1
    29b0:	60 e0       	ldi	r22, 0x00	; 0
    29b2:	70 e0       	ldi	r23, 0x00	; 0
    29b4:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pwm_lfo_cv, MIN);
    29b8:	80 ee       	ldi	r24, 0xE0	; 224
    29ba:	91 e0       	ldi	r25, 0x01	; 1
    29bc:	60 e0       	ldi	r22, 0x00	; 0
    29be:	70 e0       	ldi	r23, 0x00	; 0
    29c0:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off all filter modulation
	set_control_voltage(&fil_lfo_cv, MIN);
    29c4:	81 ed       	ldi	r24, 0xD1	; 209
    29c6:	91 e0       	ldi	r25, 0x01	; 1
    29c8:	60 e0       	ldi	r22, 0x00	; 0
    29ca:	70 e0       	ldi	r23, 0x00	; 0
    29cc:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&fil_eg2_cv, MIN);
    29d0:	86 ed       	ldi	r24, 0xD6	; 214
    29d2:	91 e0       	ldi	r25, 0x01	; 1
    29d4:	60 e0       	ldi	r22, 0x00	; 0
    29d6:	70 e0       	ldi	r23, 0x00	; 0
    29d8:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&fil_vco2_cv, MIN);
    29dc:	82 ed       	ldi	r24, 0xD2	; 210
    29de:	91 e0       	ldi	r25, 0x01	; 1
    29e0:	60 e0       	ldi	r22, 0x00	; 0
    29e2:	70 e0       	ldi	r23, 0x00	; 0
    29e4:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&key_track_cv, MIN);
    29e8:	83 ed       	ldi	r24, 0xD3	; 211
    29ea:	91 e0       	ldi	r25, 0x01	; 1
    29ec:	60 e0       	ldi	r22, 0x00	; 0
    29ee:	70 e0       	ldi	r23, 0x00	; 0
    29f0:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//open filter with max resonance
	set_control_voltage(&cutoff_cv, MAX); //need to start with MAX to get filter oscillating
    29f4:	84 ed       	ldi	r24, 0xD4	; 212
    29f6:	91 e0       	ldi	r25, 0x01	; 1
    29f8:	6f ef       	ldi	r22, 0xFF	; 255
    29fa:	7f e3       	ldi	r23, 0x3F	; 63
    29fc:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&res_cv, MAX);
    2a00:	85 ed       	ldi	r24, 0xD5	; 213
    2a02:	91 e0       	ldi	r25, 0x01	; 1
    2a04:	6f ef       	ldi	r22, 0xFF	; 255
    2a06:	7f e3       	ldi	r23, 0x3F	; 63
    2a08:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off VCA LFO modulation
	set_control_voltage(&amp_lfo_cv, MIN);
    2a0c:	89 ed       	ldi	r24, 0xD9	; 217
    2a0e:	91 e0       	ldi	r25, 0x01	; 1
    2a10:	60 e0       	ldi	r22, 0x00	; 0
    2a12:	70 e0       	ldi	r23, 0x00	; 0
    2a14:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//initialize VCA envelope
	set_control_voltage(&attack_1_cv, MIN);
    2a18:	8e ec       	ldi	r24, 0xCE	; 206
    2a1a:	91 e0       	ldi	r25, 0x01	; 1
    2a1c:	60 e0       	ldi	r22, 0x00	; 0
    2a1e:	70 e0       	ldi	r23, 0x00	; 0
    2a20:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&decay_1_cv, MIN);
    2a24:	8c ec       	ldi	r24, 0xCC	; 204
    2a26:	91 e0       	ldi	r25, 0x01	; 1
    2a28:	60 e0       	ldi	r22, 0x00	; 0
    2a2a:	70 e0       	ldi	r23, 0x00	; 0
    2a2c:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&sustain_1_cv, MAX);
    2a30:	8a ec       	ldi	r24, 0xCA	; 202
    2a32:	91 e0       	ldi	r25, 0x01	; 1
    2a34:	6f ef       	ldi	r22, 0xFF	; 255
    2a36:	7f e3       	ldi	r23, 0x3F	; 63
    2a38:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&release_1_cv, MIN);
    2a3c:	88 ec       	ldi	r24, 0xC8	; 200
    2a3e:	91 e0       	ldi	r25, 0x01	; 1
    2a40:	60 e0       	ldi	r22, 0x00	; 0
    2a42:	70 e0       	ldi	r23, 0x00	; 0
    2a44:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off noise, VCO1 and VCO2
	set_control_voltage(&noise_mix_cv, MIN);
    2a48:	80 ed       	ldi	r24, 0xD0	; 208
    2a4a:	91 e0       	ldi	r25, 0x01	; 1
    2a4c:	60 e0       	ldi	r22, 0x00	; 0
    2a4e:	70 e0       	ldi	r23, 0x00	; 0
    2a50:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&vco1_mix_cv, MIN);
    2a54:	83 ee       	ldi	r24, 0xE3	; 227
    2a56:	91 e0       	ldi	r25, 0x01	; 1
    2a58:	60 e0       	ldi	r22, 0x00	; 0
    2a5a:	70 e0       	ldi	r23, 0x00	; 0
    2a5c:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&vco2_mix_cv, MIN);
    2a60:	84 ee       	ldi	r24, 0xE4	; 228
    2a62:	91 e0       	ldi	r25, 0x01	; 1
    2a64:	60 e0       	ldi	r22, 0x00	; 0
    2a66:	70 e0       	ldi	r23, 0x00	; 0
    2a68:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>


	//latch switch data
	DATA_BUS = 0; //turn off all VCO waveforms
    2a6c:	12 b8       	out	0x02, r1	; 2
	VCO_SW_LATCH_PORT |= (1<<VCO_SW_LATCH);
    2a6e:	ed ed       	ldi	r30, 0xDD	; 221
    2a70:	f0 e0       	ldi	r31, 0x00	; 0
    2a72:	80 81       	ld	r24, Z
    2a74:	80 64       	ori	r24, 0x40	; 64
    2a76:	80 83       	st	Z, r24
	//_delay_us(1); //why is this delay here????
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    2a78:	80 81       	ld	r24, Z
    2a7a:	8f 7b       	andi	r24, 0xBF	; 191
    2a7c:	80 83       	st	Z, r24
	//DATA_BUS = 0;


	period = 1; //need to initialize to minimum period number here
    2a7e:	81 e0       	ldi	r24, 0x01	; 1
    2a80:	80 93 80 03 	sts	0x0380, r24
	PORTF |= (1<<GATE); //turn gate on
    2a84:	89 9a       	sbi	0x11, 1	; 17
    2a86:	9e 01       	movw	r18, r28
    2a88:	2f 5f       	subi	r18, 0xFF	; 255
    2a8a:	3f 4f       	sbci	r19, 0xFF	; 255
    2a8c:	3d ab       	sts	0x5d, r19
    2a8e:	2c ab       	sts	0x5c, r18
    2a90:	85 e1       	ldi	r24, 0x15	; 21
    2a92:	93 e0       	ldi	r25, 0x03	; 3
    2a94:	99 af       	sts	0x79, r25
    2a96:	88 af       	sts	0x78, r24
	
	
	
	for (int note_number = 0; note_number <= 14; note_number++)
    2a98:	1f aa       	sts	0x9f, r17
    2a9a:	1e aa       	sts	0x9e, r17
		uint16_t pitch_cv = 0;
		for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
		
			pitch_cv |= (1<<dac_bit);

			set_control_voltage(&cutoff_cv, pitch_cv);
    2a9c:	0f 2e       	mov	r0, r31
    2a9e:	f4 ed       	ldi	r31, 0xD4	; 212
    2aa0:	af 2e       	mov	r10, r31
    2aa2:	f1 e0       	ldi	r31, 0x01	; 1
    2aa4:	bf 2e       	mov	r11, r31
    2aa6:	f0 2d       	mov	r31, r0
				//value_to_display = TCNT0;
				//update_display(value_to_display, DEC);
				
		
				set_control_voltage(&cutoff_cv, pitch_cv);
				set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
    2aa8:	0f 2e       	mov	r0, r31
    2aaa:	f8 ed       	ldi	r31, 0xD8	; 216
    2aac:	6f 2e       	mov	r6, r31
    2aae:	f1 e0       	ldi	r31, 0x01	; 1
    2ab0:	7f 2e       	mov	r7, r31
    2ab2:	f0 2d       	mov	r31, r0
				set_control_voltage(&res_cv, MAX);
    2ab4:	0f 2e       	mov	r0, r31
    2ab6:	f5 ed       	ldi	r31, 0xD5	; 213
    2ab8:	4f 2e       	mov	r4, r31
    2aba:	f1 e0       	ldi	r31, 0x01	; 1
    2abc:	5f 2e       	mov	r5, r31
    2abe:	f0 2d       	mov	r31, r0
				set_control_voltage(&sustain_1_cv, MAX);
    2ac0:	0f 2e       	mov	r0, r31
    2ac2:	fa ec       	ldi	r31, 0xCA	; 202
    2ac4:	2f 2e       	mov	r2, r31
    2ac6:	f1 e0       	ldi	r31, 0x01	; 1
    2ac8:	3f 2e       	mov	r3, r31
    2aca:	f0 2d       	mov	r31, r0
		
	
	
	}
	
void tune_filter(void) {
    2acc:	ac a9       	sts	0x4c, r26
    2ace:	bd a9       	sts	0x4d, r27
	
	
	
	for (int note_number = 0; note_number <= 14; note_number++)
	{
		period = reference[note_number].period;
    2ad0:	8c 91       	ld	r24, X
    2ad2:	80 93 80 03 	sts	0x0380, r24
		//period timer needs to be initialized here and turned off after each note's SAR to prevent glitching caused by leaving timer0 running
		TCCR0A |= (1<<CS02) | (1<<CS01) | (1<<CS00) | (1<<WGM01); //clocked by external T0 pin, rising edge + clear timer on compare match
    2ad6:	84 b5       	in	r24, 0x24	; 36
    2ad8:	8f 60       	ori	r24, 0x0F	; 15
    2ada:	84 bd       	out	0x24, r24	; 36
		OCR0A = 1; //output compare register - set to number of periods to be counted. OCR0A needs to be set to (periods_to_be_counted - 1) ***COULD PROBABLY CHANGE THIS TO 0 NOW*** - NOPE. NEEDS TO BE 1!!!
    2adc:	81 e0       	ldi	r24, 0x01	; 1
    2ade:	87 bd       	out	0x27, r24	; 39
		TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
    2ae0:	ee e6       	ldi	r30, 0x6E	; 110
    2ae2:	f0 e0       	ldi	r31, 0x00	; 0
    2ae4:	80 81       	ld	r24, Z
    2ae6:	82 60       	ori	r24, 0x02	; 2
    2ae8:	80 83       	st	Z, r24
		TCNT0 = 0; //make sure timer/counter0 is actually 0.
    2aea:	16 bc       	out	0x26, r1	; 38
		
		if (note_number <= 1) {
    2aec:	ee a9       	sts	0x4e, r30
    2aee:	ff a9       	sts	0x4f, r31
    2af0:	e2 30       	cpi	r30, 0x02	; 2
    2af2:	f1 05       	cpc	r31, r1
    2af4:	24 f4       	brge	.+8      	; 0x2afe <tune_filter+0x1d4>
			
			//set timer/counter1 to /64 0.3125 MHz
			timer1_clock = (1<<CS11) | (1<<CS10);
    2af6:	83 e0       	ldi	r24, 0x03	; 3
    2af8:	80 93 7f 03 	sts	0x037F, r24
    2afc:	03 c0       	rjmp	.+6      	; 0x2b04 <tune_filter+0x1da>
			
		} else {
			
			//set timer/counter1 to /8 2.5 MHz
			timer1_clock = (1<<CS11);
    2afe:	82 e0       	ldi	r24, 0x02	; 2
    2b00:	80 93 7f 03 	sts	0x037F, r24
			
		}
		//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
		uint16_t reference_count = reference[note_number].count;
    2b04:	11 96       	adiw	r26, 0x01	; 1
    2b06:	2d 91       	ld	r18, X+
    2b08:	3c 91       	ld	r19, X
    2b0a:	12 97       	sbiw	r26, 0x02	; 2
    2b0c:	3b ab       	sts	0x5b, r19
    2b0e:	2a ab       	sts	0x5a, r18
		uint16_t pitch_cv = 0;
		for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
    2b10:	8d e0       	ldi	r24, 0x0D	; 13
    2b12:	90 e0       	ldi	r25, 0x00	; 0
    2b14:	9f a7       	lds	r25, 0x7f
    2b16:	8e a7       	lds	r24, 0x7e
			timer1_clock = (1<<CS11);
			
		}
		//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
		uint16_t reference_count = reference[note_number].count;
		uint16_t pitch_cv = 0;
    2b18:	ee 24       	eor	r14, r14
    2b1a:	ff 24       	eor	r15, r15
				set_control_voltage(&cutoff_cv, pitch_cv);
				set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
				set_control_voltage(&res_cv, MAX);
				set_control_voltage(&sustain_1_cv, MAX);
				set_control_voltage(&attack_1_cv, MIN); //keep attack at minimum
				set_control_voltage(&fil_lfo_cv, MIN);	//keep all filter modulation at a minimum
    2b1c:	0f 2e       	mov	r0, r31
    2b1e:	f1 ed       	ldi	r31, 0xD1	; 209
    2b20:	cf 2e       	mov	r12, r31
    2b22:	f1 e0       	ldi	r31, 0x01	; 1
    2b24:	df 2e       	mov	r13, r31
    2b26:	f0 2d       	mov	r31, r0
				set_control_voltage(&fil_eg2_cv, MIN);
    2b28:	0f 2e       	mov	r0, r31
    2b2a:	f6 ed       	ldi	r31, 0xD6	; 214
    2b2c:	8f 2e       	mov	r8, r31
    2b2e:	f1 e0       	ldi	r31, 0x01	; 1
    2b30:	9f 2e       	mov	r9, r31
    2b32:	f0 2d       	mov	r31, r0
		//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
		uint16_t reference_count = reference[note_number].count;
		uint16_t pitch_cv = 0;
		for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
		
			pitch_cv |= (1<<dac_bit);
    2b34:	81 e0       	ldi	r24, 0x01	; 1
    2b36:	90 e0       	ldi	r25, 0x00	; 0
    2b38:	fc 01       	movw	r30, r24
    2b3a:	0e a4       	lds	r16, 0xae
    2b3c:	02 c0       	rjmp	.+4      	; 0x2b42 <tune_filter+0x218>
    2b3e:	ee 0f       	add	r30, r30
    2b40:	ff 1f       	adc	r31, r31
    2b42:	0a 94       	dec	r0
    2b44:	e2 f7       	brpl	.-8      	; 0x2b3e <tune_filter+0x214>
    2b46:	f9 ab       	sts	0x59, r31
    2b48:	e8 ab       	sts	0x58, r30
    2b4a:	ee 2a       	or	r14, r30
    2b4c:	ff 2a       	or	r15, r31

			set_control_voltage(&cutoff_cv, pitch_cv);
    2b4e:	c5 01       	movw	r24, r10
    2b50:	b7 01       	movw	r22, r14
    2b52:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
			count_finished = FALSE;
    2b56:	10 92 7e 03 	sts	0x037E, r1
			period_counter = 0;
    2b5a:	10 92 81 03 	sts	0x0381, r1
		
			//enable watchdog timer
			wdt_enable(WDTO_2S);
    2b5e:	8f e0       	ldi	r24, 0x0F	; 15
    2b60:	28 e1       	ldi	r18, 0x18	; 24
    2b62:	30 e0       	ldi	r19, 0x00	; 0
    2b64:	0f b6       	in	r0, 0x3f	; 63
    2b66:	f8 94       	cli
    2b68:	a8 95       	wdr
    2b6a:	20 93 60 00 	sts	0x0060, r18
    2b6e:	0f be       	out	0x3f, r0	; 63
    2b70:	80 93 60 00 	sts	0x0060, r24
			while (count_finished == FALSE) {
    2b74:	80 91 7e 03 	lds	r24, 0x037E
    2b78:	88 23       	and	r24, r24
    2b7a:	b1 f5       	brne	.+108    	; 0x2be8 <tune_filter+0x2be>
				set_control_voltage(&res_cv, MAX);
				set_control_voltage(&sustain_1_cv, MAX);
				set_control_voltage(&attack_1_cv, MIN); //keep attack at minimum
				set_control_voltage(&fil_lfo_cv, MIN);	//keep all filter modulation at a minimum
				set_control_voltage(&fil_eg2_cv, MIN);
				set_control_voltage(&fil_vco2_cv, MIN);
    2b7c:	02 ed       	ldi	r16, 0xD2	; 210
    2b7e:	11 e0       	ldi	r17, 0x01	; 1
		
			//enable watchdog timer
			wdt_enable(WDTO_2S);
			while (count_finished == FALSE) {
				//update_display(vco_number + period + (compare_match_counter>>4)*100, DEC);
				update_display(300 + period, DEC);//
    2b80:	80 91 80 03 	lds	r24, 0x0380
    2b84:	90 e0       	ldi	r25, 0x00	; 0
    2b86:	84 5d       	subi	r24, 0xD4	; 212
    2b88:	9e 4f       	sbci	r25, 0xFE	; 254
    2b8a:	60 e0       	ldi	r22, 0x00	; 0
    2b8c:	0e 94 38 03 	call	0x670	; 0x670 <update_display>
				//value_to_display = TCNT0;
				//update_display(value_to_display, DEC);
				
		
				set_control_voltage(&cutoff_cv, pitch_cv);
    2b90:	c5 01       	movw	r24, r10
    2b92:	b7 01       	movw	r22, r14
    2b94:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
				set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
    2b98:	c3 01       	movw	r24, r6
    2b9a:	60 e0       	ldi	r22, 0x00	; 0
    2b9c:	70 e0       	ldi	r23, 0x00	; 0
    2b9e:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
				set_control_voltage(&res_cv, MAX);
    2ba2:	c2 01       	movw	r24, r4
    2ba4:	6f ef       	ldi	r22, 0xFF	; 255
    2ba6:	7f e3       	ldi	r23, 0x3F	; 63
    2ba8:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
				set_control_voltage(&sustain_1_cv, MAX);
    2bac:	c1 01       	movw	r24, r2
    2bae:	6f ef       	ldi	r22, 0xFF	; 255
    2bb0:	7f e3       	ldi	r23, 0x3F	; 63
    2bb2:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
				set_control_voltage(&attack_1_cv, MIN); //keep attack at minimum
    2bb6:	8e ec       	ldi	r24, 0xCE	; 206
    2bb8:	91 e0       	ldi	r25, 0x01	; 1
    2bba:	60 e0       	ldi	r22, 0x00	; 0
    2bbc:	70 e0       	ldi	r23, 0x00	; 0
    2bbe:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
				set_control_voltage(&fil_lfo_cv, MIN);	//keep all filter modulation at a minimum
    2bc2:	c6 01       	movw	r24, r12
    2bc4:	60 e0       	ldi	r22, 0x00	; 0
    2bc6:	70 e0       	ldi	r23, 0x00	; 0
    2bc8:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
				set_control_voltage(&fil_eg2_cv, MIN);
    2bcc:	c4 01       	movw	r24, r8
    2bce:	60 e0       	ldi	r22, 0x00	; 0
    2bd0:	70 e0       	ldi	r23, 0x00	; 0
    2bd2:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
				set_control_voltage(&fil_vco2_cv, MIN);
    2bd6:	c8 01       	movw	r24, r16
    2bd8:	60 e0       	ldi	r22, 0x00	; 0
    2bda:	70 e0       	ldi	r23, 0x00	; 0
    2bdc:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
			count_finished = FALSE;
			period_counter = 0;
		
			//enable watchdog timer
			wdt_enable(WDTO_2S);
			while (count_finished == FALSE) {
    2be0:	80 91 7e 03 	lds	r24, 0x037E
    2be4:	88 23       	and	r24, r24
    2be6:	61 f2       	breq	.-104    	; 0x2b80 <tune_filter+0x256>
				set_control_voltage(&fil_eg2_cv, MIN);
				set_control_voltage(&fil_vco2_cv, MIN);
						
			}
			//turn off watchdog timer
			wdt_disable();
    2be8:	88 e1       	ldi	r24, 0x18	; 24
    2bea:	0f b6       	in	r0, 0x3f	; 63
    2bec:	f8 94       	cli
    2bee:	80 93 60 00 	sts	0x0060, r24
    2bf2:	10 92 60 00 	sts	0x0060, r1
    2bf6:	0f be       	out	0x3f, r0	; 63
			//Omar changed this from <= to < which makes sense. <= was an error because if it's equal you don't want to clear the bit
			if ((osc_count <= reference_count) && (no_overflow == TRUE))pitch_cv &= ~(1<<dac_bit);
    2bf8:	80 91 7c 03 	lds	r24, 0x037C
    2bfc:	90 91 7d 03 	lds	r25, 0x037D
    2c00:	2a a9       	sts	0x4a, r18
    2c02:	3b a9       	sts	0x4b, r19
    2c04:	28 17       	cp	r18, r24
    2c06:	39 07       	cpc	r19, r25
    2c08:	50 f0       	brcs	.+20     	; 0x2c1e <tune_filter+0x2f4>
    2c0a:	80 91 af 02 	lds	r24, 0x02AF
    2c0e:	81 30       	cpi	r24, 0x01	; 1
    2c10:	31 f4       	brne	.+12     	; 0x2c1e <tune_filter+0x2f4>
    2c12:	88 a9       	sts	0x48, r24
    2c14:	99 a9       	sts	0x49, r25
    2c16:	80 95       	com	r24
    2c18:	90 95       	com	r25
    2c1a:	e8 22       	and	r14, r24
    2c1c:	f9 22       	and	r15, r25
		
			if (osc_count == reference_count && no_overflow == TRUE) {
    2c1e:	80 91 7c 03 	lds	r24, 0x037C
    2c22:	90 91 7d 03 	lds	r25, 0x037D
    2c26:	ea a9       	sts	0x4a, r30
    2c28:	fb a9       	sts	0x4b, r31
    2c2a:	8e 17       	cp	r24, r30
    2c2c:	9f 07       	cpc	r25, r31
    2c2e:	21 f4       	brne	.+8      	; 0x2c38 <tune_filter+0x30e>
    2c30:	80 91 af 02 	lds	r24, 0x02AF
    2c34:	81 30       	cpi	r24, 0x01	; 1
    2c36:	71 f0       	breq	.+28     	; 0x2c54 <tune_filter+0x32a>
				break;	//if you hit the reference count then get out of here
			}
			no_overflow = TRUE;
    2c38:	81 e0       	ldi	r24, 0x01	; 1
    2c3a:	80 93 af 02 	sts	0x02AF, r24
			
		}
		//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
		uint16_t reference_count = reference[note_number].count;
		uint16_t pitch_cv = 0;
		for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
    2c3e:	2e a5       	lds	r18, 0x6e
    2c40:	3f a5       	lds	r19, 0x6f
    2c42:	21 50       	subi	r18, 0x01	; 1
    2c44:	30 40       	sbci	r19, 0x00	; 0
    2c46:	3f a7       	lds	r19, 0x7f
    2c48:	2e a7       	lds	r18, 0x7e
    2c4a:	8f ef       	ldi	r24, 0xFF	; 255
    2c4c:	2f 3f       	cpi	r18, 0xFF	; 255
    2c4e:	38 07       	cpc	r19, r24
    2c50:	09 f0       	breq	.+2      	; 0x2c54 <tune_filter+0x32a>
    2c52:	70 cf       	rjmp	.-288    	; 0x2b34 <tune_filter+0x20a>
		
		
	}
	
	
	filter_pitch_table[note_number+1] = pitch_cv + 32; //32 is an offset that is trying to fix a bug somewhere else. This fix seems to work, but why 2^5 shift is required doesn't make sense to me yet. Need to look into this further
    2c54:	ee a9       	sts	0x4e, r30
    2c56:	ff a9       	sts	0x4f, r31
    2c58:	31 96       	adiw	r30, 0x01	; 1
    2c5a:	ff ab       	sts	0x5f, r31
    2c5c:	ee ab       	sts	0x5e, r30
    2c5e:	c7 01       	movw	r24, r14
    2c60:	80 96       	adiw	r24, 0x20	; 32
    2c62:	e8 ad       	sts	0x68, r30
    2c64:	f9 ad       	sts	0x69, r31
    2c66:	81 93       	st	Z+, r24
    2c68:	91 93       	st	Z+, r25
    2c6a:	f9 af       	sts	0x79, r31
    2c6c:	e8 af       	sts	0x78, r30
	
	//need to turn timer off here. This seems to have stopped periodic glitching of first note of first VCO tuned.
	TIMSK0 &= ~(1<<OCIE0A); //turn off timer0 compare match A interrupt
    2c6e:	ee e6       	ldi	r30, 0x6E	; 110
    2c70:	f0 e0       	ldi	r31, 0x00	; 0
    2c72:	80 81       	ld	r24, Z
    2c74:	8d 7f       	andi	r24, 0xFD	; 253
    2c76:	80 83       	st	Z, r24
	TCCR0A = 0; //turn off timer0
    2c78:	14 bc       	out	0x24, r1	; 36
    2c7a:	2c a9       	sts	0x4c, r18
    2c7c:	3d a9       	sts	0x4d, r19
    2c7e:	2d 5f       	subi	r18, 0xFD	; 253
    2c80:	3f 4f       	sbci	r19, 0xFF	; 255
    2c82:	3d ab       	sts	0x5d, r19
    2c84:	2c ab       	sts	0x5c, r18
	period = 1; //need to initialize to minimum period number here
	PORTF |= (1<<GATE); //turn gate on
	
	
	
	for (int note_number = 0; note_number <= 14; note_number++)
    2c86:	8e a9       	sts	0x4e, r24
    2c88:	9f a9       	sts	0x4f, r25
    2c8a:	8f 30       	cpi	r24, 0x0F	; 15
    2c8c:	91 05       	cpc	r25, r1
    2c8e:	09 f0       	breq	.+2      	; 0x2c92 <tune_filter+0x368>
    2c90:	1d cf       	rjmp	.-454    	; 0x2acc <tune_filter+0x1a2>
}


//eeprom_update_block((const void*)filter_pitch_table, (void*)filter_pitch_table_eeprom, sizeof(filter_pitch_table));

PORTF &= ~(1<<GATE); //turn gate off
    2c92:	89 98       	cbi	0x11, 1	; 17
	
	
}	
    2c94:	e9 96       	adiw	r28, 0x39	; 57
    2c96:	0f b6       	in	r0, 0x3f	; 63
    2c98:	f8 94       	cli
    2c9a:	de bf       	out	0x3e, r29	; 62
    2c9c:	0f be       	out	0x3f, r0	; 63
    2c9e:	cd bf       	out	0x3d, r28	; 61
    2ca0:	df 91       	pop	r29
    2ca2:	cf 91       	pop	r28
    2ca4:	1f 91       	pop	r17
    2ca6:	0f 91       	pop	r16
    2ca8:	ff 90       	pop	r15
    2caa:	ef 90       	pop	r14
    2cac:	df 90       	pop	r13
    2cae:	cf 90       	pop	r12
    2cb0:	bf 90       	pop	r11
    2cb2:	af 90       	pop	r10
    2cb4:	9f 90       	pop	r9
    2cb6:	8f 90       	pop	r8
    2cb8:	7f 90       	pop	r7
    2cba:	6f 90       	pop	r6
    2cbc:	5f 90       	pop	r5
    2cbe:	4f 90       	pop	r4
    2cc0:	3f 90       	pop	r3
    2cc2:	2f 90       	pop	r2
    2cc4:	08 95       	ret

00002cc6 <save_tuning_tables>:


void save_tuning_tables(void) { //write tuning tables to memory
	
	eeprom_update_block((const void*)filter_pitch_table, (void*)filter_pitch_table_eeprom, sizeof(filter_pitch_table));
    2cc6:	83 e1       	ldi	r24, 0x13	; 19
    2cc8:	93 e0       	ldi	r25, 0x03	; 3
    2cca:	6c e0       	ldi	r22, 0x0C	; 12
    2ccc:	76 e0       	ldi	r23, 0x06	; 6
    2cce:	40 e2       	ldi	r20, 0x20	; 32
    2cd0:	50 e0       	ldi	r21, 0x00	; 0
    2cd2:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <__eeupd_block_m6450a>
	eeprom_update_block((const void*)vco1_pitch_table, (void*)vco1_pitch_table_eeprom, sizeof(vco1_pitch_table));
    2cd6:	85 e5       	ldi	r24, 0x55	; 85
    2cd8:	93 e0       	ldi	r25, 0x03	; 3
    2cda:	6e e4       	ldi	r22, 0x4E	; 78
    2cdc:	76 e0       	ldi	r23, 0x06	; 6
    2cde:	42 e2       	ldi	r20, 0x22	; 34
    2ce0:	50 e0       	ldi	r21, 0x00	; 0
    2ce2:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <__eeupd_block_m6450a>
	eeprom_update_block((const void*)vco2_pitch_table, (void*)vco2_pitch_table_eeprom, sizeof(vco2_pitch_table));
    2ce6:	83 e3       	ldi	r24, 0x33	; 51
    2ce8:	93 e0       	ldi	r25, 0x03	; 3
    2cea:	6c e2       	ldi	r22, 0x2C	; 44
    2cec:	76 e0       	ldi	r23, 0x06	; 6
    2cee:	42 e2       	ldi	r20, 0x22	; 34
    2cf0:	50 e0       	ldi	r21, 0x00	; 0
    2cf2:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <__eeupd_block_m6450a>
	
	
}
    2cf6:	08 95       	ret

00002cf8 <load_tuning_tables>:

void load_tuning_tables(void) { //retrieve tuning tables from memory
	
	
	vco1_init_cv = eeprom_read_word(&vco1_init_cv_eeprom);
    2cf8:	82 e7       	ldi	r24, 0x72	; 114
    2cfa:	96 e0       	ldi	r25, 0x06	; 6
    2cfc:	0e 94 74 1f 	call	0x3ee8	; 0x3ee8 <__eerd_word_m6450a>
    2d00:	90 93 7a 03 	sts	0x037A, r25
    2d04:	80 93 79 03 	sts	0x0379, r24
	vco2_init_cv = eeprom_read_word(&vco2_init_cv_eeprom);
    2d08:	80 e7       	ldi	r24, 0x70	; 112
    2d0a:	96 e0       	ldi	r25, 0x06	; 6
    2d0c:	0e 94 74 1f 	call	0x3ee8	; 0x3ee8 <__eerd_word_m6450a>
    2d10:	90 93 78 03 	sts	0x0378, r25
    2d14:	80 93 77 03 	sts	0x0377, r24
	//uint16_t eeprom_addr = 0;
	//vco1_init_cv = eeprom_read_word((uint16_t*)eeprom_addr);
	//eeprom_addr += sizeof(vco2_init_cv);
	//vco2_init_cv = eeprom_read_word((uint16_t*)eeprom_addr);
	eeprom_read_block((void*)vco1_pitch_table, (const void*)vco1_pitch_table_eeprom, sizeof(vco1_pitch_table));
    2d18:	85 e5       	ldi	r24, 0x55	; 85
    2d1a:	93 e0       	ldi	r25, 0x03	; 3
    2d1c:	6e e4       	ldi	r22, 0x4E	; 78
    2d1e:	76 e0       	ldi	r23, 0x06	; 6
    2d20:	42 e2       	ldi	r20, 0x22	; 34
    2d22:	50 e0       	ldi	r21, 0x00	; 0
    2d24:	0e 94 64 1f 	call	0x3ec8	; 0x3ec8 <__eerd_block_m6450a>
	eeprom_read_block((void*)vco2_pitch_table, (const void*)vco2_pitch_table_eeprom, sizeof(vco2_pitch_table));
    2d28:	83 e3       	ldi	r24, 0x33	; 51
    2d2a:	93 e0       	ldi	r25, 0x03	; 3
    2d2c:	6c e2       	ldi	r22, 0x2C	; 44
    2d2e:	76 e0       	ldi	r23, 0x06	; 6
    2d30:	42 e2       	ldi	r20, 0x22	; 34
    2d32:	50 e0       	ldi	r21, 0x00	; 0
    2d34:	0e 94 64 1f 	call	0x3ec8	; 0x3ec8 <__eerd_block_m6450a>
	eeprom_read_block((void*)filter_pitch_table, (const void*)filter_pitch_table_eeprom, sizeof(filter_pitch_table));
    2d38:	83 e1       	ldi	r24, 0x13	; 19
    2d3a:	93 e0       	ldi	r25, 0x03	; 3
    2d3c:	6c e0       	ldi	r22, 0x0C	; 12
    2d3e:	76 e0       	ldi	r23, 0x06	; 6
    2d40:	40 e2       	ldi	r20, 0x20	; 32
    2d42:	50 e0       	ldi	r21, 0x00	; 0
    2d44:	0e 94 64 1f 	call	0x3ec8	; 0x3ec8 <__eerd_block_m6450a>
	
	//value_to_display = vco1_init_cv_eeprom;
	
}			
    2d48:	08 95       	ret

00002d4a <interpolate_pitch_cv>:
	
uint16_t interpolate_pitch_cv(uint8_t note, uint16_t *pitch_table) {
	
	uint8_t pitch_index = note>>3;
    2d4a:	98 2f       	mov	r25, r24
    2d4c:	96 95       	lsr	r25
    2d4e:	96 95       	lsr	r25
    2d50:	96 95       	lsr	r25
	uint8_t delta_note = note - pitch_index*8; //will range from 0 to 7
		
	uint16_t y0 = pitch_table[pitch_index -1];
    2d52:	29 2f       	mov	r18, r25
    2d54:	30 e0       	ldi	r19, 0x00	; 0
    2d56:	f9 01       	movw	r30, r18
    2d58:	31 97       	sbiw	r30, 0x01	; 1
    2d5a:	ee 0f       	add	r30, r30
    2d5c:	ff 1f       	adc	r31, r31
    2d5e:	e6 0f       	add	r30, r22
    2d60:	f7 1f       	adc	r31, r23
    2d62:	01 90       	ld	r0, Z+
    2d64:	f0 81       	ld	r31, Z
    2d66:	e0 2d       	mov	r30, r0
	uint16_t y1 = pitch_table[pitch_index];
    2d68:	22 0f       	add	r18, r18
    2d6a:	33 1f       	adc	r19, r19
    2d6c:	26 0f       	add	r18, r22
    2d6e:	37 1f       	adc	r19, r23
	
	uint16_t interpolated_pitch_cv = y0 + (((y1 - y0)*delta_note)>>3); //mind order of operations here: + is evaluated before >>	also, might be possible to optimize this with 16MUL8SHIFT8 from Anushri ASM util
    2d70:	d9 01       	movw	r26, r18
    2d72:	4d 91       	ld	r20, X+
    2d74:	5c 91       	ld	r21, X
    2d76:	11 97       	sbiw	r26, 0x01	; 1
    2d78:	4e 1b       	sub	r20, r30
    2d7a:	5f 0b       	sbc	r21, r31
}			
	
uint16_t interpolate_pitch_cv(uint8_t note, uint16_t *pitch_table) {
	
	uint8_t pitch_index = note>>3;
	uint8_t delta_note = note - pitch_index*8; //will range from 0 to 7
    2d7c:	99 0f       	add	r25, r25
    2d7e:	99 0f       	add	r25, r25
    2d80:	99 0f       	add	r25, r25
    2d82:	89 1b       	sub	r24, r25
		
	uint16_t y0 = pitch_table[pitch_index -1];
	uint16_t y1 = pitch_table[pitch_index];
	
	uint16_t interpolated_pitch_cv = y0 + (((y1 - y0)*delta_note)>>3); //mind order of operations here: + is evaluated before >>	also, might be possible to optimize this with 16MUL8SHIFT8 from Anushri ASM util
    2d84:	90 e0       	ldi	r25, 0x00	; 0
    2d86:	48 9f       	mul	r20, r24
    2d88:	90 01       	movw	r18, r0
    2d8a:	49 9f       	mul	r20, r25
    2d8c:	30 0d       	add	r19, r0
    2d8e:	58 9f       	mul	r21, r24
    2d90:	30 0d       	add	r19, r0
    2d92:	11 24       	eor	r1, r1
    2d94:	36 95       	lsr	r19
    2d96:	27 95       	ror	r18
    2d98:	36 95       	lsr	r19
    2d9a:	27 95       	ror	r18
    2d9c:	36 95       	lsr	r19
    2d9e:	27 95       	ror	r18
    2da0:	e2 0f       	add	r30, r18
    2da2:	f3 1f       	adc	r31, r19
	
	
	
	return interpolated_pitch_cv;
	
}
    2da4:	8e 2f       	mov	r24, r30
    2da6:	9f 2f       	mov	r25, r31
    2da8:	08 95       	ret

00002daa <set_one_volt_per_octave>:

void set_one_volt_per_octave(void) { //does this get stored in RAM? Should it go in progmem instead?
    2daa:	cf 93       	push	r28
    2dac:	df 93       	push	r29
    2dae:	cd b7       	in	r28, 0x3d	; 61
    2db0:	de b7       	in	r29, 0x3e	; 62
    2db2:	a2 97       	sbiw	r28, 0x22	; 34
    2db4:	0f b6       	in	r0, 0x3f	; 63
    2db6:	f8 94       	cli
    2db8:	de bf       	out	0x3e, r29	; 62
    2dba:	0f be       	out	0x3f, r0	; 63
    2dbc:	cd bf       	out	0x3d, r28	; 61
	
	uint16_t vpo_pitch_table[17] = {
    2dbe:	de 01       	movw	r26, r28
    2dc0:	11 96       	adiw	r26, 0x01	; 1
    2dc2:	ed e8       	ldi	r30, 0x8D	; 141
    2dc4:	f2 e0       	ldi	r31, 0x02	; 2
    2dc6:	82 e2       	ldi	r24, 0x22	; 34
    2dc8:	01 90       	ld	r0, Z+
    2dca:	0d 92       	st	X+, r0
    2dcc:	81 50       	subi	r24, 0x01	; 1
    2dce:	e1 f7       	brne	.-8      	; 0x2dc8 <set_one_volt_per_octave+0x1e>
		16384
		
	};
	
	
	memcpy((void*)vco1_pitch_table, (const void*)vpo_pitch_table, (size_t)sizeof(vpo_pitch_table));
    2dd0:	a5 e5       	ldi	r26, 0x55	; 85
    2dd2:	b3 e0       	ldi	r27, 0x03	; 3
    2dd4:	fe 01       	movw	r30, r28
    2dd6:	31 96       	adiw	r30, 0x01	; 1
    2dd8:	82 e2       	ldi	r24, 0x22	; 34
    2dda:	01 90       	ld	r0, Z+
    2ddc:	0d 92       	st	X+, r0
    2dde:	81 50       	subi	r24, 0x01	; 1
    2de0:	e1 f7       	brne	.-8      	; 0x2dda <set_one_volt_per_octave+0x30>
	memcpy((void*)vco2_pitch_table, (const void*)vpo_pitch_table, (size_t)sizeof(vpo_pitch_table));
    2de2:	a3 e3       	ldi	r26, 0x33	; 51
    2de4:	b3 e0       	ldi	r27, 0x03	; 3
    2de6:	fe 01       	movw	r30, r28
    2de8:	31 96       	adiw	r30, 0x01	; 1
    2dea:	82 e2       	ldi	r24, 0x22	; 34
    2dec:	01 90       	ld	r0, Z+
    2dee:	0d 92       	st	X+, r0
    2df0:	81 50       	subi	r24, 0x01	; 1
    2df2:	e1 f7       	brne	.-8      	; 0x2dec <set_one_volt_per_octave+0x42>
	
	
}
    2df4:	a2 96       	adiw	r28, 0x22	; 34
    2df6:	0f b6       	in	r0, 0x3f	; 63
    2df8:	f8 94       	cli
    2dfa:	de bf       	out	0x3e, r29	; 62
    2dfc:	0f be       	out	0x3f, r0	; 63
    2dfe:	cd bf       	out	0x3d, r28	; 61
    2e00:	df 91       	pop	r29
    2e02:	cf 91       	pop	r28
    2e04:	08 95       	ret

00002e06 <tune>:
void tune(void) {
	

			
			//turn off Timer1 output compare match now, it is used by the system clock
			TIMSK1 &= (1<<OCIE1A);
    2e06:	ef e6       	ldi	r30, 0x6F	; 111
    2e08:	f0 e0       	ldi	r31, 0x00	; 0
    2e0a:	80 81       	ld	r24, Z
    2e0c:	82 70       	andi	r24, 0x02	; 2
    2e0e:	80 83       	st	Z, r24
			//get rid of CTC here for Timer1 too
			TCCR1B &= ~(1<<WGM12); //turn off CTC
    2e10:	e1 e8       	ldi	r30, 0x81	; 129
    2e12:	f0 e0       	ldi	r31, 0x00	; 0
    2e14:	80 81       	ld	r24, Z
    2e16:	87 7f       	andi	r24, 0xF7	; 247
    2e18:	80 83       	st	Z, r24
			
			vco1_init_cv = set_vco_init_cv(VCO1, 24079);
    2e1a:	8f e0       	ldi	r24, 0x0F	; 15
    2e1c:	6f e0       	ldi	r22, 0x0F	; 15
    2e1e:	7e e5       	ldi	r23, 0x5E	; 94
    2e20:	0e 94 91 11 	call	0x2322	; 0x2322 <set_vco_init_cv>
    2e24:	90 93 7a 03 	sts	0x037A, r25
    2e28:	80 93 79 03 	sts	0x0379, r24
			vco2_init_cv = set_vco_init_cv(VCO2, 24079);
    2e2c:	80 ef       	ldi	r24, 0xF0	; 240
    2e2e:	6f e0       	ldi	r22, 0x0F	; 15
    2e30:	7e e5       	ldi	r23, 0x5E	; 94
    2e32:	0e 94 91 11 	call	0x2322	; 0x2322 <set_vco_init_cv>
    2e36:	90 93 78 03 	sts	0x0378, r25
    2e3a:	80 93 77 03 	sts	0x0377, r24
			//vco1_init_cv = vco2_init_cv;
			tune_8ths(VCO1);
    2e3e:	8f e0       	ldi	r24, 0x0F	; 15
    2e40:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <tune_8ths>
			tune_8ths(VCO2);
    2e44:	80 ef       	ldi	r24, 0xF0	; 240
    2e46:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <tune_8ths>
			tune_filter();
    2e4a:	0e 94 95 14 	call	0x292a	; 0x292a <tune_filter>
			save_tuning_tables();
    2e4e:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <save_tuning_tables>
    2e52:	8f e4       	ldi	r24, 0x4F	; 79
    2e54:	93 ec       	ldi	r25, 0xC3	; 195
    2e56:	01 97       	sbiw	r24, 0x01	; 1
    2e58:	f1 f7       	brne	.-4      	; 0x2e56 <tune+0x50>
    2e5a:	00 c0       	rjmp	.+0      	; 0x2e5c <tune+0x56>
    2e5c:	00 00       	nop
			_delay_ms(200);	//give some time for release to decay to avoid pops
			
			//need to restore Timer1 settings. This currently happens after the function is called, but should really be included here
	
    2e5e:	08 95       	ret

00002e60 <read_switch_port>:
uint8_t read_switch_port(void) {
	
	static uint8_t previous_port_state = 0;
	static uint16_t prog_hold_counter = 0;
	
	uint8_t current_port_state = SWITCH_PORT; //read switch state byte
    2e60:	8f b1       	in	r24, 0x0f	; 15
	switch_press |= current_port_state & 0b00001100; //mask for four PROG buttons 
    2e62:	98 2f       	mov	r25, r24
    2e64:	9c 70       	andi	r25, 0x0C	; 12
    2e66:	20 91 c5 02 	lds	r18, 0x02C5
    2e6a:	92 2b       	or	r25, r18
    2e6c:	90 93 c5 02 	sts	0x02C5, r25
	
	if ((current_port_state >> PROG_DOWN_SW) & 1) { //press and hold handler for PROG DOWN switch. Should have a general framework for handling switch presses and holds
    2e70:	98 2f       	mov	r25, r24
    2e72:	92 95       	swap	r25
    2e74:	96 95       	lsr	r25
    2e76:	97 70       	andi	r25, 0x07	; 7
    2e78:	90 ff       	sbrs	r25, 0
    2e7a:	16 c0       	rjmp	.+44     	; 0x2ea8 <read_switch_port+0x48>
		
		if (++prog_hold_counter == 600) { //problem here is that the hold time is dependent on main loop execution speed. Could maybe somehow link this to Timer1, which is running at constant /1024
    2e7c:	20 91 85 03 	lds	r18, 0x0385
    2e80:	30 91 86 03 	lds	r19, 0x0386
    2e84:	2f 5f       	subi	r18, 0xFF	; 255
    2e86:	3f 4f       	sbci	r19, 0xFF	; 255
    2e88:	30 93 86 03 	sts	0x0386, r19
    2e8c:	20 93 85 03 	sts	0x0385, r18
    2e90:	92 e0       	ldi	r25, 0x02	; 2
    2e92:	28 35       	cpi	r18, 0x58	; 88
    2e94:	39 07       	cpc	r19, r25
    2e96:	61 f4       	brne	.+24     	; 0x2eb0 <read_switch_port+0x50>
			
			prog_hold_counter = 0; //shouldn't need this as prog_hold_counter will overflow to 0 on next press
    2e98:	10 92 86 03 	sts	0x0386, r1
    2e9c:	10 92 85 03 	sts	0x0385, r1
			current_patch.mode = CAL;
    2ea0:	95 e0       	ldi	r25, 0x05	; 5
    2ea2:	90 93 0b 03 	sts	0x030B, r25
    2ea6:	04 c0       	rjmp	.+8      	; 0x2eb0 <read_switch_port+0x50>
			
		}
		
	} else { prog_hold_counter = 0;} //reset counter to 0
    2ea8:	10 92 86 03 	sts	0x0386, r1
    2eac:	10 92 85 03 	sts	0x0385, r1
		
	//this toggle code works, but I haven't figured out how it works
	//source: http://forum.allaboutcircuits.com/threads/help-with-programming-uc-toggle-led-using-one-switch.51602/	
	current_port_state ^= previous_port_state;
    2eb0:	90 91 87 03 	lds	r25, 0x0387
    2eb4:	89 27       	eor	r24, r25
	previous_port_state ^= current_port_state;
    2eb6:	98 27       	eor	r25, r24
    2eb8:	90 93 87 03 	sts	0x0387, r25
	current_port_state &= previous_port_state;
	
	return current_port_state;
	
}
    2ebc:	89 23       	and	r24, r25
    2ebe:	08 95       	ret

00002ec0 <update_analog_switch_latch>:

void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    2ec0:	ed ed       	ldi	r30, 0xDD	; 221
    2ec2:	f0 e0       	ldi	r31, 0x00	; 0
    2ec4:	90 81       	ld	r25, Z
    2ec6:	9f 7b       	andi	r25, 0xBF	; 191
    2ec8:	90 83       	st	Z, r25
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
	((switch_state_byte >> VCO_SYNC_SW) & 1) << VCO_SYNC_LATCH_BIT |
	((switch_state_byte >> VCO1_SAW_SW) & 1) << VCO1_SAW_LATCH_BIT |
	((switch_state_byte >> VCO1_TRI_SW) & 1) << VCO1_TRI_LATCH_BIT |
	((switch_state_byte >> VCO1_PULSE_SW) & 1) << VCO1_PULSE_LATCH_BIT |
    2eca:	28 2f       	mov	r18, r24
    2ecc:	30 e0       	ldi	r19, 0x00	; 0
    2ece:	21 70       	andi	r18, 0x01	; 1
    2ed0:	30 70       	andi	r19, 0x00	; 0
    2ed2:	22 0f       	add	r18, r18
    2ed4:	33 1f       	adc	r19, r19
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
	((switch_state_byte >> VCO2_TRI_SW) & 1) << VCO2_TRI_LATCH_BIT |
    2ed6:	68 2f       	mov	r22, r24
    2ed8:	62 95       	swap	r22
    2eda:	66 95       	lsr	r22
    2edc:	67 70       	andi	r22, 0x07	; 7
    2ede:	67 95       	ror	r22
    2ee0:	66 27       	eor	r22, r22
    2ee2:	67 95       	ror	r22
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2ee4:	26 2b       	or	r18, r22
    2ee6:	98 2f       	mov	r25, r24
    2ee8:	96 95       	lsr	r25
    2eea:	96 95       	lsr	r25
    2eec:	91 70       	andi	r25, 0x01	; 1
    2eee:	29 2b       	or	r18, r25
	((switch_state_byte >> VCO_SYNC_SW) & 1) << VCO_SYNC_LATCH_BIT |
    2ef0:	68 2f       	mov	r22, r24
    2ef2:	66 1f       	adc	r22, r22
    2ef4:	66 27       	eor	r22, r22
    2ef6:	66 1f       	adc	r22, r22
    2ef8:	66 0f       	add	r22, r22
    2efa:	66 0f       	add	r22, r22
    2efc:	66 0f       	add	r22, r22
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2efe:	26 2b       	or	r18, r22
	((switch_state_byte >> VCO_SYNC_SW) & 1) << VCO_SYNC_LATCH_BIT |
	((switch_state_byte >> VCO1_SAW_SW) & 1) << VCO1_SAW_LATCH_BIT |
	((switch_state_byte >> VCO1_TRI_SW) & 1) << VCO1_TRI_LATCH_BIT |
    2f00:	a8 2f       	mov	r26, r24
    2f02:	a6 95       	lsr	r26
    2f04:	b0 e0       	ldi	r27, 0x00	; 0
    2f06:	a1 70       	andi	r26, 0x01	; 1
    2f08:	b0 70       	andi	r27, 0x00	; 0
    2f0a:	bd 01       	movw	r22, r26
    2f0c:	66 0f       	add	r22, r22
    2f0e:	77 1f       	adc	r23, r23
    2f10:	66 0f       	add	r22, r22
    2f12:	77 1f       	adc	r23, r23
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2f14:	26 2b       	or	r18, r22
	((switch_state_byte >> VCO_SYNC_SW) & 1) << VCO_SYNC_LATCH_BIT |
	((switch_state_byte >> VCO1_SAW_SW) & 1) << VCO1_SAW_LATCH_BIT |
	((switch_state_byte >> VCO1_TRI_SW) & 1) << VCO1_TRI_LATCH_BIT |
	((switch_state_byte >> VCO1_PULSE_SW) & 1) << VCO1_PULSE_LATCH_BIT |
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
    2f16:	68 2f       	mov	r22, r24
    2f18:	62 95       	swap	r22
    2f1a:	6f 70       	andi	r22, 0x0F	; 15
    2f1c:	70 e0       	ldi	r23, 0x00	; 0
    2f1e:	61 70       	andi	r22, 0x01	; 1
    2f20:	70 70       	andi	r23, 0x00	; 0
    2f22:	ab 01       	movw	r20, r22
    2f24:	00 24       	eor	r0, r0
    2f26:	56 95       	lsr	r21
    2f28:	47 95       	ror	r20
    2f2a:	07 94       	ror	r0
    2f2c:	56 95       	lsr	r21
    2f2e:	47 95       	ror	r20
    2f30:	07 94       	ror	r0
    2f32:	54 2f       	mov	r21, r20
    2f34:	40 2d       	mov	r20, r0
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2f36:	62 2f       	mov	r22, r18
    2f38:	64 2b       	or	r22, r20
	((switch_state_byte >> VCO1_SAW_SW) & 1) << VCO1_SAW_LATCH_BIT |
	((switch_state_byte >> VCO1_TRI_SW) & 1) << VCO1_TRI_LATCH_BIT |
	((switch_state_byte >> VCO1_PULSE_SW) & 1) << VCO1_PULSE_LATCH_BIT |
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
	((switch_state_byte >> VCO2_TRI_SW) & 1) << VCO2_TRI_LATCH_BIT |
	((switch_state_byte >> VCO2_PULSE_SW) & 1) << VCO2_PULSE_LATCH_BIT |
    2f3a:	48 2f       	mov	r20, r24
    2f3c:	42 95       	swap	r20
    2f3e:	46 95       	lsr	r20
    2f40:	46 95       	lsr	r20
    2f42:	43 70       	andi	r20, 0x03	; 3
    2f44:	50 e0       	ldi	r21, 0x00	; 0
    2f46:	41 70       	andi	r20, 0x01	; 1
    2f48:	50 70       	andi	r21, 0x00	; 0
    2f4a:	9a 01       	movw	r18, r20
    2f4c:	22 0f       	add	r18, r18
    2f4e:	33 1f       	adc	r19, r19
    2f50:	22 95       	swap	r18
    2f52:	32 95       	swap	r19
    2f54:	30 7f       	andi	r19, 0xF0	; 240
    2f56:	32 27       	eor	r19, r18
    2f58:	20 7f       	andi	r18, 0xF0	; 240
    2f5a:	32 27       	eor	r19, r18
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2f5c:	46 2f       	mov	r20, r22
    2f5e:	42 2b       	or	r20, r18
	((switch_state_byte >> VCO1_PULSE_SW) & 1) << VCO1_PULSE_LATCH_BIT |
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
	((switch_state_byte >> VCO2_TRI_SW) & 1) << VCO2_TRI_LATCH_BIT |
	((switch_state_byte >> VCO2_PULSE_SW) & 1) << VCO2_PULSE_LATCH_BIT |
	//BMOD_SW_ON << BMOD_LATCH_BIT;
	((switch_state_byte >> 3) & 1) << BMOD_LATCH_BIT;
    2f60:	86 95       	lsr	r24
    2f62:	86 95       	lsr	r24
    2f64:	86 95       	lsr	r24
    2f66:	28 2f       	mov	r18, r24
    2f68:	30 e0       	ldi	r19, 0x00	; 0
    2f6a:	21 70       	andi	r18, 0x01	; 1
    2f6c:	30 70       	andi	r19, 0x00	; 0
    2f6e:	c9 01       	movw	r24, r18
    2f70:	82 95       	swap	r24
    2f72:	92 95       	swap	r25
    2f74:	90 7f       	andi	r25, 0xF0	; 240
    2f76:	98 27       	eor	r25, r24
    2f78:	80 7f       	andi	r24, 0xF0	; 240
    2f7a:	98 27       	eor	r25, r24
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2f7c:	84 2b       	or	r24, r20
    2f7e:	82 b9       	out	0x02, r24	; 2
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
	((switch_state_byte >> VCO2_TRI_SW) & 1) << VCO2_TRI_LATCH_BIT |
	((switch_state_byte >> VCO2_PULSE_SW) & 1) << VCO2_PULSE_LATCH_BIT |
	//BMOD_SW_ON << BMOD_LATCH_BIT;
	((switch_state_byte >> 3) & 1) << BMOD_LATCH_BIT;
	VCO_SW_LATCH_PORT |= (1<<VCO_SW_LATCH);
    2f80:	80 81       	ld	r24, Z
    2f82:	80 64       	ori	r24, 0x40	; 64
    2f84:	80 83       	st	Z, r24
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    2f86:	80 81       	ld	r24, Z
    2f88:	8f 7b       	andi	r24, 0xBF	; 191
    2f8a:	80 83       	st	Z, r24
	DATA_BUS = 0;
    2f8c:	12 b8       	out	0x02, r1	; 2
	
	
    2f8e:	08 95       	ret

00002f90 <bytequeue_init>:
//along with avr-bytequeue.  If not, see <http://www.gnu.org/licenses/>.

#include "bytequeue.h"
#include "interrupt_setting.h"

void bytequeue_init(byteQueue_t * queue, uint8_t * dataArray, byteQueueIndex_t arrayLen){
    2f90:	fc 01       	movw	r30, r24
   queue->length = arrayLen;
    2f92:	42 83       	std	Z+2, r20	; 0x02
   queue->data = dataArray;
    2f94:	74 83       	std	Z+4, r23	; 0x04
    2f96:	63 83       	std	Z+3, r22	; 0x03
   queue->start = queue->end = 0;
    2f98:	11 82       	std	Z+1, r1	; 0x01
    2f9a:	10 82       	st	Z, r1
}
    2f9c:	08 95       	ret

00002f9e <bytequeue_enqueue>:

bool bytequeue_enqueue(byteQueue_t * queue, uint8_t item){
    2f9e:	1f 93       	push	r17
    2fa0:	cf 93       	push	r28
    2fa2:	df 93       	push	r29
    2fa4:	ec 01       	movw	r28, r24
    2fa6:	16 2f       	mov	r17, r22
   interrupt_setting_t setting = store_and_clear_interrupt();
    2fa8:	0e 94 3e 18 	call	0x307c	; 0x307c <store_and_clear_interrupt>
    2fac:	28 2f       	mov	r18, r24
   //full
   if(((queue->end + 1) % queue->length) == queue->start){
    2fae:	39 81       	ldd	r19, Y+1	; 0x01
    2fb0:	83 2f       	mov	r24, r19
    2fb2:	90 e0       	ldi	r25, 0x00	; 0
    2fb4:	01 96       	adiw	r24, 0x01	; 1
    2fb6:	6a 81       	ldd	r22, Y+2	; 0x02
    2fb8:	70 e0       	ldi	r23, 0x00	; 0
    2fba:	0e 94 b6 1e 	call	0x3d6c	; 0x3d6c <__divmodhi4>
    2fbe:	48 81       	ld	r20, Y
    2fc0:	50 e0       	ldi	r21, 0x00	; 0
    2fc2:	84 17       	cp	r24, r20
    2fc4:	95 07       	cpc	r25, r21
    2fc6:	29 f4       	brne	.+10     	; 0x2fd2 <bytequeue_enqueue+0x34>
      restore_interrupt_setting(setting);
    2fc8:	82 2f       	mov	r24, r18
    2fca:	0e 94 41 18 	call	0x3082	; 0x3082 <restore_interrupt_setting>
      return false;
    2fce:	80 e0       	ldi	r24, 0x00	; 0
    2fd0:	11 c0       	rjmp	.+34     	; 0x2ff4 <bytequeue_enqueue+0x56>
   } else {
      queue->data[queue->end] = item;
    2fd2:	eb 81       	ldd	r30, Y+3	; 0x03
    2fd4:	fc 81       	ldd	r31, Y+4	; 0x04
    2fd6:	e3 0f       	add	r30, r19
    2fd8:	f1 1d       	adc	r31, r1
    2fda:	10 83       	st	Z, r17
      queue->end = (queue->end + 1) % queue->length;
    2fdc:	89 81       	ldd	r24, Y+1	; 0x01
    2fde:	90 e0       	ldi	r25, 0x00	; 0
    2fe0:	01 96       	adiw	r24, 0x01	; 1
    2fe2:	6a 81       	ldd	r22, Y+2	; 0x02
    2fe4:	70 e0       	ldi	r23, 0x00	; 0
    2fe6:	0e 94 b6 1e 	call	0x3d6c	; 0x3d6c <__divmodhi4>
    2fea:	89 83       	std	Y+1, r24	; 0x01
      restore_interrupt_setting(setting);
    2fec:	82 2f       	mov	r24, r18
    2fee:	0e 94 41 18 	call	0x3082	; 0x3082 <restore_interrupt_setting>
      return true;
    2ff2:	81 e0       	ldi	r24, 0x01	; 1
   }
}
    2ff4:	df 91       	pop	r29
    2ff6:	cf 91       	pop	r28
    2ff8:	1f 91       	pop	r17
    2ffa:	08 95       	ret

00002ffc <bytequeue_length>:

byteQueueIndex_t bytequeue_length(byteQueue_t * queue){
    2ffc:	cf 93       	push	r28
    2ffe:	df 93       	push	r29
    3000:	ec 01       	movw	r28, r24
   byteQueueIndex_t len;
   interrupt_setting_t setting = store_and_clear_interrupt();
    3002:	0e 94 3e 18 	call	0x307c	; 0x307c <store_and_clear_interrupt>
   if(queue->end >= queue->start)
    3006:	29 81       	ldd	r18, Y+1	; 0x01
    3008:	98 81       	ld	r25, Y
    300a:	29 17       	cp	r18, r25
    300c:	18 f0       	brcs	.+6      	; 0x3014 <bytequeue_length+0x18>
      len = queue->end - queue->start;
    300e:	c2 2f       	mov	r28, r18
    3010:	c9 1b       	sub	r28, r25
    3012:	03 c0       	rjmp	.+6      	; 0x301a <bytequeue_length+0x1e>
   else
      len = (queue->length - queue->start) + queue->end;
    3014:	ca 81       	ldd	r28, Y+2	; 0x02
    3016:	c2 0f       	add	r28, r18
    3018:	c9 1b       	sub	r28, r25
   restore_interrupt_setting(setting);
    301a:	0e 94 41 18 	call	0x3082	; 0x3082 <restore_interrupt_setting>
   return len;
}
    301e:	8c 2f       	mov	r24, r28
    3020:	df 91       	pop	r29
    3022:	cf 91       	pop	r28
    3024:	08 95       	ret

00003026 <bytequeue_get>:

//we don't need to avoid interrupts if there is only one reader
uint8_t bytequeue_get(byteQueue_t * queue, byteQueueIndex_t index){
    3026:	fc 01       	movw	r30, r24
   return queue->data[(queue->start + index) % queue->length];
    3028:	20 81       	ld	r18, Z
    302a:	86 2f       	mov	r24, r22
    302c:	90 e0       	ldi	r25, 0x00	; 0
    302e:	82 0f       	add	r24, r18
    3030:	91 1d       	adc	r25, r1
    3032:	62 81       	ldd	r22, Z+2	; 0x02
    3034:	70 e0       	ldi	r23, 0x00	; 0
    3036:	0e 94 b6 1e 	call	0x3d6c	; 0x3d6c <__divmodhi4>
    303a:	03 80       	ldd	r0, Z+3	; 0x03
    303c:	f4 81       	ldd	r31, Z+4	; 0x04
    303e:	e0 2d       	mov	r30, r0
    3040:	e8 0f       	add	r30, r24
    3042:	f9 1f       	adc	r31, r25
}
    3044:	80 81       	ld	r24, Z
    3046:	08 95       	ret

00003048 <bytequeue_remove>:

//we just update the start index to remove elements
void bytequeue_remove(byteQueue_t * queue, byteQueueIndex_t numToRemove){
    3048:	1f 93       	push	r17
    304a:	cf 93       	push	r28
    304c:	df 93       	push	r29
    304e:	ec 01       	movw	r28, r24
    3050:	16 2f       	mov	r17, r22
   interrupt_setting_t setting = store_and_clear_interrupt();
    3052:	0e 94 3e 18 	call	0x307c	; 0x307c <store_and_clear_interrupt>
    3056:	48 2f       	mov	r20, r24
   queue->start = (queue->start + numToRemove) % queue->length;
    3058:	88 81       	ld	r24, Y
    305a:	21 2f       	mov	r18, r17
    305c:	30 e0       	ldi	r19, 0x00	; 0
    305e:	28 0f       	add	r18, r24
    3060:	31 1d       	adc	r19, r1
    3062:	6a 81       	ldd	r22, Y+2	; 0x02
    3064:	c9 01       	movw	r24, r18
    3066:	70 e0       	ldi	r23, 0x00	; 0
    3068:	0e 94 b6 1e 	call	0x3d6c	; 0x3d6c <__divmodhi4>
    306c:	88 83       	st	Y, r24
   restore_interrupt_setting(setting);
    306e:	84 2f       	mov	r24, r20
    3070:	0e 94 41 18 	call	0x3082	; 0x3082 <restore_interrupt_setting>
}
    3074:	df 91       	pop	r29
    3076:	cf 91       	pop	r28
    3078:	1f 91       	pop	r17
    307a:	08 95       	ret

0000307c <store_and_clear_interrupt>:

#include "interrupt_setting.h"
#include <avr/interrupt.h>

interrupt_setting_t store_and_clear_interrupt(void) {
   uint8_t sreg = SREG;
    307c:	8f b7       	in	r24, 0x3f	; 63
   cli();
    307e:	f8 94       	cli
   return sreg;
}
    3080:	08 95       	ret

00003082 <restore_interrupt_setting>:

void restore_interrupt_setting(interrupt_setting_t setting) {
   SREG = setting;
    3082:	8f bf       	out	0x3f, r24	; 63
}
    3084:	08 95       	ret

00003086 <midi_is_statusbyte>:
#define NULL 0
#endif

bool midi_is_statusbyte(uint8_t theByte){
   return (bool)(theByte & MIDI_STATUSMASK);
}
    3086:	88 1f       	adc	r24, r24
    3088:	88 27       	eor	r24, r24
    308a:	88 1f       	adc	r24, r24
    308c:	08 95       	ret

0000308e <midi_is_realtime>:

bool midi_is_realtime(uint8_t theByte){
   return (theByte >= MIDI_CLOCK);
    308e:	91 e0       	ldi	r25, 0x01	; 1
    3090:	88 3f       	cpi	r24, 0xF8	; 248
    3092:	08 f4       	brcc	.+2      	; 0x3096 <midi_is_realtime+0x8>
    3094:	90 e0       	ldi	r25, 0x00	; 0
}
    3096:	89 2f       	mov	r24, r25
    3098:	08 95       	ret

0000309a <midi_packet_length>:

midi_packet_length_t midi_packet_length(uint8_t status){
   switch(status & 0xF0){
    309a:	28 2f       	mov	r18, r24
    309c:	30 e0       	ldi	r19, 0x00	; 0
    309e:	20 7f       	andi	r18, 0xF0	; 240
    30a0:	30 70       	andi	r19, 0x00	; 0
    30a2:	20 3c       	cpi	r18, 0xC0	; 192
    30a4:	31 05       	cpc	r19, r1
    30a6:	e9 f1       	breq	.+122    	; 0x3122 <midi_packet_length+0x88>
    30a8:	21 3c       	cpi	r18, 0xC1	; 193
    30aa:	31 05       	cpc	r19, r1
    30ac:	8c f4       	brge	.+34     	; 0x30d0 <midi_packet_length+0x36>
    30ae:	20 39       	cpi	r18, 0x90	; 144
    30b0:	31 05       	cpc	r19, r1
    30b2:	e1 f0       	breq	.+56     	; 0x30ec <midi_packet_length+0x52>
    30b4:	21 39       	cpi	r18, 0x91	; 145
    30b6:	31 05       	cpc	r19, r1
    30b8:	24 f4       	brge	.+8      	; 0x30c2 <midi_packet_length+0x28>
    30ba:	20 38       	cpi	r18, 0x80	; 128
    30bc:	31 05       	cpc	r19, r1
    30be:	79 f5       	brne	.+94     	; 0x311e <midi_packet_length+0x84>
    30c0:	15 c0       	rjmp	.+42     	; 0x30ec <midi_packet_length+0x52>
    30c2:	20 3a       	cpi	r18, 0xA0	; 160
    30c4:	31 05       	cpc	r19, r1
    30c6:	91 f0       	breq	.+36     	; 0x30ec <midi_packet_length+0x52>
    30c8:	20 3b       	cpi	r18, 0xB0	; 176
    30ca:	31 05       	cpc	r19, r1
    30cc:	41 f5       	brne	.+80     	; 0x311e <midi_packet_length+0x84>
    30ce:	0e c0       	rjmp	.+28     	; 0x30ec <midi_packet_length+0x52>
    30d0:	20 3e       	cpi	r18, 0xE0	; 224
    30d2:	31 05       	cpc	r19, r1
    30d4:	59 f0       	breq	.+22     	; 0x30ec <midi_packet_length+0x52>
    30d6:	21 3e       	cpi	r18, 0xE1	; 225
    30d8:	31 05       	cpc	r19, r1
    30da:	24 f4       	brge	.+8      	; 0x30e4 <midi_packet_length+0x4a>
    30dc:	20 3d       	cpi	r18, 0xD0	; 208
    30de:	31 05       	cpc	r19, r1
    30e0:	f1 f4       	brne	.+60     	; 0x311e <midi_packet_length+0x84>
    30e2:	1f c0       	rjmp	.+62     	; 0x3122 <midi_packet_length+0x88>
    30e4:	20 3f       	cpi	r18, 0xF0	; 240
    30e6:	31 05       	cpc	r19, r1
    30e8:	d1 f4       	brne	.+52     	; 0x311e <midi_packet_length+0x84>
    30ea:	02 c0       	rjmp	.+4      	; 0x30f0 <midi_packet_length+0x56>
      case MIDI_CC:
      case MIDI_NOTEON:
      case MIDI_NOTEOFF:
      case MIDI_AFTERTOUCH:
      case MIDI_PITCHBEND:
         return THREE3;
    30ec:	83 e0       	ldi	r24, 0x03	; 3
    30ee:	08 95       	ret
      case MIDI_PROGCHANGE:
      case MIDI_CHANPRESSURE:
      case MIDI_SONGSELECT:
         return TWO2;
      case 0xF0:
         switch(status) {
    30f0:	86 3f       	cpi	r24, 0xF6	; 246
    30f2:	79 f0       	breq	.+30     	; 0x3112 <midi_packet_length+0x78>
    30f4:	87 3f       	cpi	r24, 0xF7	; 247
    30f6:	38 f4       	brcc	.+14     	; 0x3106 <midi_packet_length+0x6c>
    30f8:	82 3f       	cpi	r24, 0xF2	; 242
    30fa:	a9 f0       	breq	.+42     	; 0x3126 <midi_packet_length+0x8c>
    30fc:	83 3f       	cpi	r24, 0xF3	; 243
    30fe:	59 f0       	breq	.+22     	; 0x3116 <midi_packet_length+0x7c>
    3100:	81 3f       	cpi	r24, 0xF1	; 241
    3102:	59 f4       	brne	.+22     	; 0x311a <midi_packet_length+0x80>
    3104:	08 c0       	rjmp	.+16     	; 0x3116 <midi_packet_length+0x7c>
    3106:	88 3f       	cpi	r24, 0xF8	; 248
    3108:	40 f0       	brcs	.+16     	; 0x311a <midi_packet_length+0x80>
    310a:	8d 3f       	cpi	r24, 0xFD	; 253
    310c:	10 f0       	brcs	.+4      	; 0x3112 <midi_packet_length+0x78>
    310e:	8e 3f       	cpi	r24, 0xFE	; 254
    3110:	20 f0       	brcs	.+8      	; 0x311a <midi_packet_length+0x80>
            case MIDI_CONTINUE:
            case MIDI_STOP:
            case MIDI_ACTIVESENSE:
            case MIDI_RESET:
            case MIDI_TUNEREQUEST:
               return ONE1;
    3112:	81 e0       	ldi	r24, 0x01	; 1
    3114:	08 95       	ret
            case MIDI_SONGPOSITION:
               return THREE3;
            case MIDI_TC_QUARTERFRAME:
            case MIDI_SONGSELECT:
               return TWO2;
    3116:	82 e0       	ldi	r24, 0x02	; 2
    3118:	08 95       	ret
            case SYSEX_END:
            case SYSEX_BEGIN:
            default:
               return UNDEFINED;
    311a:	80 e0       	ldi	r24, 0x00	; 0
    311c:	08 95       	ret
         }
      default:
         return UNDEFINED;
    311e:	80 e0       	ldi	r24, 0x00	; 0
    3120:	08 95       	ret
      case MIDI_PITCHBEND:
         return THREE3;
      case MIDI_PROGCHANGE:
      case MIDI_CHANPRESSURE:
      case MIDI_SONGSELECT:
         return TWO2;
    3122:	82 e0       	ldi	r24, 0x02	; 2
    3124:	08 95       	ret
            case MIDI_ACTIVESENSE:
            case MIDI_RESET:
            case MIDI_TUNEREQUEST:
               return ONE1;
            case MIDI_SONGPOSITION:
               return THREE3;
    3126:	83 e0       	ldi	r24, 0x03	; 3
               return UNDEFINED;
         }
      default:
         return UNDEFINED;
   }
}
    3128:	08 95       	ret

0000312a <midi_send_cc>:

void midi_send_cc(MidiDevice * device, uint8_t chan, uint8_t num, uint8_t val){
    312a:	0f 93       	push	r16
    312c:	34 2f       	mov	r19, r20
    312e:	02 2f       	mov	r16, r18
   //CC Status: 0xB0 to 0xBF where the low nibble is the MIDI channel.
   //CC Data: Controller Num, Controller Val
   device->send_func(device, 3,
    3130:	46 2f       	mov	r20, r22
    3132:	4f 70       	andi	r20, 0x0F	; 15
    3134:	40 6b       	ori	r20, 0xB0	; 176
    3136:	23 2f       	mov	r18, r19
    3138:	2f 77       	andi	r18, 0x7F	; 127
    313a:	0f 77       	andi	r16, 0x7F	; 127
    313c:	dc 01       	movw	r26, r24
    313e:	ed 91       	ld	r30, X+
    3140:	fc 91       	ld	r31, X
    3142:	63 e0       	ldi	r22, 0x03	; 3
    3144:	70 e0       	ldi	r23, 0x00	; 0
    3146:	09 95       	icall
         MIDI_CC | (chan & MIDI_CHANMASK),
         num & 0x7F,
         val & 0x7F);
}
    3148:	0f 91       	pop	r16
    314a:	08 95       	ret

0000314c <midi_send_noteon>:

void midi_send_noteon(MidiDevice * device, uint8_t chan, uint8_t num, uint8_t vel){
    314c:	0f 93       	push	r16
    314e:	34 2f       	mov	r19, r20
    3150:	02 2f       	mov	r16, r18
   //Note Data: Note Num, Note Velocity
   device->send_func(device, 3,
    3152:	46 2f       	mov	r20, r22
    3154:	4f 70       	andi	r20, 0x0F	; 15
    3156:	40 69       	ori	r20, 0x90	; 144
    3158:	23 2f       	mov	r18, r19
    315a:	2f 77       	andi	r18, 0x7F	; 127
    315c:	0f 77       	andi	r16, 0x7F	; 127
    315e:	dc 01       	movw	r26, r24
    3160:	ed 91       	ld	r30, X+
    3162:	fc 91       	ld	r31, X
    3164:	63 e0       	ldi	r22, 0x03	; 3
    3166:	70 e0       	ldi	r23, 0x00	; 0
    3168:	09 95       	icall
         MIDI_NOTEON | (chan & MIDI_CHANMASK),
         num & 0x7F,
         vel & 0x7F);
}
    316a:	0f 91       	pop	r16
    316c:	08 95       	ret

0000316e <midi_send_noteoff>:

void midi_send_noteoff(MidiDevice * device, uint8_t chan, uint8_t num, uint8_t vel){
    316e:	0f 93       	push	r16
    3170:	34 2f       	mov	r19, r20
    3172:	02 2f       	mov	r16, r18
   //Note Data: Note Num, Note Velocity
   device->send_func(device, 3,
    3174:	46 2f       	mov	r20, r22
    3176:	4f 70       	andi	r20, 0x0F	; 15
    3178:	40 68       	ori	r20, 0x80	; 128
    317a:	23 2f       	mov	r18, r19
    317c:	2f 77       	andi	r18, 0x7F	; 127
    317e:	0f 77       	andi	r16, 0x7F	; 127
    3180:	dc 01       	movw	r26, r24
    3182:	ed 91       	ld	r30, X+
    3184:	fc 91       	ld	r31, X
    3186:	63 e0       	ldi	r22, 0x03	; 3
    3188:	70 e0       	ldi	r23, 0x00	; 0
    318a:	09 95       	icall
         MIDI_NOTEOFF | (chan & MIDI_CHANMASK),
         num & 0x7F,
         vel & 0x7F);
}
    318c:	0f 91       	pop	r16
    318e:	08 95       	ret

00003190 <midi_send_aftertouch>:

void midi_send_aftertouch(MidiDevice * device, uint8_t chan, uint8_t note_num, uint8_t amt){
    3190:	0f 93       	push	r16
    3192:	34 2f       	mov	r19, r20
    3194:	02 2f       	mov	r16, r18
   device->send_func(device, 3,
    3196:	46 2f       	mov	r20, r22
    3198:	4f 70       	andi	r20, 0x0F	; 15
    319a:	40 6a       	ori	r20, 0xA0	; 160
    319c:	23 2f       	mov	r18, r19
    319e:	2f 77       	andi	r18, 0x7F	; 127
    31a0:	0f 77       	andi	r16, 0x7F	; 127
    31a2:	dc 01       	movw	r26, r24
    31a4:	ed 91       	ld	r30, X+
    31a6:	fc 91       	ld	r31, X
    31a8:	63 e0       	ldi	r22, 0x03	; 3
    31aa:	70 e0       	ldi	r23, 0x00	; 0
    31ac:	09 95       	icall
         MIDI_AFTERTOUCH | (chan & MIDI_CHANMASK),
         note_num & 0x7F,
         amt & 0x7F);
}
    31ae:	0f 91       	pop	r16
    31b0:	08 95       	ret

000031b2 <midi_send_pitchbend>:

//XXX does this work right?
//amt in range -0x2000, 0x1fff
//uAmt should be in range..
//0x0000 to 0x3FFF
void midi_send_pitchbend(MidiDevice * device, uint8_t chan, int16_t amt){
    31b2:	0f 93       	push	r16
    31b4:	1f 93       	push	r17
   uint16_t uAmt;
   //check range
   if(amt > 0x1fff){
    31b6:	20 e2       	ldi	r18, 0x20	; 32
    31b8:	40 30       	cpi	r20, 0x00	; 0
    31ba:	52 07       	cpc	r21, r18
    31bc:	44 f4       	brge	.+16     	; 0x31ce <midi_send_pitchbend+0x1c>
      uAmt = 0x3FFF;
   } else if(amt < -0x2000){
    31be:	a0 ee       	ldi	r26, 0xE0	; 224
    31c0:	40 30       	cpi	r20, 0x00	; 0
    31c2:	5a 07       	cpc	r21, r26
    31c4:	3c f0       	brlt	.+14     	; 0x31d4 <midi_send_pitchbend+0x22>
      uAmt = 0;
   } else {
      uAmt = amt + 0x2000;
    31c6:	8a 01       	movw	r16, r20
    31c8:	00 50       	subi	r16, 0x00	; 0
    31ca:	10 4e       	sbci	r17, 0xE0	; 224
    31cc:	05 c0       	rjmp	.+10     	; 0x31d8 <midi_send_pitchbend+0x26>
//0x0000 to 0x3FFF
void midi_send_pitchbend(MidiDevice * device, uint8_t chan, int16_t amt){
   uint16_t uAmt;
   //check range
   if(amt > 0x1fff){
      uAmt = 0x3FFF;
    31ce:	0f ef       	ldi	r16, 0xFF	; 255
    31d0:	1f e3       	ldi	r17, 0x3F	; 63
    31d2:	02 c0       	rjmp	.+4      	; 0x31d8 <midi_send_pitchbend+0x26>
   } else if(amt < -0x2000){
      uAmt = 0;
    31d4:	00 e0       	ldi	r16, 0x00	; 0
    31d6:	10 e0       	ldi	r17, 0x00	; 0
   } else {
      uAmt = amt + 0x2000;
   }
   device->send_func(device, 3,
    31d8:	46 2f       	mov	r20, r22
    31da:	4f 70       	andi	r20, 0x0F	; 15
    31dc:	40 6e       	ori	r20, 0xE0	; 224
    31de:	20 2f       	mov	r18, r16
    31e0:	2f 77       	andi	r18, 0x7F	; 127
         MIDI_PITCHBEND | (chan & MIDI_CHANMASK),
         uAmt & 0x7F,
         (uAmt >> 7) & 0x7F);
    31e2:	00 0f       	add	r16, r16
    31e4:	01 2f       	mov	r16, r17
    31e6:	00 1f       	adc	r16, r16
    31e8:	11 0b       	sbc	r17, r17
    31ea:	11 95       	neg	r17
   } else if(amt < -0x2000){
      uAmt = 0;
   } else {
      uAmt = amt + 0x2000;
   }
   device->send_func(device, 3,
    31ec:	0f 77       	andi	r16, 0x7F	; 127
    31ee:	dc 01       	movw	r26, r24
    31f0:	ed 91       	ld	r30, X+
    31f2:	fc 91       	ld	r31, X
    31f4:	63 e0       	ldi	r22, 0x03	; 3
    31f6:	70 e0       	ldi	r23, 0x00	; 0
    31f8:	09 95       	icall
         MIDI_PITCHBEND | (chan & MIDI_CHANMASK),
         uAmt & 0x7F,
         (uAmt >> 7) & 0x7F);
}
    31fa:	1f 91       	pop	r17
    31fc:	0f 91       	pop	r16
    31fe:	08 95       	ret

00003200 <midi_send_programchange>:

void midi_send_programchange(MidiDevice * device, uint8_t chan, uint8_t num){
    3200:	0f 93       	push	r16
    3202:	24 2f       	mov	r18, r20
   device->send_func(device, 2,
    3204:	46 2f       	mov	r20, r22
    3206:	4f 70       	andi	r20, 0x0F	; 15
    3208:	40 6c       	ori	r20, 0xC0	; 192
    320a:	2f 77       	andi	r18, 0x7F	; 127
    320c:	dc 01       	movw	r26, r24
    320e:	ed 91       	ld	r30, X+
    3210:	fc 91       	ld	r31, X
    3212:	62 e0       	ldi	r22, 0x02	; 2
    3214:	70 e0       	ldi	r23, 0x00	; 0
    3216:	00 e0       	ldi	r16, 0x00	; 0
    3218:	09 95       	icall
         MIDI_PROGCHANGE | (chan & MIDI_CHANMASK),
         num & 0x7F,
         0);
}
    321a:	0f 91       	pop	r16
    321c:	08 95       	ret

0000321e <midi_send_channelpressure>:

void midi_send_channelpressure(MidiDevice * device, uint8_t chan, uint8_t amt){
    321e:	0f 93       	push	r16
    3220:	24 2f       	mov	r18, r20
   device->send_func(device, 2,
    3222:	46 2f       	mov	r20, r22
    3224:	4f 70       	andi	r20, 0x0F	; 15
    3226:	40 6d       	ori	r20, 0xD0	; 208
    3228:	2f 77       	andi	r18, 0x7F	; 127
    322a:	dc 01       	movw	r26, r24
    322c:	ed 91       	ld	r30, X+
    322e:	fc 91       	ld	r31, X
    3230:	62 e0       	ldi	r22, 0x02	; 2
    3232:	70 e0       	ldi	r23, 0x00	; 0
    3234:	00 e0       	ldi	r16, 0x00	; 0
    3236:	09 95       	icall
         MIDI_CHANPRESSURE | (chan & MIDI_CHANMASK),
         amt & 0x7F,
         0);
}
    3238:	0f 91       	pop	r16
    323a:	08 95       	ret

0000323c <midi_send_clock>:

void midi_send_clock(MidiDevice * device){
    323c:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_CLOCK, 0, 0);
    323e:	dc 01       	movw	r26, r24
    3240:	ed 91       	ld	r30, X+
    3242:	fc 91       	ld	r31, X
    3244:	61 e0       	ldi	r22, 0x01	; 1
    3246:	70 e0       	ldi	r23, 0x00	; 0
    3248:	48 ef       	ldi	r20, 0xF8	; 248
    324a:	20 e0       	ldi	r18, 0x00	; 0
    324c:	00 e0       	ldi	r16, 0x00	; 0
    324e:	09 95       	icall
}
    3250:	0f 91       	pop	r16
    3252:	08 95       	ret

00003254 <midi_send_tick>:

void midi_send_tick(MidiDevice * device){
    3254:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_TICK, 0, 0);
    3256:	dc 01       	movw	r26, r24
    3258:	ed 91       	ld	r30, X+
    325a:	fc 91       	ld	r31, X
    325c:	61 e0       	ldi	r22, 0x01	; 1
    325e:	70 e0       	ldi	r23, 0x00	; 0
    3260:	49 ef       	ldi	r20, 0xF9	; 249
    3262:	20 e0       	ldi	r18, 0x00	; 0
    3264:	00 e0       	ldi	r16, 0x00	; 0
    3266:	09 95       	icall
}
    3268:	0f 91       	pop	r16
    326a:	08 95       	ret

0000326c <midi_send_start>:

void midi_send_start(MidiDevice * device){
    326c:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_START, 0, 0);
    326e:	dc 01       	movw	r26, r24
    3270:	ed 91       	ld	r30, X+
    3272:	fc 91       	ld	r31, X
    3274:	61 e0       	ldi	r22, 0x01	; 1
    3276:	70 e0       	ldi	r23, 0x00	; 0
    3278:	4a ef       	ldi	r20, 0xFA	; 250
    327a:	20 e0       	ldi	r18, 0x00	; 0
    327c:	00 e0       	ldi	r16, 0x00	; 0
    327e:	09 95       	icall
}
    3280:	0f 91       	pop	r16
    3282:	08 95       	ret

00003284 <midi_send_continue>:

void midi_send_continue(MidiDevice * device){
    3284:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_CONTINUE, 0, 0);
    3286:	dc 01       	movw	r26, r24
    3288:	ed 91       	ld	r30, X+
    328a:	fc 91       	ld	r31, X
    328c:	61 e0       	ldi	r22, 0x01	; 1
    328e:	70 e0       	ldi	r23, 0x00	; 0
    3290:	4b ef       	ldi	r20, 0xFB	; 251
    3292:	20 e0       	ldi	r18, 0x00	; 0
    3294:	00 e0       	ldi	r16, 0x00	; 0
    3296:	09 95       	icall
}
    3298:	0f 91       	pop	r16
    329a:	08 95       	ret

0000329c <midi_send_stop>:

void midi_send_stop(MidiDevice * device){
    329c:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_STOP, 0, 0);
    329e:	dc 01       	movw	r26, r24
    32a0:	ed 91       	ld	r30, X+
    32a2:	fc 91       	ld	r31, X
    32a4:	61 e0       	ldi	r22, 0x01	; 1
    32a6:	70 e0       	ldi	r23, 0x00	; 0
    32a8:	4c ef       	ldi	r20, 0xFC	; 252
    32aa:	20 e0       	ldi	r18, 0x00	; 0
    32ac:	00 e0       	ldi	r16, 0x00	; 0
    32ae:	09 95       	icall
}
    32b0:	0f 91       	pop	r16
    32b2:	08 95       	ret

000032b4 <midi_send_activesense>:

void midi_send_activesense(MidiDevice * device){
    32b4:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_ACTIVESENSE, 0, 0);
    32b6:	dc 01       	movw	r26, r24
    32b8:	ed 91       	ld	r30, X+
    32ba:	fc 91       	ld	r31, X
    32bc:	61 e0       	ldi	r22, 0x01	; 1
    32be:	70 e0       	ldi	r23, 0x00	; 0
    32c0:	4e ef       	ldi	r20, 0xFE	; 254
    32c2:	20 e0       	ldi	r18, 0x00	; 0
    32c4:	00 e0       	ldi	r16, 0x00	; 0
    32c6:	09 95       	icall
}
    32c8:	0f 91       	pop	r16
    32ca:	08 95       	ret

000032cc <midi_send_reset>:

void midi_send_reset(MidiDevice * device){
    32cc:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_RESET, 0, 0);
    32ce:	dc 01       	movw	r26, r24
    32d0:	ed 91       	ld	r30, X+
    32d2:	fc 91       	ld	r31, X
    32d4:	61 e0       	ldi	r22, 0x01	; 1
    32d6:	70 e0       	ldi	r23, 0x00	; 0
    32d8:	4f ef       	ldi	r20, 0xFF	; 255
    32da:	20 e0       	ldi	r18, 0x00	; 0
    32dc:	00 e0       	ldi	r16, 0x00	; 0
    32de:	09 95       	icall
}
    32e0:	0f 91       	pop	r16
    32e2:	08 95       	ret

000032e4 <midi_send_tcquarterframe>:

void midi_send_tcquarterframe(MidiDevice * device, uint8_t time){
    32e4:	0f 93       	push	r16
   device->send_func(device, 2,
    32e6:	26 2f       	mov	r18, r22
    32e8:	2f 77       	andi	r18, 0x7F	; 127
    32ea:	dc 01       	movw	r26, r24
    32ec:	ed 91       	ld	r30, X+
    32ee:	fc 91       	ld	r31, X
    32f0:	62 e0       	ldi	r22, 0x02	; 2
    32f2:	70 e0       	ldi	r23, 0x00	; 0
    32f4:	41 ef       	ldi	r20, 0xF1	; 241
    32f6:	00 e0       	ldi	r16, 0x00	; 0
    32f8:	09 95       	icall
         MIDI_TC_QUARTERFRAME,
         time & 0x7F,
         0);
}
    32fa:	0f 91       	pop	r16
    32fc:	08 95       	ret

000032fe <midi_send_songposition>:

//XXX is this right?
void midi_send_songposition(MidiDevice * device, uint16_t pos){
    32fe:	0f 93       	push	r16
    3300:	1f 93       	push	r17
   device->send_func(device, 3,
    3302:	26 2f       	mov	r18, r22
    3304:	2f 77       	andi	r18, 0x7F	; 127
         MIDI_SONGPOSITION,
         pos & 0x7F,
         (pos >> 7) & 0x7F);
    3306:	8b 01       	movw	r16, r22
    3308:	00 0f       	add	r16, r16
    330a:	01 2f       	mov	r16, r17
    330c:	00 1f       	adc	r16, r16
    330e:	11 0b       	sbc	r17, r17
    3310:	11 95       	neg	r17
         0);
}

//XXX is this right?
void midi_send_songposition(MidiDevice * device, uint16_t pos){
   device->send_func(device, 3,
    3312:	0f 77       	andi	r16, 0x7F	; 127
    3314:	dc 01       	movw	r26, r24
    3316:	ed 91       	ld	r30, X+
    3318:	fc 91       	ld	r31, X
    331a:	63 e0       	ldi	r22, 0x03	; 3
    331c:	70 e0       	ldi	r23, 0x00	; 0
    331e:	42 ef       	ldi	r20, 0xF2	; 242
    3320:	09 95       	icall
         MIDI_SONGPOSITION,
         pos & 0x7F,
         (pos >> 7) & 0x7F);
}
    3322:	1f 91       	pop	r17
    3324:	0f 91       	pop	r16
    3326:	08 95       	ret

00003328 <midi_send_songselect>:

void midi_send_songselect(MidiDevice * device, uint8_t song){
    3328:	0f 93       	push	r16
   device->send_func(device, 2,
    332a:	26 2f       	mov	r18, r22
    332c:	2f 77       	andi	r18, 0x7F	; 127
    332e:	dc 01       	movw	r26, r24
    3330:	ed 91       	ld	r30, X+
    3332:	fc 91       	ld	r31, X
    3334:	62 e0       	ldi	r22, 0x02	; 2
    3336:	70 e0       	ldi	r23, 0x00	; 0
    3338:	43 ef       	ldi	r20, 0xF3	; 243
    333a:	00 e0       	ldi	r16, 0x00	; 0
    333c:	09 95       	icall
         MIDI_SONGSELECT,
         song & 0x7F,
         0);
}
    333e:	0f 91       	pop	r16
    3340:	08 95       	ret

00003342 <midi_send_tunerequest>:

void midi_send_tunerequest(MidiDevice * device){
    3342:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_TUNEREQUEST, 0, 0);
    3344:	dc 01       	movw	r26, r24
    3346:	ed 91       	ld	r30, X+
    3348:	fc 91       	ld	r31, X
    334a:	61 e0       	ldi	r22, 0x01	; 1
    334c:	70 e0       	ldi	r23, 0x00	; 0
    334e:	46 ef       	ldi	r20, 0xF6	; 246
    3350:	20 e0       	ldi	r18, 0x00	; 0
    3352:	00 e0       	ldi	r16, 0x00	; 0
    3354:	09 95       	icall
}
    3356:	0f 91       	pop	r16
    3358:	08 95       	ret

0000335a <midi_send_byte>:

void midi_send_byte(MidiDevice * device, uint8_t b){
    335a:	0f 93       	push	r16
    335c:	46 2f       	mov	r20, r22
   device->send_func(device, 1, b, 0, 0);
    335e:	dc 01       	movw	r26, r24
    3360:	ed 91       	ld	r30, X+
    3362:	fc 91       	ld	r31, X
    3364:	61 e0       	ldi	r22, 0x01	; 1
    3366:	70 e0       	ldi	r23, 0x00	; 0
    3368:	20 e0       	ldi	r18, 0x00	; 0
    336a:	00 e0       	ldi	r16, 0x00	; 0
    336c:	09 95       	icall
}
    336e:	0f 91       	pop	r16
    3370:	08 95       	ret

00003372 <midi_send_data>:

void midi_send_data(MidiDevice * device, uint16_t count, uint8_t byte0, uint8_t byte1, uint8_t byte2){
    3372:	0f 93       	push	r16
   //ensure that the count passed along is always 3 or lower
   if (count > 3) {
      //TODO how to do this correctly?
   }
   device->send_func(device, count, byte0, byte1, byte2);
    3374:	dc 01       	movw	r26, r24
    3376:	ed 91       	ld	r30, X+
    3378:	fc 91       	ld	r31, X
    337a:	09 95       	icall
}
    337c:	0f 91       	pop	r16
    337e:	08 95       	ret

00003380 <midi_send_array>:

void midi_send_array(MidiDevice * device, uint16_t count, uint8_t * array) {
    3380:	6f 92       	push	r6
    3382:	7f 92       	push	r7
    3384:	8f 92       	push	r8
    3386:	9f 92       	push	r9
    3388:	af 92       	push	r10
    338a:	bf 92       	push	r11
    338c:	cf 92       	push	r12
    338e:	df 92       	push	r13
    3390:	ef 92       	push	r14
    3392:	ff 92       	push	r15
    3394:	0f 93       	push	r16
    3396:	1f 93       	push	r17
    3398:	cf 93       	push	r28
    339a:	df 93       	push	r29
    339c:	00 d0       	rcall	.+0      	; 0x339e <midi_send_array+0x1e>
    339e:	0f 92       	push	r0
    33a0:	cd b7       	in	r28, 0x3d	; 61
    33a2:	de b7       	in	r29, 0x3e	; 62
    33a4:	4c 01       	movw	r8, r24
    33a6:	6b 01       	movw	r12, r22
    33a8:	5a 01       	movw	r10, r20
  uint16_t i;
  for (i = 0; i < count; i += 3) {
    33aa:	61 15       	cp	r22, r1
    33ac:	71 05       	cpc	r23, r1
    33ae:	41 f1       	breq	.+80     	; 0x3400 <midi_send_array+0x80>
    33b0:	ee 24       	eor	r14, r14
    33b2:	ff 24       	eor	r15, r15
    uint8_t b[3] = { 0, 0, 0 };
    uint16_t to_send = count - i;
    to_send = (to_send > 3) ? 3 : to_send;
    33b4:	0f 2e       	mov	r0, r31
    33b6:	f3 e0       	ldi	r31, 0x03	; 3
    33b8:	6f 2e       	mov	r6, r31
    33ba:	77 24       	eor	r7, r7
    33bc:	f0 2d       	mov	r31, r0
}

void midi_send_array(MidiDevice * device, uint16_t count, uint8_t * array) {
  uint16_t i;
  for (i = 0; i < count; i += 3) {
    uint8_t b[3] = { 0, 0, 0 };
    33be:	19 82       	std	Y+1, r1	; 0x01
    33c0:	1a 82       	std	Y+2, r1	; 0x02
    33c2:	1b 82       	std	Y+3, r1	; 0x03
    uint16_t to_send = count - i;
    33c4:	86 01       	movw	r16, r12
    33c6:	0e 19       	sub	r16, r14
    33c8:	1f 09       	sbc	r17, r15
    to_send = (to_send > 3) ? 3 : to_send;
    33ca:	04 30       	cpi	r16, 0x04	; 4
    33cc:	11 05       	cpc	r17, r1
    33ce:	08 f0       	brcs	.+2      	; 0x33d2 <midi_send_array+0x52>
    33d0:	83 01       	movw	r16, r6
      //TODO how to do this correctly?
   }
   device->send_func(device, count, byte0, byte1, byte2);
}

void midi_send_array(MidiDevice * device, uint16_t count, uint8_t * array) {
    33d2:	b5 01       	movw	r22, r10
    33d4:	6e 0d       	add	r22, r14
    33d6:	7f 1d       	adc	r23, r15
  uint16_t i;
  for (i = 0; i < count; i += 3) {
    uint8_t b[3] = { 0, 0, 0 };
    uint16_t to_send = count - i;
    to_send = (to_send > 3) ? 3 : to_send;
    memcpy(b, array + i, to_send);
    33d8:	ce 01       	movw	r24, r28
    33da:	01 96       	adiw	r24, 0x01	; 1
    33dc:	40 2f       	mov	r20, r16
    33de:	51 2f       	mov	r21, r17
    33e0:	0e 94 49 1f 	call	0x3e92	; 0x3e92 <memcpy>
    midi_send_data(device, to_send, b[0], b[1], b[2]);
    33e4:	c4 01       	movw	r24, r8
    33e6:	b8 01       	movw	r22, r16
    33e8:	49 81       	ldd	r20, Y+1	; 0x01
    33ea:	2a 81       	ldd	r18, Y+2	; 0x02
    33ec:	0b 81       	ldd	r16, Y+3	; 0x03
    33ee:	0e 94 b9 19 	call	0x3372	; 0x3372 <midi_send_data>
   device->send_func(device, count, byte0, byte1, byte2);
}

void midi_send_array(MidiDevice * device, uint16_t count, uint8_t * array) {
  uint16_t i;
  for (i = 0; i < count; i += 3) {
    33f2:	83 e0       	ldi	r24, 0x03	; 3
    33f4:	90 e0       	ldi	r25, 0x00	; 0
    33f6:	e8 0e       	add	r14, r24
    33f8:	f9 1e       	adc	r15, r25
    33fa:	ec 14       	cp	r14, r12
    33fc:	fd 04       	cpc	r15, r13
    33fe:	f8 f2       	brcs	.-66     	; 0x33be <midi_send_array+0x3e>
    uint16_t to_send = count - i;
    to_send = (to_send > 3) ? 3 : to_send;
    memcpy(b, array + i, to_send);
    midi_send_data(device, to_send, b[0], b[1], b[2]);
  }
}
    3400:	0f 90       	pop	r0
    3402:	0f 90       	pop	r0
    3404:	0f 90       	pop	r0
    3406:	df 91       	pop	r29
    3408:	cf 91       	pop	r28
    340a:	1f 91       	pop	r17
    340c:	0f 91       	pop	r16
    340e:	ff 90       	pop	r15
    3410:	ef 90       	pop	r14
    3412:	df 90       	pop	r13
    3414:	cf 90       	pop	r12
    3416:	bf 90       	pop	r11
    3418:	af 90       	pop	r10
    341a:	9f 90       	pop	r9
    341c:	8f 90       	pop	r8
    341e:	7f 90       	pop	r7
    3420:	6f 90       	pop	r6
    3422:	08 95       	ret

00003424 <midi_register_cc_callback>:


void midi_register_cc_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_cc_callback = func;
    3424:	fc 01       	movw	r30, r24
    3426:	73 83       	std	Z+3, r23	; 0x03
    3428:	62 83       	std	Z+2, r22	; 0x02
}
    342a:	08 95       	ret

0000342c <midi_register_noteon_callback>:

void midi_register_noteon_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_noteon_callback = func;
    342c:	fc 01       	movw	r30, r24
    342e:	75 83       	std	Z+5, r23	; 0x05
    3430:	64 83       	std	Z+4, r22	; 0x04
}
    3432:	08 95       	ret

00003434 <midi_register_noteoff_callback>:

void midi_register_noteoff_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_noteoff_callback = func;
    3434:	fc 01       	movw	r30, r24
    3436:	77 83       	std	Z+7, r23	; 0x07
    3438:	66 83       	std	Z+6, r22	; 0x06
}
    343a:	08 95       	ret

0000343c <midi_register_aftertouch_callback>:

void midi_register_aftertouch_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_aftertouch_callback = func;
    343c:	fc 01       	movw	r30, r24
    343e:	71 87       	std	Z+9, r23	; 0x09
    3440:	60 87       	std	Z+8, r22	; 0x08
}
    3442:	08 95       	ret

00003444 <midi_register_pitchbend_callback>:

void midi_register_pitchbend_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_pitchbend_callback = func;
    3444:	fc 01       	movw	r30, r24
    3446:	73 87       	std	Z+11, r23	; 0x0b
    3448:	62 87       	std	Z+10, r22	; 0x0a
}
    344a:	08 95       	ret

0000344c <midi_register_songposition_callback>:

void midi_register_songposition_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_songposition_callback = func;
    344c:	fc 01       	movw	r30, r24
    344e:	75 87       	std	Z+13, r23	; 0x0d
    3450:	64 87       	std	Z+12, r22	; 0x0c
}
    3452:	08 95       	ret

00003454 <midi_register_progchange_callback>:

void midi_register_progchange_callback(MidiDevice * device, midi_two_byte_func_t func) {
   device->input_progchange_callback = func;
    3454:	fc 01       	movw	r30, r24
    3456:	77 87       	std	Z+15, r23	; 0x0f
    3458:	66 87       	std	Z+14, r22	; 0x0e
}
    345a:	08 95       	ret

0000345c <midi_register_chanpressure_callback>:

void midi_register_chanpressure_callback(MidiDevice * device, midi_two_byte_func_t func) {
   device->input_chanpressure_callback = func;
    345c:	fc 01       	movw	r30, r24
    345e:	71 8b       	std	Z+17, r23	; 0x11
    3460:	60 8b       	std	Z+16, r22	; 0x10
}
    3462:	08 95       	ret

00003464 <midi_register_songselect_callback>:

void midi_register_songselect_callback(MidiDevice * device, midi_two_byte_func_t func) {
   device->input_songselect_callback = func;
    3464:	fc 01       	movw	r30, r24
    3466:	73 8b       	std	Z+19, r23	; 0x13
    3468:	62 8b       	std	Z+18, r22	; 0x12
}
    346a:	08 95       	ret

0000346c <midi_register_tc_quarterframe_callback>:

void midi_register_tc_quarterframe_callback(MidiDevice * device, midi_two_byte_func_t func) {
   device->input_tc_quarterframe_callback = func;
    346c:	fc 01       	movw	r30, r24
    346e:	75 8b       	std	Z+21, r23	; 0x15
    3470:	64 8b       	std	Z+20, r22	; 0x14
}
    3472:	08 95       	ret

00003474 <midi_register_realtime_callback>:

void midi_register_realtime_callback(MidiDevice * device, midi_one_byte_func_t func){
   device->input_realtime_callback = func;
    3474:	fc 01       	movw	r30, r24
    3476:	77 8b       	std	Z+23, r23	; 0x17
    3478:	66 8b       	std	Z+22, r22	; 0x16
}
    347a:	08 95       	ret

0000347c <midi_register_tunerequest_callback>:

void midi_register_tunerequest_callback(MidiDevice * device, midi_one_byte_func_t func){
   device->input_tunerequest_callback = func;
    347c:	fc 01       	movw	r30, r24
    347e:	71 8f       	std	Z+25, r23	; 0x19
    3480:	60 8f       	std	Z+24, r22	; 0x18
}
    3482:	08 95       	ret

00003484 <midi_register_sysex_callback>:

void midi_register_sysex_callback(MidiDevice * device, midi_sysex_func_t func) {
   device->input_sysex_callback = func;
    3484:	fc 01       	movw	r30, r24
    3486:	73 8f       	std	Z+27, r23	; 0x1b
    3488:	62 8f       	std	Z+26, r22	; 0x1a
}
    348a:	08 95       	ret

0000348c <midi_register_fallthrough_callback>:

void midi_register_fallthrough_callback(MidiDevice * device, midi_var_byte_func_t func){
   device->input_fallthrough_callback = func;
    348c:	fc 01       	movw	r30, r24
    348e:	75 8f       	std	Z+29, r23	; 0x1d
    3490:	64 8f       	std	Z+28, r22	; 0x1c
}
    3492:	08 95       	ret

00003494 <midi_register_catchall_callback>:

void midi_register_catchall_callback(MidiDevice * device, midi_var_byte_func_t func){
   device->input_catchall_callback = func;
    3494:	fc 01       	movw	r30, r24
    3496:	77 8f       	std	Z+31, r23	; 0x1f
    3498:	66 8f       	std	Z+30, r22	; 0x1e
}
    349a:	08 95       	ret

0000349c <midi_device_init>:

//forward declarations, internally used to call the callbacks
void midi_input_callbacks(MidiDevice * device, uint16_t cnt, uint8_t byte0, uint8_t byte1, uint8_t byte2);
void midi_process_byte(MidiDevice * device, uint8_t input);

void midi_device_init(MidiDevice * device){
    349c:	cf 93       	push	r28
    349e:	df 93       	push	r29
    34a0:	ec 01       	movw	r28, r24
  device->input_state = IDLE;
    34a2:	1d a2       	lds	r17, 0x9d
  device->input_count = 0;
    34a4:	1f a2       	lds	r17, 0x9f
    34a6:	1e a2       	lds	r17, 0x9e
  bytequeue_init(&device->input_queue, device->input_queue_data, MIDI_INPUT_QUEUE_LENGTH);
    34a8:	bc 01       	movw	r22, r24
    34aa:	68 5d       	subi	r22, 0xD8	; 216
    34ac:	7f 4f       	sbci	r23, 0xFF	; 255
    34ae:	88 51       	subi	r24, 0x18	; 24
    34b0:	9f 4f       	sbci	r25, 0xFF	; 255
    34b2:	40 ec       	ldi	r20, 0xC0	; 192
    34b4:	0e 94 c8 17 	call	0x2f90	; 0x2f90 <bytequeue_init>

  //three byte funcs
  device->input_cc_callback = NULL;
    34b8:	1b 82       	std	Y+3, r1	; 0x03
    34ba:	1a 82       	std	Y+2, r1	; 0x02
  device->input_noteon_callback = NULL;
    34bc:	1d 82       	std	Y+5, r1	; 0x05
    34be:	1c 82       	std	Y+4, r1	; 0x04
  device->input_noteoff_callback = NULL;
    34c0:	1f 82       	std	Y+7, r1	; 0x07
    34c2:	1e 82       	std	Y+6, r1	; 0x06
  device->input_aftertouch_callback = NULL;
    34c4:	19 86       	std	Y+9, r1	; 0x09
    34c6:	18 86       	std	Y+8, r1	; 0x08
  device->input_pitchbend_callback = NULL;
    34c8:	1b 86       	std	Y+11, r1	; 0x0b
    34ca:	1a 86       	std	Y+10, r1	; 0x0a
  device->input_songposition_callback = NULL;
    34cc:	1d 86       	std	Y+13, r1	; 0x0d
    34ce:	1c 86       	std	Y+12, r1	; 0x0c

  //two byte funcs
  device->input_progchange_callback = NULL;
    34d0:	1f 86       	std	Y+15, r1	; 0x0f
    34d2:	1e 86       	std	Y+14, r1	; 0x0e
  device->input_chanpressure_callback = NULL;
    34d4:	19 8a       	std	Y+17, r1	; 0x11
    34d6:	18 8a       	std	Y+16, r1	; 0x10
  device->input_songselect_callback = NULL;
    34d8:	1b 8a       	std	Y+19, r1	; 0x13
    34da:	1a 8a       	std	Y+18, r1	; 0x12
  device->input_tc_quarterframe_callback = NULL;
    34dc:	1d 8a       	std	Y+21, r1	; 0x15
    34de:	1c 8a       	std	Y+20, r1	; 0x14

  //one byte funcs
  device->input_realtime_callback = NULL;
    34e0:	1f 8a       	std	Y+23, r1	; 0x17
    34e2:	1e 8a       	std	Y+22, r1	; 0x16
  device->input_tunerequest_callback = NULL;
    34e4:	19 8e       	std	Y+25, r1	; 0x19
    34e6:	18 8e       	std	Y+24, r1	; 0x18

  //var byte functions
  device->input_sysex_callback = NULL;
    34e8:	1b 8e       	std	Y+27, r1	; 0x1b
    34ea:	1a 8e       	std	Y+26, r1	; 0x1a
  device->input_fallthrough_callback = NULL;
    34ec:	1d 8e       	std	Y+29, r1	; 0x1d
    34ee:	1c 8e       	std	Y+28, r1	; 0x1c
  device->input_catchall_callback = NULL;
    34f0:	1f 8e       	std	Y+31, r1	; 0x1f
    34f2:	1e 8e       	std	Y+30, r1	; 0x1e

  device->pre_input_process_callback = NULL;
    34f4:	19 a2       	lds	r17, 0x99
    34f6:	18 a2       	lds	r17, 0x98
}
    34f8:	df 91       	pop	r29
    34fa:	cf 91       	pop	r28
    34fc:	08 95       	ret

000034fe <midi_device_input>:

void midi_device_input(MidiDevice * device, uint8_t cnt, uint8_t * input) {
    34fe:	ef 92       	push	r14
    3500:	ff 92       	push	r15
    3502:	0f 93       	push	r16
    3504:	1f 93       	push	r17
    3506:	cf 93       	push	r28
    3508:	df 93       	push	r29
    350a:	d6 2f       	mov	r29, r22
  uint8_t i;
  for (i = 0; i < cnt; i++)
    350c:	66 23       	and	r22, r22
    350e:	99 f0       	breq	.+38     	; 0x3536 <midi_device_input+0x38>
    3510:	04 2f       	mov	r16, r20
    3512:	15 2f       	mov	r17, r21
    3514:	c0 e0       	ldi	r28, 0x00	; 0
    bytequeue_enqueue(&device->input_queue, input[i]);
    3516:	0f 2e       	mov	r0, r31
    3518:	f8 ee       	ldi	r31, 0xE8	; 232
    351a:	ef 2e       	mov	r14, r31
    351c:	ff 24       	eor	r15, r15
    351e:	f0 2d       	mov	r31, r0
    3520:	e8 0e       	add	r14, r24
    3522:	f9 1e       	adc	r15, r25
    3524:	f8 01       	movw	r30, r16
    3526:	61 91       	ld	r22, Z+
    3528:	8f 01       	movw	r16, r30
    352a:	c7 01       	movw	r24, r14
    352c:	0e 94 cf 17 	call	0x2f9e	; 0x2f9e <bytequeue_enqueue>
  device->pre_input_process_callback = NULL;
}

void midi_device_input(MidiDevice * device, uint8_t cnt, uint8_t * input) {
  uint8_t i;
  for (i = 0; i < cnt; i++)
    3530:	cf 5f       	subi	r28, 0xFF	; 255
    3532:	cd 17       	cp	r28, r29
    3534:	b9 f7       	brne	.-18     	; 0x3524 <midi_device_input+0x26>
    bytequeue_enqueue(&device->input_queue, input[i]);
}
    3536:	df 91       	pop	r29
    3538:	cf 91       	pop	r28
    353a:	1f 91       	pop	r17
    353c:	0f 91       	pop	r16
    353e:	ff 90       	pop	r15
    3540:	ef 90       	pop	r14
    3542:	08 95       	ret

00003544 <midi_device_set_send_func>:

void midi_device_set_send_func(MidiDevice * device, midi_var_byte_func_t send_func){
  device->send_func = send_func;
    3544:	fc 01       	movw	r30, r24
    3546:	71 83       	std	Z+1, r23	; 0x01
    3548:	60 83       	st	Z, r22
}
    354a:	08 95       	ret

0000354c <midi_device_set_pre_input_process_func>:

void midi_device_set_pre_input_process_func(MidiDevice * device, midi_no_byte_func_t pre_process_func){
  device->pre_input_process_callback = pre_process_func;
    354c:	fc 01       	movw	r30, r24
    354e:	71 a3       	lds	r23, 0x51
    3550:	60 a3       	lds	r22, 0x50
}
    3552:	08 95       	ret

00003554 <midi_input_callbacks>:
      }
    }
  }
}

void midi_input_callbacks(MidiDevice * device, uint16_t cnt, uint8_t byte0, uint8_t byte1, uint8_t byte2) {
    3554:	af 92       	push	r10
    3556:	bf 92       	push	r11
    3558:	cf 92       	push	r12
    355a:	df 92       	push	r13
    355c:	ef 92       	push	r14
    355e:	ff 92       	push	r15
    3560:	0f 93       	push	r16
    3562:	1f 93       	push	r17
    3564:	cf 93       	push	r28
    3566:	df 93       	push	r29
    3568:	00 d0       	rcall	.+0      	; 0x356a <midi_input_callbacks+0x16>
    356a:	0f 92       	push	r0
    356c:	cd b7       	in	r28, 0x3d	; 61
    356e:	de b7       	in	r29, 0x3e	; 62
    3570:	6c 01       	movw	r12, r24
    3572:	5b 01       	movw	r10, r22
    3574:	f4 2e       	mov	r15, r20
    3576:	e2 2e       	mov	r14, r18
    3578:	10 2f       	mov	r17, r16
  //did we end up calling a callback?
  bool called = false;
  if (device->input_state == SYSEX_MESSAGE) {
    357a:	dc 01       	movw	r26, r24
    357c:	95 96       	adiw	r26, 0x25	; 37
    357e:	8c 91       	ld	r24, X
    3580:	95 97       	sbiw	r26, 0x25	; 37
    3582:	84 30       	cpi	r24, 0x04	; 4
    3584:	e9 f4       	brne	.+58     	; 0x35c0 <midi_input_callbacks+0x6c>
    if (device->input_sysex_callback) {
    3586:	5a 96       	adiw	r26, 0x1a	; 26
    3588:	ed 91       	ld	r30, X+
    358a:	fc 91       	ld	r31, X
    358c:	5b 97       	sbiw	r26, 0x1b	; 27
    358e:	30 97       	sbiw	r30, 0x00	; 0
    3590:	09 f4       	brne	.+2      	; 0x3594 <midi_input_callbacks+0x40>
    3592:	ee c0       	rjmp	.+476    	; 0x3770 <midi_input_callbacks+0x21c>
      const uint16_t start = ((cnt - 1) / 3) * 3;
    3594:	cb 01       	movw	r24, r22
    3596:	01 97       	sbiw	r24, 0x01	; 1
    3598:	63 e0       	ldi	r22, 0x03	; 3
    359a:	70 e0       	ldi	r23, 0x00	; 0
    359c:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <__udivmodhi4>
    35a0:	cb 01       	movw	r24, r22
    35a2:	88 0f       	add	r24, r24
    35a4:	99 1f       	adc	r25, r25
    35a6:	68 0f       	add	r22, r24
    35a8:	79 1f       	adc	r23, r25
      const uint8_t length = (cnt - start);
      uint8_t data[3];
      data[0] = byte0;
    35aa:	49 83       	std	Y+1, r20	; 0x01
      data[1] = byte1;
    35ac:	2a 83       	std	Y+2, r18	; 0x02
      data[2] = byte2;
    35ae:	0b 83       	std	Y+3, r16	; 0x03
  //did we end up calling a callback?
  bool called = false;
  if (device->input_state == SYSEX_MESSAGE) {
    if (device->input_sysex_callback) {
      const uint16_t start = ((cnt - 1) / 3) * 3;
      const uint8_t length = (cnt - start);
    35b0:	4a 2d       	mov	r20, r10
    35b2:	46 1b       	sub	r20, r22
      uint8_t data[3];
      data[0] = byte0;
      data[1] = byte1;
      data[2] = byte2;
      device->input_sysex_callback(device, start, length, data);
    35b4:	c6 01       	movw	r24, r12
    35b6:	9e 01       	movw	r18, r28
    35b8:	2f 5f       	subi	r18, 0xFF	; 255
    35ba:	3f 4f       	sbci	r19, 0xFF	; 255
    35bc:	09 95       	icall
    35be:	c8 c0       	rjmp	.+400    	; 0x3750 <midi_input_callbacks+0x1fc>
      called = true;
    }
  } else {
    switch (cnt) {
    35c0:	62 30       	cpi	r22, 0x02	; 2
    35c2:	71 05       	cpc	r23, r1
    35c4:	09 f4       	brne	.+2      	; 0x35c8 <midi_input_callbacks+0x74>
    35c6:	5f c0       	rjmp	.+190    	; 0x3686 <midi_input_callbacks+0x132>
    35c8:	63 30       	cpi	r22, 0x03	; 3
    35ca:	71 05       	cpc	r23, r1
    35cc:	29 f0       	breq	.+10     	; 0x35d8 <midi_input_callbacks+0x84>
    35ce:	61 30       	cpi	r22, 0x01	; 1
    35d0:	71 05       	cpc	r23, r1
    35d2:	09 f0       	breq	.+2      	; 0x35d6 <midi_input_callbacks+0x82>
    35d4:	b3 c0       	rjmp	.+358    	; 0x373c <midi_input_callbacks+0x1e8>
    35d6:	99 c0       	rjmp	.+306    	; 0x370a <midi_input_callbacks+0x1b6>
      case 3:
        {
          midi_three_byte_func_t func = NULL;
          switch (byte0 & 0xF0) {
    35d8:	84 2f       	mov	r24, r20
    35da:	90 e0       	ldi	r25, 0x00	; 0
    35dc:	80 7f       	andi	r24, 0xF0	; 240
    35de:	90 70       	andi	r25, 0x00	; 0
    35e0:	80 3a       	cpi	r24, 0xA0	; 160
    35e2:	91 05       	cpc	r25, r1
    35e4:	29 f1       	breq	.+74     	; 0x3630 <midi_input_callbacks+0xdc>
    35e6:	81 3a       	cpi	r24, 0xA1	; 161
    35e8:	91 05       	cpc	r25, r1
    35ea:	3c f4       	brge	.+14     	; 0x35fa <midi_input_callbacks+0xa6>
    35ec:	80 38       	cpi	r24, 0x80	; 128
    35ee:	91 05       	cpc	r25, r1
    35f0:	c9 f0       	breq	.+50     	; 0x3624 <midi_input_callbacks+0xd0>
    35f2:	80 39       	cpi	r24, 0x90	; 144
    35f4:	91 05       	cpc	r25, r1
    35f6:	91 f5       	brne	.+100    	; 0x365c <midi_input_callbacks+0x108>
    35f8:	0f c0       	rjmp	.+30     	; 0x3618 <midi_input_callbacks+0xc4>
    35fa:	80 3e       	cpi	r24, 0xE0	; 224
    35fc:	91 05       	cpc	r25, r1
    35fe:	f1 f0       	breq	.+60     	; 0x363c <midi_input_callbacks+0xe8>
    3600:	80 3f       	cpi	r24, 0xF0	; 240
    3602:	91 05       	cpc	r25, r1
    3604:	09 f1       	breq	.+66     	; 0x3648 <midi_input_callbacks+0xf4>
    3606:	80 3b       	cpi	r24, 0xB0	; 176
    3608:	91 05       	cpc	r25, r1
    360a:	41 f5       	brne	.+80     	; 0x365c <midi_input_callbacks+0x108>
            case MIDI_CC:
              func = device->input_cc_callback;
    360c:	d6 01       	movw	r26, r12
    360e:	12 96       	adiw	r26, 0x02	; 2
    3610:	ed 91       	ld	r30, X+
    3612:	fc 91       	ld	r31, X
    3614:	13 97       	sbiw	r26, 0x03	; 3
              break;
    3616:	24 c0       	rjmp	.+72     	; 0x3660 <midi_input_callbacks+0x10c>
            case MIDI_NOTEON:
              func = device->input_noteon_callback;
    3618:	d6 01       	movw	r26, r12
    361a:	14 96       	adiw	r26, 0x04	; 4
    361c:	ed 91       	ld	r30, X+
    361e:	fc 91       	ld	r31, X
    3620:	15 97       	sbiw	r26, 0x05	; 5
              break;
    3622:	1e c0       	rjmp	.+60     	; 0x3660 <midi_input_callbacks+0x10c>
            case MIDI_NOTEOFF:
              func = device->input_noteoff_callback;
    3624:	d6 01       	movw	r26, r12
    3626:	16 96       	adiw	r26, 0x06	; 6
    3628:	ed 91       	ld	r30, X+
    362a:	fc 91       	ld	r31, X
    362c:	17 97       	sbiw	r26, 0x07	; 7
              break;
    362e:	18 c0       	rjmp	.+48     	; 0x3660 <midi_input_callbacks+0x10c>
            case MIDI_AFTERTOUCH:
              func = device->input_aftertouch_callback;
    3630:	d6 01       	movw	r26, r12
    3632:	18 96       	adiw	r26, 0x08	; 8
    3634:	ed 91       	ld	r30, X+
    3636:	fc 91       	ld	r31, X
    3638:	19 97       	sbiw	r26, 0x09	; 9
              break;
    363a:	12 c0       	rjmp	.+36     	; 0x3660 <midi_input_callbacks+0x10c>
            case MIDI_PITCHBEND:
              func = device->input_pitchbend_callback;
    363c:	d6 01       	movw	r26, r12
    363e:	1a 96       	adiw	r26, 0x0a	; 10
    3640:	ed 91       	ld	r30, X+
    3642:	fc 91       	ld	r31, X
    3644:	1b 97       	sbiw	r26, 0x0b	; 11
              break;
    3646:	0c c0       	rjmp	.+24     	; 0x3660 <midi_input_callbacks+0x10c>
            case 0xF0:
              if (byte0 == MIDI_SONGPOSITION)
    3648:	b2 ef       	ldi	r27, 0xF2	; 242
    364a:	4b 17       	cp	r20, r27
    364c:	09 f0       	breq	.+2      	; 0x3650 <midi_input_callbacks+0xfc>
    364e:	90 c0       	rjmp	.+288    	; 0x3770 <midi_input_callbacks+0x21c>
                func = device->input_songposition_callback;
    3650:	d6 01       	movw	r26, r12
    3652:	1c 96       	adiw	r26, 0x0c	; 12
    3654:	ed 91       	ld	r30, X+
    3656:	fc 91       	ld	r31, X
    3658:	1d 97       	sbiw	r26, 0x0d	; 13
    365a:	02 c0       	rjmp	.+4      	; 0x3660 <midi_input_callbacks+0x10c>
    }
  } else {
    switch (cnt) {
      case 3:
        {
          midi_three_byte_func_t func = NULL;
    365c:	e0 e0       	ldi	r30, 0x00	; 0
    365e:	f0 e0       	ldi	r31, 0x00	; 0
                func = device->input_songposition_callback;
              break;
            default:
              break;
          }
          if(func) {
    3660:	30 97       	sbiw	r30, 0x00	; 0
    3662:	09 f4       	brne	.+2      	; 0x3666 <midi_input_callbacks+0x112>
    3664:	85 c0       	rjmp	.+266    	; 0x3770 <midi_input_callbacks+0x21c>
            //mask off the channel for non song position functions
            if (byte0 == MIDI_SONGPOSITION)
    3666:	b2 ef       	ldi	r27, 0xF2	; 242
    3668:	fb 16       	cp	r15, r27
    366a:	31 f4       	brne	.+12     	; 0x3678 <midi_input_callbacks+0x124>
              func(device, byte0, byte1, byte2);
    366c:	c6 01       	movw	r24, r12
    366e:	62 ef       	ldi	r22, 0xF2	; 242
    3670:	4e 2d       	mov	r20, r14
    3672:	21 2f       	mov	r18, r17
    3674:	09 95       	icall
    3676:	6c c0       	rjmp	.+216    	; 0x3750 <midi_input_callbacks+0x1fc>
            else
              func(device, byte0 & 0x0F, byte1, byte2);
    3678:	6f 2d       	mov	r22, r15
    367a:	6f 70       	andi	r22, 0x0F	; 15
    367c:	c6 01       	movw	r24, r12
    367e:	4e 2d       	mov	r20, r14
    3680:	21 2f       	mov	r18, r17
    3682:	09 95       	icall
    3684:	65 c0       	rjmp	.+202    	; 0x3750 <midi_input_callbacks+0x1fc>
        }
        break;
      case 2:
        {
          midi_two_byte_func_t func = NULL;
          switch (byte0 & 0xF0) {
    3686:	84 2f       	mov	r24, r20
    3688:	90 e0       	ldi	r25, 0x00	; 0
    368a:	80 7f       	andi	r24, 0xF0	; 240
    368c:	90 70       	andi	r25, 0x00	; 0
    368e:	80 3d       	cpi	r24, 0xD0	; 208
    3690:	91 05       	cpc	r25, r1
    3692:	61 f0       	breq	.+24     	; 0x36ac <midi_input_callbacks+0x158>
    3694:	80 3f       	cpi	r24, 0xF0	; 240
    3696:	91 05       	cpc	r25, r1
    3698:	79 f0       	breq	.+30     	; 0x36b8 <midi_input_callbacks+0x164>
    369a:	80 3c       	cpi	r24, 0xC0	; 192
    369c:	91 05       	cpc	r25, r1
    369e:	f9 f4       	brne	.+62     	; 0x36de <midi_input_callbacks+0x18a>
            case MIDI_PROGCHANGE:
              func = device->input_progchange_callback;
    36a0:	d6 01       	movw	r26, r12
    36a2:	1e 96       	adiw	r26, 0x0e	; 14
    36a4:	ed 91       	ld	r30, X+
    36a6:	fc 91       	ld	r31, X
    36a8:	1f 97       	sbiw	r26, 0x0f	; 15
              break;
    36aa:	1b c0       	rjmp	.+54     	; 0x36e2 <midi_input_callbacks+0x18e>
            case MIDI_CHANPRESSURE:
              func = device->input_chanpressure_callback;
    36ac:	d6 01       	movw	r26, r12
    36ae:	50 96       	adiw	r26, 0x10	; 16
    36b0:	ed 91       	ld	r30, X+
    36b2:	fc 91       	ld	r31, X
    36b4:	51 97       	sbiw	r26, 0x11	; 17
              break;
    36b6:	15 c0       	rjmp	.+42     	; 0x36e2 <midi_input_callbacks+0x18e>
            case 0xF0:
              if (byte0 == MIDI_SONGSELECT)
    36b8:	b3 ef       	ldi	r27, 0xF3	; 243
    36ba:	4b 17       	cp	r20, r27
    36bc:	31 f4       	brne	.+12     	; 0x36ca <midi_input_callbacks+0x176>
                func = device->input_songselect_callback;
    36be:	d6 01       	movw	r26, r12
    36c0:	52 96       	adiw	r26, 0x12	; 18
    36c2:	ed 91       	ld	r30, X+
    36c4:	fc 91       	ld	r31, X
    36c6:	53 97       	sbiw	r26, 0x13	; 19
    36c8:	0c c0       	rjmp	.+24     	; 0x36e2 <midi_input_callbacks+0x18e>
              else if (byte0 == MIDI_TC_QUARTERFRAME)
    36ca:	b1 ef       	ldi	r27, 0xF1	; 241
    36cc:	4b 17       	cp	r20, r27
    36ce:	09 f0       	breq	.+2      	; 0x36d2 <midi_input_callbacks+0x17e>
    36d0:	4f c0       	rjmp	.+158    	; 0x3770 <midi_input_callbacks+0x21c>
                func = device->input_tc_quarterframe_callback;
    36d2:	d6 01       	movw	r26, r12
    36d4:	54 96       	adiw	r26, 0x14	; 20
    36d6:	ed 91       	ld	r30, X+
    36d8:	fc 91       	ld	r31, X
    36da:	55 97       	sbiw	r26, 0x15	; 21
    36dc:	02 c0       	rjmp	.+4      	; 0x36e2 <midi_input_callbacks+0x18e>
          }
        }
        break;
      case 2:
        {
          midi_two_byte_func_t func = NULL;
    36de:	e0 e0       	ldi	r30, 0x00	; 0
    36e0:	f0 e0       	ldi	r31, 0x00	; 0
                func = device->input_tc_quarterframe_callback;
              break;
            default:
              break;
          }
          if(func) {
    36e2:	30 97       	sbiw	r30, 0x00	; 0
    36e4:	09 f4       	brne	.+2      	; 0x36e8 <midi_input_callbacks+0x194>
    36e6:	44 c0       	rjmp	.+136    	; 0x3770 <midi_input_callbacks+0x21c>
            //mask off the channel
            if (byte0 == MIDI_SONGSELECT || byte0 == MIDI_TC_QUARTERFRAME)
    36e8:	b3 ef       	ldi	r27, 0xF3	; 243
    36ea:	fb 16       	cp	r15, r27
    36ec:	19 f0       	breq	.+6      	; 0x36f4 <midi_input_callbacks+0x1a0>
    36ee:	81 ef       	ldi	r24, 0xF1	; 241
    36f0:	f8 16       	cp	r15, r24
    36f2:	29 f4       	brne	.+10     	; 0x36fe <midi_input_callbacks+0x1aa>
              func(device, byte0, byte1);
    36f4:	c6 01       	movw	r24, r12
    36f6:	6f 2d       	mov	r22, r15
    36f8:	4e 2d       	mov	r20, r14
    36fa:	09 95       	icall
    36fc:	29 c0       	rjmp	.+82     	; 0x3750 <midi_input_callbacks+0x1fc>
            else
              func(device, byte0 & 0x0F, byte1);
    36fe:	6f 2d       	mov	r22, r15
    3700:	6f 70       	andi	r22, 0x0F	; 15
    3702:	c6 01       	movw	r24, r12
    3704:	4e 2d       	mov	r20, r14
    3706:	09 95       	icall
    3708:	23 c0       	rjmp	.+70     	; 0x3750 <midi_input_callbacks+0x1fc>
        }
        break;
      case 1:
        {
          midi_one_byte_func_t func = NULL;
          if (midi_is_realtime(byte0))
    370a:	84 2f       	mov	r24, r20
    370c:	0e 94 47 18 	call	0x308e	; 0x308e <midi_is_realtime>
    3710:	88 23       	and	r24, r24
    3712:	31 f0       	breq	.+12     	; 0x3720 <midi_input_callbacks+0x1cc>
            func = device->input_realtime_callback;
    3714:	d6 01       	movw	r26, r12
    3716:	56 96       	adiw	r26, 0x16	; 22
    3718:	ed 91       	ld	r30, X+
    371a:	fc 91       	ld	r31, X
    371c:	57 97       	sbiw	r26, 0x17	; 23
    371e:	08 c0       	rjmp	.+16     	; 0x3730 <midi_input_callbacks+0x1dc>
          else if (byte0 == MIDI_TUNEREQUEST)
    3720:	b6 ef       	ldi	r27, 0xF6	; 246
    3722:	fb 16       	cp	r15, r27
    3724:	29 f5       	brne	.+74     	; 0x3770 <midi_input_callbacks+0x21c>
            func = device->input_tunerequest_callback;
    3726:	d6 01       	movw	r26, r12
    3728:	58 96       	adiw	r26, 0x18	; 24
    372a:	ed 91       	ld	r30, X+
    372c:	fc 91       	ld	r31, X
    372e:	59 97       	sbiw	r26, 0x19	; 25
          if (func) {
    3730:	30 97       	sbiw	r30, 0x00	; 0
    3732:	f1 f0       	breq	.+60     	; 0x3770 <midi_input_callbacks+0x21c>
            func(device, byte0);
    3734:	c6 01       	movw	r24, r12
    3736:	6f 2d       	mov	r22, r15
    3738:	09 95       	icall
    373a:	0a c0       	rjmp	.+20     	; 0x3750 <midi_input_callbacks+0x1fc>
          }
        }
        break;
      default:
        //just in case
        if (cnt > 3)
    373c:	64 30       	cpi	r22, 0x04	; 4
    373e:	71 05       	cpc	r23, r1
    3740:	a8 f4       	brcc	.+42     	; 0x376c <midi_input_callbacks+0x218>
    3742:	16 c0       	rjmp	.+44     	; 0x3770 <midi_input_callbacks+0x21c>
  }

  //if there is fallthrough default callback and we haven't called a more specific one, 
  //call the fallthrough
  if (!called && device->input_fallthrough_callback)
    device->input_fallthrough_callback(device, cnt, byte0, byte1, byte2);
    3744:	c6 01       	movw	r24, r12
    3746:	b5 01       	movw	r22, r10
    3748:	4f 2d       	mov	r20, r15
    374a:	2e 2d       	mov	r18, r14
    374c:	01 2f       	mov	r16, r17
    374e:	09 95       	icall
  //always call the catch all if it exists
  if (device->input_catchall_callback)
    3750:	d6 01       	movw	r26, r12
    3752:	5e 96       	adiw	r26, 0x1e	; 30
    3754:	ed 91       	ld	r30, X+
    3756:	fc 91       	ld	r31, X
    3758:	5f 97       	sbiw	r26, 0x1f	; 31
    375a:	30 97       	sbiw	r30, 0x00	; 0
    375c:	89 f0       	breq	.+34     	; 0x3780 <midi_input_callbacks+0x22c>
    device->input_catchall_callback(device, cnt, byte0, byte1, byte2);
    375e:	c6 01       	movw	r24, r12
    3760:	b5 01       	movw	r22, r10
    3762:	4f 2d       	mov	r20, r15
    3764:	2e 2d       	mov	r18, r14
    3766:	01 2f       	mov	r16, r17
    3768:	09 95       	icall
    376a:	0a c0       	rjmp	.+20     	; 0x3780 <midi_input_callbacks+0x22c>
        }
        break;
      default:
        //just in case
        if (cnt > 3)
          cnt = 0;
    376c:	aa 24       	eor	r10, r10
    376e:	bb 24       	eor	r11, r11
    }
  }

  //if there is fallthrough default callback and we haven't called a more specific one, 
  //call the fallthrough
  if (!called && device->input_fallthrough_callback)
    3770:	d6 01       	movw	r26, r12
    3772:	5c 96       	adiw	r26, 0x1c	; 28
    3774:	ed 91       	ld	r30, X+
    3776:	fc 91       	ld	r31, X
    3778:	5d 97       	sbiw	r26, 0x1d	; 29
    377a:	30 97       	sbiw	r30, 0x00	; 0
    377c:	19 f7       	brne	.-58     	; 0x3744 <midi_input_callbacks+0x1f0>
    377e:	e8 cf       	rjmp	.-48     	; 0x3750 <midi_input_callbacks+0x1fc>
    device->input_fallthrough_callback(device, cnt, byte0, byte1, byte2);
  //always call the catch all if it exists
  if (device->input_catchall_callback)
    device->input_catchall_callback(device, cnt, byte0, byte1, byte2);
}
    3780:	0f 90       	pop	r0
    3782:	0f 90       	pop	r0
    3784:	0f 90       	pop	r0
    3786:	df 91       	pop	r29
    3788:	cf 91       	pop	r28
    378a:	1f 91       	pop	r17
    378c:	0f 91       	pop	r16
    378e:	ff 90       	pop	r15
    3790:	ef 90       	pop	r14
    3792:	df 90       	pop	r13
    3794:	cf 90       	pop	r12
    3796:	bf 90       	pop	r11
    3798:	af 90       	pop	r10
    379a:	08 95       	ret

0000379c <midi_process_byte>:
    midi_process_byte(device, val);
    bytequeue_remove(&device->input_queue, 1);
  }
}

void midi_process_byte(MidiDevice * device, uint8_t input) {
    379c:	ef 92       	push	r14
    379e:	ff 92       	push	r15
    37a0:	0f 93       	push	r16
    37a2:	cf 93       	push	r28
    37a4:	df 93       	push	r29
    37a6:	7c 01       	movw	r14, r24
    37a8:	c6 2f       	mov	r28, r22
  if (midi_is_realtime(input)) {
    37aa:	86 2f       	mov	r24, r22
    37ac:	0e 94 47 18 	call	0x308e	; 0x308e <midi_is_realtime>
    37b0:	88 23       	and	r24, r24
    37b2:	91 f0       	breq	.+36     	; 0x37d8 <midi_process_byte+0x3c>
    //call callback, store and restore state
    input_state_t state = device->input_state;
    37b4:	d7 01       	movw	r26, r14
    37b6:	95 96       	adiw	r26, 0x25	; 37
    37b8:	dc 91       	ld	r29, X
    37ba:	95 97       	sbiw	r26, 0x25	; 37
    device->input_state = ONE_BYTE_MESSAGE;
    37bc:	81 e0       	ldi	r24, 0x01	; 1
    37be:	95 96       	adiw	r26, 0x25	; 37
    37c0:	8c 93       	st	X, r24
    midi_input_callbacks(device, 1, input, 0, 0);
    37c2:	c7 01       	movw	r24, r14
    37c4:	61 e0       	ldi	r22, 0x01	; 1
    37c6:	70 e0       	ldi	r23, 0x00	; 0
    37c8:	4c 2f       	mov	r20, r28
    37ca:	20 e0       	ldi	r18, 0x00	; 0
    37cc:	00 e0       	ldi	r16, 0x00	; 0
    37ce:	0e 94 aa 1a 	call	0x3554	; 0x3554 <midi_input_callbacks>
    device->input_state = state;
    37d2:	f7 01       	movw	r30, r14
    37d4:	d5 a3       	lds	r29, 0x55
    37d6:	b7 c0       	rjmp	.+366    	; 0x3946 <midi_process_byte+0x1aa>
  } else if (midi_is_statusbyte(input)) {
    37d8:	8c 2f       	mov	r24, r28
    37da:	0e 94 43 18 	call	0x3086	; 0x3086 <midi_is_statusbyte>
    37de:	88 23       	and	r24, r24
    37e0:	09 f4       	brne	.+2      	; 0x37e4 <midi_process_byte+0x48>
    37e2:	73 c0       	rjmp	.+230    	; 0x38ca <midi_process_byte+0x12e>
    //store the byte
    if (device->input_state != SYSEX_MESSAGE) {
    37e4:	d7 01       	movw	r26, r14
    37e6:	95 96       	adiw	r26, 0x25	; 37
    37e8:	8c 91       	ld	r24, X
    37ea:	95 97       	sbiw	r26, 0x25	; 37
    37ec:	84 30       	cpi	r24, 0x04	; 4
    37ee:	49 f0       	breq	.+18     	; 0x3802 <midi_process_byte+0x66>
      device->input_buffer[0] = input;
    37f0:	92 96       	adiw	r26, 0x22	; 34
    37f2:	cc 93       	st	X, r28
    37f4:	92 97       	sbiw	r26, 0x22	; 34
      device->input_count = 1;
    37f6:	81 e0       	ldi	r24, 0x01	; 1
    37f8:	90 e0       	ldi	r25, 0x00	; 0
    37fa:	97 96       	adiw	r26, 0x27	; 39
    37fc:	9c 93       	st	X, r25
    37fe:	8e 93       	st	-X, r24
    3800:	96 97       	sbiw	r26, 0x26	; 38
    }
    switch (midi_packet_length(input)) {
    3802:	8c 2f       	mov	r24, r28
    3804:	0e 94 4d 18 	call	0x309a	; 0x309a <midi_packet_length>
    3808:	81 30       	cpi	r24, 0x01	; 1
    380a:	41 f0       	breq	.+16     	; 0x381c <midi_process_byte+0x80>
    380c:	81 30       	cpi	r24, 0x01	; 1
    380e:	00 f1       	brcs	.+64     	; 0x3850 <midi_process_byte+0xb4>
    3810:	82 30       	cpi	r24, 0x02	; 2
    3812:	a1 f0       	breq	.+40     	; 0x383c <midi_process_byte+0xa0>
    3814:	83 30       	cpi	r24, 0x03	; 3
    3816:	09 f0       	breq	.+2      	; 0x381a <midi_process_byte+0x7e>
    3818:	4f c0       	rjmp	.+158    	; 0x38b8 <midi_process_byte+0x11c>
    381a:	14 c0       	rjmp	.+40     	; 0x3844 <midi_process_byte+0xa8>
      case ONE1:
        device->input_state = ONE_BYTE_MESSAGE;;
    381c:	81 e0       	ldi	r24, 0x01	; 1
    381e:	f7 01       	movw	r30, r14
    3820:	85 a3       	lds	r24, 0x55
        midi_input_callbacks(device, 1, input, 0, 0);
    3822:	c7 01       	movw	r24, r14
    3824:	61 e0       	ldi	r22, 0x01	; 1
    3826:	70 e0       	ldi	r23, 0x00	; 0
    3828:	4c 2f       	mov	r20, r28
    382a:	20 e0       	ldi	r18, 0x00	; 0
    382c:	00 e0       	ldi	r16, 0x00	; 0
    382e:	0e 94 aa 1a 	call	0x3554	; 0x3554 <midi_input_callbacks>
        device->input_state = IDLE;
    3832:	d7 01       	movw	r26, r14
    3834:	95 96       	adiw	r26, 0x25	; 37
    3836:	1c 92       	st	X, r1
    3838:	95 97       	sbiw	r26, 0x25	; 37
        break;
    383a:	85 c0       	rjmp	.+266    	; 0x3946 <midi_process_byte+0x1aa>
      case TWO2:
        device->input_state = TWO_BYTE_MESSAGE;
    383c:	82 e0       	ldi	r24, 0x02	; 2
    383e:	f7 01       	movw	r30, r14
    3840:	85 a3       	lds	r24, 0x55
        break;
    3842:	81 c0       	rjmp	.+258    	; 0x3946 <midi_process_byte+0x1aa>
      case THREE3:
        device->input_state = THREE_BYTE_MESSAGE;
    3844:	83 e0       	ldi	r24, 0x03	; 3
    3846:	d7 01       	movw	r26, r14
    3848:	95 96       	adiw	r26, 0x25	; 37
    384a:	8c 93       	st	X, r24
    384c:	95 97       	sbiw	r26, 0x25	; 37
        break;
    384e:	7b c0       	rjmp	.+246    	; 0x3946 <midi_process_byte+0x1aa>
      case UNDEFINED:
        switch(input) {
    3850:	c0 3f       	cpi	r28, 0xF0	; 240
    3852:	19 f0       	breq	.+6      	; 0x385a <midi_process_byte+0xbe>
    3854:	c7 3f       	cpi	r28, 0xF7	; 247
    3856:	59 f5       	brne	.+86     	; 0x38ae <midi_process_byte+0x112>
    3858:	0a c0       	rjmp	.+20     	; 0x386e <midi_process_byte+0xd2>
          case SYSEX_BEGIN:
            device->input_state = SYSEX_MESSAGE;
    385a:	84 e0       	ldi	r24, 0x04	; 4
    385c:	f7 01       	movw	r30, r14
    385e:	85 a3       	lds	r24, 0x55
            device->input_buffer[0] = input;
    3860:	80 ef       	ldi	r24, 0xF0	; 240
    3862:	82 a3       	lds	r24, 0x52
            device->input_count = 1;
    3864:	81 e0       	ldi	r24, 0x01	; 1
    3866:	90 e0       	ldi	r25, 0x00	; 0
    3868:	97 a3       	lds	r25, 0x57
    386a:	86 a3       	lds	r24, 0x56
            break;
    386c:	6c c0       	rjmp	.+216    	; 0x3946 <midi_process_byte+0x1aa>
          case SYSEX_END:
            //send what is left in the input buffer, set idle
            device->input_buffer[device->input_count % 3] = input;
    386e:	d7 01       	movw	r26, r14
    3870:	96 96       	adiw	r26, 0x26	; 38
    3872:	2d 91       	ld	r18, X+
    3874:	3c 91       	ld	r19, X
    3876:	97 97       	sbiw	r26, 0x27	; 39
    3878:	c9 01       	movw	r24, r18
    387a:	63 e0       	ldi	r22, 0x03	; 3
    387c:	70 e0       	ldi	r23, 0x00	; 0
    387e:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <__udivmodhi4>
    3882:	f7 01       	movw	r30, r14
    3884:	e8 0f       	add	r30, r24
    3886:	f9 1f       	adc	r31, r25
    3888:	87 ef       	ldi	r24, 0xF7	; 247
    388a:	82 a3       	lds	r24, 0x52
            device->input_count += 1;
    388c:	b9 01       	movw	r22, r18
    388e:	6f 5f       	subi	r22, 0xFF	; 255
    3890:	7f 4f       	sbci	r23, 0xFF	; 255
    3892:	f7 01       	movw	r30, r14
    3894:	77 a3       	lds	r23, 0x57
    3896:	66 a3       	lds	r22, 0x56
            //call the callback
            midi_input_callbacks(device, device->input_count, 
    3898:	c7 01       	movw	r24, r14
    389a:	42 a1       	lds	r20, 0x42
    389c:	23 a1       	lds	r18, 0x43
    389e:	04 a1       	lds	r16, 0x44
    38a0:	0e 94 aa 1a 	call	0x3554	; 0x3554 <midi_input_callbacks>
                device->input_buffer[0], device->input_buffer[1], device->input_buffer[2]);
            device->input_state = IDLE;
    38a4:	d7 01       	movw	r26, r14
    38a6:	95 96       	adiw	r26, 0x25	; 37
    38a8:	1c 92       	st	X, r1
    38aa:	95 97       	sbiw	r26, 0x25	; 37
            break;
    38ac:	4c c0       	rjmp	.+152    	; 0x3946 <midi_process_byte+0x1aa>
          default:
            device->input_state = IDLE;
    38ae:	f7 01       	movw	r30, r14
    38b0:	15 a2       	lds	r17, 0x95
            device->input_count = 0;
    38b2:	17 a2       	lds	r17, 0x97
    38b4:	16 a2       	lds	r17, 0x96
    38b6:	47 c0       	rjmp	.+142    	; 0x3946 <midi_process_byte+0x1aa>
        }

        break;
      default:
        device->input_state = IDLE;
    38b8:	d7 01       	movw	r26, r14
    38ba:	95 96       	adiw	r26, 0x25	; 37
    38bc:	1c 92       	st	X, r1
    38be:	95 97       	sbiw	r26, 0x25	; 37
        device->input_count = 0;
    38c0:	97 96       	adiw	r26, 0x27	; 39
    38c2:	1c 92       	st	X, r1
    38c4:	1e 92       	st	-X, r1
    38c6:	96 97       	sbiw	r26, 0x26	; 38
        break;
    38c8:	3e c0       	rjmp	.+124    	; 0x3946 <midi_process_byte+0x1aa>
    }
  } else {
    if (device->input_state != IDLE) {
    38ca:	f7 01       	movw	r30, r14
    38cc:	25 a1       	lds	r18, 0x45
    38ce:	22 23       	and	r18, r18
    38d0:	d1 f1       	breq	.+116    	; 0x3946 <midi_process_byte+0x1aa>
      //store the byte
      device->input_buffer[device->input_count % 3] = input;
    38d2:	06 a0       	lds	r16, 0x86
    38d4:	f7 a1       	lds	r31, 0x47
    38d6:	e0 2d       	mov	r30, r0
    38d8:	cf 01       	movw	r24, r30
    38da:	63 e0       	ldi	r22, 0x03	; 3
    38dc:	70 e0       	ldi	r23, 0x00	; 0
    38de:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <__udivmodhi4>
    38e2:	ac 01       	movw	r20, r24
    38e4:	8e 0d       	add	r24, r14
    38e6:	9f 1d       	adc	r25, r15
    38e8:	dc 01       	movw	r26, r24
    38ea:	92 96       	adiw	r26, 0x22	; 34
    38ec:	cc 93       	st	X, r28
    38ee:	92 97       	sbiw	r26, 0x22	; 34
      //increment count
      uint16_t prev = device->input_count;
      device->input_count += 1;
    38f0:	bf 01       	movw	r22, r30
    38f2:	6f 5f       	subi	r22, 0xFF	; 255
    38f4:	7f 4f       	sbci	r23, 0xFF	; 255
    38f6:	f7 01       	movw	r30, r14
    38f8:	77 a3       	lds	r23, 0x57
    38fa:	66 a3       	lds	r22, 0x56

      switch(prev % 3) {
    38fc:	41 30       	cpi	r20, 0x01	; 1
    38fe:	51 05       	cpc	r21, r1
    3900:	91 f0       	breq	.+36     	; 0x3926 <midi_process_byte+0x18a>
    3902:	42 30       	cpi	r20, 0x02	; 2
    3904:	51 05       	cpc	r21, r1
    3906:	f9 f4       	brne	.+62     	; 0x3946 <midi_process_byte+0x1aa>
        case 2:
          //call callback
          midi_input_callbacks(device, device->input_count,
    3908:	c7 01       	movw	r24, r14
    390a:	42 a1       	lds	r20, 0x42
    390c:	23 a1       	lds	r18, 0x43
    390e:	04 a1       	lds	r16, 0x44
    3910:	0e 94 aa 1a 	call	0x3554	; 0x3554 <midi_input_callbacks>
              device->input_buffer[0], device->input_buffer[1], device->input_buffer[2]);
          if (device->input_state != SYSEX_MESSAGE) {
    3914:	f7 01       	movw	r30, r14
    3916:	85 a1       	lds	r24, 0x45
    3918:	84 30       	cpi	r24, 0x04	; 4
    391a:	a9 f0       	breq	.+42     	; 0x3946 <midi_process_byte+0x1aa>
            //set to 1, keeping status byte, allowing for running status
            device->input_count = 1;
    391c:	81 e0       	ldi	r24, 0x01	; 1
    391e:	90 e0       	ldi	r25, 0x00	; 0
    3920:	97 a3       	lds	r25, 0x57
    3922:	86 a3       	lds	r24, 0x56
    3924:	10 c0       	rjmp	.+32     	; 0x3946 <midi_process_byte+0x1aa>
          }
          break;
        case 1:
          if (device->input_state == TWO_BYTE_MESSAGE) {
    3926:	22 30       	cpi	r18, 0x02	; 2
    3928:	71 f4       	brne	.+28     	; 0x3946 <midi_process_byte+0x1aa>
            //call callback
            midi_input_callbacks(device, device->input_count,
    392a:	c7 01       	movw	r24, r14
    392c:	42 a1       	lds	r20, 0x42
    392e:	23 a1       	lds	r18, 0x43
    3930:	00 e0       	ldi	r16, 0x00	; 0
    3932:	0e 94 aa 1a 	call	0x3554	; 0x3554 <midi_input_callbacks>
                device->input_buffer[0], device->input_buffer[1], 0);
            if (device->input_state != SYSEX_MESSAGE) {
    3936:	f7 01       	movw	r30, r14
    3938:	85 a1       	lds	r24, 0x45
    393a:	84 30       	cpi	r24, 0x04	; 4
    393c:	21 f0       	breq	.+8      	; 0x3946 <midi_process_byte+0x1aa>
              //set to 1, keeping status byte, allowing for running status
              device->input_count = 1;
    393e:	81 e0       	ldi	r24, 0x01	; 1
    3940:	90 e0       	ldi	r25, 0x00	; 0
    3942:	97 a3       	lds	r25, 0x57
    3944:	86 a3       	lds	r24, 0x56
          //one byte messages are dealt with directly
          break;
      }
    }
  }
}
    3946:	df 91       	pop	r29
    3948:	cf 91       	pop	r28
    394a:	0f 91       	pop	r16
    394c:	ff 90       	pop	r15
    394e:	ef 90       	pop	r14
    3950:	08 95       	ret

00003952 <midi_device_process>:

void midi_device_set_pre_input_process_func(MidiDevice * device, midi_no_byte_func_t pre_process_func){
  device->pre_input_process_callback = pre_process_func;
}

void midi_device_process(MidiDevice * device) {
    3952:	cf 92       	push	r12
    3954:	df 92       	push	r13
    3956:	ef 92       	push	r14
    3958:	ff 92       	push	r15
    395a:	0f 93       	push	r16
    395c:	1f 93       	push	r17
    395e:	cf 93       	push	r28
    3960:	df 93       	push	r29
    3962:	6c 01       	movw	r12, r24
  //call the pre_input_process_callback if there is one
  if(device->pre_input_process_callback)
    3964:	dc 01       	movw	r26, r24
    3966:	90 96       	adiw	r26, 0x20	; 32
    3968:	ed 91       	ld	r30, X+
    396a:	fc 91       	ld	r31, X
    396c:	91 97       	sbiw	r26, 0x21	; 33
    396e:	30 97       	sbiw	r30, 0x00	; 0
    3970:	09 f0       	breq	.+2      	; 0x3974 <midi_device_process+0x22>
    device->pre_input_process_callback(device);
    3972:	09 95       	icall

  //pull stuff off the queue and process
  byteQueueIndex_t len = bytequeue_length(&device->input_queue);
    3974:	0f 2e       	mov	r0, r31
    3976:	f8 ee       	ldi	r31, 0xE8	; 232
    3978:	ef 2e       	mov	r14, r31
    397a:	ff 24       	eor	r15, r15
    397c:	f0 2d       	mov	r31, r0
    397e:	ec 0c       	add	r14, r12
    3980:	fd 1c       	adc	r15, r13
    3982:	c7 01       	movw	r24, r14
    3984:	0e 94 fe 17 	call	0x2ffc	; 0x2ffc <bytequeue_length>
  uint16_t i;
  //TODO limit number of bytes processed?
  for(i = 0; i < len; i++) {
    3988:	c8 2f       	mov	r28, r24
    398a:	d0 e0       	ldi	r29, 0x00	; 0
    398c:	20 97       	sbiw	r28, 0x00	; 0
    398e:	99 f0       	breq	.+38     	; 0x39b6 <midi_device_process+0x64>
    3990:	00 e0       	ldi	r16, 0x00	; 0
    3992:	10 e0       	ldi	r17, 0x00	; 0
    uint8_t val = bytequeue_get(&device->input_queue, 0);
    3994:	c7 01       	movw	r24, r14
    3996:	60 e0       	ldi	r22, 0x00	; 0
    3998:	0e 94 13 18 	call	0x3026	; 0x3026 <bytequeue_get>
    399c:	68 2f       	mov	r22, r24
    midi_process_byte(device, val);
    399e:	c6 01       	movw	r24, r12
    39a0:	0e 94 ce 1b 	call	0x379c	; 0x379c <midi_process_byte>
    bytequeue_remove(&device->input_queue, 1);
    39a4:	c7 01       	movw	r24, r14
    39a6:	61 e0       	ldi	r22, 0x01	; 1
    39a8:	0e 94 24 18 	call	0x3048	; 0x3048 <bytequeue_remove>

  //pull stuff off the queue and process
  byteQueueIndex_t len = bytequeue_length(&device->input_queue);
  uint16_t i;
  //TODO limit number of bytes processed?
  for(i = 0; i < len; i++) {
    39ac:	0f 5f       	subi	r16, 0xFF	; 255
    39ae:	1f 4f       	sbci	r17, 0xFF	; 255
    39b0:	0c 17       	cp	r16, r28
    39b2:	1d 07       	cpc	r17, r29
    39b4:	78 f3       	brcs	.-34     	; 0x3994 <midi_device_process+0x42>
    uint8_t val = bytequeue_get(&device->input_queue, 0);
    midi_process_byte(device, val);
    bytequeue_remove(&device->input_queue, 1);
  }
}
    39b6:	df 91       	pop	r29
    39b8:	cf 91       	pop	r28
    39ba:	1f 91       	pop	r17
    39bc:	0f 91       	pop	r16
    39be:	ff 90       	pop	r15
    39c0:	ef 90       	pop	r14
    39c2:	df 90       	pop	r13
    39c4:	cf 90       	pop	r12
    39c6:	08 95       	ret

000039c8 <sysex_encoded_length>:
//You should have received a copy of the GNU General Public License
//along with avr-midi.  If not, see <http://www.gnu.org/licenses/>.

#include "sysex_tools.h"

uint16_t sysex_encoded_length(uint16_t decoded_length){
    39c8:	9c 01       	movw	r18, r24
   uint8_t remainder = decoded_length % 7;
    39ca:	67 e0       	ldi	r22, 0x07	; 7
    39cc:	70 e0       	ldi	r23, 0x00	; 0
    39ce:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <__udivmodhi4>
    39d2:	48 2f       	mov	r20, r24
   if (remainder)
    39d4:	88 23       	and	r24, r24
    39d6:	81 f0       	breq	.+32     	; 0x39f8 <sysex_encoded_length+0x30>
      return (decoded_length / 7) * 8 + remainder + 1;
    39d8:	c9 01       	movw	r24, r18
    39da:	67 e0       	ldi	r22, 0x07	; 7
    39dc:	70 e0       	ldi	r23, 0x00	; 0
    39de:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <__udivmodhi4>
    39e2:	cb 01       	movw	r24, r22
    39e4:	88 0f       	add	r24, r24
    39e6:	99 1f       	adc	r25, r25
    39e8:	88 0f       	add	r24, r24
    39ea:	99 1f       	adc	r25, r25
    39ec:	88 0f       	add	r24, r24
    39ee:	99 1f       	adc	r25, r25
    39f0:	01 96       	adiw	r24, 0x01	; 1
    39f2:	84 0f       	add	r24, r20
    39f4:	91 1d       	adc	r25, r1
    39f6:	08 95       	ret
   else
      return (decoded_length / 7) * 8;
    39f8:	c9 01       	movw	r24, r18
    39fa:	67 e0       	ldi	r22, 0x07	; 7
    39fc:	70 e0       	ldi	r23, 0x00	; 0
    39fe:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <__udivmodhi4>
    3a02:	cb 01       	movw	r24, r22
    3a04:	88 0f       	add	r24, r24
    3a06:	99 1f       	adc	r25, r25
    3a08:	88 0f       	add	r24, r24
    3a0a:	99 1f       	adc	r25, r25
    3a0c:	88 0f       	add	r24, r24
    3a0e:	99 1f       	adc	r25, r25
}
    3a10:	08 95       	ret

00003a12 <sysex_decoded_length>:

uint16_t sysex_decoded_length(uint16_t encoded_length){
   uint8_t remainder = encoded_length % 8;
    3a12:	48 2f       	mov	r20, r24
    3a14:	47 70       	andi	r20, 0x07	; 7
   if (remainder)
    3a16:	a1 f0       	breq	.+40     	; 0x3a40 <sysex_decoded_length+0x2e>
      return (encoded_length / 8) * 7 + remainder - 1;
    3a18:	9c 01       	movw	r18, r24
    3a1a:	36 95       	lsr	r19
    3a1c:	27 95       	ror	r18
    3a1e:	36 95       	lsr	r19
    3a20:	27 95       	ror	r18
    3a22:	36 95       	lsr	r19
    3a24:	27 95       	ror	r18
    3a26:	c9 01       	movw	r24, r18
    3a28:	88 0f       	add	r24, r24
    3a2a:	99 1f       	adc	r25, r25
    3a2c:	88 0f       	add	r24, r24
    3a2e:	99 1f       	adc	r25, r25
    3a30:	88 0f       	add	r24, r24
    3a32:	99 1f       	adc	r25, r25
    3a34:	82 1b       	sub	r24, r18
    3a36:	93 0b       	sbc	r25, r19
    3a38:	01 97       	sbiw	r24, 0x01	; 1
    3a3a:	84 0f       	add	r24, r20
    3a3c:	91 1d       	adc	r25, r1
    3a3e:	08 95       	ret
   else
      return (encoded_length / 8) * 7;
    3a40:	9c 01       	movw	r18, r24
    3a42:	36 95       	lsr	r19
    3a44:	27 95       	ror	r18
    3a46:	36 95       	lsr	r19
    3a48:	27 95       	ror	r18
    3a4a:	36 95       	lsr	r19
    3a4c:	27 95       	ror	r18
    3a4e:	c9 01       	movw	r24, r18
    3a50:	88 0f       	add	r24, r24
    3a52:	99 1f       	adc	r25, r25
    3a54:	88 0f       	add	r24, r24
    3a56:	99 1f       	adc	r25, r25
    3a58:	88 0f       	add	r24, r24
    3a5a:	99 1f       	adc	r25, r25
    3a5c:	82 1b       	sub	r24, r18
    3a5e:	93 0b       	sbc	r25, r19
}
    3a60:	08 95       	ret

00003a62 <sysex_encode>:

uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
    3a62:	2f 92       	push	r2
    3a64:	3f 92       	push	r3
    3a66:	4f 92       	push	r4
    3a68:	5f 92       	push	r5
    3a6a:	6f 92       	push	r6
    3a6c:	7f 92       	push	r7
    3a6e:	8f 92       	push	r8
    3a70:	9f 92       	push	r9
    3a72:	af 92       	push	r10
    3a74:	bf 92       	push	r11
    3a76:	cf 92       	push	r12
    3a78:	df 92       	push	r13
    3a7a:	ef 92       	push	r14
    3a7c:	ff 92       	push	r15
    3a7e:	0f 93       	push	r16
    3a80:	1f 93       	push	r17
    3a82:	cf 93       	push	r28
    3a84:	df 93       	push	r29
    3a86:	00 d0       	rcall	.+0      	; 0x3a88 <sysex_encode+0x26>
    3a88:	00 d0       	rcall	.+0      	; 0x3a8a <sysex_encode+0x28>
    3a8a:	00 d0       	rcall	.+0      	; 0x3a8c <sysex_encode+0x2a>
    3a8c:	cd b7       	in	r28, 0x3d	; 61
    3a8e:	de b7       	in	r29, 0x3e	; 62
    3a90:	1c 01       	movw	r2, r24
    3a92:	7a 83       	std	Y+2, r23	; 0x02
    3a94:	69 83       	std	Y+1, r22	; 0x01
    3a96:	3a 01       	movw	r6, r20
   uint16_t encoded_full = length / 7; //number of full 8 byte sections from 7 bytes of input
    3a98:	ca 01       	movw	r24, r20
    3a9a:	67 e0       	ldi	r22, 0x07	; 7
    3a9c:	70 e0       	ldi	r23, 0x00	; 0
    3a9e:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <__udivmodhi4>
    3aa2:	2b 01       	movw	r4, r22
    3aa4:	5b 01       	movw	r10, r22
   uint16_t i,j;

   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
    3aa6:	61 15       	cp	r22, r1
    3aa8:	71 05       	cpc	r23, r1
    3aaa:	b1 f1       	breq	.+108    	; 0x3b18 <sysex_encode+0xb6>
    3aac:	81 01       	movw	r16, r2
    3aae:	e9 80       	ldd	r14, Y+1	; 0x01
    3ab0:	fa 80       	ldd	r15, Y+2	; 0x02
    3ab2:	cc 24       	eor	r12, r12
    3ab4:	dd 24       	eor	r13, r13
      uint16_t encoded_msb_idx = i * 8;
      uint16_t input_start_idx = i * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < 7; j++){
    3ab6:	88 24       	eor	r8, r8
    3ab8:	99 24       	eor	r9, r9
      return (encoded_length / 8) * 7 + remainder - 1;
   else
      return (encoded_length / 8) * 7;
}

uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
    3aba:	1e 83       	std	Y+6, r17	; 0x06
    3abc:	0d 83       	std	Y+5, r16	; 0x05

   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t input_start_idx = i * 7;
      encoded[encoded_msb_idx] = 0;
    3abe:	f8 01       	movw	r30, r16
    3ac0:	11 92       	st	Z+, r1
      return (encoded_length / 8) * 7 + remainder - 1;
   else
      return (encoded_length / 8) * 7;
}

uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
    3ac2:	fc 82       	std	Y+4, r15	; 0x04
    3ac4:	eb 82       	std	Y+3, r14	; 0x03
   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t input_start_idx = i * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < 7; j++){
    3ac6:	a4 01       	movw	r20, r8
         uint8_t current = source[input_start_idx + j];
    3ac8:	ab 81       	ldd	r26, Y+3	; 0x03
    3aca:	bc 81       	ldd	r27, Y+4	; 0x04
    3acc:	2d 91       	ld	r18, X+
    3ace:	bc 83       	std	Y+4, r27	; 0x04
    3ad0:	ab 83       	std	Y+3, r26	; 0x03
         encoded[encoded_msb_idx] |= (0x80 & current) >> (1 + j);
    3ad2:	4f 5f       	subi	r20, 0xFF	; 255
    3ad4:	5f 4f       	sbci	r21, 0xFF	; 255
    3ad6:	82 2f       	mov	r24, r18
    3ad8:	90 e0       	ldi	r25, 0x00	; 0
    3ada:	80 78       	andi	r24, 0x80	; 128
    3adc:	90 70       	andi	r25, 0x00	; 0
    3ade:	bc 01       	movw	r22, r24
    3ae0:	04 2e       	mov	r0, r20
    3ae2:	02 c0       	rjmp	.+4      	; 0x3ae8 <sysex_encode+0x86>
    3ae4:	75 95       	asr	r23
    3ae6:	67 95       	ror	r22
    3ae8:	0a 94       	dec	r0
    3aea:	e2 f7       	brpl	.-8      	; 0x3ae4 <sysex_encode+0x82>
    3aec:	ad 81       	ldd	r26, Y+5	; 0x05
    3aee:	be 81       	ldd	r27, Y+6	; 0x06
    3af0:	8c 91       	ld	r24, X
    3af2:	86 2b       	or	r24, r22
    3af4:	8c 93       	st	X, r24
         encoded[encoded_msb_idx + 1 + j] = 0x7F & current;
    3af6:	2f 77       	andi	r18, 0x7F	; 127
    3af8:	21 93       	st	Z+, r18
   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t input_start_idx = i * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < 7; j++){
    3afa:	47 30       	cpi	r20, 0x07	; 7
    3afc:	51 05       	cpc	r21, r1
    3afe:	21 f7       	brne	.-56     	; 0x3ac8 <sysex_encode+0x66>
uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
   uint16_t encoded_full = length / 7; //number of full 8 byte sections from 7 bytes of input
   uint16_t i,j;

   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
    3b00:	08 94       	sec
    3b02:	c1 1c       	adc	r12, r1
    3b04:	d1 1c       	adc	r13, r1
    3b06:	08 5f       	subi	r16, 0xF8	; 248
    3b08:	1f 4f       	sbci	r17, 0xFF	; 255
    3b0a:	e7 e0       	ldi	r30, 0x07	; 7
    3b0c:	f0 e0       	ldi	r31, 0x00	; 0
    3b0e:	ee 0e       	add	r14, r30
    3b10:	ff 1e       	adc	r15, r31
    3b12:	ca 14       	cp	r12, r10
    3b14:	db 04       	cpc	r13, r11
    3b16:	89 f6       	brne	.-94     	; 0x3aba <sysex_encode+0x58>
         encoded[encoded_msb_idx + 1 + j] = 0x7F & current;
      }
   }

   //fill out the rest if there is any more
   uint8_t remainder = length % 7;
    3b18:	c3 01       	movw	r24, r6
    3b1a:	67 e0       	ldi	r22, 0x07	; 7
    3b1c:	70 e0       	ldi	r23, 0x00	; 0
    3b1e:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <__udivmodhi4>
   if (remainder) {
    3b22:	88 23       	and	r24, r24
    3b24:	d9 f1       	breq	.+118    	; 0x3b9c <sysex_encode+0x13a>
      uint16_t encoded_msb_idx = encoded_full * 8;
    3b26:	82 01       	movw	r16, r4
    3b28:	00 0f       	add	r16, r16
    3b2a:	11 1f       	adc	r17, r17
    3b2c:	00 0f       	add	r16, r16
    3b2e:	11 1f       	adc	r17, r17
    3b30:	00 0f       	add	r16, r16
    3b32:	11 1f       	adc	r17, r17
      uint16_t input_start_idx = encoded_full * 7;
    3b34:	78 01       	movw	r14, r16
    3b36:	e4 18       	sub	r14, r4
    3b38:	f5 08       	sbc	r15, r5
      encoded[encoded_msb_idx] = 0;
    3b3a:	d1 01       	movw	r26, r2
    3b3c:	a0 0f       	add	r26, r16
    3b3e:	b1 1f       	adc	r27, r17
    3b40:	1c 92       	st	X, r1
      for(j = 0; j < remainder; j++){
    3b42:	68 2f       	mov	r22, r24
    3b44:	70 e0       	ldi	r23, 0x00	; 0
    3b46:	61 15       	cp	r22, r1
    3b48:	71 05       	cpc	r23, r1
    3b4a:	19 f1       	breq	.+70     	; 0x3b92 <sysex_encode+0x130>
      return (encoded_length / 8) * 7 + remainder - 1;
   else
      return (encoded_length / 8) * 7;
}

uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
    3b4c:	e9 81       	ldd	r30, Y+1	; 0x01
    3b4e:	fa 81       	ldd	r31, Y+2	; 0x02
    3b50:	ee 0e       	add	r14, r30
    3b52:	ff 1e       	adc	r15, r31
    3b54:	c8 01       	movw	r24, r16
    3b56:	01 96       	adiw	r24, 0x01	; 1
    3b58:	28 0e       	add	r2, r24
    3b5a:	39 1e       	adc	r3, r25
   uint8_t remainder = length % 7;
   if (remainder) {
      uint16_t encoded_msb_idx = encoded_full * 8;
      uint16_t input_start_idx = encoded_full * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < remainder; j++){
    3b5c:	20 e0       	ldi	r18, 0x00	; 0
    3b5e:	30 e0       	ldi	r19, 0x00	; 0
         uint8_t current = source[input_start_idx + j];
    3b60:	f7 01       	movw	r30, r14
    3b62:	41 91       	ld	r20, Z+
    3b64:	7f 01       	movw	r14, r30
         encoded[encoded_msb_idx] |= (0x80 & current) >> (1 + j);
    3b66:	2f 5f       	subi	r18, 0xFF	; 255
    3b68:	3f 4f       	sbci	r19, 0xFF	; 255
    3b6a:	84 2f       	mov	r24, r20
    3b6c:	90 e0       	ldi	r25, 0x00	; 0
    3b6e:	80 78       	andi	r24, 0x80	; 128
    3b70:	90 70       	andi	r25, 0x00	; 0
    3b72:	02 2e       	mov	r0, r18
    3b74:	02 c0       	rjmp	.+4      	; 0x3b7a <sysex_encode+0x118>
    3b76:	95 95       	asr	r25
    3b78:	87 95       	ror	r24
    3b7a:	0a 94       	dec	r0
    3b7c:	e2 f7       	brpl	.-8      	; 0x3b76 <sysex_encode+0x114>
    3b7e:	9c 91       	ld	r25, X
    3b80:	89 2b       	or	r24, r25
    3b82:	8c 93       	st	X, r24
         encoded[encoded_msb_idx + 1 + j] = 0x7F & current;
    3b84:	4f 77       	andi	r20, 0x7F	; 127
    3b86:	f1 01       	movw	r30, r2
    3b88:	41 93       	st	Z+, r20
    3b8a:	1f 01       	movw	r2, r30
   uint8_t remainder = length % 7;
   if (remainder) {
      uint16_t encoded_msb_idx = encoded_full * 8;
      uint16_t input_start_idx = encoded_full * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < remainder; j++){
    3b8c:	26 17       	cp	r18, r22
    3b8e:	37 07       	cpc	r19, r23
    3b90:	38 f3       	brcs	.-50     	; 0x3b60 <sysex_encode+0xfe>
         uint8_t current = source[input_start_idx + j];
         encoded[encoded_msb_idx] |= (0x80 & current) >> (1 + j);
         encoded[encoded_msb_idx + 1 + j] = 0x7F & current;
      }
      return encoded_msb_idx + remainder + 1;
    3b92:	c8 01       	movw	r24, r16
    3b94:	01 96       	adiw	r24, 0x01	; 1
    3b96:	86 0f       	add	r24, r22
    3b98:	97 1f       	adc	r25, r23
    3b9a:	07 c0       	rjmp	.+14     	; 0x3baa <sysex_encode+0x148>
   } else {
      return encoded_full * 8;
    3b9c:	c2 01       	movw	r24, r4
    3b9e:	88 0f       	add	r24, r24
    3ba0:	99 1f       	adc	r25, r25
    3ba2:	88 0f       	add	r24, r24
    3ba4:	99 1f       	adc	r25, r25
    3ba6:	88 0f       	add	r24, r24
    3ba8:	99 1f       	adc	r25, r25
   }
}
    3baa:	26 96       	adiw	r28, 0x06	; 6
    3bac:	0f b6       	in	r0, 0x3f	; 63
    3bae:	f8 94       	cli
    3bb0:	de bf       	out	0x3e, r29	; 62
    3bb2:	0f be       	out	0x3f, r0	; 63
    3bb4:	cd bf       	out	0x3d, r28	; 61
    3bb6:	df 91       	pop	r29
    3bb8:	cf 91       	pop	r28
    3bba:	1f 91       	pop	r17
    3bbc:	0f 91       	pop	r16
    3bbe:	ff 90       	pop	r15
    3bc0:	ef 90       	pop	r14
    3bc2:	df 90       	pop	r13
    3bc4:	cf 90       	pop	r12
    3bc6:	bf 90       	pop	r11
    3bc8:	af 90       	pop	r10
    3bca:	9f 90       	pop	r9
    3bcc:	8f 90       	pop	r8
    3bce:	7f 90       	pop	r7
    3bd0:	6f 90       	pop	r6
    3bd2:	5f 90       	pop	r5
    3bd4:	4f 90       	pop	r4
    3bd6:	3f 90       	pop	r3
    3bd8:	2f 90       	pop	r2
    3bda:	08 95       	ret

00003bdc <sysex_decode>:

uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
    3bdc:	6f 92       	push	r6
    3bde:	7f 92       	push	r7
    3be0:	8f 92       	push	r8
    3be2:	9f 92       	push	r9
    3be4:	af 92       	push	r10
    3be6:	bf 92       	push	r11
    3be8:	cf 92       	push	r12
    3bea:	df 92       	push	r13
    3bec:	ef 92       	push	r14
    3bee:	ff 92       	push	r15
    3bf0:	0f 93       	push	r16
    3bf2:	1f 93       	push	r17
    3bf4:	cf 93       	push	r28
    3bf6:	df 93       	push	r29
    3bf8:	3c 01       	movw	r6, r24
    3bfa:	4b 01       	movw	r8, r22
    3bfc:	5a 01       	movw	r10, r20
   uint16_t decoded_full = length / 8;
   uint16_t i,j;

   if (length < 2)
    3bfe:	42 30       	cpi	r20, 0x02	; 2
    3c00:	51 05       	cpc	r21, r1
    3c02:	08 f4       	brcc	.+2      	; 0x3c06 <sysex_decode+0x2a>
    3c04:	6f c0       	rjmp	.+222    	; 0x3ce4 <sysex_decode+0x108>
      return encoded_full * 8;
   }
}

uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
   uint16_t decoded_full = length / 8;
    3c06:	7a 01       	movw	r14, r20
    3c08:	f6 94       	lsr	r15
    3c0a:	e7 94       	ror	r14
    3c0c:	f6 94       	lsr	r15
    3c0e:	e7 94       	ror	r14
    3c10:	f6 94       	lsr	r15
    3c12:	e7 94       	ror	r14

   if (length < 2)
      return 0;

   //fill out the fully encoded sections
   for(i = 0; i < decoded_full; i++) {
    3c14:	e1 14       	cp	r14, r1
    3c16:	f1 04       	cpc	r15, r1
    3c18:	29 f1       	breq	.+74     	; 0x3c64 <sysex_decode+0x88>
    3c1a:	eb 01       	movw	r28, r22
    3c1c:	b3 01       	movw	r22, r6
    3c1e:	00 e0       	ldi	r16, 0x00	; 0
    3c20:	10 e0       	ldi	r17, 0x00	; 0
      uint16_t encoded_msb_idx = i * 8;
      uint16_t output_start_index = i * 7;
      for(j = 0; j < 7; j++){
    3c22:	cc 24       	eor	r12, r12
    3c24:	dd 24       	eor	r13, r13
   } else {
      return encoded_full * 8;
   }
}

uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
    3c26:	de 01       	movw	r26, r28
    3c28:	11 96       	adiw	r26, 0x01	; 1
    3c2a:	fb 01       	movw	r30, r22

   //fill out the fully encoded sections
   for(i = 0; i < decoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t output_start_index = i * 7;
      for(j = 0; j < 7; j++){
    3c2c:	a6 01       	movw	r20, r12
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
    3c2e:	2d 91       	ld	r18, X+
    3c30:	2f 77       	andi	r18, 0x7F	; 127
    3c32:	20 83       	st	Z, r18
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
    3c34:	4f 5f       	subi	r20, 0xFF	; 255
    3c36:	5f 4f       	sbci	r21, 0xFF	; 255
    3c38:	88 81       	ld	r24, Y
    3c3a:	90 e0       	ldi	r25, 0x00	; 0
    3c3c:	04 2e       	mov	r0, r20
    3c3e:	02 c0       	rjmp	.+4      	; 0x3c44 <sysex_decode+0x68>
    3c40:	88 0f       	add	r24, r24
    3c42:	99 1f       	adc	r25, r25
    3c44:	0a 94       	dec	r0
    3c46:	e2 f7       	brpl	.-8      	; 0x3c40 <sysex_decode+0x64>
    3c48:	80 78       	andi	r24, 0x80	; 128
    3c4a:	28 2b       	or	r18, r24
    3c4c:	21 93       	st	Z+, r18

   //fill out the fully encoded sections
   for(i = 0; i < decoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t output_start_index = i * 7;
      for(j = 0; j < 7; j++){
    3c4e:	47 30       	cpi	r20, 0x07	; 7
    3c50:	51 05       	cpc	r21, r1
    3c52:	69 f7       	brne	.-38     	; 0x3c2e <sysex_decode+0x52>

   if (length < 2)
      return 0;

   //fill out the fully encoded sections
   for(i = 0; i < decoded_full; i++) {
    3c54:	0f 5f       	subi	r16, 0xFF	; 255
    3c56:	1f 4f       	sbci	r17, 0xFF	; 255
    3c58:	28 96       	adiw	r28, 0x08	; 8
    3c5a:	69 5f       	subi	r22, 0xF9	; 249
    3c5c:	7f 4f       	sbci	r23, 0xFF	; 255
    3c5e:	0e 15       	cp	r16, r14
    3c60:	1f 05       	cpc	r17, r15
    3c62:	09 f7       	brne	.-62     	; 0x3c26 <sysex_decode+0x4a>
      for(j = 0; j < 7; j++){
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
      }
   }
   uint8_t remainder = length % 8;
    3c64:	5a 2d       	mov	r21, r10
    3c66:	57 70       	andi	r21, 0x07	; 7
   if (remainder) {
    3c68:	99 f1       	breq	.+102    	; 0x3cd0 <sysex_decode+0xf4>
      uint16_t encoded_msb_idx = decoded_full * 8;
    3c6a:	e7 01       	movw	r28, r14
    3c6c:	cc 0f       	add	r28, r28
    3c6e:	dd 1f       	adc	r29, r29
    3c70:	cc 0f       	add	r28, r28
    3c72:	dd 1f       	adc	r29, r29
    3c74:	cc 0f       	add	r28, r28
    3c76:	dd 1f       	adc	r29, r29
      uint16_t output_start_index = decoded_full * 7;
    3c78:	8e 01       	movw	r16, r28
    3c7a:	0e 19       	sub	r16, r14
    3c7c:	1f 09       	sbc	r17, r15
      for(j = 0; j < (remainder - 1); j++) {
    3c7e:	65 2f       	mov	r22, r21
    3c80:	70 e0       	ldi	r23, 0x00	; 0
    3c82:	61 50       	subi	r22, 0x01	; 1
    3c84:	70 40       	sbci	r23, 0x00	; 0
    3c86:	f9 f0       	breq	.+62     	; 0x3cc6 <sysex_decode+0xea>
   } else {
      return encoded_full * 8;
   }
}

uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
    3c88:	ce 01       	movw	r24, r28
    3c8a:	01 96       	adiw	r24, 0x01	; 1
    3c8c:	d4 01       	movw	r26, r8
    3c8e:	a8 0f       	add	r26, r24
    3c90:	b9 1f       	adc	r27, r25
    3c92:	f3 01       	movw	r30, r6
    3c94:	e0 0f       	add	r30, r16
    3c96:	f1 1f       	adc	r31, r17
   }
   uint8_t remainder = length % 8;
   if (remainder) {
      uint16_t encoded_msb_idx = decoded_full * 8;
      uint16_t output_start_index = decoded_full * 7;
      for(j = 0; j < (remainder - 1); j++) {
    3c98:	20 e0       	ldi	r18, 0x00	; 0
    3c9a:	30 e0       	ldi	r19, 0x00	; 0
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
    3c9c:	c8 0d       	add	r28, r8
    3c9e:	d9 1d       	adc	r29, r9
   uint8_t remainder = length % 8;
   if (remainder) {
      uint16_t encoded_msb_idx = decoded_full * 8;
      uint16_t output_start_index = decoded_full * 7;
      for(j = 0; j < (remainder - 1); j++) {
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
    3ca0:	4d 91       	ld	r20, X+
    3ca2:	4f 77       	andi	r20, 0x7F	; 127
    3ca4:	40 83       	st	Z, r20
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
    3ca6:	2f 5f       	subi	r18, 0xFF	; 255
    3ca8:	3f 4f       	sbci	r19, 0xFF	; 255
    3caa:	88 81       	ld	r24, Y
    3cac:	90 e0       	ldi	r25, 0x00	; 0
    3cae:	02 2e       	mov	r0, r18
    3cb0:	02 c0       	rjmp	.+4      	; 0x3cb6 <sysex_decode+0xda>
    3cb2:	88 0f       	add	r24, r24
    3cb4:	99 1f       	adc	r25, r25
    3cb6:	0a 94       	dec	r0
    3cb8:	e2 f7       	brpl	.-8      	; 0x3cb2 <sysex_decode+0xd6>
    3cba:	80 78       	andi	r24, 0x80	; 128
    3cbc:	48 2b       	or	r20, r24
    3cbe:	41 93       	st	Z+, r20
   }
   uint8_t remainder = length % 8;
   if (remainder) {
      uint16_t encoded_msb_idx = decoded_full * 8;
      uint16_t output_start_index = decoded_full * 7;
      for(j = 0; j < (remainder - 1); j++) {
    3cc0:	26 17       	cp	r18, r22
    3cc2:	37 07       	cpc	r19, r23
    3cc4:	68 f3       	brcs	.-38     	; 0x3ca0 <sysex_decode+0xc4>
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
      }
      return decoded_full * 7 + remainder - 1;
    3cc6:	c8 01       	movw	r24, r16
    3cc8:	01 97       	sbiw	r24, 0x01	; 1
    3cca:	85 0f       	add	r24, r21
    3ccc:	91 1d       	adc	r25, r1
    3cce:	0c c0       	rjmp	.+24     	; 0x3ce8 <sysex_decode+0x10c>
   } else {
      return decoded_full * 7;
    3cd0:	c7 01       	movw	r24, r14
    3cd2:	88 0f       	add	r24, r24
    3cd4:	99 1f       	adc	r25, r25
    3cd6:	88 0f       	add	r24, r24
    3cd8:	99 1f       	adc	r25, r25
    3cda:	88 0f       	add	r24, r24
    3cdc:	99 1f       	adc	r25, r25
    3cde:	8e 19       	sub	r24, r14
    3ce0:	9f 09       	sbc	r25, r15
    3ce2:	02 c0       	rjmp	.+4      	; 0x3ce8 <sysex_decode+0x10c>
uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
   uint16_t decoded_full = length / 8;
   uint16_t i,j;

   if (length < 2)
      return 0;
    3ce4:	80 e0       	ldi	r24, 0x00	; 0
    3ce6:	90 e0       	ldi	r25, 0x00	; 0
      }
      return decoded_full * 7 + remainder - 1;
   } else {
      return decoded_full * 7;
   }
}
    3ce8:	df 91       	pop	r29
    3cea:	cf 91       	pop	r28
    3cec:	1f 91       	pop	r17
    3cee:	0f 91       	pop	r16
    3cf0:	ff 90       	pop	r15
    3cf2:	ef 90       	pop	r14
    3cf4:	df 90       	pop	r13
    3cf6:	cf 90       	pop	r12
    3cf8:	bf 90       	pop	r11
    3cfa:	af 90       	pop	r10
    3cfc:	9f 90       	pop	r9
    3cfe:	8f 90       	pop	r8
    3d00:	7f 90       	pop	r7
    3d02:	6f 90       	pop	r6
    3d04:	08 95       	ret

00003d06 <__mulsi3>:
    3d06:	62 9f       	mul	r22, r18
    3d08:	d0 01       	movw	r26, r0
    3d0a:	73 9f       	mul	r23, r19
    3d0c:	f0 01       	movw	r30, r0
    3d0e:	82 9f       	mul	r24, r18
    3d10:	e0 0d       	add	r30, r0
    3d12:	f1 1d       	adc	r31, r1
    3d14:	64 9f       	mul	r22, r20
    3d16:	e0 0d       	add	r30, r0
    3d18:	f1 1d       	adc	r31, r1
    3d1a:	92 9f       	mul	r25, r18
    3d1c:	f0 0d       	add	r31, r0
    3d1e:	83 9f       	mul	r24, r19
    3d20:	f0 0d       	add	r31, r0
    3d22:	74 9f       	mul	r23, r20
    3d24:	f0 0d       	add	r31, r0
    3d26:	65 9f       	mul	r22, r21
    3d28:	f0 0d       	add	r31, r0
    3d2a:	99 27       	eor	r25, r25
    3d2c:	72 9f       	mul	r23, r18
    3d2e:	b0 0d       	add	r27, r0
    3d30:	e1 1d       	adc	r30, r1
    3d32:	f9 1f       	adc	r31, r25
    3d34:	63 9f       	mul	r22, r19
    3d36:	b0 0d       	add	r27, r0
    3d38:	e1 1d       	adc	r30, r1
    3d3a:	f9 1f       	adc	r31, r25
    3d3c:	bd 01       	movw	r22, r26
    3d3e:	cf 01       	movw	r24, r30
    3d40:	11 24       	eor	r1, r1
    3d42:	08 95       	ret

00003d44 <__udivmodhi4>:
    3d44:	aa 1b       	sub	r26, r26
    3d46:	bb 1b       	sub	r27, r27
    3d48:	51 e1       	ldi	r21, 0x11	; 17
    3d4a:	07 c0       	rjmp	.+14     	; 0x3d5a <__udivmodhi4_ep>

00003d4c <__udivmodhi4_loop>:
    3d4c:	aa 1f       	adc	r26, r26
    3d4e:	bb 1f       	adc	r27, r27
    3d50:	a6 17       	cp	r26, r22
    3d52:	b7 07       	cpc	r27, r23
    3d54:	10 f0       	brcs	.+4      	; 0x3d5a <__udivmodhi4_ep>
    3d56:	a6 1b       	sub	r26, r22
    3d58:	b7 0b       	sbc	r27, r23

00003d5a <__udivmodhi4_ep>:
    3d5a:	88 1f       	adc	r24, r24
    3d5c:	99 1f       	adc	r25, r25
    3d5e:	5a 95       	dec	r21
    3d60:	a9 f7       	brne	.-22     	; 0x3d4c <__udivmodhi4_loop>
    3d62:	80 95       	com	r24
    3d64:	90 95       	com	r25
    3d66:	bc 01       	movw	r22, r24
    3d68:	cd 01       	movw	r24, r26
    3d6a:	08 95       	ret

00003d6c <__divmodhi4>:
    3d6c:	97 fb       	bst	r25, 7
    3d6e:	09 2e       	mov	r0, r25
    3d70:	07 26       	eor	r0, r23
    3d72:	0a d0       	rcall	.+20     	; 0x3d88 <__divmodhi4_neg1>
    3d74:	77 fd       	sbrc	r23, 7
    3d76:	04 d0       	rcall	.+8      	; 0x3d80 <__divmodhi4_neg2>
    3d78:	e5 df       	rcall	.-54     	; 0x3d44 <__udivmodhi4>
    3d7a:	06 d0       	rcall	.+12     	; 0x3d88 <__divmodhi4_neg1>
    3d7c:	00 20       	and	r0, r0
    3d7e:	1a f4       	brpl	.+6      	; 0x3d86 <__divmodhi4_exit>

00003d80 <__divmodhi4_neg2>:
    3d80:	70 95       	com	r23
    3d82:	61 95       	neg	r22
    3d84:	7f 4f       	sbci	r23, 0xFF	; 255

00003d86 <__divmodhi4_exit>:
    3d86:	08 95       	ret

00003d88 <__divmodhi4_neg1>:
    3d88:	f6 f7       	brtc	.-4      	; 0x3d86 <__divmodhi4_exit>
    3d8a:	90 95       	com	r25
    3d8c:	81 95       	neg	r24
    3d8e:	9f 4f       	sbci	r25, 0xFF	; 255
    3d90:	08 95       	ret

00003d92 <__udivmodsi4>:
    3d92:	a1 e2       	ldi	r26, 0x21	; 33
    3d94:	1a 2e       	mov	r1, r26
    3d96:	aa 1b       	sub	r26, r26
    3d98:	bb 1b       	sub	r27, r27
    3d9a:	fd 01       	movw	r30, r26
    3d9c:	0d c0       	rjmp	.+26     	; 0x3db8 <__udivmodsi4_ep>

00003d9e <__udivmodsi4_loop>:
    3d9e:	aa 1f       	adc	r26, r26
    3da0:	bb 1f       	adc	r27, r27
    3da2:	ee 1f       	adc	r30, r30
    3da4:	ff 1f       	adc	r31, r31
    3da6:	a2 17       	cp	r26, r18
    3da8:	b3 07       	cpc	r27, r19
    3daa:	e4 07       	cpc	r30, r20
    3dac:	f5 07       	cpc	r31, r21
    3dae:	20 f0       	brcs	.+8      	; 0x3db8 <__udivmodsi4_ep>
    3db0:	a2 1b       	sub	r26, r18
    3db2:	b3 0b       	sbc	r27, r19
    3db4:	e4 0b       	sbc	r30, r20
    3db6:	f5 0b       	sbc	r31, r21

00003db8 <__udivmodsi4_ep>:
    3db8:	66 1f       	adc	r22, r22
    3dba:	77 1f       	adc	r23, r23
    3dbc:	88 1f       	adc	r24, r24
    3dbe:	99 1f       	adc	r25, r25
    3dc0:	1a 94       	dec	r1
    3dc2:	69 f7       	brne	.-38     	; 0x3d9e <__udivmodsi4_loop>
    3dc4:	60 95       	com	r22
    3dc6:	70 95       	com	r23
    3dc8:	80 95       	com	r24
    3dca:	90 95       	com	r25
    3dcc:	9b 01       	movw	r18, r22
    3dce:	ac 01       	movw	r20, r24
    3dd0:	bd 01       	movw	r22, r26
    3dd2:	cf 01       	movw	r24, r30
    3dd4:	08 95       	ret

00003dd6 <do_random>:
    3dd6:	a0 e0       	ldi	r26, 0x00	; 0
    3dd8:	b0 e0       	ldi	r27, 0x00	; 0
    3dda:	e1 ef       	ldi	r30, 0xF1	; 241
    3ddc:	fe e1       	ldi	r31, 0x1E	; 30
    3dde:	0c 94 c2 1f 	jmp	0x3f84	; 0x3f84 <__prologue_saves__+0xc>
    3de2:	ec 01       	movw	r28, r24
    3de4:	88 81       	ld	r24, Y
    3de6:	99 81       	ldd	r25, Y+1	; 0x01
    3de8:	aa 81       	ldd	r26, Y+2	; 0x02
    3dea:	bb 81       	ldd	r27, Y+3	; 0x03
    3dec:	00 97       	sbiw	r24, 0x00	; 0
    3dee:	a1 05       	cpc	r26, r1
    3df0:	b1 05       	cpc	r27, r1
    3df2:	21 f4       	brne	.+8      	; 0x3dfc <do_random+0x26>
    3df4:	84 e2       	ldi	r24, 0x24	; 36
    3df6:	99 ed       	ldi	r25, 0xD9	; 217
    3df8:	ab e5       	ldi	r26, 0x5B	; 91
    3dfa:	b7 e0       	ldi	r27, 0x07	; 7
    3dfc:	bc 01       	movw	r22, r24
    3dfe:	cd 01       	movw	r24, r26
    3e00:	2d e1       	ldi	r18, 0x1D	; 29
    3e02:	33 ef       	ldi	r19, 0xF3	; 243
    3e04:	41 e0       	ldi	r20, 0x01	; 1
    3e06:	50 e0       	ldi	r21, 0x00	; 0
    3e08:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <__divmodsi4>
    3e0c:	49 01       	movw	r8, r18
    3e0e:	5a 01       	movw	r10, r20
    3e10:	27 ea       	ldi	r18, 0xA7	; 167
    3e12:	31 e4       	ldi	r19, 0x41	; 65
    3e14:	40 e0       	ldi	r20, 0x00	; 0
    3e16:	50 e0       	ldi	r21, 0x00	; 0
    3e18:	0e 94 83 1e 	call	0x3d06	; 0x3d06 <__mulsi3>
    3e1c:	6b 01       	movw	r12, r22
    3e1e:	7c 01       	movw	r14, r24
    3e20:	c5 01       	movw	r24, r10
    3e22:	b4 01       	movw	r22, r8
    3e24:	2c ee       	ldi	r18, 0xEC	; 236
    3e26:	34 ef       	ldi	r19, 0xF4	; 244
    3e28:	4f ef       	ldi	r20, 0xFF	; 255
    3e2a:	5f ef       	ldi	r21, 0xFF	; 255
    3e2c:	0e 94 83 1e 	call	0x3d06	; 0x3d06 <__mulsi3>
    3e30:	dc 01       	movw	r26, r24
    3e32:	cb 01       	movw	r24, r22
    3e34:	c8 0e       	add	r12, r24
    3e36:	d9 1e       	adc	r13, r25
    3e38:	ea 1e       	adc	r14, r26
    3e3a:	fb 1e       	adc	r15, r27
    3e3c:	f7 fe       	sbrs	r15, 7
    3e3e:	08 c0       	rjmp	.+16     	; 0x3e50 <do_random+0x7a>
    3e40:	8f ef       	ldi	r24, 0xFF	; 255
    3e42:	9f ef       	ldi	r25, 0xFF	; 255
    3e44:	af ef       	ldi	r26, 0xFF	; 255
    3e46:	bf e7       	ldi	r27, 0x7F	; 127
    3e48:	c8 0e       	add	r12, r24
    3e4a:	d9 1e       	adc	r13, r25
    3e4c:	ea 1e       	adc	r14, r26
    3e4e:	fb 1e       	adc	r15, r27
    3e50:	c8 82       	st	Y, r12
    3e52:	d9 82       	std	Y+1, r13	; 0x01
    3e54:	ea 82       	std	Y+2, r14	; 0x02
    3e56:	fb 82       	std	Y+3, r15	; 0x03
    3e58:	97 01       	movw	r18, r14
    3e5a:	86 01       	movw	r16, r12
    3e5c:	3f 77       	andi	r19, 0x7F	; 127
    3e5e:	b8 01       	movw	r22, r16
    3e60:	c9 01       	movw	r24, r18
    3e62:	cd b7       	in	r28, 0x3d	; 61
    3e64:	de b7       	in	r29, 0x3e	; 62
    3e66:	ec e0       	ldi	r30, 0x0C	; 12
    3e68:	0c 94 de 1f 	jmp	0x3fbc	; 0x3fbc <__epilogue_restores__+0xc>

00003e6c <random_r>:
    3e6c:	0e 94 eb 1e 	call	0x3dd6	; 0x3dd6 <do_random>
    3e70:	08 95       	ret

00003e72 <random>:
    3e72:	80 eb       	ldi	r24, 0xB0	; 176
    3e74:	92 e0       	ldi	r25, 0x02	; 2
    3e76:	0e 94 eb 1e 	call	0x3dd6	; 0x3dd6 <do_random>
    3e7a:	08 95       	ret

00003e7c <srandom>:
    3e7c:	dc 01       	movw	r26, r24
    3e7e:	cb 01       	movw	r24, r22
    3e80:	80 93 b0 02 	sts	0x02B0, r24
    3e84:	90 93 b1 02 	sts	0x02B1, r25
    3e88:	a0 93 b2 02 	sts	0x02B2, r26
    3e8c:	b0 93 b3 02 	sts	0x02B3, r27
    3e90:	08 95       	ret

00003e92 <memcpy>:
    3e92:	fb 01       	movw	r30, r22
    3e94:	dc 01       	movw	r26, r24
    3e96:	02 c0       	rjmp	.+4      	; 0x3e9c <memcpy+0xa>
    3e98:	01 90       	ld	r0, Z+
    3e9a:	0d 92       	st	X+, r0
    3e9c:	41 50       	subi	r20, 0x01	; 1
    3e9e:	50 40       	sbci	r21, 0x00	; 0
    3ea0:	d8 f7       	brcc	.-10     	; 0x3e98 <memcpy+0x6>
    3ea2:	08 95       	ret

00003ea4 <memmove>:
    3ea4:	68 17       	cp	r22, r24
    3ea6:	79 07       	cpc	r23, r25
    3ea8:	68 f4       	brcc	.+26     	; 0x3ec4 <memmove+0x20>
    3eaa:	fb 01       	movw	r30, r22
    3eac:	dc 01       	movw	r26, r24
    3eae:	e4 0f       	add	r30, r20
    3eb0:	f5 1f       	adc	r31, r21
    3eb2:	a4 0f       	add	r26, r20
    3eb4:	b5 1f       	adc	r27, r21
    3eb6:	02 c0       	rjmp	.+4      	; 0x3ebc <memmove+0x18>
    3eb8:	02 90       	ld	r0, -Z
    3eba:	0e 92       	st	-X, r0
    3ebc:	41 50       	subi	r20, 0x01	; 1
    3ebe:	50 40       	sbci	r21, 0x00	; 0
    3ec0:	d8 f7       	brcc	.-10     	; 0x3eb8 <memmove+0x14>
    3ec2:	08 95       	ret
    3ec4:	0c 94 49 1f 	jmp	0x3e92	; 0x3e92 <memcpy>

00003ec8 <__eerd_block_m6450a>:
    3ec8:	dc 01       	movw	r26, r24
    3eca:	cb 01       	movw	r24, r22

00003ecc <__eerd_blraw_m6450a>:
    3ecc:	fc 01       	movw	r30, r24
    3ece:	f9 99       	sbic	0x1f, 1	; 31
    3ed0:	fe cf       	rjmp	.-4      	; 0x3ece <__eerd_blraw_m6450a+0x2>
    3ed2:	06 c0       	rjmp	.+12     	; 0x3ee0 <__eerd_blraw_m6450a+0x14>
    3ed4:	f2 bd       	out	0x22, r31	; 34
    3ed6:	e1 bd       	out	0x21, r30	; 33
    3ed8:	f8 9a       	sbi	0x1f, 0	; 31
    3eda:	31 96       	adiw	r30, 0x01	; 1
    3edc:	00 b4       	in	r0, 0x20	; 32
    3ede:	0d 92       	st	X+, r0
    3ee0:	41 50       	subi	r20, 0x01	; 1
    3ee2:	50 40       	sbci	r21, 0x00	; 0
    3ee4:	b8 f7       	brcc	.-18     	; 0x3ed4 <__eerd_blraw_m6450a+0x8>
    3ee6:	08 95       	ret

00003ee8 <__eerd_word_m6450a>:
    3ee8:	a8 e1       	ldi	r26, 0x18	; 24
    3eea:	b0 e0       	ldi	r27, 0x00	; 0
    3eec:	42 e0       	ldi	r20, 0x02	; 2
    3eee:	50 e0       	ldi	r21, 0x00	; 0
    3ef0:	0c 94 66 1f 	jmp	0x3ecc	; 0x3ecc <__eerd_blraw_m6450a>

00003ef4 <__eeupd_block_m6450a>:
    3ef4:	dc 01       	movw	r26, r24
    3ef6:	a4 0f       	add	r26, r20
    3ef8:	b5 1f       	adc	r27, r21
    3efa:	41 50       	subi	r20, 0x01	; 1
    3efc:	50 40       	sbci	r21, 0x00	; 0
    3efe:	48 f0       	brcs	.+18     	; 0x3f12 <__eeupd_block_m6450a+0x1e>
    3f00:	cb 01       	movw	r24, r22
    3f02:	84 0f       	add	r24, r20
    3f04:	95 1f       	adc	r25, r21
    3f06:	2e 91       	ld	r18, -X
    3f08:	0e 94 8b 1f 	call	0x3f16	; 0x3f16 <__eeupd_r18_m6450a>
    3f0c:	41 50       	subi	r20, 0x01	; 1
    3f0e:	50 40       	sbci	r21, 0x00	; 0
    3f10:	d0 f7       	brcc	.-12     	; 0x3f06 <__eeupd_block_m6450a+0x12>
    3f12:	08 95       	ret

00003f14 <__eeupd_byte_m6450a>:
    3f14:	26 2f       	mov	r18, r22

00003f16 <__eeupd_r18_m6450a>:
    3f16:	f9 99       	sbic	0x1f, 1	; 31
    3f18:	fe cf       	rjmp	.-4      	; 0x3f16 <__eeupd_r18_m6450a>
    3f1a:	92 bd       	out	0x22, r25	; 34
    3f1c:	81 bd       	out	0x21, r24	; 33
    3f1e:	f8 9a       	sbi	0x1f, 0	; 31
    3f20:	01 97       	sbiw	r24, 0x01	; 1
    3f22:	00 b4       	in	r0, 0x20	; 32
    3f24:	02 16       	cp	r0, r18
    3f26:	31 f0       	breq	.+12     	; 0x3f34 <__eeupd_r18_m6450a+0x1e>
    3f28:	20 bd       	out	0x20, r18	; 32
    3f2a:	0f b6       	in	r0, 0x3f	; 63
    3f2c:	f8 94       	cli
    3f2e:	fa 9a       	sbi	0x1f, 2	; 31
    3f30:	f9 9a       	sbi	0x1f, 1	; 31
    3f32:	0f be       	out	0x3f, r0	; 63
    3f34:	08 95       	ret

00003f36 <__eeupd_word_m6450a>:
    3f36:	01 96       	adiw	r24, 0x01	; 1
    3f38:	27 2f       	mov	r18, r23
    3f3a:	0e 94 8b 1f 	call	0x3f16	; 0x3f16 <__eeupd_r18_m6450a>
    3f3e:	0c 94 8a 1f 	jmp	0x3f14	; 0x3f14 <__eeupd_byte_m6450a>

00003f42 <__divmodsi4>:
    3f42:	97 fb       	bst	r25, 7
    3f44:	09 2e       	mov	r0, r25
    3f46:	05 26       	eor	r0, r21
    3f48:	0e d0       	rcall	.+28     	; 0x3f66 <__divmodsi4_neg1>
    3f4a:	57 fd       	sbrc	r21, 7
    3f4c:	04 d0       	rcall	.+8      	; 0x3f56 <__divmodsi4_neg2>
    3f4e:	21 df       	rcall	.-446    	; 0x3d92 <__udivmodsi4>
    3f50:	0a d0       	rcall	.+20     	; 0x3f66 <__divmodsi4_neg1>
    3f52:	00 1c       	adc	r0, r0
    3f54:	38 f4       	brcc	.+14     	; 0x3f64 <__divmodsi4_exit>

00003f56 <__divmodsi4_neg2>:
    3f56:	50 95       	com	r21
    3f58:	40 95       	com	r20
    3f5a:	30 95       	com	r19
    3f5c:	21 95       	neg	r18
    3f5e:	3f 4f       	sbci	r19, 0xFF	; 255
    3f60:	4f 4f       	sbci	r20, 0xFF	; 255
    3f62:	5f 4f       	sbci	r21, 0xFF	; 255

00003f64 <__divmodsi4_exit>:
    3f64:	08 95       	ret

00003f66 <__divmodsi4_neg1>:
    3f66:	f6 f7       	brtc	.-4      	; 0x3f64 <__divmodsi4_exit>
    3f68:	90 95       	com	r25
    3f6a:	80 95       	com	r24
    3f6c:	70 95       	com	r23
    3f6e:	61 95       	neg	r22
    3f70:	7f 4f       	sbci	r23, 0xFF	; 255
    3f72:	8f 4f       	sbci	r24, 0xFF	; 255
    3f74:	9f 4f       	sbci	r25, 0xFF	; 255
    3f76:	08 95       	ret

00003f78 <__prologue_saves__>:
    3f78:	2f 92       	push	r2
    3f7a:	3f 92       	push	r3
    3f7c:	4f 92       	push	r4
    3f7e:	5f 92       	push	r5
    3f80:	6f 92       	push	r6
    3f82:	7f 92       	push	r7
    3f84:	8f 92       	push	r8
    3f86:	9f 92       	push	r9
    3f88:	af 92       	push	r10
    3f8a:	bf 92       	push	r11
    3f8c:	cf 92       	push	r12
    3f8e:	df 92       	push	r13
    3f90:	ef 92       	push	r14
    3f92:	ff 92       	push	r15
    3f94:	0f 93       	push	r16
    3f96:	1f 93       	push	r17
    3f98:	cf 93       	push	r28
    3f9a:	df 93       	push	r29
    3f9c:	cd b7       	in	r28, 0x3d	; 61
    3f9e:	de b7       	in	r29, 0x3e	; 62
    3fa0:	ca 1b       	sub	r28, r26
    3fa2:	db 0b       	sbc	r29, r27
    3fa4:	0f b6       	in	r0, 0x3f	; 63
    3fa6:	f8 94       	cli
    3fa8:	de bf       	out	0x3e, r29	; 62
    3faa:	0f be       	out	0x3f, r0	; 63
    3fac:	cd bf       	out	0x3d, r28	; 61
    3fae:	09 94       	ijmp

00003fb0 <__epilogue_restores__>:
    3fb0:	2a 88       	ldd	r2, Y+18	; 0x12
    3fb2:	39 88       	ldd	r3, Y+17	; 0x11
    3fb4:	48 88       	ldd	r4, Y+16	; 0x10
    3fb6:	5f 84       	ldd	r5, Y+15	; 0x0f
    3fb8:	6e 84       	ldd	r6, Y+14	; 0x0e
    3fba:	7d 84       	ldd	r7, Y+13	; 0x0d
    3fbc:	8c 84       	ldd	r8, Y+12	; 0x0c
    3fbe:	9b 84       	ldd	r9, Y+11	; 0x0b
    3fc0:	aa 84       	ldd	r10, Y+10	; 0x0a
    3fc2:	b9 84       	ldd	r11, Y+9	; 0x09
    3fc4:	c8 84       	ldd	r12, Y+8	; 0x08
    3fc6:	df 80       	ldd	r13, Y+7	; 0x07
    3fc8:	ee 80       	ldd	r14, Y+6	; 0x06
    3fca:	fd 80       	ldd	r15, Y+5	; 0x05
    3fcc:	0c 81       	ldd	r16, Y+4	; 0x04
    3fce:	1b 81       	ldd	r17, Y+3	; 0x03
    3fd0:	aa 81       	ldd	r26, Y+2	; 0x02
    3fd2:	b9 81       	ldd	r27, Y+1	; 0x01
    3fd4:	ce 0f       	add	r28, r30
    3fd6:	d1 1d       	adc	r29, r1
    3fd8:	0f b6       	in	r0, 0x3f	; 63
    3fda:	f8 94       	cli
    3fdc:	de bf       	out	0x3e, r29	; 62
    3fde:	0f be       	out	0x3f, r0	; 63
    3fe0:	cd bf       	out	0x3d, r28	; 61
    3fe2:	ed 01       	movw	r28, r26
    3fe4:	08 95       	ret

00003fe6 <_exit>:
    3fe6:	f8 94       	cli

00003fe8 <__stop_program>:
    3fe8:	ff cf       	rjmp	.-2      	; 0x3fe8 <__stop_program>
