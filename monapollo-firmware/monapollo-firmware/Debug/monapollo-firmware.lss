
monapollo-firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001b4  00800100  00003e98  00003f4c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003e98  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000215  008002b4  008002b4  00004100  2**0
                  ALLOC
  3 .eeprom       00000674  00810000  00810000  00004100  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00000bf4  00000000  00000000  00004774  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      0000033e  00000000  00000000  00005368  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 000003b8  00000000  00000000  000056a8  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00006f48  00000000  00000000  00005a60  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000019e5  00000000  00000000  0000c9a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000024a7  00000000  00000000  0000e38d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000e10  00000000  00000000  00010834  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001a11  00000000  00000000  00011644  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00003001  00000000  00000000  00013055  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000138  00000000  00000000  00016056  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 32 00 	jmp	0x64	; 0x64 <__ctors_end>
       4:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
       8:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
       c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      10:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      14:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      18:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      1c:	0c 94 92 03 	jmp	0x724	; 0x724 <__vector_7>
      20:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      24:	0c 94 86 03 	jmp	0x70c	; 0x70c <__vector_9>
      28:	0c 94 47 03 	jmp	0x68e	; 0x68e <__vector_10>
      2c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      30:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      34:	0c 94 47 04 	jmp	0x88e	; 0x88e <__vector_13>
      38:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      3c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      40:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      44:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      48:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      4c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      50:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      54:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      58:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      5c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      60:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>

00000064 <__ctors_end>:
      64:	11 24       	eor	r1, r1
      66:	1f be       	out	0x3f, r1	; 63
      68:	cf ef       	ldi	r28, 0xFF	; 255
      6a:	d0 e1       	ldi	r29, 0x10	; 16
      6c:	de bf       	out	0x3e, r29	; 62
      6e:	cd bf       	out	0x3d, r28	; 61

00000070 <__do_copy_data>:
      70:	12 e0       	ldi	r17, 0x02	; 2
      72:	a0 e0       	ldi	r26, 0x00	; 0
      74:	b1 e0       	ldi	r27, 0x01	; 1
      76:	e8 e9       	ldi	r30, 0x98	; 152
      78:	fe e3       	ldi	r31, 0x3E	; 62
      7a:	02 c0       	rjmp	.+4      	; 0x80 <__do_copy_data+0x10>
      7c:	05 90       	lpm	r0, Z+
      7e:	0d 92       	st	X+, r0
      80:	a4 3b       	cpi	r26, 0xB4	; 180
      82:	b1 07       	cpc	r27, r17
      84:	d9 f7       	brne	.-10     	; 0x7c <__do_copy_data+0xc>

00000086 <__do_clear_bss>:
      86:	14 e0       	ldi	r17, 0x04	; 4
      88:	a4 eb       	ldi	r26, 0xB4	; 180
      8a:	b2 e0       	ldi	r27, 0x02	; 2
      8c:	01 c0       	rjmp	.+2      	; 0x90 <.do_clear_bss_start>

0000008e <.do_clear_bss_loop>:
      8e:	1d 92       	st	X+, r1

00000090 <.do_clear_bss_start>:
      90:	a9 3c       	cpi	r26, 0xC9	; 201
      92:	b1 07       	cpc	r27, r17
      94:	e1 f7       	brne	.-8      	; 0x8e <.do_clear_bss_loop>
      96:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <main>
      9a:	0c 94 4a 1f 	jmp	0x3e94	; 0x3e94 <_exit>

0000009e <__bad_interrupt>:
      9e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a2 <setup_adc>:

void setup_adc(void)
{
	//ADCSRA |= (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0); //set ADC clock to 156.25 KHz for 20 MHz clock
	//ADCSRA |= (1<<ADPS2) | (1<<ADPS1); //set ADC clock to 312.5 KHz for 20 MHz clock
	ADCSRA |= (1<<ADPS2);// | (1<<ADPS0); //set ADC clock to 1.25 MHz for 20 MHz clock
      a2:	ea e7       	ldi	r30, 0x7A	; 122
      a4:	f0 e0       	ldi	r31, 0x00	; 0
      a6:	80 81       	ld	r24, Z
      a8:	84 60       	ori	r24, 0x04	; 4
      aa:	80 83       	st	Z, r24
	ADMUX |= (1<<REFS0); //set ADC reference to AVCC (+5V)
      ac:	ac e7       	ldi	r26, 0x7C	; 124
      ae:	b0 e0       	ldi	r27, 0x00	; 0
      b0:	8c 91       	ld	r24, X
      b2:	80 64       	ori	r24, 0x40	; 64
      b4:	8c 93       	st	X, r24
	
	DIDR0 |= 0x01; //disable digital input buffer for ADC0
      b6:	ae e7       	ldi	r26, 0x7E	; 126
      b8:	b0 e0       	ldi	r27, 0x00	; 0
      ba:	8c 91       	ld	r24, X
      bc:	81 60       	ori	r24, 0x01	; 1
      be:	8c 93       	st	X, r24
	
	ADCSRA |= (1<<ADEN); //enable ADC
      c0:	80 81       	ld	r24, Z
      c2:	80 68       	ori	r24, 0x80	; 128
      c4:	80 83       	st	Z, r24
}
      c6:	08 95       	ret

000000c8 <read_pot>:

uint16_t read_pot(struct potentiometer *pot) {
      c8:	fc 01       	movw	r30, r24
	
	DATA_BUS = pot->channel;
      ca:	83 81       	ldd	r24, Z+3	; 0x03
      cc:	8f 70       	andi	r24, 0x0F	; 15
      ce:	82 b9       	out	0x02, r24	; 2
	POT_MUX &= ~(1<<pot->mux_addr);
      d0:	aa ed       	ldi	r26, 0xDA	; 218
      d2:	b0 e0       	ldi	r27, 0x00	; 0
      d4:	4c 91       	ld	r20, X
      d6:	83 81       	ldd	r24, Z+3	; 0x03
      d8:	82 95       	swap	r24
      da:	8f 70       	andi	r24, 0x0F	; 15
      dc:	87 70       	andi	r24, 0x07	; 7
      de:	21 e0       	ldi	r18, 0x01	; 1
      e0:	30 e0       	ldi	r19, 0x00	; 0
      e2:	b9 01       	movw	r22, r18
      e4:	02 c0       	rjmp	.+4      	; 0xea <read_pot+0x22>
      e6:	66 0f       	add	r22, r22
      e8:	77 1f       	adc	r23, r23
      ea:	8a 95       	dec	r24
      ec:	e2 f7       	brpl	.-8      	; 0xe6 <read_pot+0x1e>
      ee:	cb 01       	movw	r24, r22
      f0:	80 95       	com	r24
      f2:	84 23       	and	r24, r20
      f4:	8c 93       	st	X, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
      f6:	7d e0       	ldi	r23, 0x0D	; 13
      f8:	7a 95       	dec	r23
      fa:	f1 f7       	brne	.-4      	; 0xf8 <read_pot+0x30>
      fc:	00 00       	nop
	_delay_us(2); //ADC settling time. Previously used 10 us, testing 2 us now. Now testing 1 us. See how it sounds. Nope. Needs to 2 us minimum to prevent crosstalk between multiplexer channels
	ADCSRA |= (1<<ADSC); //start ADC conversion
      fe:	aa e7       	ldi	r26, 0x7A	; 122
     100:	b0 e0       	ldi	r27, 0x00	; 0
     102:	8c 91       	ld	r24, X
     104:	80 64       	ori	r24, 0x40	; 64
     106:	8c 93       	st	X, r24
	while ((ADCSRA & (1<<ADSC))); //wait for ADC conversion to complete (13 cycles of ADC clock - 10.4 us for 1.25Mhz clock) - need to figure out what to do with this time - would interrupt be more efficient?
     108:	8c 91       	ld	r24, X
     10a:	86 fd       	sbrc	r24, 6
     10c:	fd cf       	rjmp	.-6      	; 0x108 <read_pot+0x40>
	POT_MUX |= (1<<pot->mux_addr); //disable pot multiplexer
     10e:	aa ed       	ldi	r26, 0xDA	; 218
     110:	b0 e0       	ldi	r27, 0x00	; 0
     112:	4c 91       	ld	r20, X
     114:	83 81       	ldd	r24, Z+3	; 0x03
     116:	82 95       	swap	r24
     118:	8f 70       	andi	r24, 0x0F	; 15
     11a:	87 70       	andi	r24, 0x07	; 7
     11c:	21 e0       	ldi	r18, 0x01	; 1
     11e:	30 e0       	ldi	r19, 0x00	; 0
     120:	b9 01       	movw	r22, r18
     122:	02 c0       	rjmp	.+4      	; 0x128 <read_pot+0x60>
     124:	66 0f       	add	r22, r22
     126:	77 1f       	adc	r23, r23
     128:	8a 95       	dec	r24
     12a:	e2 f7       	brpl	.-8      	; 0x124 <read_pot+0x5c>
     12c:	cb 01       	movw	r24, r22
     12e:	84 2b       	or	r24, r20
     130:	8c 93       	st	X, r24
	//note that ADSC reads HIGH as long as conversion is in progress, goes LOW when conversion is complete
			
			
	uint16_t adc_read = ADCL;
     132:	80 91 78 00 	lds	r24, 0x0078
     136:	90 e0       	ldi	r25, 0x00	; 0
	adc_read = adc_read | (ADCH <<8);
     138:	40 91 79 00 	lds	r20, 0x0079
     13c:	34 2f       	mov	r19, r20
     13e:	20 e0       	ldi	r18, 0x00	; 0
     140:	82 2b       	or	r24, r18
     142:	93 2b       	or	r25, r19
			
	return adc_read;
     144:	08 95       	ret

00000146 <update_arp_sequence>:
struct arp arp;


//static struct midi_note arp_sequence[24] = {0,0};

void update_arp_sequence(void) {
     146:	4f 92       	push	r4
     148:	5f 92       	push	r5
     14a:	6f 92       	push	r6
     14c:	7f 92       	push	r7
     14e:	8f 92       	push	r8
     150:	9f 92       	push	r9
     152:	af 92       	push	r10
     154:	bf 92       	push	r11
     156:	cf 92       	push	r12
     158:	df 92       	push	r13
     15a:	ef 92       	push	r14
     15c:	ff 92       	push	r15
     15e:	0f 93       	push	r16
     160:	1f 93       	push	r17
     162:	cf 93       	push	r28
     164:	df 93       	push	r29
		//arp.current_note = arp.sequence[arp.last_step].note; //temp note to store for release phase
		//arp.step_position = 0; //reset step position
		////return;
	//}

	arp.step_number = gate_buffer*(arp.range + 1);
     166:	90 91 88 03 	lds	r25, 0x0388
     16a:	9f 5f       	subi	r25, 0xFF	; 255
     16c:	80 91 b4 02 	lds	r24, 0x02B4
     170:	98 9f       	mul	r25, r24
     172:	80 2d       	mov	r24, r0
     174:	11 24       	eor	r1, r1
     176:	80 93 89 03 	sts	0x0389, r24
     17a:	88 24       	eor	r8, r8
     17c:	99 24       	eor	r9, r9
	
	//set arp sequence
	uint8_t step = 0;
	
	
	for (int range = 0; range <= arp.range; range++) {
     17e:	66 24       	eor	r6, r6
     180:	77 24       	eor	r7, r7
	
	
	//if ((arp.mode == UP_DOWN) && (arp.range > 0)) arp.step_number = arp.step_number << 1;//twice as many steps
	
	//set arp sequence
	uint8_t step = 0;
     182:	ff 24       	eor	r15, r15
					break;
					
				case DOWN:
					
					 //handle min note out of range here
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
     184:	44 24       	eor	r4, r4
     186:	55 24       	eor	r5, r5
		for (int i = 0; i < gate_buffer; i++) { // NOTE < rather than <= - <= was causing extra iteration that was over incrementing step!!!!!
			
			uint8_t root_note = get_indexed_note(gate_buffer - i - 1); //need to get notes in reverse order out of note pool
			//uint8_t root_note = get_indexed_note(i);
				
			switch(arp.mode) {
     188:	0f 2e       	mov	r0, r31
     18a:	ff e8       	ldi	r31, 0x8F	; 143
     18c:	cf 2e       	mov	r12, r31
     18e:	f3 e0       	ldi	r31, 0x03	; 3
     190:	df 2e       	mov	r13, r31
     192:	f0 2d       	mov	r31, r0
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
						
						root_note += 12;
						
					}
					arp.sequence[step++].note = root_note - (range*12);
     194:	0f 2e       	mov	r0, r31
     196:	f8 e8       	ldi	r31, 0x88	; 136
     198:	af 2e       	mov	r10, r31
     19a:	f3 e0       	ldi	r31, 0x03	; 3
     19c:	bf 2e       	mov	r11, r31
     19e:	f0 2d       	mov	r31, r0
     1a0:	49 c0       	rjmp	.+146    	; 0x234 <update_arp_sequence+0xee>
	
	for (int range = 0; range <= arp.range; range++) {
			
		for (int i = 0; i < gate_buffer; i++) { // NOTE < rather than <= - <= was causing extra iteration that was over incrementing step!!!!!
			
			uint8_t root_note = get_indexed_note(gate_buffer - i - 1); //need to get notes in reverse order out of note pool
     1a2:	81 50       	subi	r24, 0x01	; 1
     1a4:	80 1b       	sub	r24, r16
     1a6:	0e 94 82 01 	call	0x304	; 0x304 <get_indexed_note>
     1aa:	28 2f       	mov	r18, r24
			//uint8_t root_note = get_indexed_note(i);
				
			switch(arp.mode) {
     1ac:	f6 01       	movw	r30, r12
     1ae:	80 81       	ld	r24, Z
     1b0:	81 30       	cpi	r24, 0x01	; 1
     1b2:	29 f0       	breq	.+10     	; 0x1be <update_arp_sequence+0x78>
     1b4:	81 30       	cpi	r24, 0x01	; 1
     1b6:	50 f0       	brcs	.+20     	; 0x1cc <update_arp_sequence+0x86>
     1b8:	84 30       	cpi	r24, 0x04	; 4
     1ba:	30 f5       	brcc	.+76     	; 0x208 <update_arp_sequence+0xc2>
     1bc:	07 c0       	rjmp	.+14     	; 0x1cc <update_arp_sequence+0x86>
					break;
					
				case DOWN:
					
					 //handle min note out of range here
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
     1be:	ce 01       	movw	r24, r28
     1c0:	82 0f       	add	r24, r18
     1c2:	91 1d       	adc	r25, r1
     1c4:	88 30       	cpi	r24, 0x08	; 8
     1c6:	91 05       	cpc	r25, r1
     1c8:	6c f0       	brlt	.+26     	; 0x1e4 <update_arp_sequence+0x9e>
     1ca:	13 c0       	rjmp	.+38     	; 0x1f2 <update_arp_sequence+0xac>
			switch(arp.mode) {
				
				case UP:
				case UP_DOWN:
				case RANDOM:
					arp.sequence[step++].note = root_note + (range*12); //will need to handle max note out of range here
     1cc:	8f 2d       	mov	r24, r15
     1ce:	90 e0       	ldi	r25, 0x00	; 0
     1d0:	04 96       	adiw	r24, 0x04	; 4
     1d2:	88 0f       	add	r24, r24
     1d4:	99 1f       	adc	r25, r25
     1d6:	8a 0d       	add	r24, r10
     1d8:	9b 1d       	adc	r25, r11
     1da:	2e 19       	sub	r18, r14
     1dc:	fc 01       	movw	r30, r24
     1de:	20 83       	st	Z, r18
     1e0:	f3 94       	inc	r15
				
					break;
     1e2:	12 c0       	rjmp	.+36     	; 0x208 <update_arp_sequence+0xc2>
				case DOWN:
					
					 //handle min note out of range here
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
						
						root_note += 12;
     1e4:	24 5f       	subi	r18, 0xF4	; 244
					break;
					
				case DOWN:
					
					 //handle min note out of range here
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
     1e6:	ce 01       	movw	r24, r28
     1e8:	82 0f       	add	r24, r18
     1ea:	91 1d       	adc	r25, r1
     1ec:	88 30       	cpi	r24, 0x08	; 8
     1ee:	91 05       	cpc	r25, r1
     1f0:	cc f3       	brlt	.-14     	; 0x1e4 <update_arp_sequence+0x9e>
						
						root_note += 12;
						
					}
					arp.sequence[step++].note = root_note - (range*12);
     1f2:	8f 2d       	mov	r24, r15
     1f4:	90 e0       	ldi	r25, 0x00	; 0
     1f6:	04 96       	adiw	r24, 0x04	; 4
     1f8:	88 0f       	add	r24, r24
     1fa:	99 1f       	adc	r25, r25
     1fc:	8a 0d       	add	r24, r10
     1fe:	9b 1d       	adc	r25, r11
     200:	2e 0d       	add	r18, r14
     202:	fc 01       	movw	r30, r24
     204:	20 83       	st	Z, r18
     206:	f3 94       	inc	r15
	uint8_t step = 0;
	
	
	for (int range = 0; range <= arp.range; range++) {
			
		for (int i = 0; i < gate_buffer; i++) { // NOTE < rather than <= - <= was causing extra iteration that was over incrementing step!!!!!
     208:	0f 5f       	subi	r16, 0xFF	; 255
     20a:	1f 4f       	sbci	r17, 0xFF	; 255
     20c:	80 91 b4 02 	lds	r24, 0x02B4
     210:	28 2f       	mov	r18, r24
     212:	30 e0       	ldi	r19, 0x00	; 0
     214:	02 17       	cp	r16, r18
     216:	13 07       	cpc	r17, r19
     218:	24 f2       	brlt	.-120    	; 0x1a2 <update_arp_sequence+0x5c>
	
	//set arp sequence
	uint8_t step = 0;
	
	
	for (int range = 0; range <= arp.range; range++) {
     21a:	08 94       	sec
     21c:	61 1c       	adc	r6, r1
     21e:	71 1c       	adc	r7, r1
     220:	84 ef       	ldi	r24, 0xF4	; 244
     222:	9f ef       	ldi	r25, 0xFF	; 255
     224:	88 0e       	add	r8, r24
     226:	99 1e       	adc	r9, r25
     228:	f5 01       	movw	r30, r10
     22a:	80 81       	ld	r24, Z
     22c:	90 e0       	ldi	r25, 0x00	; 0
     22e:	86 15       	cp	r24, r6
     230:	97 05       	cpc	r25, r7
     232:	44 f0       	brlt	.+16     	; 0x244 <update_arp_sequence+0xfe>
			
		for (int i = 0; i < gate_buffer; i++) { // NOTE < rather than <= - <= was causing extra iteration that was over incrementing step!!!!!
     234:	80 91 b4 02 	lds	r24, 0x02B4
     238:	88 23       	and	r24, r24
     23a:	79 f3       	breq	.-34     	; 0x21a <update_arp_sequence+0xd4>
struct arp arp;


//static struct midi_note arp_sequence[24] = {0,0};

void update_arp_sequence(void) {
     23c:	e8 2c       	mov	r14, r8
					break;
					
				case DOWN:
					
					 //handle min note out of range here
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
     23e:	e4 01       	movw	r28, r8
     240:	82 01       	movw	r16, r4
     242:	af cf       	rjmp	.-162    	; 0x1a2 <update_arp_sequence+0x5c>
	

		
	
	
}
     244:	df 91       	pop	r29
     246:	cf 91       	pop	r28
     248:	1f 91       	pop	r17
     24a:	0f 91       	pop	r16
     24c:	ff 90       	pop	r15
     24e:	ef 90       	pop	r14
     250:	df 90       	pop	r13
     252:	cf 90       	pop	r12
     254:	bf 90       	pop	r11
     256:	af 90       	pop	r10
     258:	9f 90       	pop	r9
     25a:	8f 90       	pop	r8
     25c:	7f 90       	pop	r7
     25e:	6f 90       	pop	r6
     260:	5f 90       	pop	r5
     262:	4f 90       	pop	r4
     264:	08 95       	ret

00000266 <step_arp_note>:

void step_arp_note(void) { //updates arp note according to step position in sequence
	
	arp.current_note = arp.sequence[arp.step_position].note;
     266:	90 91 8a 03 	lds	r25, 0x038A
     26a:	a9 2f       	mov	r26, r25
     26c:	b0 e0       	ldi	r27, 0x00	; 0
     26e:	14 96       	adiw	r26, 0x04	; 4
     270:	e8 e8       	ldi	r30, 0x88	; 136
     272:	f3 e0       	ldi	r31, 0x03	; 3
     274:	aa 0f       	add	r26, r26
     276:	bb 1f       	adc	r27, r27
     278:	ae 0f       	add	r26, r30
     27a:	bf 1f       	adc	r27, r31
     27c:	8c 91       	ld	r24, X
     27e:	85 83       	std	Z+5, r24	; 0x05
	arp.previous_note = arp.current_note;
     280:	84 83       	std	Z+4, r24	; 0x04
	
	switch (arp.mode) {
     282:	87 81       	ldd	r24, Z+7	; 0x07
     284:	82 30       	cpi	r24, 0x02	; 2
     286:	19 f0       	breq	.+6      	; 0x28e <step_arp_note+0x28>
     288:	83 30       	cpi	r24, 0x03	; 3
     28a:	91 f5       	brne	.+100    	; 0x2f0 <step_arp_note+0x8a>
     28c:	27 c0       	rjmp	.+78     	; 0x2dc <step_arp_note+0x76>
		
		case UP_DOWN:
			
			if (arp.direction == UP) {
     28e:	80 91 8b 03 	lds	r24, 0x038B
     292:	88 23       	and	r24, r24
     294:	91 f4       	brne	.+36     	; 0x2ba <step_arp_note+0x54>
				arp.step_position++;	
     296:	9f 5f       	subi	r25, 0xFF	; 255
     298:	90 93 8a 03 	sts	0x038A, r25
				
				if (arp.step_position >= arp.step_number) {
     29c:	80 91 89 03 	lds	r24, 0x0389
     2a0:	98 17       	cp	r25, r24
     2a2:	78 f1       	brcs	.+94     	; 0x302 <step_arp_note+0x9c>
					arp.step_position = arp.step_number == 1 ? 0 : arp.step_number - 2; //Omar handles edge case here
     2a4:	81 30       	cpi	r24, 0x01	; 1
     2a6:	11 f0       	breq	.+4      	; 0x2ac <step_arp_note+0x46>
     2a8:	82 50       	subi	r24, 0x02	; 2
     2aa:	01 c0       	rjmp	.+2      	; 0x2ae <step_arp_note+0x48>
     2ac:	80 e0       	ldi	r24, 0x00	; 0
     2ae:	80 93 8a 03 	sts	0x038A, r24
					arp.direction = DOWN;
     2b2:	81 e0       	ldi	r24, 0x01	; 1
     2b4:	80 93 8b 03 	sts	0x038B, r24
     2b8:	08 95       	ret
				}				
				
			} else {
				if (arp.step_position <= 0) {
     2ba:	99 23       	and	r25, r25
     2bc:	59 f4       	brne	.+22     	; 0x2d4 <step_arp_note+0x6e>
					
					arp.step_position = arp.step_number == 1 ? 0 : 1; //Omar handles edge case here
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	90 91 89 03 	lds	r25, 0x0389
     2c4:	91 30       	cpi	r25, 0x01	; 1
     2c6:	09 f4       	brne	.+2      	; 0x2ca <step_arp_note+0x64>
     2c8:	80 e0       	ldi	r24, 0x00	; 0
     2ca:	80 93 8a 03 	sts	0x038A, r24
					arp.direction = UP;
     2ce:	10 92 8b 03 	sts	0x038B, r1
     2d2:	08 95       	ret
					
				} else {
					arp.step_position--;
     2d4:	91 50       	subi	r25, 0x01	; 1
     2d6:	90 93 8a 03 	sts	0x038A, r25
     2da:	08 95       	ret
			
			break;
			
		case RANDOM:
		
			arp.step_position = random() % arp.step_number;
     2dc:	0e 94 6e 1e 	call	0x3cdc	; 0x3cdc <random>
     2e0:	60 91 89 03 	lds	r22, 0x0389
     2e4:	70 e0       	ldi	r23, 0x00	; 0
     2e6:	0e 94 0d 1e 	call	0x3c1a	; 0x3c1a <__divmodhi4>
     2ea:	80 93 8a 03 	sts	0x038A, r24
		
			break;
     2ee:	08 95       	ret
			
		default:
		
			if (++arp.step_position >= arp.step_number) arp.step_position  = 0;//reset step position when at end of sequence 
     2f0:	9f 5f       	subi	r25, 0xFF	; 255
     2f2:	90 93 8a 03 	sts	0x038A, r25
     2f6:	80 91 89 03 	lds	r24, 0x0389
     2fa:	98 17       	cp	r25, r24
     2fc:	10 f0       	brcs	.+4      	; 0x302 <step_arp_note+0x9c>
     2fe:	10 92 8a 03 	sts	0x038A, r1
     302:	08 95       	ret

00000304 <get_indexed_note>:

static uint8_t current_note = 0; //this acts as a buffer for the current note to maintain pitch during release stage of envelopes

uint8_t get_indexed_note(uint8_t index) {
	
	return note_pool[index].note;
     304:	e8 2f       	mov	r30, r24
     306:	f0 e0       	ldi	r31, 0x00	; 0
     308:	ee 0f       	add	r30, r30
     30a:	ff 1f       	adc	r31, r31
     30c:	e8 54       	subi	r30, 0x48	; 72
     30e:	fe 4f       	sbci	r31, 0xFE	; 254
	
	
	
}
     310:	80 81       	ld	r24, Z
     312:	08 95       	ret

00000314 <get_current_note>:
uint8_t get_current_note() { //Force inline this function? Ask Omar. BUT, this could be where interpolation is calculated!
	
	uint8_t note = 0;
	if (arp.clock_source == OFF) {
     314:	80 91 8e 03 	lds	r24, 0x038E
     318:	82 30       	cpi	r24, 0x02	; 2
     31a:	19 f4       	brne	.+6      	; 0x322 <get_current_note+0xe>
		
		note = current_note;
     31c:	80 91 b5 02 	lds	r24, 0x02B5
     320:	08 95       	ret

		
	} else {
		
		//do something here to determine what arp note should be
		note = arp.current_note; //yeah, like this!
     322:	80 91 8d 03 	lds	r24, 0x038D
		//if (gate_buffer) note = arp.current_note;
		
	}
	return note;
	
}
     326:	08 95       	ret

00000328 <new_note>:

void new_note(uint8_t note, uint8_t velocity) {
     328:	0f 93       	push	r16
     32a:	1f 93       	push	r17
     32c:	cf 93       	push	r28
     32e:	df 93       	push	r29
     330:	18 2f       	mov	r17, r24
     332:	06 2f       	mov	r16, r22
	
	
	//shift contents of note_pool right by one element
	memmove(note_pool + 1, note_pool, sizeof(note_pool) -sizeof(*note_pool)); //last argument: sizeof struct - sizeof one element of struct. See http://www.cplusplus.com/forum/beginner/1936/
     334:	8a eb       	ldi	r24, 0xBA	; 186
     336:	91 e0       	ldi	r25, 0x01	; 1
     338:	ec 01       	movw	r28, r24
     33a:	22 97       	sbiw	r28, 0x02	; 2
     33c:	be 01       	movw	r22, r28
     33e:	4e e0       	ldi	r20, 0x0E	; 14
     340:	50 e0       	ldi	r21, 0x00	; 0
     342:	0e 94 87 1e 	call	0x3d0e	; 0x3d0e <memmove>
	
	//add new note to pool
	note_pool[0].note = note;
     346:	18 83       	st	Y, r17
	note_pool[0].velocity = velocity;
     348:	09 83       	std	Y+1, r16	; 0x01
	
	current_note = note; //set current note
     34a:	10 93 b5 02 	sts	0x02B5, r17
	
} 
     34e:	df 91       	pop	r29
     350:	cf 91       	pop	r28
     352:	1f 91       	pop	r17
     354:	0f 91       	pop	r16
     356:	08 95       	ret

00000358 <remove_note>:
void remove_note(uint8_t note){
     358:	cf 93       	push	r28
	
	uint8_t free_slot = 0;
	uint8_t temp_note = note_pool[0].note; //holder for current note
     35a:	c0 91 b8 01 	lds	r28, 0x01B8
	for (int i = 0; i <= 7; i++) { //search for note in note stack
		
		if (note_pool[i].note == note) {
     35e:	c8 17       	cp	r28, r24
     360:	41 f0       	breq	.+16     	; 0x372 <remove_note+0x1a>
     362:	ea eb       	ldi	r30, 0xBA	; 186
     364:	f1 e0       	ldi	r31, 0x01	; 1
} 
void remove_note(uint8_t note){
	
	uint8_t free_slot = 0;
	uint8_t temp_note = note_pool[0].note; //holder for current note
	for (int i = 0; i <= 7; i++) { //search for note in note stack
     366:	41 e0       	ldi	r20, 0x01	; 1
     368:	50 e0       	ldi	r21, 0x00	; 0
		
		if (note_pool[i].note == note) {
     36a:	90 81       	ld	r25, Z
     36c:	98 17       	cp	r25, r24
     36e:	59 f4       	brne	.+22     	; 0x386 <remove_note+0x2e>
     370:	02 c0       	rjmp	.+4      	; 0x376 <remove_note+0x1e>
} 
void remove_note(uint8_t note){
	
	uint8_t free_slot = 0;
	uint8_t temp_note = note_pool[0].note; //holder for current note
	for (int i = 0; i <= 7; i++) { //search for note in note stack
     372:	40 e0       	ldi	r20, 0x00	; 0
     374:	50 e0       	ldi	r21, 0x00	; 0
		
		if (note_pool[i].note == note) {
			
			note_pool[i].note = EMPTY;
     376:	fa 01       	movw	r30, r20
     378:	ee 0f       	add	r30, r30
     37a:	ff 1f       	adc	r31, r31
     37c:	e8 54       	subi	r30, 0x48	; 72
     37e:	fe 4f       	sbci	r31, 0xFE	; 254
     380:	8f ef       	ldi	r24, 0xFF	; 255
     382:	80 83       	st	Z, r24
			free_slot = i;
			break;
     384:	07 c0       	rjmp	.+14     	; 0x394 <remove_note+0x3c>
} 
void remove_note(uint8_t note){
	
	uint8_t free_slot = 0;
	uint8_t temp_note = note_pool[0].note; //holder for current note
	for (int i = 0; i <= 7; i++) { //search for note in note stack
     386:	4f 5f       	subi	r20, 0xFF	; 255
     388:	5f 4f       	sbci	r21, 0xFF	; 255
     38a:	32 96       	adiw	r30, 0x02	; 2
     38c:	48 30       	cpi	r20, 0x08	; 8
     38e:	51 05       	cpc	r21, r1
     390:	61 f7       	brne	.-40     	; 0x36a <remove_note+0x12>
	current_note = note; //set current note
	
} 
void remove_note(uint8_t note){
	
	uint8_t free_slot = 0;
     392:	40 e0       	ldi	r20, 0x00	; 0
		
	}
	
	
	//now shift elements left	
	memmove(note_pool + free_slot, note_pool + free_slot + 1, sizeof(note_pool) - (sizeof(*note_pool)*(free_slot + 1)));
     394:	50 e0       	ldi	r21, 0x00	; 0
     396:	ca 01       	movw	r24, r20
     398:	88 0f       	add	r24, r24
     39a:	99 1f       	adc	r25, r25
     39c:	bc 01       	movw	r22, r24
     39e:	66 54       	subi	r22, 0x46	; 70
     3a0:	7e 4f       	sbci	r23, 0xFE	; 254
     3a2:	40 95       	com	r20
     3a4:	50 95       	com	r21
     3a6:	48 5f       	subi	r20, 0xF8	; 248
     3a8:	5f 4f       	sbci	r21, 0xFF	; 255
     3aa:	44 0f       	add	r20, r20
     3ac:	55 1f       	adc	r21, r21
     3ae:	88 54       	subi	r24, 0x48	; 72
     3b0:	9e 4f       	sbci	r25, 0xFE	; 254
     3b2:	0e 94 87 1e 	call	0x3d0e	; 0x3d0e <memmove>
	note_pool[7].note = EMPTY;	
     3b6:	8f ef       	ldi	r24, 0xFF	; 255
     3b8:	80 93 c6 01 	sts	0x01C6, r24
	
	//check to see if this is the last note released		
	//if it is, this might be a good place to ensure gate_buffer is empty
	if (note_pool[0].note == EMPTY) {
     3bc:	80 91 b8 01 	lds	r24, 0x01B8
     3c0:	8f 3f       	cpi	r24, 0xFF	; 255
     3c2:	19 f4       	brne	.+6      	; 0x3ca <remove_note+0x72>
		
		current_note = temp_note; //store last note released for maintaining pitch during envelope release stage
     3c4:	c0 93 b5 02 	sts	0x02B5, r28
     3c8:	02 c0       	rjmp	.+4      	; 0x3ce <remove_note+0x76>
		
	} else {		
		
		current_note = note_pool[0].note; //otherwise, the current note is the next one in the note stack
     3ca:	80 93 b5 02 	sts	0x02B5, r24

	}	
	
}
     3ce:	cf 91       	pop	r28
     3d0:	08 95       	ret

000003d2 <setup_system_clock>:
struct clock system_clock;

void setup_system_clock(void) {
	
	
	TCCR1B = (1<<CS10) | (1<<CS12) | (1<<WGM12);//TIMER1_DIVIDE_1024;
     3d2:	8d e0       	ldi	r24, 0x0D	; 13
     3d4:	80 93 81 00 	sts	0x0081, r24
	TIMSK1 = (1<<OCIE1A);
     3d8:	82 e0       	ldi	r24, 0x02	; 2
     3da:	80 93 6f 00 	sts	0x006F, r24
	
	
	
}
     3de:	08 95       	ret

000003e0 <update_clock_rate>:

void update_clock_rate(uint16_t rate) {
	
	OCR1A = rate;
     3e0:	90 93 89 00 	sts	0x0089, r25
     3e4:	80 93 88 00 	sts	0x0088, r24
	if (TCNT1 > rate) TCNT1 = rate - 1; //this prevents wrapping. setting TCNT1 = rate would cause immediate interrupt. Is that OK?
     3e8:	20 91 84 00 	lds	r18, 0x0084
     3ec:	30 91 85 00 	lds	r19, 0x0085
     3f0:	82 17       	cp	r24, r18
     3f2:	93 07       	cpc	r25, r19
     3f4:	28 f4       	brcc	.+10     	; 0x400 <update_clock_rate+0x20>
     3f6:	01 97       	sbiw	r24, 0x01	; 1
     3f8:	90 93 85 00 	sts	0x0085, r25
     3fc:	80 93 84 00 	sts	0x0084, r24
     400:	08 95       	ret

00000402 <set_control_voltage>:
struct control_voltage sustain_2_cv		={SUSTAIN_2,	DAC_MUX_EN3};
struct control_voltage sustain_1_cv		={SUSTAIN_1,	DAC_MUX_EN3};
struct control_voltage release_2_cv		={RELEASE_2,	DAC_MUX_EN3};
struct control_voltage release_1_cv		={RELEASE_1,	DAC_MUX_EN3};		

void set_control_voltage (struct control_voltage * cv, uint16_t value) {
     402:	dc 01       	movw	r26, r24

	DAC_BUS_LOW = value & 0b00000011111111; //mask top 6 MSBs to set low byte
     404:	6b b9       	out	0x0b, r22	; 11
	
	DAC_BUS_HIGH = value >> 8; //shift away bottom LSBs to set high byte
     406:	78 b9       	out	0x08, r23	; 8
	
	DAC_CTRL &= ~(1<<DAC_WR); //write DATA
     408:	a0 98       	cbi	0x14, 0	; 20
	DAC_CTRL |= (1<<DAC_WR);	
     40a:	a0 9a       	sbi	0x14, 0	; 20

	DATA_BUS = cv->channel; //set channel for DG408 multiplexer output
     40c:	8c 91       	ld	r24, X
     40e:	87 70       	andi	r24, 0x07	; 7
     410:	82 b9       	out	0x02, r24	; 2
     412:	66 e0       	ldi	r22, 0x06	; 6
     414:	6a 95       	dec	r22
     416:	f1 f7       	brne	.-4      	; 0x414 <set_control_voltage+0x12>
     418:	00 c0       	rjmp	.+0      	; 0x41a <set_control_voltage+0x18>

	_delay_us(1); //AD5556 DAC has 0.5 us settling time. 1 us wasn't long enough for transitions from 10V to 0V
	DAC_MUX |= (1<<cv->mux_addr); //enable multiplexer
     41a:	ea ed       	ldi	r30, 0xDA	; 218
     41c:	f0 e0       	ldi	r31, 0x00	; 0
     41e:	40 81       	ld	r20, Z
     420:	8c 91       	ld	r24, X
     422:	86 95       	lsr	r24
     424:	86 95       	lsr	r24
     426:	86 95       	lsr	r24
     428:	87 70       	andi	r24, 0x07	; 7
     42a:	21 e0       	ldi	r18, 0x01	; 1
     42c:	30 e0       	ldi	r19, 0x00	; 0
     42e:	b9 01       	movw	r22, r18
     430:	02 c0       	rjmp	.+4      	; 0x436 <set_control_voltage+0x34>
     432:	66 0f       	add	r22, r22
     434:	77 1f       	adc	r23, r23
     436:	8a 95       	dec	r24
     438:	e2 f7       	brpl	.-8      	; 0x432 <set_control_voltage+0x30>
     43a:	cb 01       	movw	r24, r22
     43c:	84 2b       	or	r24, r20
     43e:	80 83       	st	Z, r24
     440:	76 e0       	ldi	r23, 0x06	; 6
     442:	7a 95       	dec	r23
     444:	f1 f7       	brne	.-4      	; 0x442 <set_control_voltage+0x40>
     446:	00 c0       	rjmp	.+0      	; 0x448 <set_control_voltage+0x46>
	_delay_us(1); //wait for S&H cap to charge - need to figure out how to do this more time efficiently
	DAC_MUX &= ~(1<<cv->mux_addr); //disable multiplexer
     448:	80 81       	ld	r24, Z
     44a:	9c 91       	ld	r25, X
     44c:	96 95       	lsr	r25
     44e:	96 95       	lsr	r25
     450:	96 95       	lsr	r25
     452:	97 70       	andi	r25, 0x07	; 7
     454:	02 c0       	rjmp	.+4      	; 0x45a <set_control_voltage+0x58>
     456:	22 0f       	add	r18, r18
     458:	33 1f       	adc	r19, r19
     45a:	9a 95       	dec	r25
     45c:	e2 f7       	brpl	.-8      	; 0x456 <set_control_voltage+0x54>
     45e:	20 95       	com	r18
     460:	28 23       	and	r18, r24
     462:	20 83       	st	Z, r18
	
}	
     464:	08 95       	ret

00000466 <setup_dac>:

	
void setup_dac(void) //set up DAC
{
	DDRG |= (1<<DAC_WR) | (1<<DAC_RS); //set DAC control bits as outputs
     466:	83 b3       	in	r24, 0x13	; 19
     468:	83 60       	ori	r24, 0x03	; 3
     46a:	83 bb       	out	0x13, r24	; 19
	DDRD = 0xFF; //set DAC_BUS_LOW bits to outputs
     46c:	8f ef       	ldi	r24, 0xFF	; 255
     46e:	8a b9       	out	0x0a, r24	; 10
	DDRC |= 0xFF;//set DAC_BUS_HIGH bits to outputs
     470:	97 b1       	in	r25, 0x07	; 7
     472:	87 b9       	out	0x07, r24	; 7
	DDRH |= (1<<DAC_MUX_EN0) | (1<<DAC_MUX_EN1) | (1<<DAC_MUX_EN2) | (1<<DAC_MUX_EN3); //set DAC_MUX_EN pins as outputs
     474:	e9 ed       	ldi	r30, 0xD9	; 217
     476:	f0 e0       	ldi	r31, 0x00	; 0
     478:	80 81       	ld	r24, Z
     47a:	8f 60       	ori	r24, 0x0F	; 15
     47c:	80 83       	st	Z, r24
	
	DAC_MUX &= ~((1<<DAC_MUX_EN0) | (1<<DAC_MUX_EN1) | (1<<DAC_MUX_EN2) | (1<<DAC_MUX_EN3)); //disable DG408 VDAC multiplexers
     47e:	ea ed       	ldi	r30, 0xDA	; 218
     480:	f0 e0       	ldi	r31, 0x00	; 0
     482:	80 81       	ld	r24, Z
     484:	80 7f       	andi	r24, 0xF0	; 240
     486:	80 83       	st	Z, r24
	
	DAC_CTRL |= (1<<DAC_RS) | (1<<DAC_WR); //disable DAC
     488:	84 b3       	in	r24, 0x14	; 20
     48a:	83 60       	ori	r24, 0x03	; 3
     48c:	84 bb       	out	0x14, r24	; 20
	
	DAC_CTRL &= ~(1<<DAC_RS); //reset DAC
     48e:	a1 98       	cbi	0x14, 1	; 20
	DAC_CTRL |= (1<<DAC_RS);
     490:	a1 9a       	sbi	0x14, 1	; 20
	
	DAC_CTRL &= ~(1<<DAC_WR); //write DATA - falling edge then rising edge to toggle DAC bits to output register
     492:	a0 98       	cbi	0x14, 0	; 20
	DAC_CTRL |= (1<<DAC_WR);
     494:	a0 9a       	sbi	0x14, 0	; 20
}
     496:	08 95       	ret

00000498 <display_dec>:
#include "synth.h"



void display_dec(uint16_t number, uint8_t place)
{
     498:	0f 93       	push	r16
     49a:	1f 93       	push	r17
     49c:	cf 93       	push	r28
     49e:	df 93       	push	r29
     4a0:	cd b7       	in	r28, 0x3d	; 61
     4a2:	de b7       	in	r29, 0x3e	; 62
     4a4:	2e 97       	sbiw	r28, 0x0e	; 14
     4a6:	0f b6       	in	r0, 0x3f	; 63
     4a8:	f8 94       	cli
     4aa:	de bf       	out	0x3e, r29	; 62
     4ac:	0f be       	out	0x3f, r0	; 63
     4ae:	cd bf       	out	0x3d, r28	; 61
	
	uint8_t digit[] = {
     4b0:	28 e0       	ldi	r18, 0x08	; 8
     4b2:	29 83       	std	Y+1, r18	; 0x01
     4b4:	21 e0       	ldi	r18, 0x01	; 1
     4b6:	2a 83       	std	Y+2, r18	; 0x02
     4b8:	22 e0       	ldi	r18, 0x02	; 2
     4ba:	2b 83       	std	Y+3, r18	; 0x03
     4bc:	24 e0       	ldi	r18, 0x04	; 4
     4be:	2c 83       	std	Y+4, r18	; 0x04
		TENS,
		HUNDS,
		THOUS,
	};
	
	uint8_t dec[] = {
     4c0:	de 01       	movw	r26, r28
     4c2:	15 96       	adiw	r26, 0x05	; 5
     4c4:	e7 ee       	ldi	r30, 0xE7	; 231
     4c6:	f1 e0       	ldi	r31, 0x01	; 1
     4c8:	2a e0       	ldi	r18, 0x0A	; 10
     4ca:	01 90       	ld	r0, Z+
     4cc:	0d 92       	st	X+, r0
     4ce:	21 50       	subi	r18, 0x01	; 1
     4d0:	e1 f7       	brne	.-8      	; 0x4ca <display_dec+0x32>
		
		
	};
	
	//clear cathode bits
	DATA_BUS = 0xFF; //set bits for cathode (current sinks, active LOW)
     4d2:	2f ef       	ldi	r18, 0xFF	; 255
     4d4:	22 b9       	out	0x02, r18	; 2
	//latch data to cathode lines
	DISPLAY_PORT |= (1<<DISP_CATHODE_LATCH);
     4d6:	ea ed       	ldi	r30, 0xDA	; 218
     4d8:	f0 e0       	ldi	r31, 0x00	; 0
     4da:	20 81       	ld	r18, Z
     4dc:	20 61       	ori	r18, 0x10	; 16
     4de:	20 83       	st	Z, r18
	DISPLAY_PORT &= ~(1<<DISP_CATHODE_LATCH);
     4e0:	20 81       	ld	r18, Z
     4e2:	2f 7e       	andi	r18, 0xEF	; 239
     4e4:	20 83       	st	Z, r18
	
	//set anode bit
	DATA_BUS = digit[place];
     4e6:	06 2f       	mov	r16, r22
     4e8:	10 e0       	ldi	r17, 0x00	; 0
     4ea:	de 01       	movw	r26, r28
     4ec:	a0 0f       	add	r26, r16
     4ee:	b1 1f       	adc	r27, r17
     4f0:	11 96       	adiw	r26, 0x01	; 1
     4f2:	2c 91       	ld	r18, X
     4f4:	11 97       	sbiw	r26, 0x01	; 1
     4f6:	22 b9       	out	0x02, r18	; 2
	//latch data to anode lines
	DISPLAY_PORT |= (1<<DISP_ANODE_LATCH);
     4f8:	20 81       	ld	r18, Z
     4fa:	20 62       	ori	r18, 0x20	; 32
     4fc:	20 83       	st	Z, r18
	DISPLAY_PORT &= ~(1<<DISP_ANODE_LATCH);
     4fe:	20 81       	ld	r18, Z
     500:	2f 7d       	andi	r18, 0xDF	; 223
     502:	20 83       	st	Z, r18
     504:	48 2f       	mov	r20, r24
     506:	59 2f       	mov	r21, r25
     508:	87 e2       	ldi	r24, 0x27	; 39
     50a:	40 31       	cpi	r20, 0x10	; 16
     50c:	58 07       	cpc	r21, r24
     50e:	10 f0       	brcs	.+4      	; 0x514 <display_dec+0x7c>
     510:	4f e0       	ldi	r20, 0x0F	; 15
     512:	57 e2       	ldi	r21, 0x27	; 39
	if (number > 9999) {
		number = 9999;
		}
	
	/* First division by 10 */
	q1 = (number >> 1) + (number >> 2);
     514:	ca 01       	movw	r24, r20
     516:	96 95       	lsr	r25
     518:	87 95       	ror	r24
     51a:	96 95       	lsr	r25
     51c:	87 95       	ror	r24
     51e:	9a 01       	movw	r18, r20
     520:	36 95       	lsr	r19
     522:	27 95       	ror	r18
     524:	28 0f       	add	r18, r24
     526:	39 1f       	adc	r19, r25
	q1 += q1 >> 4;
     528:	c9 01       	movw	r24, r18
     52a:	92 95       	swap	r25
     52c:	82 95       	swap	r24
     52e:	8f 70       	andi	r24, 0x0F	; 15
     530:	89 27       	eor	r24, r25
     532:	9f 70       	andi	r25, 0x0F	; 15
     534:	89 27       	eor	r24, r25
     536:	82 0f       	add	r24, r18
     538:	93 1f       	adc	r25, r19
	q1 += q1 >> 8;
     53a:	29 2f       	mov	r18, r25
     53c:	33 27       	eor	r19, r19
     53e:	82 0f       	add	r24, r18
     540:	93 1f       	adc	r25, r19
	q2 = q1 >> 3;
     542:	96 95       	lsr	r25
     544:	87 95       	ror	r24
     546:	96 95       	lsr	r25
     548:	87 95       	ror	r24
     54a:	96 95       	lsr	r25
     54c:	87 95       	ror	r24
	r = number - q2 * 10;
     54e:	28 2f       	mov	r18, r24
     550:	22 0f       	add	r18, r18
     552:	32 2f       	mov	r19, r18
     554:	33 0f       	add	r19, r19
     556:	33 0f       	add	r19, r19
     558:	23 0f       	add	r18, r19
     55a:	e4 2f       	mov	r30, r20
     55c:	e2 1b       	sub	r30, r18
	//r = number - (((q2 << 2) + q2) << 1);
	qa = q2 + (r > 9);
     55e:	61 e0       	ldi	r22, 0x01	; 1
     560:	70 e0       	ldi	r23, 0x00	; 0
     562:	ea 30       	cpi	r30, 0x0A	; 10
     564:	10 f4       	brcc	.+4      	; 0x56a <display_dec+0xd2>
     566:	60 e0       	ldi	r22, 0x00	; 0
     568:	70 e0       	ldi	r23, 0x00	; 0
     56a:	68 0f       	add	r22, r24
     56c:	79 1f       	adc	r23, r25
	ones_place = rem[r];

	/* second division by 10 */

	q2 = (qa >> 1) + (qa >> 2);
     56e:	9b 01       	movw	r18, r22
     570:	36 95       	lsr	r19
     572:	27 95       	ror	r18
     574:	36 95       	lsr	r19
     576:	27 95       	ror	r18
     578:	ab 01       	movw	r20, r22
     57a:	56 95       	lsr	r21
     57c:	47 95       	ror	r20
     57e:	24 0f       	add	r18, r20
     580:	35 1f       	adc	r19, r21
	q2 += q2 >> 4;
     582:	c9 01       	movw	r24, r18
     584:	92 95       	swap	r25
     586:	82 95       	swap	r24
     588:	8f 70       	andi	r24, 0x0F	; 15
     58a:	89 27       	eor	r24, r25
     58c:	9f 70       	andi	r25, 0x0F	; 15
     58e:	89 27       	eor	r24, r25
     590:	82 0f       	add	r24, r18
     592:	93 1f       	adc	r25, r19
	q2 += q2 >> 8;
     594:	29 2f       	mov	r18, r25
     596:	33 27       	eor	r19, r19
     598:	82 0f       	add	r24, r18
     59a:	93 1f       	adc	r25, r19
	q3 = q2 >> 3;
     59c:	96 95       	lsr	r25
     59e:	87 95       	ror	r24
     5a0:	96 95       	lsr	r25
     5a2:	87 95       	ror	r24
     5a4:	96 95       	lsr	r25
     5a6:	87 95       	ror	r24
	r = qa - q3 * 10;
     5a8:	98 2f       	mov	r25, r24
     5aa:	99 0f       	add	r25, r25
     5ac:	29 2f       	mov	r18, r25
     5ae:	22 0f       	add	r18, r18
     5b0:	22 0f       	add	r18, r18
     5b2:	92 0f       	add	r25, r18
     5b4:	69 1b       	sub	r22, r25
	qb = q3 + (r > 9);
     5b6:	91 e0       	ldi	r25, 0x01	; 1
     5b8:	6a 30       	cpi	r22, 0x0A	; 10
     5ba:	08 f4       	brcc	.+2      	; 0x5be <display_dec+0x126>
     5bc:	90 e0       	ldi	r25, 0x00	; 0
     5be:	89 0f       	add	r24, r25
	tens_place = rem[r];
     5c0:	41 ef       	ldi	r20, 0xF1	; 241
     5c2:	51 e0       	ldi	r21, 0x01	; 1
     5c4:	da 01       	movw	r26, r20
     5c6:	a6 0f       	add	r26, r22
     5c8:	b1 1d       	adc	r27, r1
     5ca:	3c 91       	ld	r19, X

	/* third division by 10 */

	q4 = (qb >> 1) + (qb >> 2);
     5cc:	28 2f       	mov	r18, r24
     5ce:	26 95       	lsr	r18
     5d0:	26 95       	lsr	r18
     5d2:	98 2f       	mov	r25, r24
     5d4:	96 95       	lsr	r25
     5d6:	92 0f       	add	r25, r18
	q4 += q4 >> 4;
     5d8:	29 2f       	mov	r18, r25
     5da:	22 95       	swap	r18
     5dc:	2f 70       	andi	r18, 0x0F	; 15
     5de:	92 0f       	add	r25, r18
	q4 = q4 >> 3;
     5e0:	96 95       	lsr	r25
     5e2:	96 95       	lsr	r25
     5e4:	96 95       	lsr	r25
	r = qb - q4 * 10;
     5e6:	29 2f       	mov	r18, r25
     5e8:	22 0f       	add	r18, r18
     5ea:	62 2f       	mov	r22, r18
     5ec:	66 0f       	add	r22, r22
     5ee:	66 0f       	add	r22, r22
     5f0:	26 0f       	add	r18, r22
     5f2:	82 1b       	sub	r24, r18
	thous_place = q4 + (r > 9);
	hunds_place = rem[r];
     5f4:	da 01       	movw	r26, r20
     5f6:	a8 0f       	add	r26, r24
     5f8:	b1 1d       	adc	r27, r1
     5fa:	2c 91       	ld	r18, X
	q1 += q1 >> 8;
	q2 = q1 >> 3;
	r = number - q2 * 10;
	//r = number - (((q2 << 2) + q2) << 1);
	qa = q2 + (r > 9);
	ones_place = rem[r];
     5fc:	4e 0f       	add	r20, r30
     5fe:	51 1d       	adc	r21, r1
	q4 = q4 >> 3;
	r = qb - q4 * 10;
	thous_place = q4 + (r > 9);
	hunds_place = rem[r];

	digit_index[0] = ones_place;
     600:	fa 01       	movw	r30, r20
     602:	40 81       	ld	r20, Z
     604:	40 93 b8 02 	sts	0x02B8, r20
	digit_index[1] = tens_place;
     608:	30 93 b9 02 	sts	0x02B9, r19
	digit_index[2] = hunds_place;
     60c:	20 93 ba 02 	sts	0x02BA, r18

	q4 = (qb >> 1) + (qb >> 2);
	q4 += q4 >> 4;
	q4 = q4 >> 3;
	r = qb - q4 * 10;
	thous_place = q4 + (r > 9);
     610:	21 e0       	ldi	r18, 0x01	; 1
     612:	8a 30       	cpi	r24, 0x0A	; 10
     614:	08 f4       	brcc	.+2      	; 0x618 <display_dec+0x180>
     616:	20 e0       	ldi	r18, 0x00	; 0
     618:	92 0f       	add	r25, r18
	hunds_place = rem[r];

	digit_index[0] = ones_place;
	digit_index[1] = tens_place;
	digit_index[2] = hunds_place;
	digit_index[3] = thous_place;
     61a:	90 93 bb 02 	sts	0x02BB, r25

	cathode_byte = dec[digit_index[place]];
     61e:	f8 01       	movw	r30, r16
     620:	e8 54       	subi	r30, 0x48	; 72
     622:	fd 4f       	sbci	r31, 0xFD	; 253
     624:	80 81       	ld	r24, Z
     626:	fe 01       	movw	r30, r28
     628:	e8 0f       	add	r30, r24
     62a:	f1 1d       	adc	r31, r1
     62c:	85 81       	ldd	r24, Z+5	; 0x05
	
	if (current_patch.mode == EDIT) cathode_byte |= dp;
     62e:	90 91 0b 03 	lds	r25, 0x030B
     632:	92 30       	cpi	r25, 0x02	; 2
     634:	11 f4       	brne	.+4      	; 0x63a <display_dec+0x1a2>
     636:	80 62       	ori	r24, 0x20	; 32
     638:	03 c0       	rjmp	.+6      	; 0x640 <display_dec+0x1a8>
	if (current_patch.mode == MANUAL) cathode_byte = g; //Roland style dash for MANUAL mode. Could move this to the top as manual mode precludes the need to parse digit
     63a:	91 30       	cpi	r25, 0x01	; 1
     63c:	09 f4       	brne	.+2      	; 0x640 <display_dec+0x1a8>
     63e:	88 e0       	ldi	r24, 0x08	; 8
	
	
	//set cathode byte
	DATA_BUS = ~(cathode_byte); //set bits for cathode (current sinks, active LOW)
     640:	80 95       	com	r24
     642:	82 b9       	out	0x02, r24	; 2
	//latch data to cathode lines
	DISPLAY_PORT |= (1<<DISP_CATHODE_LATCH);
     644:	ea ed       	ldi	r30, 0xDA	; 218
     646:	f0 e0       	ldi	r31, 0x00	; 0
     648:	80 81       	ld	r24, Z
     64a:	80 61       	ori	r24, 0x10	; 16
     64c:	80 83       	st	Z, r24
	DISPLAY_PORT &= ~(1<<DISP_CATHODE_LATCH);
     64e:	80 81       	ld	r24, Z
     650:	8f 7e       	andi	r24, 0xEF	; 239
     652:	80 83       	st	Z, r24
	
	//DATA_BUS = 0; //clear DATA_BUS before return
}
     654:	2e 96       	adiw	r28, 0x0e	; 14
     656:	0f b6       	in	r0, 0x3f	; 63
     658:	f8 94       	cli
     65a:	de bf       	out	0x3e, r29	; 62
     65c:	0f be       	out	0x3f, r0	; 63
     65e:	cd bf       	out	0x3d, r28	; 61
     660:	df 91       	pop	r29
     662:	cf 91       	pop	r28
     664:	1f 91       	pop	r17
     666:	0f 91       	pop	r16
     668:	08 95       	ret

0000066a <update_display>:

void update_display(uint16_t number, uint8_t type) {
     66a:	cf 93       	push	r28
	
	static uint8_t place = 0;
	

	
	if (type == DEC) {
     66c:	66 23       	and	r22, r22
     66e:	69 f4       	brne	.+26     	; 0x68a <update_display+0x20>

		
			
		display_dec(number, place);
     670:	c0 91 bc 02 	lds	r28, 0x02BC
     674:	6c 2f       	mov	r22, r28
     676:	0e 94 4c 02 	call	0x498	; 0x498 <display_dec>
		//increment digit display place
		if (place++ == 3) //post increment
     67a:	8c 2f       	mov	r24, r28
     67c:	8f 5f       	subi	r24, 0xFF	; 255
     67e:	80 93 bc 02 	sts	0x02BC, r24
     682:	c3 30       	cpi	r28, 0x03	; 3
     684:	11 f4       	brne	.+4      	; 0x68a <update_display+0x20>
		{
			place = 0;
     686:	10 92 bc 02 	sts	0x02BC, r1
		
		
	}
	
	
     68a:	cf 91       	pop	r28
     68c:	08 95       	ret

0000068e <__vector_10>:
#include "display.h"
#include "clock.h"
#include "assigner.h"
#include "arp.h"

ISR (TIMER0_COMP_vect) { //timer 0 output compare interrupt for tuning
     68e:	1f 92       	push	r1
     690:	0f 92       	push	r0
     692:	0f b6       	in	r0, 0x3f	; 63
     694:	0f 92       	push	r0
     696:	11 24       	eor	r1, r1
     698:	8f 93       	push	r24
     69a:	9f 93       	push	r25
     69c:	ef 93       	push	r30
     69e:	ff 93       	push	r31
	
	OCR0A = period-1; //OCR0A counts n-1 periods - see comment in tune.c about setting OCR0A
     6a0:	80 91 80 03 	lds	r24, 0x0380
     6a4:	81 50       	subi	r24, 0x01	; 1
     6a6:	87 bd       	out	0x27, r24	; 39
	//PORTB ^= (1<<ARP_SYNC_LED); //toggle arp ARP_SYNC LED
	if (period_counter == 0) {
     6a8:	80 91 81 03 	lds	r24, 0x0381
     6ac:	88 23       	and	r24, r24
     6ae:	a1 f4       	brne	.+40     	; 0x6d8 <__vector_10+0x4a>
		count_finished = FALSE;
     6b0:	10 92 7e 03 	sts	0x037E, r1
		no_overflow = TRUE;
     6b4:	81 e0       	ldi	r24, 0x01	; 1
     6b6:	80 93 af 02 	sts	0x02AF, r24
		period_counter = 1; //set period counter to 1
     6ba:	80 93 81 03 	sts	0x0381, r24
		//set up 16 bit timer/counter1		
		TCCR1B |= timer1_clock; //clock /64 to run at 312.5 KHz or /8 to run at 2.5 MHz, dependent on note frequency being measured
     6be:	e1 e8       	ldi	r30, 0x81	; 129
     6c0:	f0 e0       	ldi	r31, 0x00	; 0
     6c2:	80 81       	ld	r24, Z
     6c4:	90 91 7f 03 	lds	r25, 0x037F
     6c8:	89 2b       	or	r24, r25
     6ca:	80 83       	st	Z, r24
		TIMSK1 |= (1<<TOIE1); //enable timer1 overflow interrupt
     6cc:	ef e6       	ldi	r30, 0x6F	; 111
     6ce:	f0 e0       	ldi	r31, 0x00	; 0
     6d0:	80 81       	ld	r24, Z
     6d2:	81 60       	ori	r24, 0x01	; 1
     6d4:	80 83       	st	Z, r24
     6d6:	11 c0       	rjmp	.+34     	; 0x6fa <__vector_10+0x6c>
		
	} else {
		
		osc_count = TCNT1;		
     6d8:	e4 e8       	ldi	r30, 0x84	; 132
     6da:	f0 e0       	ldi	r31, 0x00	; 0
     6dc:	80 81       	ld	r24, Z
     6de:	91 81       	ldd	r25, Z+1	; 0x01
     6e0:	90 93 7d 03 	sts	0x037D, r25
     6e4:	80 93 7c 03 	sts	0x037C, r24
		TCCR1B = 0; //turn off 16 bit timer/counter1
     6e8:	10 92 81 00 	sts	0x0081, r1
		count_finished = TRUE;
     6ec:	81 e0       	ldi	r24, 0x01	; 1
     6ee:	80 93 7e 03 	sts	0x037E, r24
		period_counter = 0;
     6f2:	10 92 81 03 	sts	0x0381, r1
		TCNT1 = 0; //reset timer/counter 1
     6f6:	11 82       	std	Z+1, r1	; 0x01
     6f8:	10 82       	st	Z, r1
	}
	
	
	
	
}
     6fa:	ff 91       	pop	r31
     6fc:	ef 91       	pop	r30
     6fe:	9f 91       	pop	r25
     700:	8f 91       	pop	r24
     702:	0f 90       	pop	r0
     704:	0f be       	out	0x3f, r0	; 63
     706:	0f 90       	pop	r0
     708:	1f 90       	pop	r1
     70a:	18 95       	reti

0000070c <__vector_9>:



ISR (TIMER1_OVF_vect) {
     70c:	1f 92       	push	r1
     70e:	0f 92       	push	r0
     710:	0f b6       	in	r0, 0x3f	; 63
     712:	0f 92       	push	r0
     714:	11 24       	eor	r1, r1
	
	//during frequency counting, if timer1 overflow occurs set overflow flag
	no_overflow = FALSE;
     716:	10 92 af 02 	sts	0x02AF, r1
	//PORTB ^= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED
	
}
     71a:	0f 90       	pop	r0
     71c:	0f be       	out	0x3f, r0	; 63
     71e:	0f 90       	pop	r0
     720:	1f 90       	pop	r1
     722:	18 95       	reti

00000724 <__vector_7>:

ISR (TIMER1_COMPA_vect) { //output compare match for master clock
     724:	1f 92       	push	r1
     726:	0f 92       	push	r0
     728:	0f b6       	in	r0, 0x3f	; 63
     72a:	0f 92       	push	r0
     72c:	11 24       	eor	r1, r1
     72e:	2f 93       	push	r18
     730:	3f 93       	push	r19
     732:	4f 93       	push	r20
     734:	5f 93       	push	r21
     736:	6f 93       	push	r22
     738:	7f 93       	push	r23
     73a:	8f 93       	push	r24
     73c:	9f 93       	push	r25
     73e:	af 93       	push	r26
     740:	bf 93       	push	r27
     742:	ef 93       	push	r30
     744:	ff 93       	push	r31
	//PORTB ^= (1<<ARP_SYNC_LED);
	
	if (system_clock.ppqn_counter == system_clock.divider >> 1) { //50% gate width
     746:	80 91 d0 03 	lds	r24, 0x03D0
     74a:	86 95       	lsr	r24
     74c:	90 91 d1 03 	lds	r25, 0x03D1
     750:	98 17       	cp	r25, r24
     752:	31 f4       	brne	.+12     	; 0x760 <__vector_7+0x3c>
				
		PORTB &= ~ (1<<ARP_SYNC_LED);
     754:	2f 98       	cbi	0x05, 7	; 5
		if (arp.clock_source == INTERNAL_CLOCK) PORTF &= ~(1<<GATE); //if arp is running, turn gate off
     756:	80 91 8e 03 	lds	r24, 0x038E
     75a:	81 30       	cpi	r24, 0x01	; 1
     75c:	09 f4       	brne	.+2      	; 0x760 <__vector_7+0x3c>
     75e:	89 98       	cbi	0x11, 1	; 17
	}	
		
	if (++system_clock.ppqn_counter == system_clock.divider) {
     760:	80 91 d1 03 	lds	r24, 0x03D1
     764:	8f 5f       	subi	r24, 0xFF	; 255
     766:	80 93 d1 03 	sts	0x03D1, r24
     76a:	90 91 d0 03 	lds	r25, 0x03D0
     76e:	89 17       	cp	r24, r25
     770:	71 f4       	brne	.+28     	; 0x78e <__vector_7+0x6a>
		
		system_clock.ppqn_counter = 0;
     772:	10 92 d1 03 	sts	0x03D1, r1
		PORTB |= (1<<ARP_SYNC_LED);
     776:	2f 9a       	sbi	0x05, 7	; 5
		if (arp.clock_source == INTERNAL_CLOCK) {
     778:	80 91 8e 03 	lds	r24, 0x038E
     77c:	81 30       	cpi	r24, 0x01	; 1
     77e:	39 f4       	brne	.+14     	; 0x78e <__vector_7+0x6a>
			
			//step arp note here based on range and note sequence from assigner	

			
			if (gate_buffer) { //if there are still notes in gate buffer
     780:	80 91 b4 02 	lds	r24, 0x02B4
     784:	88 23       	and	r24, r24
     786:	19 f0       	breq	.+6      	; 0x78e <__vector_7+0x6a>
				step_arp_note(); //will need to force inline this function. It will need to be used elsewhere for arp MIDI sync.
     788:	0e 94 33 01 	call	0x266	; 0x266 <step_arp_note>
				PORTF |= (1<<GATE);
     78c:	89 9a       	sbi	0x11, 1	; 17
				
			//if (gate_buffer != 0) PORTF |= (1<<GATE); //if arp is running and there are notes to be played, turn gate ON
		}			
	}
	
     78e:	ff 91       	pop	r31
     790:	ef 91       	pop	r30
     792:	bf 91       	pop	r27
     794:	af 91       	pop	r26
     796:	9f 91       	pop	r25
     798:	8f 91       	pop	r24
     79a:	7f 91       	pop	r23
     79c:	6f 91       	pop	r22
     79e:	5f 91       	pop	r21
     7a0:	4f 91       	pop	r20
     7a2:	3f 91       	pop	r19
     7a4:	2f 91       	pop	r18
     7a6:	0f 90       	pop	r0
     7a8:	0f be       	out	0x3f, r0	; 63
     7aa:	0f 90       	pop	r0
     7ac:	1f 90       	pop	r1
     7ae:	18 95       	reti

000007b0 <real_time_event>:
}

void real_time_event(MidiDevice * device, uint8_t real_time_byte) {
	//PORTB ^= (1<<ARP_SYNC_LED);
	//if (~(current_patch.byte_2 & (1<<LFO_KEY_SYNC) >> 1)) return; //if not in a sync mode, then retrun
	switch (real_time_byte) {
     7b0:	68 3f       	cpi	r22, 0xF8	; 248
     7b2:	19 f0       	breq	.+6      	; 0x7ba <real_time_event+0xa>
     7b4:	6a 3f       	cpi	r22, 0xFA	; 250
     7b6:	c1 f4       	brne	.+48     	; 0x7e8 <real_time_event+0x38>
     7b8:	15 c0       	rjmp	.+42     	; 0x7e4 <real_time_event+0x34>
		
		case MIDI_CLOCK:
		
			if (++midi_clock.ppqn_counter == midi_clock.divider) {
     7ba:	80 91 d7 03 	lds	r24, 0x03D7
     7be:	8f 5f       	subi	r24, 0xFF	; 255
     7c0:	80 93 d7 03 	sts	0x03D7, r24
     7c4:	90 91 d6 03 	lds	r25, 0x03D6
     7c8:	89 17       	cp	r24, r25
     7ca:	71 f4       	brne	.+28     	; 0x7e8 <real_time_event+0x38>
				PORTB |= (1<< LFO_RESET);
     7cc:	2c 9a       	sbi	0x05, 4	; 5
     7ce:	86 e0       	ldi	r24, 0x06	; 6
     7d0:	8a 95       	dec	r24
     7d2:	f1 f7       	brne	.-4      	; 0x7d0 <real_time_event+0x20>
     7d4:	00 c0       	rjmp	.+0      	; 0x7d6 <real_time_event+0x26>
				_delay_us(1); //what is minimum pulse width required for LFO reset?
				
				PORTB ^= (1<<ARP_SYNC_LED);
     7d6:	85 b1       	in	r24, 0x05	; 5
     7d8:	80 58       	subi	r24, 0x80	; 128
     7da:	85 b9       	out	0x05, r24	; 5
				//register clock event - this will do something  - reset LFO or initiate LFO
				midi_clock.ppqn_counter = 0; //reset MIDI ppqn clock	
     7dc:	10 92 d7 03 	sts	0x03D7, r1
				PORTB &= ~(1<< LFO_RESET); //turn off LFO reset pin
     7e0:	2c 98       	cbi	0x05, 4	; 5
     7e2:	08 95       	ret
			
			break;
			
		case MIDI_START:
			
			midi_clock.ppqn_counter = 0;
     7e4:	10 92 d7 03 	sts	0x03D7, r1
     7e8:	08 95       	ret

000007ea <note_off_event>:
		}		
	}
	//PORTB &= ~(1<< LFO_RESET);
	
}
void note_off_event(MidiDevice * device, uint8_t status, uint8_t note, uint8_t velocity) {
     7ea:	84 2f       	mov	r24, r20
	
	remove_note(note);
     7ec:	0e 94 ac 01 	call	0x358	; 0x358 <remove_note>
	gate_buffer--;
     7f0:	80 91 b4 02 	lds	r24, 0x02B4
     7f4:	81 50       	subi	r24, 0x01	; 1
     7f6:	80 93 b4 02 	sts	0x02B4, r24
	if (gate_buffer == 0) PORTF &= ~(1<<GATE);
     7fa:	88 23       	and	r24, r24
     7fc:	09 f4       	brne	.+2      	; 0x800 <note_off_event+0x16>
     7fe:	89 98       	cbi	0x11, 1	; 17
	if (arp.clock_source != OFF) {	//if arp on, update arp sequence
     800:	80 91 8e 03 	lds	r24, 0x038E
     804:	82 30       	cpi	r24, 0x02	; 2
     806:	71 f0       	breq	.+28     	; 0x824 <note_off_event+0x3a>
		//gate_buffer--;
		if (gate_buffer == 0) {
     808:	80 91 b4 02 	lds	r24, 0x02B4
     80c:	88 23       	and	r24, r24
     80e:	41 f4       	brne	.+16     	; 0x820 <note_off_event+0x36>
			arp.current_note = arp.previous_note; //handle last note prevservation for release phase
     810:	80 91 8c 03 	lds	r24, 0x038C
     814:	80 93 8d 03 	sts	0x038D, r24
			arp.step_position = 0;
     818:	10 92 8a 03 	sts	0x038A, r1
			arp.direction = UP;
     81c:	10 92 8b 03 	sts	0x038B, r1
		}			
		update_arp_sequence();
     820:	0e 94 a3 00 	call	0x146	; 0x146 <update_arp_sequence>
     824:	08 95       	ret

00000826 <note_on_event>:





void note_on_event(MidiDevice * device, uint8_t status, uint8_t note, uint8_t velocity) {
     826:	84 2f       	mov	r24, r20
	
	if ((current_patch.byte_2 >> LFO_KEY_SYNC) & 1) {
     828:	90 91 03 03 	lds	r25, 0x0303
     82c:	90 ff       	sbrs	r25, 0
     82e:	06 c0       	rjmp	.+12     	; 0x83c <note_on_event+0x16>
		
		PORTB |= (1<< LFO_RESET);
     830:	2c 9a       	sbi	0x05, 4	; 5
     832:	96 e0       	ldi	r25, 0x06	; 6
     834:	9a 95       	dec	r25
     836:	f1 f7       	brne	.-4      	; 0x834 <note_on_event+0xe>
     838:	00 c0       	rjmp	.+0      	; 0x83a <note_on_event+0x14>
		_delay_us(1); //what is minimum pulse width required for LFO reset?
		PORTB &= ~(1<< LFO_RESET);
     83a:	2c 98       	cbi	0x05, 4	; 5
			
	}		
	
	midi_note_number = note;
     83c:	80 93 be 02 	sts	0x02BE, r24
	if (velocity == 0) { //if velocity is 0 then it is a note off event - just call note off function rather than duplicate code here. arp will need to handle this too
     840:	22 23       	and	r18, r18
     842:	59 f4       	brne	.+22     	; 0x85a <note_on_event+0x34>
		remove_note(note);
     844:	0e 94 ac 01 	call	0x358	; 0x358 <remove_note>
		gate_buffer--;
     848:	80 91 b4 02 	lds	r24, 0x02B4
     84c:	81 50       	subi	r24, 0x01	; 1
     84e:	80 93 b4 02 	sts	0x02B4, r24
		if (gate_buffer == 0) PORTF &= ~(1<<GATE);
     852:	88 23       	and	r24, r24
     854:	91 f4       	brne	.+36     	; 0x87a <note_on_event+0x54>
     856:	89 98       	cbi	0x11, 1	; 17
     858:	08 95       	ret
				
	} else {
		
		new_note(note, velocity);
     85a:	62 2f       	mov	r22, r18
     85c:	0e 94 94 01 	call	0x328	; 0x328 <new_note>
		
		gate_buffer++;
     860:	80 91 b4 02 	lds	r24, 0x02B4
     864:	8f 5f       	subi	r24, 0xFF	; 255
     866:	80 93 b4 02 	sts	0x02B4, r24
		if (arp.clock_source == OFF) { //if arp is off, handle gate
     86a:	80 91 8e 03 	lds	r24, 0x038E
     86e:	82 30       	cpi	r24, 0x02	; 2
     870:	11 f4       	brne	.+4      	; 0x876 <note_on_event+0x50>
			//PORTF &= ~(1<<GATE); //turn gate off to re-trigger envelopes - this isn't nearly long enough
			//retriggering is a feature offered by Kenton Pro-Solo - maybe want it here, but need to decide how long to turn gate off
			//looking at gate of Pro-Solo on oscilloscope might give an idea of how long the Pro-Solo gate is released between retriggers  - checked: Pro-Solo gate-retrigger is 0.3ms
			//could implement this with timers. MIDI Implant is 0.5 ms. Could maybe use Timer1 here to generate 0.3-0.5 ms gate retrigger
			
			PORTF |= (1<<GATE); //if arp is OFF then turn on gate. Otherwise arpeggiator handles GATE
     872:	89 9a       	sbi	0x11, 1	; 17
     874:	08 95       	ret
		} else {
			
			update_arp_sequence();
     876:	0e 94 a3 00 	call	0x146	; 0x146 <update_arp_sequence>
     87a:	08 95       	ret

0000087c <setup_midi_usart>:

void setup_midi_usart(void)
{
    uint16_t ubbr_value = 39; //20MHz/(16*31250 BAUD) - 1
    //write ubbr_value to H and L UBBR1 registers:
    UBRR0L = (unsigned char) ubbr_value;
     87c:	87 e2       	ldi	r24, 0x27	; 39
     87e:	80 93 c4 00 	sts	0x00C4, r24
    UBRR0H = (unsigned char) (ubbr_value >> 8);
     882:	10 92 c5 00 	sts	0x00C5, r1
	
	UCSR0B = (1<<RXEN0)|(1<<TXEN0) | (1<<RXCIE0);
     886:	88 e9       	ldi	r24, 0x98	; 152
     888:	80 93 c1 00 	sts	0x00C1, r24
	//UCSR0C |= (0<<UMSEL0)|(0<<UMSEL01)|(0<<UPM01)|(0<<UPM00)|(0<<USBS0)|(0<<UCSZ02)|(1<<UCSZ01)|(1<<UCSZ00);  	
}
     88c:	08 95       	ret

0000088e <__vector_13>:



ISR (USART_RX_vect) { // USART receive interrupt
     88e:	1f 92       	push	r1
     890:	0f 92       	push	r0
     892:	0f b6       	in	r0, 0x3f	; 63
     894:	0f 92       	push	r0
     896:	11 24       	eor	r1, r1
     898:	2f 93       	push	r18
     89a:	3f 93       	push	r19
     89c:	4f 93       	push	r20
     89e:	5f 93       	push	r21
     8a0:	6f 93       	push	r22
     8a2:	7f 93       	push	r23
     8a4:	8f 93       	push	r24
     8a6:	9f 93       	push	r25
     8a8:	af 93       	push	r26
     8aa:	bf 93       	push	r27
     8ac:	ef 93       	push	r30
     8ae:	ff 93       	push	r31
     8b0:	cf 93       	push	r28
     8b2:	df 93       	push	r29
     8b4:	0f 92       	push	r0
     8b6:	cd b7       	in	r28, 0x3d	; 61
     8b8:	de b7       	in	r29, 0x3e	; 62
	//PORTB ^= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED 
	uint8_t inByte = UDR0;
     8ba:	80 91 c6 00 	lds	r24, 0x00C6
     8be:	89 83       	std	Y+1, r24	; 0x01
	midi_device_input(&midi_device, 1, &inByte); 
     8c0:	8c ed       	ldi	r24, 0xDC	; 220
     8c2:	93 e0       	ldi	r25, 0x03	; 3
     8c4:	61 e0       	ldi	r22, 0x01	; 1
     8c6:	ae 01       	movw	r20, r28
     8c8:	4f 5f       	subi	r20, 0xFF	; 255
     8ca:	5f 4f       	sbci	r21, 0xFF	; 255
     8cc:	0e 94 d6 19 	call	0x33ac	; 0x33ac <midi_device_input>
	//calling a function in an interrupt is inefficient according to AVR C guidelines
	// so this function should maybe be inlined in main loop if inByte is made volatile	
	//***HOWEVER***, xnor-midi example code has this function being called from USART_RX_vect ISR  	
}
     8d0:	0f 90       	pop	r0
     8d2:	df 91       	pop	r29
     8d4:	cf 91       	pop	r28
     8d6:	ff 91       	pop	r31
     8d8:	ef 91       	pop	r30
     8da:	bf 91       	pop	r27
     8dc:	af 91       	pop	r26
     8de:	9f 91       	pop	r25
     8e0:	8f 91       	pop	r24
     8e2:	7f 91       	pop	r23
     8e4:	6f 91       	pop	r22
     8e6:	5f 91       	pop	r21
     8e8:	4f 91       	pop	r20
     8ea:	3f 91       	pop	r19
     8ec:	2f 91       	pop	r18
     8ee:	0f 90       	pop	r0
     8f0:	0f be       	out	0x3f, r0	; 63
     8f2:	0f 90       	pop	r0
     8f4:	1f 90       	pop	r1
     8f6:	18 95       	reti

000008f8 <main>:


int main(void)
{
	//turn off JTAG so all outputs of PORTC can be used
	MCUCR = (1<<JTD);
     8f8:	c0 e8       	ldi	r28, 0x80	; 128
     8fa:	c5 bf       	out	0x35, r28	; 53
	MCUCR = (1<<JTD);
     8fc:	c5 bf       	out	0x35, r28	; 53
		
	//SET PORTB PIN 7 (PB7) as OUTPUT
	DDRB |= (1<<ARP_SYNC_LED);
     8fe:	27 9a       	sbi	0x04, 7	; 4
	
	DDRB |= (1<< LFO_RESET); //set LFO reset as output. This affects LFO rate and TRI balance - needed to trim both rate and balance.
     900:	24 9a       	sbi	0x04, 4	; 4
	//PORTB |= (1<< LFO_RESET);
	
	
	DDRF |= (1<<GATE); //set gate as output
     902:	81 9a       	sbi	0x10, 1	; 16
	//PORTF |= (1<<GATE); //turn gate on for testing
	
	DDRG |= (1<<TUNE_SELECT); //set tune select bit as output on PORTG
     904:	9a 9a       	sbi	0x13, 2	; 19
	PORTG &= ~(1<<TUNE_SELECT); //set tune select bit to 0 to select VCF/VCA output for oscillator tuning
     906:	a2 98       	cbi	0x14, 2	; 20
	//PORTG |= (1<<TUNE_SELECT);
	
	setup_spi(); 
     908:	0e 94 cf 07 	call	0xf9e	; 0xf9e <setup_spi>
	
	DDRH |= (1<<POTMUX_EN0) | (1<<POTMUX_EN1); //set POTMUX_EN pins as outputs
     90c:	a9 ed       	ldi	r26, 0xD9	; 217
     90e:	b0 e0       	ldi	r27, 0x00	; 0
     910:	8c 91       	ld	r24, X
     912:	80 6c       	ori	r24, 0xC0	; 192
     914:	8c 93       	st	X, r24
	POT_MUX |= (1<<POTMUX_EN0) | (1<<POTMUX_EN1); //set POTMUX_EN pins HIGH (active LOW)
     916:	ea ed       	ldi	r30, 0xDA	; 218
     918:	f0 e0       	ldi	r31, 0x00	; 0
     91a:	80 81       	ld	r24, Z
     91c:	80 6c       	ori	r24, 0xC0	; 192
     91e:	80 83       	st	Z, r24
	//POT_MUX |= (1<<POTMUX_EN1);
	
	//set up LED display
	DDRA |= 0b11111111; //set all lines or DATA_BUS to outputs
     920:	81 b1       	in	r24, 0x01	; 1
     922:	8f ef       	ldi	r24, 0xFF	; 255
     924:	81 b9       	out	0x01, r24	; 1
	DATA_BUS |= 0b11111111; //set all DATA_BUS lines to HIGH (cathodes OFF)
     926:	92 b1       	in	r25, 0x02	; 2
     928:	82 b9       	out	0x02, r24	; 2
	DDRH |= (1<<DISP_CATHODE_LATCH) | (1<<DISP_ANODE_LATCH); //set display latches to outputs
     92a:	8c 91       	ld	r24, X
     92c:	80 63       	ori	r24, 0x30	; 48
     92e:	8c 93       	st	X, r24
	DISPLAY_PORT &= ~(1<<DISP_ANODE_LATCH | 1<< DISP_CATHODE_LATCH); //set DISP latches to LOW (inactive)
     930:	80 81       	ld	r24, Z
     932:	8f 7c       	andi	r24, 0xCF	; 207
     934:	80 83       	st	Z, r24
	
	//set up switch port
	DDRF &= ~(1<<BMOD_SW); //set BMOD_SW pin as input
     936:	82 98       	cbi	0x10, 2	; 16
	
	//set up LFO DEMUX LATCH
	DDRJ |= (1<<LFO_SW_LATCH); //set LFO_SW_LATCH pin as output
     938:	ec ed       	ldi	r30, 0xDC	; 220
     93a:	f0 e0       	ldi	r31, 0x00	; 0
     93c:	80 81       	ld	r24, Z
     93e:	80 62       	ori	r24, 0x20	; 32
     940:	80 83       	st	Z, r24
	DATA_BUS = LFO_TRI_ADDR;
     942:	12 b8       	out	0x02, r1	; 2
	LFO_LATCH_PORT |= (1<<LFO_SW_LATCH);
     944:	ed ed       	ldi	r30, 0xDD	; 221
     946:	f0 e0       	ldi	r31, 0x00	; 0
     948:	80 81       	ld	r24, Z
     94a:	80 62       	ori	r24, 0x20	; 32
     94c:	80 83       	st	Z, r24
	LFO_LATCH_PORT &= ~(1<<LFO_SW_LATCH);
     94e:	80 81       	ld	r24, Z
     950:	8f 7d       	andi	r24, 0xDF	; 223
     952:	80 83       	st	Z, r24
	DATA_BUS = 0;
     954:	12 b8       	out	0x02, r1	; 2
	current_patch.byte_2 = (1<<LFO_TRI);
     956:	c0 93 03 03 	sts	0x0303, r28
	
	//setup ADC
    setup_adc();		
     95a:	0e 94 51 00 	call	0xa2	; 0xa2 <setup_adc>
	//setup DAC
	setup_dac();
     95e:	0e 94 33 02 	call	0x466	; 0x466 <setup_dac>
	
	//setup MIDI
	//initialize MIDI device
	midi_device_init(&midi_device);
     962:	cc ed       	ldi	r28, 0xDC	; 220
     964:	d3 e0       	ldi	r29, 0x03	; 3
     966:	ce 01       	movw	r24, r28
     968:	0e 94 a5 19 	call	0x334a	; 0x334a <midi_device_init>
	//register callbacks
	midi_register_noteon_callback(&midi_device, note_on_event);
     96c:	ce 01       	movw	r24, r28
     96e:	63 e1       	ldi	r22, 0x13	; 19
     970:	74 e0       	ldi	r23, 0x04	; 4
     972:	0e 94 6d 19 	call	0x32da	; 0x32da <midi_register_noteon_callback>
	midi_register_noteoff_callback(&midi_device, note_off_event);
     976:	ce 01       	movw	r24, r28
     978:	65 ef       	ldi	r22, 0xF5	; 245
     97a:	73 e0       	ldi	r23, 0x03	; 3
     97c:	0e 94 71 19 	call	0x32e2	; 0x32e2 <midi_register_noteoff_callback>
	midi_register_realtime_callback(&midi_device, real_time_event);
     980:	ce 01       	movw	r24, r28
     982:	68 ed       	ldi	r22, 0xD8	; 216
     984:	73 e0       	ldi	r23, 0x03	; 3
     986:	0e 94 91 19 	call	0x3322	; 0x3322 <midi_register_realtime_callback>
	//setup MIDI USART
	setup_midi_usart();
     98a:	0e 94 3e 04 	call	0x87c	; 0x87c <setup_midi_usart>
	
	update_spi(); //initial update of SPI - will eventual be useful for picking up special power up switch holds
     98e:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <update_spi>
	
	
	current_patch.number = 1;
     992:	81 e0       	ldi	r24, 0x01	; 1
     994:	80 93 07 03 	sts	0x0307, r24
		
	sei(); //enable global interrupts
     998:	78 94       	sei

	
	//eeprom_update_word((uint16_t*)109, test_word);
	//value_to_display = eeprom_read_word((uint16_t*)109);
	
	load_tuning_tables();
     99a:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <load_tuning_tables>
	//value_to_display = vco1_init_cv;
	//set_one_volt_per_octave(); //overwrite tuning tables with 1V/octave data for calibration purposes
	//set initial switch states
	//switch_states.byte0 = (1<<VCO1_PULSE_SW) | (1<<VCO2_PULSE_SW);
	//current_patch.byte_4 = (1<<VCO1_32F) | (1<<VCO2_32F);
	load_patch(1);
     99e:	81 e0       	ldi	r24, 0x01	; 1
     9a0:	0e 94 6d 0a 	call	0x14da	; 0x14da <load_patch>
	
	setup_system_clock();
     9a4:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <setup_system_clock>
	//update_clock_speed(244);
	system_clock.divider = 24;
     9a8:	88 e1       	ldi	r24, 0x18	; 24
     9aa:	80 93 d0 03 	sts	0x03D0, r24
	arp.step_position = 0; //initialize step position
     9ae:	10 92 8a 03 	sts	0x038A, r1

	while(1)
	{	
		
		
		midi_device_process(&midi_device); //this needs to be called 'frequently' in order for MIDI to work
     9b2:	8e 01       	movw	r16, r28
		if (switch_timer++ == 5)
		{
			switch_timer = 0;
			switch_press = 0; //reset global switch press flag
			//read switches directly connected to MCU	
			switch_states.byte2 ^= read_switch_port(); //toggle switch states
     9b4:	0f 2e       	mov	r0, r31
     9b6:	f4 e8       	ldi	r31, 0x84	; 132
     9b8:	ef 2e       	mov	r14, r31
     9ba:	f3 e0       	ldi	r31, 0x03	; 3
     9bc:	ff 2e       	mov	r15, r31
     9be:	f0 2d       	mov	r31, r0
			switch_states.byte2 |= (current_patch.mode == MANUAL) << PROG_MANUAL_SW; //if MANUAL then don't toggle switch
     9c0:	0f 2e       	mov	r0, r31
     9c2:	fb e0       	ldi	r31, 0x0B	; 11
     9c4:	cf 2e       	mov	r12, r31
     9c6:	f3 e0       	ldi	r31, 0x03	; 3
     9c8:	df 2e       	mov	r13, r31
     9ca:	f0 2d       	mov	r31, r0
			//switch_states.byte2 |= (current_patch.mode == WRITE) << PROG_WRITE_SW; //if WRITE then don't toggle switch
			update_spi();
			if (switch_press) { 
				update_patch();
				if (current_patch.mode == MEMORY) current_patch.mode = EDIT; //change mode to EDIT if non-program switch is detected
     9cc:	bb 24       	eor	r11, r11
     9ce:	68 94       	set
     9d0:	b1 f8       	bld	r11, 1
		{
			switch_timer = 0;
			switch_press = 0; //reset global switch press flag
			//read switches directly connected to MCU	
			switch_states.byte2 ^= read_switch_port(); //toggle switch states
			switch_states.byte2 |= (current_patch.mode == MANUAL) << PROG_MANUAL_SW; //if MANUAL then don't toggle switch
     9d2:	d0 e8       	ldi	r29, 0x80	; 128

	while(1)
	{	
		
		
		midi_device_process(&midi_device); //this needs to be called 'frequently' in order for MIDI to work
     9d4:	c8 01       	movw	r24, r16
     9d6:	0e 94 00 1c 	call	0x3800	; 0x3800 <midi_device_process>
		//value_to_display = vco1_init_cv;
		//PORTB |= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED
		update_display(value_to_display, DEC); //maybe move this into switch_timer loop. Probably doesn't need to be updated this frequently
     9da:	80 91 fd 01 	lds	r24, 0x01FD
     9de:	90 91 fe 01 	lds	r25, 0x01FE
     9e2:	60 e0       	ldi	r22, 0x00	; 0
     9e4:	0e 94 35 03 	call	0x66a	; 0x66a <update_display>
		//PORTB &= ~(1<<ARP_SYNC_LED);
		 	
		//scan_pots_and_update_control_voltages();
		scan_pots();
     9e8:	0e 94 23 05 	call	0xa46	; 0xa46 <scan_pots>
		update_control_voltages();
     9ec:	0e 94 b0 05 	call	0xb60	; 0xb60 <update_control_voltages>
			
		//do SPI read/write every 5 loops. This is quite clumsy. Not sure yet how to better implement it
		if (switch_timer++ == 5)
     9f0:	80 91 bd 02 	lds	r24, 0x02BD
     9f4:	98 2f       	mov	r25, r24
     9f6:	9f 5f       	subi	r25, 0xFF	; 255
     9f8:	90 93 bd 02 	sts	0x02BD, r25
     9fc:	85 30       	cpi	r24, 0x05	; 5
     9fe:	51 f7       	brne	.-44     	; 0x9d4 <main+0xdc>
		{
			switch_timer = 0;
     a00:	10 92 bd 02 	sts	0x02BD, r1
			switch_press = 0; //reset global switch press flag
     a04:	10 92 c5 02 	sts	0x02C5, r1
			//read switches directly connected to MCU	
			switch_states.byte2 ^= read_switch_port(); //toggle switch states
     a08:	f7 01       	movw	r30, r14
     a0a:	c0 81       	ld	r28, Z
     a0c:	0e 94 87 16 	call	0x2d0e	; 0x2d0e <read_switch_port>
     a10:	8c 27       	eor	r24, r28
			switch_states.byte2 |= (current_patch.mode == MANUAL) << PROG_MANUAL_SW; //if MANUAL then don't toggle switch
     a12:	f6 01       	movw	r30, r12
     a14:	90 81       	ld	r25, Z
     a16:	91 30       	cpi	r25, 0x01	; 1
     a18:	11 f4       	brne	.+4      	; 0xa1e <main+0x126>
     a1a:	cd 2f       	mov	r28, r29
     a1c:	01 c0       	rjmp	.+2      	; 0xa20 <main+0x128>
     a1e:	c0 e0       	ldi	r28, 0x00	; 0
     a20:	c8 2b       	or	r28, r24
     a22:	f7 01       	movw	r30, r14
     a24:	c0 83       	st	Z, r28
			//switch_states.byte2 |= (current_patch.mode == WRITE) << PROG_WRITE_SW; //if WRITE then don't toggle switch
			update_spi();
     a26:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <update_spi>
			if (switch_press) { 
     a2a:	80 91 c5 02 	lds	r24, 0x02C5
     a2e:	88 23       	and	r24, r24
     a30:	39 f0       	breq	.+14     	; 0xa40 <main+0x148>
				update_patch();
     a32:	0e 94 4e 0f 	call	0x1e9c	; 0x1e9c <update_patch>
				if (current_patch.mode == MEMORY) current_patch.mode = EDIT; //change mode to EDIT if non-program switch is detected
     a36:	f6 01       	movw	r30, r12
     a38:	80 81       	ld	r24, Z
     a3a:	88 23       	and	r24, r24
     a3c:	09 f4       	brne	.+2      	; 0xa40 <main+0x148>
     a3e:	b0 82       	st	Z, r11
			}				
			update_patch_programmer();	
     a40:	0e 94 db 0f 	call	0x1fb6	; 0x1fb6 <update_patch_programmer>
     a44:	c7 cf       	rjmp	.-114    	; 0x9d4 <main+0xdc>

00000a46 <scan_pots>:

uint8_t midi_note_number = 0; //store incoming MIDI note here for pitch lookup table

volatile uint16_t value_to_display = 79; //global to hold display value
	
void scan_pots(void) { //should probably move this to adc.c
     a46:	bf 92       	push	r11
     a48:	cf 92       	push	r12
     a4a:	df 92       	push	r13
     a4c:	ef 92       	push	r14
     a4e:	ff 92       	push	r15
     a50:	0f 93       	push	r16
     a52:	1f 93       	push	r17
     a54:	cf 93       	push	r28
     a56:	df 93       	push	r29
     a58:	c0 e0       	ldi	r28, 0x00	; 0
     a5a:	d1 e0       	ldi	r29, 0x01	; 1
     a5c:	06 ec       	ldi	r16, 0xC6	; 198
     a5e:	12 e0       	ldi	r17, 0x02	; 2
     a60:	0f 2e       	mov	r0, r31
     a62:	fc e3       	ldi	r31, 0x3C	; 60
     a64:	cf 2e       	mov	r12, r31
     a66:	dd 24       	eor	r13, r13
     a68:	f0 2d       	mov	r31, r0
     a6a:	cc 0e       	add	r12, r28
     a6c:	dd 1e       	adc	r13, r29
		//what happens next depends on mode. if pot is locked, then the value of the pot is not written to the current patch unless it is different from the pot's locked value
		
		uint8_t delta_pot = pot_id[i]->locked_value - ((pot_id[i]->value >> 2)); //quick and dirty subtraction, where unsigned delta pot will overflow if value > locked value. see below
		
		
		if ((current_patch.mode == MANUAL) || (pot_id[i]->locked == 0)) { //if in manual mode or pot is already unlocked
     a6e:	0f 2e       	mov	r0, r31
     a70:	fb e0       	ldi	r31, 0x0B	; 11
     a72:	ef 2e       	mov	r14, r31
     a74:	f3 e0       	ldi	r31, 0x03	; 3
     a76:	ff 2e       	mov	r15, r31
     a78:	f0 2d       	mov	r31, r0
		//} else if ((((pot_id[i]->value >> 2) != pot_id[i]->locked_value)) && (pot_id[i]->locked == 1)) { //need to figure out delta threshold here. 10 bit to 8 bit resolution should be enough???
			
		} else if (((delta_pot > 2) && (delta_pot < 253)) && (pot_id[i]->locked == 1)) { //set a threshold of +/- 3 for pot change  		  		  	
			*(patch_value + i) = pot_id[i]->value;
			pot_id[i]->locked = 0; //unlock pot
			current_patch.mode = EDIT;
     a7a:	bb 24       	eor	r11, r11
     a7c:	68 94       	set
     a7e:	b1 f8       	bld	r11, 1
	
	uint16_t *patch_value = &(current_patch.vco2_mix); //pointer to first element of current_patch struct
	//scan 30 parameter pots
	for (int i = 0; i <= NUM_POTS; i++) {
		
		adc_value = read_pot(pot_id[i]);
     a80:	88 81       	ld	r24, Y
     a82:	99 81       	ldd	r25, Y+1	; 0x01
     a84:	0e 94 64 00 	call	0xc8	; 0xc8 <read_pot>
     a88:	90 93 c0 02 	sts	0x02C0, r25
     a8c:	80 93 bf 02 	sts	0x02BF, r24
		adc_change = adc_value - pot_id[i]->value;
     a90:	e8 81       	ld	r30, Y
     a92:	f9 81       	ldd	r31, Y+1	; 0x01
     a94:	40 81       	ld	r20, Z
     a96:	21 81       	ldd	r18, Z+1	; 0x01
     a98:	52 2f       	mov	r21, r18
     a9a:	53 70       	andi	r21, 0x03	; 3
     a9c:	84 1b       	sub	r24, r20
     a9e:	95 0b       	sbc	r25, r21
		pot_id[i]->value = pot_id[i]->value + (adc_change >> 2);
     aa0:	95 95       	asr	r25
     aa2:	87 95       	ror	r24
     aa4:	95 95       	asr	r25
     aa6:	87 95       	ror	r24
     aa8:	84 0f       	add	r24, r20
     aaa:	95 1f       	adc	r25, r21
     aac:	80 83       	st	Z, r24
     aae:	89 2f       	mov	r24, r25
     ab0:	83 70       	andi	r24, 0x03	; 3
     ab2:	2c 7f       	andi	r18, 0xFC	; 252
     ab4:	28 2b       	or	r18, r24
     ab6:	21 83       	std	Z+1, r18	; 0x01
		//what happens next depends on mode. if pot is locked, then the value of the pot is not written to the current patch unless it is different from the pot's locked value
		
		uint8_t delta_pot = pot_id[i]->locked_value - ((pot_id[i]->value >> 2)); //quick and dirty subtraction, where unsigned delta pot will overflow if value > locked value. see below
     ab8:	e9 91       	ld	r30, Y+
     aba:	f9 91       	ld	r31, Y+
     abc:	92 81       	ldd	r25, Z+2	; 0x02
     abe:	20 81       	ld	r18, Z
     ac0:	81 81       	ldd	r24, Z+1	; 0x01
     ac2:	38 2f       	mov	r19, r24
     ac4:	33 70       	andi	r19, 0x03	; 3
		
		
		if ((current_patch.mode == MANUAL) || (pot_id[i]->locked == 0)) { //if in manual mode or pot is already unlocked
     ac6:	d7 01       	movw	r26, r14
     ac8:	8c 91       	ld	r24, X
     aca:	81 30       	cpi	r24, 0x01	; 1
     acc:	19 f0       	breq	.+6      	; 0xad4 <scan_pots+0x8e>
     ace:	83 81       	ldd	r24, Z+3	; 0x03
     ad0:	88 23       	and	r24, r24
     ad2:	24 f0       	brlt	.+8      	; 0xadc <scan_pots+0x96>
			
			*(patch_value + i) = pot_id[i]->value; //this is a hacked way of indexing the patch structure. Depends on order of pots in pot array being the same as order of parameters in patch struct
     ad4:	f8 01       	movw	r30, r16
     ad6:	31 83       	std	Z+1, r19	; 0x01
     ad8:	20 83       	st	Z, r18
     ada:	14 c0       	rjmp	.+40     	; 0xb04 <scan_pots+0xbe>
		adc_value = read_pot(pot_id[i]);
		adc_change = adc_value - pot_id[i]->value;
		pot_id[i]->value = pot_id[i]->value + (adc_change >> 2);
		//what happens next depends on mode. if pot is locked, then the value of the pot is not written to the current patch unless it is different from the pot's locked value
		
		uint8_t delta_pot = pot_id[i]->locked_value - ((pot_id[i]->value >> 2)); //quick and dirty subtraction, where unsigned delta pot will overflow if value > locked value. see below
     adc:	49 2f       	mov	r20, r25
     ade:	43 50       	subi	r20, 0x03	; 3
     ae0:	c9 01       	movw	r24, r18
     ae2:	95 95       	asr	r25
     ae4:	87 95       	ror	r24
     ae6:	95 95       	asr	r25
     ae8:	87 95       	ror	r24
			
			*(patch_value + i) = pot_id[i]->value; //this is a hacked way of indexing the patch structure. Depends on order of pots in pot array being the same as order of parameters in patch struct
			
		//} else if ((((pot_id[i]->value >> 2) != pot_id[i]->locked_value)) && (pot_id[i]->locked == 1)) { //need to figure out delta threshold here. 10 bit to 8 bit resolution should be enough???
			
		} else if (((delta_pot > 2) && (delta_pot < 253)) && (pot_id[i]->locked == 1)) { //set a threshold of +/- 3 for pot change  		  		  	
     aea:	94 2f       	mov	r25, r20
     aec:	98 1b       	sub	r25, r24
     aee:	9a 3f       	cpi	r25, 0xFA	; 250
     af0:	48 f4       	brcc	.+18     	; 0xb04 <scan_pots+0xbe>
			*(patch_value + i) = pot_id[i]->value;
     af2:	d8 01       	movw	r26, r16
     af4:	11 96       	adiw	r26, 0x01	; 1
     af6:	3c 93       	st	X, r19
     af8:	2e 93       	st	-X, r18
			pot_id[i]->locked = 0; //unlock pot
     afa:	83 81       	ldd	r24, Z+3	; 0x03
     afc:	8f 77       	andi	r24, 0x7F	; 127
     afe:	83 83       	std	Z+3, r24	; 0x03
			current_patch.mode = EDIT;
     b00:	f7 01       	movw	r30, r14
     b02:	b0 82       	st	Z, r11
     b04:	0e 5f       	subi	r16, 0xFE	; 254
     b06:	1f 4f       	sbci	r17, 0xFF	; 255

	int adc_change = 0;
	
	uint16_t *patch_value = &(current_patch.vco2_mix); //pointer to first element of current_patch struct
	//scan 30 parameter pots
	for (int i = 0; i <= NUM_POTS; i++) {
     b08:	cc 15       	cp	r28, r12
     b0a:	dd 05       	cpc	r29, r13
     b0c:	09 f0       	breq	.+2      	; 0xb10 <scan_pots+0xca>
     b0e:	b8 cf       	rjmp	.-144    	; 0xa80 <scan_pots+0x3a>
		
	}
	
	
	//scan volume pot
	adc_value = read_pot(&volume_pot);
     b10:	8c e7       	ldi	r24, 0x7C	; 124
     b12:	91 e0       	ldi	r25, 0x01	; 1
     b14:	0e 94 64 00 	call	0xc8	; 0xc8 <read_pot>
     b18:	90 93 c0 02 	sts	0x02C0, r25
     b1c:	80 93 bf 02 	sts	0x02BF, r24
	adc_change = adc_value - volume_pot.value;
     b20:	20 91 7c 01 	lds	r18, 0x017C
     b24:	40 91 7d 01 	lds	r20, 0x017D
     b28:	34 2f       	mov	r19, r20
     b2a:	33 70       	andi	r19, 0x03	; 3
     b2c:	82 1b       	sub	r24, r18
     b2e:	93 0b       	sbc	r25, r19
	volume_pot.value = volume_pot.value + (adc_change >> 2);
     b30:	95 95       	asr	r25
     b32:	87 95       	ror	r24
     b34:	95 95       	asr	r25
     b36:	87 95       	ror	r24
     b38:	28 0f       	add	r18, r24
     b3a:	39 1f       	adc	r19, r25
     b3c:	20 93 7c 01 	sts	0x017C, r18
     b40:	83 2f       	mov	r24, r19
     b42:	83 70       	andi	r24, 0x03	; 3
     b44:	4c 7f       	andi	r20, 0xFC	; 252
     b46:	48 2b       	or	r20, r24
     b48:	40 93 7d 01 	sts	0x017D, r20
	
}
     b4c:	df 91       	pop	r29
     b4e:	cf 91       	pop	r28
     b50:	1f 91       	pop	r17
     b52:	0f 91       	pop	r16
     b54:	ff 90       	pop	r15
     b56:	ef 90       	pop	r14
     b58:	df 90       	pop	r13
     b5a:	cf 90       	pop	r12
     b5c:	bf 90       	pop	r11
     b5e:	08 95       	ret

00000b60 <update_control_voltages>:

void update_control_voltages(void) { //keep everything updated in the current order of pots. Probably arbitrary, but try to minimize change from old CV update to new CV update
     b60:	cf 93       	push	r28
     b62:	df 93       	push	r29
	
	set_control_voltage(&vco2_mix_cv, (current_patch.vco2_mix << 4));
     b64:	60 91 c6 02 	lds	r22, 0x02C6
     b68:	70 91 c7 02 	lds	r23, 0x02C7
     b6c:	62 95       	swap	r22
     b6e:	72 95       	swap	r23
     b70:	70 7f       	andi	r23, 0xF0	; 240
     b72:	76 27       	eor	r23, r22
     b74:	60 7f       	andi	r22, 0xF0	; 240
     b76:	76 27       	eor	r23, r22
     b78:	84 ee       	ldi	r24, 0xE4	; 228
     b7a:	91 e0       	ldi	r25, 0x01	; 1
     b7c:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&vco1_mix_cv, (current_patch.vco1_mix << 4));
     b80:	60 91 c8 02 	lds	r22, 0x02C8
     b84:	70 91 c9 02 	lds	r23, 0x02C9
     b88:	62 95       	swap	r22
     b8a:	72 95       	swap	r23
     b8c:	70 7f       	andi	r23, 0xF0	; 240
     b8e:	76 27       	eor	r23, r22
     b90:	60 7f       	andi	r22, 0xF0	; 240
     b92:	76 27       	eor	r23, r22
     b94:	83 ee       	ldi	r24, 0xE3	; 227
     b96:	91 e0       	ldi	r25, 0x01	; 1
     b98:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&pitch_eg2_cv, (current_patch.pitch_eg2 << 3)); //1/4 scale
     b9c:	60 91 ca 02 	lds	r22, 0x02CA
     ba0:	70 91 cb 02 	lds	r23, 0x02CB
     ba4:	66 0f       	add	r22, r22
     ba6:	77 1f       	adc	r23, r23
     ba8:	66 0f       	add	r22, r22
     baa:	77 1f       	adc	r23, r23
     bac:	66 0f       	add	r22, r22
     bae:	77 1f       	adc	r23, r23
     bb0:	82 ee       	ldi	r24, 0xE2	; 226
     bb2:	91 e0       	ldi	r25, 0x01	; 1
     bb4:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&pitch_vco2_cv, (current_patch.pitch_vco2 << 4));
     bb8:	60 91 cc 02 	lds	r22, 0x02CC
     bbc:	70 91 cd 02 	lds	r23, 0x02CD
     bc0:	62 95       	swap	r22
     bc2:	72 95       	swap	r23
     bc4:	70 7f       	andi	r23, 0xF0	; 240
     bc6:	76 27       	eor	r23, r22
     bc8:	60 7f       	andi	r22, 0xF0	; 240
     bca:	76 27       	eor	r23, r22
     bcc:	87 eb       	ldi	r24, 0xB7	; 183
     bce:	92 e0       	ldi	r25, 0x02	; 2
     bd0:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&pitch_lfo_cv, (current_patch.pitch_lfo << 3)); // 1/4 scale
     bd4:	60 91 ce 02 	lds	r22, 0x02CE
     bd8:	70 91 cf 02 	lds	r23, 0x02CF
     bdc:	66 0f       	add	r22, r22
     bde:	77 1f       	adc	r23, r23
     be0:	66 0f       	add	r22, r22
     be2:	77 1f       	adc	r23, r23
     be4:	66 0f       	add	r22, r22
     be6:	77 1f       	adc	r23, r23
     be8:	81 ee       	ldi	r24, 0xE1	; 225
     bea:	91 e0       	ldi	r25, 0x01	; 1
     bec:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&pwm_lfo_cv, (current_patch.pwm_lfo) << 4);
     bf0:	60 91 d0 02 	lds	r22, 0x02D0
     bf4:	70 91 d1 02 	lds	r23, 0x02D1
     bf8:	62 95       	swap	r22
     bfa:	72 95       	swap	r23
     bfc:	70 7f       	andi	r23, 0xF0	; 240
     bfe:	76 27       	eor	r23, r22
     c00:	60 7f       	andi	r22, 0xF0	; 240
     c02:	76 27       	eor	r23, r22
     c04:	80 ee       	ldi	r24, 0xE0	; 224
     c06:	91 e0       	ldi	r25, 0x01	; 1
     c08:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&pwm_eg2_cv, (current_patch.pwm_eg2) << 4);
     c0c:	60 91 d2 02 	lds	r22, 0x02D2
     c10:	70 91 d3 02 	lds	r23, 0x02D3
     c14:	62 95       	swap	r22
     c16:	72 95       	swap	r23
     c18:	70 7f       	andi	r23, 0xF0	; 240
     c1a:	76 27       	eor	r23, r22
     c1c:	60 7f       	andi	r22, 0xF0	; 240
     c1e:	76 27       	eor	r23, r22
     c20:	8f ed       	ldi	r24, 0xDF	; 223
     c22:	91 e0       	ldi	r25, 0x01	; 1
     c24:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&vco1_pw_cv, (current_patch.vco1_pw) << 4);
     c28:	60 91 d4 02 	lds	r22, 0x02D4
     c2c:	70 91 d5 02 	lds	r23, 0x02D5
     c30:	62 95       	swap	r22
     c32:	72 95       	swap	r23
     c34:	70 7f       	andi	r23, 0xF0	; 240
     c36:	76 27       	eor	r23, r22
     c38:	60 7f       	andi	r22, 0xF0	; 240
     c3a:	76 27       	eor	r23, r22
     c3c:	8e ed       	ldi	r24, 0xDE	; 222
     c3e:	91 e0       	ldi	r25, 0x01	; 1
     c40:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	
	int tune_offset = 512 - current_patch.tune; //master tune offset
     c44:	80 91 d8 02 	lds	r24, 0x02D8
     c48:	90 91 d9 02 	lds	r25, 0x02D9
     c4c:	c0 e0       	ldi	r28, 0x00	; 0
     c4e:	d2 e0       	ldi	r29, 0x02	; 2
     c50:	c8 1b       	sub	r28, r24
     c52:	d9 0b       	sbc	r29, r25
	
	int fine_offset = 512 - current_patch.fine; //fine tune offset
     c54:	60 91 77 03 	lds	r22, 0x0377
     c58:	70 91 78 03 	lds	r23, 0x0378
     c5c:	60 50       	subi	r22, 0x00	; 0
     c5e:	7e 4f       	sbci	r23, 0xFE	; 254
	
	set_control_voltage(&fine_cv, vco2_init_cv + tune_offset + fine_offset);
     c60:	80 91 d6 02 	lds	r24, 0x02D6
     c64:	90 91 d7 02 	lds	r25, 0x02D7
     c68:	68 1b       	sub	r22, r24
     c6a:	79 0b       	sbc	r23, r25
     c6c:	6c 0f       	add	r22, r28
     c6e:	7d 1f       	adc	r23, r29
     c70:	8d ed       	ldi	r24, 0xDD	; 221
     c72:	91 e0       	ldi	r25, 0x01	; 1
     c74:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&tune_cv, vco1_init_cv + tune_offset);
     c78:	60 91 79 03 	lds	r22, 0x0379
     c7c:	70 91 7a 03 	lds	r23, 0x037A
     c80:	6c 0f       	add	r22, r28
     c82:	7d 1f       	adc	r23, r29
     c84:	8c ed       	ldi	r24, 0xDC	; 220
     c86:	91 e0       	ldi	r25, 0x01	; 1
     c88:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	
	set_control_voltage(&lfo_rate_cv, (current_patch.lfo_rate) << 4);
     c8c:	60 91 da 02 	lds	r22, 0x02DA
     c90:	70 91 db 02 	lds	r23, 0x02DB
     c94:	62 95       	swap	r22
     c96:	72 95       	swap	r23
     c98:	70 7f       	andi	r23, 0xF0	; 240
     c9a:	76 27       	eor	r23, r22
     c9c:	60 7f       	andi	r22, 0xF0	; 240
     c9e:	76 27       	eor	r23, r22
     ca0:	8b ed       	ldi	r24, 0xDB	; 219
     ca2:	91 e0       	ldi	r25, 0x01	; 1
     ca4:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&glide_cv, (current_patch.glide) << 4);
     ca8:	60 91 de 02 	lds	r22, 0x02DE
     cac:	70 91 df 02 	lds	r23, 0x02DF
     cb0:	62 95       	swap	r22
     cb2:	72 95       	swap	r23
     cb4:	70 7f       	andi	r23, 0xF0	; 240
     cb6:	76 27       	eor	r23, r22
     cb8:	60 7f       	andi	r22, 0xF0	; 240
     cba:	76 27       	eor	r23, r22
     cbc:	8a ed       	ldi	r24, 0xDA	; 218
     cbe:	91 e0       	ldi	r25, 0x01	; 1
     cc0:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&amp_lfo_cv, (current_patch.amp_lfo) << 4);
     cc4:	60 91 e0 02 	lds	r22, 0x02E0
     cc8:	70 91 e1 02 	lds	r23, 0x02E1
     ccc:	62 95       	swap	r22
     cce:	72 95       	swap	r23
     cd0:	70 7f       	andi	r23, 0xF0	; 240
     cd2:	76 27       	eor	r23, r22
     cd4:	60 7f       	andi	r22, 0xF0	; 240
     cd6:	76 27       	eor	r23, r22
     cd8:	89 ed       	ldi	r24, 0xD9	; 217
     cda:	91 e0       	ldi	r25, 0x01	; 1
     cdc:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&volume_cv, (volume_pot.value << 4)); //volume level not a patch parameter
     ce0:	60 91 7c 01 	lds	r22, 0x017C
     ce4:	80 91 7d 01 	lds	r24, 0x017D
     ce8:	78 2f       	mov	r23, r24
     cea:	73 70       	andi	r23, 0x03	; 3
     cec:	62 95       	swap	r22
     cee:	72 95       	swap	r23
     cf0:	70 7f       	andi	r23, 0xF0	; 240
     cf2:	76 27       	eor	r23, r22
     cf4:	60 7f       	andi	r22, 0xF0	; 240
     cf6:	76 27       	eor	r23, r22
     cf8:	88 ed       	ldi	r24, 0xD8	; 216
     cfa:	91 e0       	ldi	r25, 0x01	; 1
     cfc:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&vco2_pw_cv, (current_patch.vco2_pw) << 4);	
     d00:	60 91 e2 02 	lds	r22, 0x02E2
     d04:	70 91 e3 02 	lds	r23, 0x02E3
     d08:	62 95       	swap	r22
     d0a:	72 95       	swap	r23
     d0c:	70 7f       	andi	r23, 0xF0	; 240
     d0e:	76 27       	eor	r23, r22
     d10:	60 7f       	andi	r22, 0xF0	; 240
     d12:	76 27       	eor	r23, r22
     d14:	87 ed       	ldi	r24, 0xD7	; 215
     d16:	91 e0       	ldi	r25, 0x01	; 1
     d18:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	
	set_control_voltage(&fil_eg2_cv, (current_patch.fil_eg2) << 4);
     d1c:	60 91 e4 02 	lds	r22, 0x02E4
     d20:	70 91 e5 02 	lds	r23, 0x02E5
     d24:	62 95       	swap	r22
     d26:	72 95       	swap	r23
     d28:	70 7f       	andi	r23, 0xF0	; 240
     d2a:	76 27       	eor	r23, r22
     d2c:	60 7f       	andi	r22, 0xF0	; 240
     d2e:	76 27       	eor	r23, r22
     d30:	86 ed       	ldi	r24, 0xD6	; 214
     d32:	91 e0       	ldi	r25, 0x01	; 1
     d34:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&res_cv, (current_patch.res) << 4);
     d38:	60 91 e6 02 	lds	r22, 0x02E6
     d3c:	70 91 e7 02 	lds	r23, 0x02E7
     d40:	62 95       	swap	r22
     d42:	72 95       	swap	r23
     d44:	70 7f       	andi	r23, 0xF0	; 240
     d46:	76 27       	eor	r23, r22
     d48:	60 7f       	andi	r22, 0xF0	; 240
     d4a:	76 27       	eor	r23, r22
     d4c:	85 ed       	ldi	r24, 0xD5	; 213
     d4e:	91 e0       	ldi	r25, 0x01	; 1
     d50:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	
	//this next bit should be separated out, but leave it here for now while testing decoupled adc/dac read/write
	uint8_t note = get_current_note(); //get current note from assigner
     d54:	0e 94 8a 01 	call	0x314	; 0x314 <get_current_note>
     d58:	c8 2f       	mov	r28, r24
	if (note < 8) note = 8; //init_cv gives VCO range from MIDI note 8 to MIDI note 127+. If you don't set notes <8 to 8 then you get array out of bounds problems. Should find a better way to handle this.
     d5a:	88 30       	cpi	r24, 0x08	; 8
     d5c:	08 f4       	brcc	.+2      	; 0xd60 <update_control_voltages+0x200>
     d5e:	c8 e0       	ldi	r28, 0x08	; 8
	//value_to_display = current_patch.number + 100*(arp.sequence[arp.step_position].note); //100*note;
	//value_to_display = arp.sequence[arp.step_position].note;
	//uint8_t arp_note = arp.sequence[arp.step_position].note;
	//if (arp_note == EMPTY) arp_note = 0;
	value_to_display = current_patch.number + 100*arp.step_position;
     d60:	60 91 07 03 	lds	r22, 0x0307
     d64:	40 91 8a 03 	lds	r20, 0x038A
     d68:	50 e0       	ldi	r21, 0x00	; 0
     d6a:	24 e6       	ldi	r18, 0x64	; 100
     d6c:	30 e0       	ldi	r19, 0x00	; 0
     d6e:	42 9f       	mul	r20, r18
     d70:	c0 01       	movw	r24, r0
     d72:	43 9f       	mul	r20, r19
     d74:	90 0d       	add	r25, r0
     d76:	52 9f       	mul	r21, r18
     d78:	90 0d       	add	r25, r0
     d7a:	11 24       	eor	r1, r1
     d7c:	86 0f       	add	r24, r22
     d7e:	91 1d       	adc	r25, r1
     d80:	90 93 fe 01 	sts	0x01FE, r25
     d84:	80 93 fd 01 	sts	0x01FD, r24
		
	uint16_t interpolated_pitch_cv = 0; //holder for interpolated pitch values
	
	interpolated_pitch_cv = interpolate_pitch_cv(note-8, filter_pitch_table); //subtract 8 from note because filter pitch is calibrated so that 0V is E, 20.6 Hz
     d88:	8c 2f       	mov	r24, r28
     d8a:	88 50       	subi	r24, 0x08	; 8
     d8c:	63 e1       	ldi	r22, 0x13	; 19
     d8e:	73 e0       	ldi	r23, 0x03	; 3
     d90:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <interpolate_pitch_cv>
	//note that product of key_track and interpolated_pitch_cv needs to be cast as uint32t - otherwise product is evaluated incorrectly
	uint16_t divided_pitch_cv = ((uint32_t)current_patch.key_track*interpolated_pitch_cv) >> 10;
     d94:	bc 01       	movw	r22, r24
     d96:	80 e0       	ldi	r24, 0x00	; 0
     d98:	90 e0       	ldi	r25, 0x00	; 0
     d9a:	20 91 ea 02 	lds	r18, 0x02EA
     d9e:	30 91 eb 02 	lds	r19, 0x02EB
     da2:	40 e0       	ldi	r20, 0x00	; 0
     da4:	50 e0       	ldi	r21, 0x00	; 0
     da6:	0e 94 da 1d 	call	0x3bb4	; 0x3bb4 <__mulsi3>
     daa:	dc 01       	movw	r26, r24
     dac:	cb 01       	movw	r24, r22
     dae:	07 2e       	mov	r0, r23
     db0:	7a e0       	ldi	r23, 0x0A	; 10
     db2:	b6 95       	lsr	r27
     db4:	a7 95       	ror	r26
     db6:	97 95       	ror	r25
     db8:	87 95       	ror	r24
     dba:	7a 95       	dec	r23
     dbc:	d1 f7       	brne	.-12     	; 0xdb2 <update_control_voltages+0x252>
     dbe:	70 2d       	mov	r23, r0
	uint16_t filter_cutoff_cv = divided_pitch_cv + (current_patch.cutoff << 4); //filter cutoff CV is the sum of filter cutoff pot and key track amount.
     dc0:	60 91 e8 02 	lds	r22, 0x02E8
     dc4:	70 91 e9 02 	lds	r23, 0x02E9
     dc8:	62 95       	swap	r22
     dca:	72 95       	swap	r23
     dcc:	70 7f       	andi	r23, 0xF0	; 240
     dce:	76 27       	eor	r23, r22
     dd0:	60 7f       	andi	r22, 0xF0	; 240
     dd2:	76 27       	eor	r23, r22
     dd4:	86 0f       	add	r24, r22
     dd6:	97 1f       	adc	r25, r23
	if (filter_cutoff_cv > MAX) filter_cutoff_cv = MAX; //make sure there is no overflow/wrap by capping max
	set_control_voltage(&cutoff_cv, filter_cutoff_cv);	
     dd8:	bc 01       	movw	r22, r24
     dda:	80 e4       	ldi	r24, 0x40	; 64
     ddc:	60 30       	cpi	r22, 0x00	; 0
     dde:	78 07       	cpc	r23, r24
     de0:	10 f0       	brcs	.+4      	; 0xde6 <update_control_voltages+0x286>
     de2:	6f ef       	ldi	r22, 0xFF	; 255
     de4:	7f e3       	ldi	r23, 0x3F	; 63
     de6:	84 ed       	ldi	r24, 0xD4	; 212
     de8:	91 e0       	ldi	r25, 0x01	; 1
     dea:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	
	set_control_voltage(&fil_vco2_cv, (current_patch.fil_vco2) << 4);
     dee:	60 91 ec 02 	lds	r22, 0x02EC
     df2:	70 91 ed 02 	lds	r23, 0x02ED
     df6:	62 95       	swap	r22
     df8:	72 95       	swap	r23
     dfa:	70 7f       	andi	r23, 0xF0	; 240
     dfc:	76 27       	eor	r23, r22
     dfe:	60 7f       	andi	r22, 0xF0	; 240
     e00:	76 27       	eor	r23, r22
     e02:	82 ed       	ldi	r24, 0xD2	; 210
     e04:	91 e0       	ldi	r25, 0x01	; 1
     e06:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&fil_lfo_cv, (current_patch.fil_lfo) << 4);
     e0a:	60 91 ee 02 	lds	r22, 0x02EE
     e0e:	70 91 ef 02 	lds	r23, 0x02EF
     e12:	62 95       	swap	r22
     e14:	72 95       	swap	r23
     e16:	70 7f       	andi	r23, 0xF0	; 240
     e18:	76 27       	eor	r23, r22
     e1a:	60 7f       	andi	r22, 0xF0	; 240
     e1c:	76 27       	eor	r23, r22
     e1e:	81 ed       	ldi	r24, 0xD1	; 209
     e20:	91 e0       	ldi	r25, 0x01	; 1
     e22:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&noise_mix_cv, (current_patch.noise_mix) << 4);
     e26:	60 91 f0 02 	lds	r22, 0x02F0
     e2a:	70 91 f1 02 	lds	r23, 0x02F1
     e2e:	62 95       	swap	r22
     e30:	72 95       	swap	r23
     e32:	70 7f       	andi	r23, 0xF0	; 240
     e34:	76 27       	eor	r23, r22
     e36:	60 7f       	andi	r22, 0xF0	; 240
     e38:	76 27       	eor	r23, r22
     e3a:	80 ed       	ldi	r24, 0xD0	; 208
     e3c:	91 e0       	ldi	r25, 0x01	; 1
     e3e:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&attack_2_cv, (current_patch.attack_2) << 4);
     e42:	60 91 f2 02 	lds	r22, 0x02F2
     e46:	70 91 f3 02 	lds	r23, 0x02F3
     e4a:	62 95       	swap	r22
     e4c:	72 95       	swap	r23
     e4e:	70 7f       	andi	r23, 0xF0	; 240
     e50:	76 27       	eor	r23, r22
     e52:	60 7f       	andi	r22, 0xF0	; 240
     e54:	76 27       	eor	r23, r22
     e56:	8f ec       	ldi	r24, 0xCF	; 207
     e58:	91 e0       	ldi	r25, 0x01	; 1
     e5a:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&attack_1_cv, (current_patch.attack_1) << 4);
     e5e:	60 91 f4 02 	lds	r22, 0x02F4
     e62:	70 91 f5 02 	lds	r23, 0x02F5
     e66:	62 95       	swap	r22
     e68:	72 95       	swap	r23
     e6a:	70 7f       	andi	r23, 0xF0	; 240
     e6c:	76 27       	eor	r23, r22
     e6e:	60 7f       	andi	r22, 0xF0	; 240
     e70:	76 27       	eor	r23, r22
     e72:	8e ec       	ldi	r24, 0xCE	; 206
     e74:	91 e0       	ldi	r25, 0x01	; 1
     e76:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&decay_2_cv, (current_patch.decay_2) << 4);
     e7a:	60 91 f6 02 	lds	r22, 0x02F6
     e7e:	70 91 f7 02 	lds	r23, 0x02F7
     e82:	62 95       	swap	r22
     e84:	72 95       	swap	r23
     e86:	70 7f       	andi	r23, 0xF0	; 240
     e88:	76 27       	eor	r23, r22
     e8a:	60 7f       	andi	r22, 0xF0	; 240
     e8c:	76 27       	eor	r23, r22
     e8e:	8d ec       	ldi	r24, 0xCD	; 205
     e90:	91 e0       	ldi	r25, 0x01	; 1
     e92:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&decay_1_cv, (current_patch.decay_1) << 4);
     e96:	60 91 f8 02 	lds	r22, 0x02F8
     e9a:	70 91 f9 02 	lds	r23, 0x02F9
     e9e:	62 95       	swap	r22
     ea0:	72 95       	swap	r23
     ea2:	70 7f       	andi	r23, 0xF0	; 240
     ea4:	76 27       	eor	r23, r22
     ea6:	60 7f       	andi	r22, 0xF0	; 240
     ea8:	76 27       	eor	r23, r22
     eaa:	8c ec       	ldi	r24, 0xCC	; 204
     eac:	91 e0       	ldi	r25, 0x01	; 1
     eae:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&sustain_1_cv, (current_patch.sustain_1) << 4);
     eb2:	60 91 fc 02 	lds	r22, 0x02FC
     eb6:	70 91 fd 02 	lds	r23, 0x02FD
     eba:	62 95       	swap	r22
     ebc:	72 95       	swap	r23
     ebe:	70 7f       	andi	r23, 0xF0	; 240
     ec0:	76 27       	eor	r23, r22
     ec2:	60 7f       	andi	r22, 0xF0	; 240
     ec4:	76 27       	eor	r23, r22
     ec6:	8a ec       	ldi	r24, 0xCA	; 202
     ec8:	91 e0       	ldi	r25, 0x01	; 1
     eca:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&sustain_2_cv, (current_patch.sustain_2) << 4);
     ece:	60 91 fa 02 	lds	r22, 0x02FA
     ed2:	70 91 fb 02 	lds	r23, 0x02FB
     ed6:	62 95       	swap	r22
     ed8:	72 95       	swap	r23
     eda:	70 7f       	andi	r23, 0xF0	; 240
     edc:	76 27       	eor	r23, r22
     ede:	60 7f       	andi	r22, 0xF0	; 240
     ee0:	76 27       	eor	r23, r22
     ee2:	8b ec       	ldi	r24, 0xCB	; 203
     ee4:	91 e0       	ldi	r25, 0x01	; 1
     ee6:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&release_1_cv, (current_patch.release_1) << 4);
     eea:	60 91 00 03 	lds	r22, 0x0300
     eee:	70 91 01 03 	lds	r23, 0x0301
     ef2:	62 95       	swap	r22
     ef4:	72 95       	swap	r23
     ef6:	70 7f       	andi	r23, 0xF0	; 240
     ef8:	76 27       	eor	r23, r22
     efa:	60 7f       	andi	r22, 0xF0	; 240
     efc:	76 27       	eor	r23, r22
     efe:	88 ec       	ldi	r24, 0xC8	; 200
     f00:	91 e0       	ldi	r25, 0x01	; 1
     f02:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&release_2_cv, (current_patch.release_2) << 4);
     f06:	60 91 fe 02 	lds	r22, 0x02FE
     f0a:	70 91 ff 02 	lds	r23, 0x02FF
     f0e:	62 95       	swap	r22
     f10:	72 95       	swap	r23
     f12:	70 7f       	andi	r23, 0xF0	; 240
     f14:	76 27       	eor	r23, r22
     f16:	60 7f       	andi	r22, 0xF0	; 240
     f18:	76 27       	eor	r23, r22
     f1a:	89 ec       	ldi	r24, 0xC9	; 201
     f1c:	91 e0       	ldi	r25, 0x01	; 1
     f1e:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>

	//set VCO1 and VCO2 pitch control voltages. Remember, set_control_voltage() is expecting a pointer to a control_voltage struct
	//that contains the control_voltage multiplexer channel and the multiplexer address
	

	uint8_t vco1_note = transpose_note(note, VCO1); //transpose
     f22:	8c 2f       	mov	r24, r28
     f24:	6f e0       	ldi	r22, 0x0F	; 15
     f26:	0e 94 4d 0d 	call	0x1a9a	; 0x1a9a <transpose_note>

	interpolated_pitch_cv = interpolate_pitch_cv(vco1_note, vco1_pitch_table);
     f2a:	65 e5       	ldi	r22, 0x55	; 85
     f2c:	73 e0       	ldi	r23, 0x03	; 3
     f2e:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <interpolate_pitch_cv>
     f32:	bc 01       	movw	r22, r24
	
	//value_to_display = interpolated_pitch_cv;
	
	set_control_voltage(&vco1_pitch_cv, interpolated_pitch_cv);
     f34:	86 ee       	ldi	r24, 0xE6	; 230
     f36:	91 e0       	ldi	r25, 0x01	; 1
     f38:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	
	uint8_t vco2_note = transpose_note(note, VCO2);
     f3c:	8c 2f       	mov	r24, r28
     f3e:	60 ef       	ldi	r22, 0xF0	; 240
     f40:	0e 94 4d 0d 	call	0x1a9a	; 0x1a9a <transpose_note>
	
	interpolated_pitch_cv = interpolate_pitch_cv(vco2_note, vco2_pitch_table);
     f44:	63 e3       	ldi	r22, 0x33	; 51
     f46:	73 e0       	ldi	r23, 0x03	; 3
     f48:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <interpolate_pitch_cv>
     f4c:	bc 01       	movw	r22, r24
	
	set_control_voltage(&vco2_pitch_cv, interpolated_pitch_cv);
     f4e:	85 ee       	ldi	r24, 0xE5	; 229
     f50:	91 e0       	ldi	r25, 0x01	; 1
     f52:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
		
	DAC_CTRL &= ~(1<<DAC_RS); //reset DAC
     f56:	a1 98       	cbi	0x14, 1	; 20
	DAC_CTRL |= (1<<DAC_RS);
     f58:	a1 9a       	sbi	0x14, 1	; 20
	
	system_clock.rate = (1023 - arp_rate_pot.value) + 244;    
     f5a:	20 91 88 01 	lds	r18, 0x0188
     f5e:	80 91 89 01 	lds	r24, 0x0189
     f62:	38 2f       	mov	r19, r24
     f64:	33 70       	andi	r19, 0x03	; 3
     f66:	83 ef       	ldi	r24, 0xF3	; 243
     f68:	94 e0       	ldi	r25, 0x04	; 4
     f6a:	82 1b       	sub	r24, r18
     f6c:	93 0b       	sbc	r25, r19
     f6e:	90 93 d3 03 	sts	0x03D3, r25
     f72:	80 93 d2 03 	sts	0x03D2, r24
	
	if (system_clock.rate != system_clock.previous_rate) {
     f76:	20 91 d4 03 	lds	r18, 0x03D4
     f7a:	30 91 d5 03 	lds	r19, 0x03D5
     f7e:	82 17       	cp	r24, r18
     f80:	93 07       	cpc	r25, r19
     f82:	11 f0       	breq	.+4      	; 0xf88 <update_control_voltages+0x428>
		
		update_clock_rate(system_clock.rate);
     f84:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <update_clock_rate>
	
	}
	
	system_clock.previous_rate = system_clock.rate;
     f88:	80 91 d2 03 	lds	r24, 0x03D2
     f8c:	90 91 d3 03 	lds	r25, 0x03D3
     f90:	90 93 d5 03 	sts	0x03D5, r25
     f94:	80 93 d4 03 	sts	0x03D4, r24
	
}			
     f98:	df 91       	pop	r29
     f9a:	cf 91       	pop	r28
     f9c:	08 95       	ret

00000f9e <setup_spi>:
void setup_spi(void) {
	
		//SET SPI_DATA_OUT and SPI_CLK and SPI_SW_LATCH pins as outputs
		//also set Slave Select (PB0) as output just to ensure it doesn't interfere with SPI communication (currently floating)
		//ACTUALLY, Slave Select ***MUST*** be set as output. Leaving it floating without setting its data direction bit breaks SPI!
		DDRB |= (SPI_DATA_OUT | SPI_CLK | SPI_SW_LATCH |(1<<PB0));
     f9e:	84 b1       	in	r24, 0x04	; 4
     fa0:	87 62       	ori	r24, 0x27	; 39
     fa2:	84 b9       	out	0x04, r24	; 4
		
		//SET SPI_EN and LED_LATCH and VCO_SW_LATCH and EG2_POL pins as outputs
		DDRJ |= (SPI_EN | LED_LATCH | (1<<VCO_SW_LATCH) | (1<<EG2_POL));
     fa4:	ec ed       	ldi	r30, 0xDC	; 220
     fa6:	f0 e0       	ldi	r31, 0x00	; 0
     fa8:	80 81       	ld	r24, Z
     faa:	8c 65       	ori	r24, 0x5C	; 92
     fac:	80 83       	st	Z, r24
		
		//SET SPI_DATA_OUT and SPI_CLK and SPI_SW_LATCH outputs LOW
		SPI_PORT &= ~(SPI_DATA_OUT | SPI_CLK | SPI_SW_LATCH);
     fae:	85 b1       	in	r24, 0x05	; 5
     fb0:	89 7d       	andi	r24, 0xD9	; 217
     fb2:	85 b9       	out	0x05, r24	; 5
		
		//SET SPI_EN LOW (active) and LED_LATCH LOW (active)
		SPI_LATCH_PORT &= ~(SPI_EN | LED_LATCH);
     fb4:	ed ed       	ldi	r30, 0xDD	; 221
     fb6:	f0 e0       	ldi	r31, 0x00	; 0
     fb8:	80 81       	ld	r24, Z
     fba:	83 7f       	andi	r24, 0xF3	; 243
     fbc:	80 83       	st	Z, r24
		
		//SET UP SPI
		SPCR = (1<<SPE) | (1<<MSTR); //Start SPI as MASTER
     fbe:	80 e5       	ldi	r24, 0x50	; 80
     fc0:	8c bd       	out	0x2c, r24	; 44
		
		//Pull LED_LATCH LOW
		SPI_LATCH_PORT &= ~LED_LATCH;
     fc2:	80 81       	ld	r24, Z
     fc4:	87 7f       	andi	r24, 0xF7	; 247
     fc6:	80 83       	st	Z, r24
		
		
		//Toggle LED_LATCH to shift data to 74HC595 shift register outputs
		
		SPI_LATCH_PORT &= ~LED_LATCH;
     fc8:	80 81       	ld	r24, Z
     fca:	87 7f       	andi	r24, 0xF7	; 247
     fcc:	80 83       	st	Z, r24
		SPI_LATCH_PORT |= LED_LATCH;
     fce:	80 81       	ld	r24, Z
     fd0:	88 60       	ori	r24, 0x08	; 8
     fd2:	80 83       	st	Z, r24
		
		//set EG2 POL
		EG2_POL_PORT &= ~(1 << EG2_POL); //0 for normal, 1 for inverted
     fd4:	80 81       	ld	r24, Z
     fd6:	8f 7e       	andi	r24, 0xEF	; 239
     fd8:	80 83       	st	Z, r24
	
}
     fda:	08 95       	ret

00000fdc <spi_shift_byte>:

uint8_t spi_shift_byte(uint8_t byte) { //shifts out byte for LED data and simultaneously reads switch data
	
	SPDR = byte;
     fdc:	8e bd       	out	0x2e, r24	; 46
	while (!(SPSR & (1<<SPIF)));
     fde:	0d b4       	in	r0, 0x2d	; 45
     fe0:	07 fe       	sbrs	r0, 7
     fe2:	fd cf       	rjmp	.-6      	; 0xfde <spi_shift_byte+0x2>
	return SPDR;
     fe4:	8e b5       	in	r24, 0x2e	; 46
	
}
     fe6:	08 95       	ret

00000fe8 <update_spi>:

void update_spi(void) {
	
			SPI_PORT |= SPI_SW_LATCH;
     fe8:	2d 9a       	sbi	0x05, 5	; 5
			
			//SHIFT 5th BYTE				
			//Read SPDR for switch data shifted in from 74XX165 U14 and write LED data to LED latch 5
			spi_sw_byte0_current_state = spi_shift_byte(current_patch.byte_5);
     fea:	80 91 06 03 	lds	r24, 0x0306
     fee:	0e 94 ee 07 	call	0xfdc	; 0xfdc <spi_shift_byte>
			switch_press |= spi_sw_byte0_current_state; //set switch press global flag
     ff2:	90 91 c5 02 	lds	r25, 0x02C5
     ff6:	98 2b       	or	r25, r24
     ff8:	90 93 c5 02 	sts	0x02C5, r25
			spi_sw_byte0_current_state ^= spi_sw_byte0_previous_state;
     ffc:	20 91 c3 02 	lds	r18, 0x02C3
    1000:	98 2f       	mov	r25, r24
    1002:	92 27       	eor	r25, r18
			spi_sw_byte0_previous_state ^= spi_sw_byte0_current_state;
    1004:	89 2f       	mov	r24, r25
    1006:	82 27       	eor	r24, r18
    1008:	80 93 c3 02 	sts	0x02C3, r24
			spi_sw_byte0_current_state &= spi_sw_byte0_previous_state;
    100c:	89 23       	and	r24, r25
    100e:	80 93 c4 02 	sts	0x02C4, r24
			
			//toggle switch state		
			switch_states.byte0 ^= spi_sw_byte0_current_state; //Omar's solution.
    1012:	90 91 82 03 	lds	r25, 0x0382
    1016:	89 27       	eor	r24, r25
    1018:	80 93 82 03 	sts	0x0382, r24
			//Now read SPDR for switch data shifted in from 74XX165 (U9)
			//uint8_t spi_data = (1<<VCO2_32F | 1<<VCO1_32F); //turn on 32' octave LEDs as default 
			
			uint8_t spi_data = current_patch.byte_4;
					
			spi_sw_byte1_current_state = spi_shift_byte(spi_data);
    101c:	80 91 05 03 	lds	r24, 0x0305
    1020:	0e 94 ee 07 	call	0xfdc	; 0xfdc <spi_shift_byte>
			switch_press |= spi_sw_byte1_current_state;
    1024:	90 91 c5 02 	lds	r25, 0x02C5
    1028:	98 2b       	or	r25, r24
    102a:	90 93 c5 02 	sts	0x02C5, r25
			spi_sw_byte1_current_state ^= spi_sw_byte1_previous_state;
    102e:	20 91 c1 02 	lds	r18, 0x02C1
    1032:	98 2f       	mov	r25, r24
    1034:	92 27       	eor	r25, r18
			spi_sw_byte1_previous_state ^= spi_sw_byte1_current_state;
    1036:	89 2f       	mov	r24, r25
    1038:	82 27       	eor	r24, r18
    103a:	80 93 c1 02 	sts	0x02C1, r24
			spi_sw_byte1_current_state &= spi_sw_byte1_previous_state;
    103e:	89 23       	and	r24, r25
    1040:	80 93 c2 02 	sts	0x02C2, r24
			
			//toggle switch state
			switch_states.byte1 ^= spi_sw_byte1_current_state; //Omar's solution.			
    1044:	90 91 83 03 	lds	r25, 0x0383
    1048:	89 27       	eor	r24, r25
    104a:	80 93 83 03 	sts	0x0383, r24
							
			//SHIFT 3th BYTE
			spi_shift_byte(current_patch.byte_3);
    104e:	80 91 04 03 	lds	r24, 0x0304
    1052:	0e 94 ee 07 	call	0xfdc	; 0xfdc <spi_shift_byte>

			//SHIFT 2th BYTE
			spi_shift_byte(current_patch.byte_2);
    1056:	80 91 03 03 	lds	r24, 0x0303
    105a:	0e 94 ee 07 	call	0xfdc	; 0xfdc <spi_shift_byte>
			
			//SHIFT 1st BYTE	//eventually need to parse this elsewhere		
			spi_data =	//((switch_states.byte1 >> ARP_MODE_SW) & 1) << ARP_MODE | 
    105e:	80 91 0b 03 	lds	r24, 0x030B
    1062:	83 30       	cpi	r24, 0x03	; 3
    1064:	11 f4       	brne	.+4      	; 0x106a <update_spi+0x82>
    1066:	20 e8       	ldi	r18, 0x80	; 128
    1068:	01 c0       	rjmp	.+2      	; 0x106c <update_spi+0x84>
    106a:	20 e0       	ldi	r18, 0x00	; 0
						//((switch_states.byte2 >> PROG_WRITE_SW) & 1) << PROG_WRITE | 
						((current_patch.mode == WRITE) << PROG_WRITE) | //hack to light PROG WRITE LED only when in WRITE mode
						//((switch_states.byte2 >> EG2_INV_SW) &1 ) << EG2_INV |
						((switch_states.byte2 >> PROG_MANUAL_SW &1) << PROG_MANUAL) |
    106c:	80 91 84 03 	lds	r24, 0x0384
    1070:	88 1f       	adc	r24, r24
    1072:	88 27       	eor	r24, r24
    1074:	88 1f       	adc	r24, r24
    1076:	82 95       	swap	r24
    1078:	88 0f       	add	r24, r24
    107a:	88 0f       	add	r24, r24
    107c:	80 7c       	andi	r24, 0xC0	; 192

			//SHIFT 2th BYTE
			spi_shift_byte(current_patch.byte_2);
			
			//SHIFT 1st BYTE	//eventually need to parse this elsewhere		
			spi_data =	//((switch_states.byte1 >> ARP_MODE_SW) & 1) << ARP_MODE | 
    107e:	90 91 02 03 	lds	r25, 0x0302
    1082:	89 2b       	or	r24, r25
						((current_patch.mode == WRITE) << PROG_WRITE) | //hack to light PROG WRITE LED only when in WRITE mode
						//((switch_states.byte2 >> EG2_INV_SW) &1 ) << EG2_INV |
						((switch_states.byte2 >> PROG_MANUAL_SW &1) << PROG_MANUAL) |
						((current_patch.byte_1)); 			
			//Wait for SPI shift to complete
			spi_shift_byte(spi_data);
    1084:	82 2b       	or	r24, r18
    1086:	0e 94 ee 07 	call	0xfdc	; 0xfdc <spi_shift_byte>
			
			//Toggle LED_LATCH to shift data to 74HC595 shift register outputs
			
			SPI_LATCH_PORT &= ~LED_LATCH;
    108a:	ed ed       	ldi	r30, 0xDD	; 221
    108c:	f0 e0       	ldi	r31, 0x00	; 0
    108e:	80 81       	ld	r24, Z
    1090:	87 7f       	andi	r24, 0xF7	; 247
    1092:	80 83       	st	Z, r24
			SPI_LATCH_PORT |= LED_LATCH;
    1094:	80 81       	ld	r24, Z
    1096:	88 60       	ori	r24, 0x08	; 8
    1098:	80 83       	st	Z, r24
			
			//clear SPI_SW_LATCH
			SPI_PORT &= ~SPI_SW_LATCH;
    109a:	2d 98       	cbi	0x05, 5	; 5
			
			

	
    109c:	08 95       	ret

0000109e <lock_pots>:
		LFO_PULSE_ADDR,
		LFO_RNDM_ADDR
	};
	

void lock_pots(void) { //run this every time new patch is loaded to lock pots and store locked values
    109e:	a0 e0       	ldi	r26, 0x00	; 0
    10a0:	b1 e0       	ldi	r27, 0x01	; 1
    10a2:	9d 01       	movw	r18, r26
    10a4:	24 5c       	subi	r18, 0xC4	; 196
    10a6:	3f 4f       	sbci	r19, 0xFF	; 255

for (int i = 0; i <= NUM_POTS; i++) {
	
	pot_id[i]->locked_value = (pot_id[i]->value) >> 2;
    10a8:	ed 91       	ld	r30, X+
    10aa:	fc 91       	ld	r31, X
    10ac:	11 97       	sbiw	r26, 0x01	; 1
    10ae:	80 81       	ld	r24, Z
    10b0:	41 81       	ldd	r20, Z+1	; 0x01
    10b2:	94 2f       	mov	r25, r20
    10b4:	93 70       	andi	r25, 0x03	; 3
    10b6:	95 95       	asr	r25
    10b8:	87 95       	ror	r24
    10ba:	95 95       	asr	r25
    10bc:	87 95       	ror	r24
    10be:	82 83       	std	Z+2, r24	; 0x02
	pot_id[i]->locked = 1;
    10c0:	ed 91       	ld	r30, X+
    10c2:	fd 91       	ld	r31, X+
    10c4:	83 81       	ldd	r24, Z+3	; 0x03
    10c6:	80 68       	ori	r24, 0x80	; 128
    10c8:	83 83       	std	Z+3, r24	; 0x03
	};
	

void lock_pots(void) { //run this every time new patch is loaded to lock pots and store locked values

for (int i = 0; i <= NUM_POTS; i++) {
    10ca:	a2 17       	cp	r26, r18
    10cc:	b3 07       	cpc	r27, r19
    10ce:	61 f7       	brne	.-40     	; 0x10a8 <lock_pots+0xa>
	pot_id[i]->locked_value = (pot_id[i]->value) >> 2;
	pot_id[i]->locked = 1;
	
}

}
    10d0:	08 95       	ret

000010d2 <unlock_pots>:

void unlock_pots(void) {
    10d2:	e0 e0       	ldi	r30, 0x00	; 0
    10d4:	f1 e0       	ldi	r31, 0x01	; 1
    10d6:	cf 01       	movw	r24, r30
    10d8:	cc 96       	adiw	r24, 0x3c	; 60
	
	for (int i = 0; i <= NUM_POTS; i++) {
		
		pot_id[i]->locked = 0;
    10da:	a1 91       	ld	r26, Z+
    10dc:	b1 91       	ld	r27, Z+
    10de:	13 96       	adiw	r26, 0x03	; 3
    10e0:	2c 91       	ld	r18, X
    10e2:	13 97       	sbiw	r26, 0x03	; 3
    10e4:	2f 77       	andi	r18, 0x7F	; 127
    10e6:	13 96       	adiw	r26, 0x03	; 3
    10e8:	2c 93       	st	X, r18
    10ea:	13 97       	sbiw	r26, 0x03	; 3

}

void unlock_pots(void) {
	
	for (int i = 0; i <= NUM_POTS; i++) {
    10ec:	e8 17       	cp	r30, r24
    10ee:	f9 07       	cpc	r31, r25
    10f0:	a1 f7       	brne	.-24     	; 0x10da <unlock_pots+0x8>
		
		pot_id[i]->locked = 0;
		
	}
	
}			
    10f2:	08 95       	ret

000010f4 <save_patch>:
	
	
void save_patch(uint8_t patch_number) {
    10f4:	1f 93       	push	r17
    10f6:	cf 93       	push	r28
    10f8:	df 93       	push	r29
    10fa:	cd b7       	in	r28, 0x3d	; 61
    10fc:	de b7       	in	r29, 0x3e	; 62
    10fe:	ab 97       	sbiw	r28, 0x2b	; 43
    1100:	0f b6       	in	r0, 0x3f	; 63
    1102:	f8 94       	cli
    1104:	de bf       	out	0x3e, r29	; 62
    1106:	0f be       	out	0x3f, r0	; 63
    1108:	cd bf       	out	0x3d, r28	; 61
    110a:	18 2f       	mov	r17, r24
	
	struct eeprom_patch patch_to_save;
	//because of bit fields in eeprom patch struct, a temporary eeprom patch needs to be filled with current_patch values and then saved to memory.
	
	patch_to_save.vco2_pw = current_patch.vco2_pw;
    110c:	e2 ee       	ldi	r30, 0xE2	; 226
    110e:	f2 e0       	ldi	r31, 0x02	; 2
    1110:	20 91 e2 02 	lds	r18, 0x02E2
    1114:	82 2f       	mov	r24, r18
    1116:	82 95       	swap	r24
    1118:	80 7f       	andi	r24, 0xF0	; 240
    111a:	22 95       	swap	r18
    111c:	2f 70       	andi	r18, 0x0F	; 15
    111e:	90 91 e3 02 	lds	r25, 0x02E3
    1122:	93 70       	andi	r25, 0x03	; 3
    1124:	92 95       	swap	r25
    1126:	90 7f       	andi	r25, 0xF0	; 240
	patch_to_save.vco1_mix = current_patch.vco1_mix;
    1128:	df 01       	movw	r26, r30
    112a:	5a 97       	sbiw	r26, 0x1a	; 26
    112c:	3c 91       	ld	r19, X
    112e:	53 2f       	mov	r21, r19
    1130:	55 0f       	add	r21, r21
    1132:	55 0f       	add	r21, r21
    1134:	4a 81       	ldd	r20, Y+2	; 0x02
    1136:	43 70       	andi	r20, 0x03	; 3
    1138:	45 2b       	or	r20, r21
    113a:	4a 83       	std	Y+2, r20	; 0x02
    113c:	63 2f       	mov	r22, r19
    113e:	62 95       	swap	r22
    1140:	66 95       	lsr	r22
    1142:	66 95       	lsr	r22
    1144:	63 70       	andi	r22, 0x03	; 3
    1146:	11 96       	adiw	r26, 0x01	; 1
    1148:	4c 91       	ld	r20, X
    114a:	43 70       	andi	r20, 0x03	; 3
    114c:	44 0f       	add	r20, r20
    114e:	44 0f       	add	r20, r20
	patch_to_save.pitch_eg2 = current_patch.pitch_eg2;
    1150:	df 01       	movw	r26, r30
    1152:	58 97       	sbiw	r26, 0x18	; 24
    1154:	3c 91       	ld	r19, X
    1156:	53 2f       	mov	r21, r19
    1158:	52 95       	swap	r21
    115a:	50 7f       	andi	r21, 0xF0	; 240
    115c:	46 2b       	or	r20, r22
    115e:	45 2b       	or	r20, r21
    1160:	4b 83       	std	Y+3, r20	; 0x03
    1162:	63 2f       	mov	r22, r19
    1164:	62 95       	swap	r22
    1166:	6f 70       	andi	r22, 0x0F	; 15
    1168:	11 96       	adiw	r26, 0x01	; 1
    116a:	4c 91       	ld	r20, X
    116c:	43 70       	andi	r20, 0x03	; 3
    116e:	42 95       	swap	r20
    1170:	40 7f       	andi	r20, 0xF0	; 240
	patch_to_save.pitch_vco2 = current_patch.pitch_vco2;
    1172:	df 01       	movw	r26, r30
    1174:	56 97       	sbiw	r26, 0x16	; 22
    1176:	3c 91       	ld	r19, X
    1178:	53 2f       	mov	r21, r19
    117a:	52 95       	swap	r21
    117c:	55 0f       	add	r21, r21
    117e:	55 0f       	add	r21, r21
    1180:	50 7c       	andi	r21, 0xC0	; 192
    1182:	46 2b       	or	r20, r22
    1184:	45 2b       	or	r20, r21
    1186:	4c 83       	std	Y+4, r20	; 0x04
    1188:	11 96       	adiw	r26, 0x01	; 1
    118a:	4c 91       	ld	r20, X
    118c:	42 95       	swap	r20
    118e:	44 0f       	add	r20, r20
    1190:	44 0f       	add	r20, r20
    1192:	40 7c       	andi	r20, 0xC0	; 192
    1194:	36 95       	lsr	r19
    1196:	36 95       	lsr	r19
    1198:	34 2b       	or	r19, r20
    119a:	3d 83       	std	Y+5, r19	; 0x05
	patch_to_save.pitch_lfo = current_patch.pitch_lfo;
    119c:	df 01       	movw	r26, r30
    119e:	54 97       	sbiw	r26, 0x14	; 20
    11a0:	3c 91       	ld	r19, X
    11a2:	3e 83       	std	Y+6, r19	; 0x06
    11a4:	11 96       	adiw	r26, 0x01	; 1
    11a6:	4c 91       	ld	r20, X
	patch_to_save.pwm_lfo = current_patch.pwm_lfo;
    11a8:	df 01       	movw	r26, r30
    11aa:	52 97       	sbiw	r26, 0x12	; 18
    11ac:	3c 91       	ld	r19, X
    11ae:	53 2f       	mov	r21, r19
    11b0:	55 0f       	add	r21, r21
    11b2:	55 0f       	add	r21, r21
    11b4:	43 70       	andi	r20, 0x03	; 3
    11b6:	45 2b       	or	r20, r21
    11b8:	4f 83       	std	Y+7, r20	; 0x07
    11ba:	63 2f       	mov	r22, r19
    11bc:	62 95       	swap	r22
    11be:	66 95       	lsr	r22
    11c0:	66 95       	lsr	r22
    11c2:	63 70       	andi	r22, 0x03	; 3
    11c4:	11 96       	adiw	r26, 0x01	; 1
    11c6:	4c 91       	ld	r20, X
    11c8:	43 70       	andi	r20, 0x03	; 3
    11ca:	44 0f       	add	r20, r20
    11cc:	44 0f       	add	r20, r20
	patch_to_save.pwm_eg2 = current_patch.pwm_eg2;
    11ce:	df 01       	movw	r26, r30
    11d0:	50 97       	sbiw	r26, 0x10	; 16
    11d2:	3c 91       	ld	r19, X
    11d4:	53 2f       	mov	r21, r19
    11d6:	52 95       	swap	r21
    11d8:	50 7f       	andi	r21, 0xF0	; 240
    11da:	46 2b       	or	r20, r22
    11dc:	45 2b       	or	r20, r21
    11de:	48 87       	std	Y+8, r20	; 0x08
    11e0:	63 2f       	mov	r22, r19
    11e2:	62 95       	swap	r22
    11e4:	6f 70       	andi	r22, 0x0F	; 15
    11e6:	11 96       	adiw	r26, 0x01	; 1
    11e8:	4c 91       	ld	r20, X
    11ea:	43 70       	andi	r20, 0x03	; 3
    11ec:	42 95       	swap	r20
    11ee:	40 7f       	andi	r20, 0xF0	; 240
	patch_to_save.vco1_pw = current_patch.vco1_pw;
    11f0:	df 01       	movw	r26, r30
    11f2:	1e 97       	sbiw	r26, 0x0e	; 14
    11f4:	3c 91       	ld	r19, X
    11f6:	53 2f       	mov	r21, r19
    11f8:	52 95       	swap	r21
    11fa:	55 0f       	add	r21, r21
    11fc:	55 0f       	add	r21, r21
    11fe:	50 7c       	andi	r21, 0xC0	; 192
    1200:	46 2b       	or	r20, r22
    1202:	45 2b       	or	r20, r21
    1204:	49 87       	std	Y+9, r20	; 0x09
    1206:	11 96       	adiw	r26, 0x01	; 1
    1208:	4c 91       	ld	r20, X
    120a:	42 95       	swap	r20
    120c:	44 0f       	add	r20, r20
    120e:	44 0f       	add	r20, r20
    1210:	40 7c       	andi	r20, 0xC0	; 192
    1212:	36 95       	lsr	r19
    1214:	36 95       	lsr	r19
    1216:	34 2b       	or	r19, r20
    1218:	3a 87       	std	Y+10, r19	; 0x0a
	patch_to_save.fine = current_patch.fine;
    121a:	df 01       	movw	r26, r30
    121c:	1c 97       	sbiw	r26, 0x0c	; 12
    121e:	3c 91       	ld	r19, X
    1220:	3b 87       	std	Y+11, r19	; 0x0b
    1222:	11 96       	adiw	r26, 0x01	; 1
    1224:	4c 91       	ld	r20, X
	patch_to_save.tune = current_patch.tune; //probably shouldn't save master tune value. Like volume, it is a parameter that doesn't apply to a patch.
    1226:	df 01       	movw	r26, r30
    1228:	1a 97       	sbiw	r26, 0x0a	; 10
    122a:	3c 91       	ld	r19, X
    122c:	53 2f       	mov	r21, r19
    122e:	55 0f       	add	r21, r21
    1230:	55 0f       	add	r21, r21
    1232:	43 70       	andi	r20, 0x03	; 3
    1234:	45 2b       	or	r20, r21
    1236:	4c 87       	std	Y+12, r20	; 0x0c
    1238:	63 2f       	mov	r22, r19
    123a:	62 95       	swap	r22
    123c:	66 95       	lsr	r22
    123e:	66 95       	lsr	r22
    1240:	63 70       	andi	r22, 0x03	; 3
    1242:	11 96       	adiw	r26, 0x01	; 1
    1244:	4c 91       	ld	r20, X
    1246:	43 70       	andi	r20, 0x03	; 3
    1248:	44 0f       	add	r20, r20
    124a:	44 0f       	add	r20, r20
	patch_to_save.lfo_rate = current_patch.lfo_rate;
    124c:	df 01       	movw	r26, r30
    124e:	18 97       	sbiw	r26, 0x08	; 8
    1250:	3c 91       	ld	r19, X
    1252:	53 2f       	mov	r21, r19
    1254:	52 95       	swap	r21
    1256:	50 7f       	andi	r21, 0xF0	; 240
    1258:	46 2b       	or	r20, r22
    125a:	45 2b       	or	r20, r21
    125c:	4d 87       	std	Y+13, r20	; 0x0d
    125e:	63 2f       	mov	r22, r19
    1260:	62 95       	swap	r22
    1262:	6f 70       	andi	r22, 0x0F	; 15
    1264:	11 96       	adiw	r26, 0x01	; 1
    1266:	4c 91       	ld	r20, X
    1268:	43 70       	andi	r20, 0x03	; 3
    126a:	42 95       	swap	r20
    126c:	40 7f       	andi	r20, 0xF0	; 240
	patch_to_save.arp_rate = current_patch.arp_rate;
    126e:	df 01       	movw	r26, r30
    1270:	16 97       	sbiw	r26, 0x06	; 6
    1272:	3c 91       	ld	r19, X
    1274:	53 2f       	mov	r21, r19
    1276:	52 95       	swap	r21
    1278:	55 0f       	add	r21, r21
    127a:	55 0f       	add	r21, r21
    127c:	50 7c       	andi	r21, 0xC0	; 192
    127e:	46 2b       	or	r20, r22
    1280:	45 2b       	or	r20, r21
    1282:	4e 87       	std	Y+14, r20	; 0x0e
    1284:	11 96       	adiw	r26, 0x01	; 1
    1286:	4c 91       	ld	r20, X
    1288:	42 95       	swap	r20
    128a:	44 0f       	add	r20, r20
    128c:	44 0f       	add	r20, r20
    128e:	40 7c       	andi	r20, 0xC0	; 192
    1290:	36 95       	lsr	r19
    1292:	36 95       	lsr	r19
    1294:	34 2b       	or	r19, r20
    1296:	3f 87       	std	Y+15, r19	; 0x0f
	patch_to_save.glide	= current_patch.glide;
    1298:	df 01       	movw	r26, r30
    129a:	14 97       	sbiw	r26, 0x04	; 4
    129c:	3c 91       	ld	r19, X
    129e:	38 8b       	std	Y+16, r19	; 0x10
    12a0:	11 96       	adiw	r26, 0x01	; 1
    12a2:	4c 91       	ld	r20, X
	patch_to_save.amp_lfo = current_patch.amp_lfo;
    12a4:	df 01       	movw	r26, r30
    12a6:	12 97       	sbiw	r26, 0x02	; 2
    12a8:	3c 91       	ld	r19, X
    12aa:	53 2f       	mov	r21, r19
    12ac:	55 0f       	add	r21, r21
    12ae:	55 0f       	add	r21, r21
    12b0:	43 70       	andi	r20, 0x03	; 3
    12b2:	45 2b       	or	r20, r21
    12b4:	49 8b       	std	Y+17, r20	; 0x11
    12b6:	32 95       	swap	r19
    12b8:	36 95       	lsr	r19
    12ba:	36 95       	lsr	r19
    12bc:	33 70       	andi	r19, 0x03	; 3
    12be:	11 96       	adiw	r26, 0x01	; 1
    12c0:	4c 91       	ld	r20, X
    12c2:	43 70       	andi	r20, 0x03	; 3
    12c4:	44 0f       	add	r20, r20
    12c6:	44 0f       	add	r20, r20
    12c8:	83 2b       	or	r24, r19
    12ca:	84 2b       	or	r24, r20
    12cc:	8a 8b       	std	Y+18, r24	; 0x12
	patch_to_save.vco2_pw = current_patch.vco2_pw;
	
	patch_to_save.fil_eg2 = current_patch.fil_eg2;
    12ce:	80 91 e4 02 	lds	r24, 0x02E4
    12d2:	38 2f       	mov	r19, r24
    12d4:	32 95       	swap	r19
    12d6:	33 0f       	add	r19, r19
    12d8:	33 0f       	add	r19, r19
    12da:	30 7c       	andi	r19, 0xC0	; 192
    12dc:	92 2b       	or	r25, r18
    12de:	93 2b       	or	r25, r19
    12e0:	9b 8b       	std	Y+19, r25	; 0x13
    12e2:	93 81       	ldd	r25, Z+3	; 0x03
    12e4:	92 95       	swap	r25
    12e6:	99 0f       	add	r25, r25
    12e8:	99 0f       	add	r25, r25
    12ea:	90 7c       	andi	r25, 0xC0	; 192
    12ec:	86 95       	lsr	r24
    12ee:	86 95       	lsr	r24
    12f0:	89 2b       	or	r24, r25
    12f2:	8c 8b       	std	Y+20, r24	; 0x14
	patch_to_save.res = current_patch.res;
    12f4:	80 91 e6 02 	lds	r24, 0x02E6
    12f8:	8d 8b       	std	Y+21, r24	; 0x15
    12fa:	95 81       	ldd	r25, Z+5	; 0x05
	patch_to_save.cutoff = current_patch.cutoff;
    12fc:	80 91 e8 02 	lds	r24, 0x02E8
    1300:	28 2f       	mov	r18, r24
    1302:	22 0f       	add	r18, r18
    1304:	22 0f       	add	r18, r18
    1306:	93 70       	andi	r25, 0x03	; 3
    1308:	92 2b       	or	r25, r18
    130a:	9e 8b       	std	Y+22, r25	; 0x16
    130c:	38 2f       	mov	r19, r24
    130e:	32 95       	swap	r19
    1310:	36 95       	lsr	r19
    1312:	36 95       	lsr	r19
    1314:	33 70       	andi	r19, 0x03	; 3
    1316:	97 81       	ldd	r25, Z+7	; 0x07
    1318:	93 70       	andi	r25, 0x03	; 3
    131a:	99 0f       	add	r25, r25
    131c:	99 0f       	add	r25, r25
	patch_to_save.key_track = current_patch.key_track;
    131e:	80 91 ea 02 	lds	r24, 0x02EA
    1322:	28 2f       	mov	r18, r24
    1324:	22 95       	swap	r18
    1326:	20 7f       	andi	r18, 0xF0	; 240
    1328:	93 2b       	or	r25, r19
    132a:	92 2b       	or	r25, r18
    132c:	9f 8b       	std	Y+23, r25	; 0x17
    132e:	38 2f       	mov	r19, r24
    1330:	32 95       	swap	r19
    1332:	3f 70       	andi	r19, 0x0F	; 15
    1334:	91 85       	ldd	r25, Z+9	; 0x09
    1336:	93 70       	andi	r25, 0x03	; 3
    1338:	92 95       	swap	r25
    133a:	90 7f       	andi	r25, 0xF0	; 240
	patch_to_save.fil_vco2 = current_patch.fil_vco2;
    133c:	80 91 ec 02 	lds	r24, 0x02EC
    1340:	28 2f       	mov	r18, r24
    1342:	22 95       	swap	r18
    1344:	22 0f       	add	r18, r18
    1346:	22 0f       	add	r18, r18
    1348:	20 7c       	andi	r18, 0xC0	; 192
    134a:	93 2b       	or	r25, r19
    134c:	92 2b       	or	r25, r18
    134e:	98 8f       	std	Y+24, r25	; 0x18
    1350:	93 85       	ldd	r25, Z+11	; 0x0b
    1352:	92 95       	swap	r25
    1354:	99 0f       	add	r25, r25
    1356:	99 0f       	add	r25, r25
    1358:	90 7c       	andi	r25, 0xC0	; 192
    135a:	86 95       	lsr	r24
    135c:	86 95       	lsr	r24
    135e:	89 2b       	or	r24, r25
    1360:	89 8f       	std	Y+25, r24	; 0x19
	patch_to_save.fil_lfo = current_patch.fil_lfo;
    1362:	80 91 ee 02 	lds	r24, 0x02EE
    1366:	8a 8f       	std	Y+26, r24	; 0x1a
    1368:	95 85       	ldd	r25, Z+13	; 0x0d
	patch_to_save.noise_mix = current_patch.noise_mix;
    136a:	80 91 f0 02 	lds	r24, 0x02F0
    136e:	28 2f       	mov	r18, r24
    1370:	22 0f       	add	r18, r18
    1372:	22 0f       	add	r18, r18
    1374:	93 70       	andi	r25, 0x03	; 3
    1376:	92 2b       	or	r25, r18
    1378:	9b 8f       	std	Y+27, r25	; 0x1b
    137a:	38 2f       	mov	r19, r24
    137c:	32 95       	swap	r19
    137e:	36 95       	lsr	r19
    1380:	36 95       	lsr	r19
    1382:	33 70       	andi	r19, 0x03	; 3
    1384:	97 85       	ldd	r25, Z+15	; 0x0f
    1386:	93 70       	andi	r25, 0x03	; 3
    1388:	99 0f       	add	r25, r25
    138a:	99 0f       	add	r25, r25
	patch_to_save.attack_2 = current_patch.attack_2;
    138c:	80 91 f2 02 	lds	r24, 0x02F2
    1390:	28 2f       	mov	r18, r24
    1392:	22 95       	swap	r18
    1394:	20 7f       	andi	r18, 0xF0	; 240
    1396:	93 2b       	or	r25, r19
    1398:	92 2b       	or	r25, r18
    139a:	9c 8f       	std	Y+28, r25	; 0x1c
    139c:	38 2f       	mov	r19, r24
    139e:	32 95       	swap	r19
    13a0:	3f 70       	andi	r19, 0x0F	; 15
    13a2:	91 89       	ldd	r25, Z+17	; 0x11
    13a4:	93 70       	andi	r25, 0x03	; 3
    13a6:	92 95       	swap	r25
    13a8:	90 7f       	andi	r25, 0xF0	; 240
	patch_to_save.attack_1 = current_patch.attack_1;
    13aa:	80 91 f4 02 	lds	r24, 0x02F4
    13ae:	28 2f       	mov	r18, r24
    13b0:	22 95       	swap	r18
    13b2:	22 0f       	add	r18, r18
    13b4:	22 0f       	add	r18, r18
    13b6:	20 7c       	andi	r18, 0xC0	; 192
    13b8:	93 2b       	or	r25, r19
    13ba:	92 2b       	or	r25, r18
    13bc:	9d 8f       	std	Y+29, r25	; 0x1d
    13be:	93 89       	ldd	r25, Z+19	; 0x13
    13c0:	92 95       	swap	r25
    13c2:	99 0f       	add	r25, r25
    13c4:	99 0f       	add	r25, r25
    13c6:	90 7c       	andi	r25, 0xC0	; 192
    13c8:	86 95       	lsr	r24
    13ca:	86 95       	lsr	r24
    13cc:	89 2b       	or	r24, r25
    13ce:	8e 8f       	std	Y+30, r24	; 0x1e
	patch_to_save.decay_2 = current_patch.decay_2;
    13d0:	80 91 f6 02 	lds	r24, 0x02F6
    13d4:	8f 8f       	std	Y+31, r24	; 0x1f
    13d6:	95 89       	ldd	r25, Z+21	; 0x15
	patch_to_save.decay_1 = current_patch.decay_1;
    13d8:	80 91 f8 02 	lds	r24, 0x02F8
    13dc:	28 2f       	mov	r18, r24
    13de:	22 0f       	add	r18, r18
    13e0:	22 0f       	add	r18, r18
    13e2:	93 70       	andi	r25, 0x03	; 3
    13e4:	92 2b       	or	r25, r18
    13e6:	98 a3       	lds	r25, 0x58
    13e8:	38 2f       	mov	r19, r24
    13ea:	32 95       	swap	r19
    13ec:	36 95       	lsr	r19
    13ee:	36 95       	lsr	r19
    13f0:	33 70       	andi	r19, 0x03	; 3
    13f2:	97 89       	ldd	r25, Z+23	; 0x17
    13f4:	93 70       	andi	r25, 0x03	; 3
    13f6:	99 0f       	add	r25, r25
    13f8:	99 0f       	add	r25, r25
	patch_to_save.sustain_2 = current_patch.sustain_2;
    13fa:	80 91 fa 02 	lds	r24, 0x02FA
    13fe:	28 2f       	mov	r18, r24
    1400:	22 95       	swap	r18
    1402:	20 7f       	andi	r18, 0xF0	; 240
    1404:	93 2b       	or	r25, r19
    1406:	92 2b       	or	r25, r18
    1408:	99 a3       	lds	r25, 0x59
    140a:	38 2f       	mov	r19, r24
    140c:	32 95       	swap	r19
    140e:	3f 70       	andi	r19, 0x0F	; 15
    1410:	91 8d       	ldd	r25, Z+25	; 0x19
    1412:	93 70       	andi	r25, 0x03	; 3
    1414:	92 95       	swap	r25
    1416:	90 7f       	andi	r25, 0xF0	; 240
	patch_to_save.sustain_1 = current_patch.sustain_1;
    1418:	80 91 fc 02 	lds	r24, 0x02FC
    141c:	28 2f       	mov	r18, r24
    141e:	22 95       	swap	r18
    1420:	22 0f       	add	r18, r18
    1422:	22 0f       	add	r18, r18
    1424:	20 7c       	andi	r18, 0xC0	; 192
    1426:	93 2b       	or	r25, r19
    1428:	92 2b       	or	r25, r18
    142a:	9a a3       	lds	r25, 0x5a
    142c:	93 8d       	ldd	r25, Z+27	; 0x1b
    142e:	92 95       	swap	r25
    1430:	99 0f       	add	r25, r25
    1432:	99 0f       	add	r25, r25
    1434:	90 7c       	andi	r25, 0xC0	; 192
    1436:	86 95       	lsr	r24
    1438:	86 95       	lsr	r24
    143a:	89 2b       	or	r24, r25
    143c:	8b a3       	lds	r24, 0x5b
	patch_to_save.release_2 = current_patch.release_2;
    143e:	80 91 fe 02 	lds	r24, 0x02FE
    1442:	8c a3       	lds	r24, 0x5c
    1444:	95 8d       	ldd	r25, Z+29	; 0x1d
	patch_to_save.release_1 = current_patch.release_1;
    1446:	80 91 00 03 	lds	r24, 0x0300
    144a:	28 2f       	mov	r18, r24
    144c:	22 0f       	add	r18, r18
    144e:	22 0f       	add	r18, r18
    1450:	93 70       	andi	r25, 0x03	; 3
    1452:	92 2b       	or	r25, r18
    1454:	9d a3       	lds	r25, 0x5d
    1456:	82 95       	swap	r24
    1458:	86 95       	lsr	r24
    145a:	86 95       	lsr	r24
    145c:	83 70       	andi	r24, 0x03	; 3
    145e:	2e a1       	lds	r18, 0x4e
    1460:	20 7f       	andi	r18, 0xF0	; 240
    1462:	97 8d       	ldd	r25, Z+31	; 0x1f
    1464:	93 70       	andi	r25, 0x03	; 3
    1466:	99 0f       	add	r25, r25
    1468:	99 0f       	add	r25, r25
    146a:	82 2b       	or	r24, r18
    146c:	89 2b       	or	r24, r25
    146e:	8e a3       	lds	r24, 0x5e
	
		
	patch_to_save.byte_1 = current_patch.byte_1;
    1470:	80 91 02 03 	lds	r24, 0x0302
    1474:	8f a3       	lds	r24, 0x5f
	patch_to_save.byte_2 = current_patch.byte_2;
    1476:	80 91 03 03 	lds	r24, 0x0303
    147a:	88 a7       	lds	r24, 0x78
	patch_to_save.byte_3 = current_patch.byte_3;
    147c:	80 91 04 03 	lds	r24, 0x0304
    1480:	89 a7       	lds	r24, 0x79
	patch_to_save.byte_4 = current_patch.byte_4;
    1482:	80 91 05 03 	lds	r24, 0x0305
    1486:	8a a7       	lds	r24, 0x7a
	patch_to_save.byte_5 = current_patch.byte_5;
    1488:	80 91 06 03 	lds	r24, 0x0306
    148c:	8b a7       	lds	r24, 0x7b
	
	
	lock_pots();
    148e:	0e 94 4f 08 	call	0x109e	; 0x109e <lock_pots>
	//if (current_patch.mode == MANUAL) switch_states.byte2 &= ~(1<< PROG_MANUAL_SW); //if in MANUAL mode, turn off MANUAL LED
	switch_states.byte2 &= ~(1<< PROG_MANUAL_SW);
    1492:	80 91 84 03 	lds	r24, 0x0384
    1496:	8f 77       	andi	r24, 0x7F	; 127
    1498:	80 93 84 03 	sts	0x0384, r24
	current_patch.mode = MEMORY;
    149c:	10 92 0b 03 	sts	0x030B, r1
	
	eeprom_update_block((const void*)&patch_to_save, (void*)&patch_memory[patch_number], sizeof(patch_to_save));
    14a0:	21 2f       	mov	r18, r17
    14a2:	30 e0       	ldi	r19, 0x00	; 0
    14a4:	8b e2       	ldi	r24, 0x2B	; 43
    14a6:	90 e0       	ldi	r25, 0x00	; 0
    14a8:	28 9f       	mul	r18, r24
    14aa:	b0 01       	movw	r22, r0
    14ac:	29 9f       	mul	r18, r25
    14ae:	70 0d       	add	r23, r0
    14b0:	38 9f       	mul	r19, r24
    14b2:	70 0d       	add	r23, r0
    14b4:	11 24       	eor	r1, r1
    14b6:	60 50       	subi	r22, 0x00	; 0
    14b8:	70 40       	sbci	r23, 0x00	; 0
    14ba:	ce 01       	movw	r24, r28
    14bc:	01 96       	adiw	r24, 0x01	; 1
    14be:	4b e2       	ldi	r20, 0x2B	; 43
    14c0:	50 e0       	ldi	r21, 0x00	; 0
    14c2:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <__eeupd_block_m6450a>
}	
    14c6:	ab 96       	adiw	r28, 0x2b	; 43
    14c8:	0f b6       	in	r0, 0x3f	; 63
    14ca:	f8 94       	cli
    14cc:	de bf       	out	0x3e, r29	; 62
    14ce:	0f be       	out	0x3f, r0	; 63
    14d0:	cd bf       	out	0x3d, r28	; 61
    14d2:	df 91       	pop	r29
    14d4:	cf 91       	pop	r28
    14d6:	1f 91       	pop	r17
    14d8:	08 95       	ret

000014da <load_patch>:
	
void load_patch(uint8_t patch_number) {
    14da:	1f 93       	push	r17
    14dc:	cf 93       	push	r28
    14de:	df 93       	push	r29
    14e0:	cd b7       	in	r28, 0x3d	; 61
    14e2:	de b7       	in	r29, 0x3e	; 62
    14e4:	c3 54       	subi	r28, 0x43	; 67
    14e6:	d0 40       	sbci	r29, 0x00	; 0
    14e8:	0f b6       	in	r0, 0x3f	; 63
    14ea:	f8 94       	cli
    14ec:	de bf       	out	0x3e, r29	; 62
    14ee:	0f be       	out	0x3f, r0	; 63
    14f0:	cd bf       	out	0x3d, r28	; 61
	
	struct eeprom_patch loaded_patch;
	//because of bit fields in eeprom patch struct, a temporary eeprom patch needs to be filled with current_patch values and then saved to memory.
	eeprom_read_block((void*)&loaded_patch, (const void*)&patch_memory[patch_number], sizeof(loaded_patch));
    14f2:	90 e0       	ldi	r25, 0x00	; 0
    14f4:	2b e2       	ldi	r18, 0x2B	; 43
    14f6:	30 e0       	ldi	r19, 0x00	; 0
    14f8:	82 9f       	mul	r24, r18
    14fa:	b0 01       	movw	r22, r0
    14fc:	83 9f       	mul	r24, r19
    14fe:	70 0d       	add	r23, r0
    1500:	92 9f       	mul	r25, r18
    1502:	70 0d       	add	r23, r0
    1504:	11 24       	eor	r1, r1
    1506:	60 50       	subi	r22, 0x00	; 0
    1508:	70 40       	sbci	r23, 0x00	; 0
    150a:	ce 01       	movw	r24, r28
    150c:	01 96       	adiw	r24, 0x01	; 1
    150e:	4b e2       	ldi	r20, 0x2B	; 43
    1510:	50 e0       	ldi	r21, 0x00	; 0
    1512:	0e 94 99 1e 	call	0x3d32	; 0x3d32 <__eerd_block_m6450a>
	
	
	
	current_patch.vco2_pw = loaded_patch.vco2_pw;
    1516:	e2 ee       	ldi	r30, 0xE2	; 226
    1518:	f2 e0       	ldi	r31, 0x02	; 2
    151a:	8a 89       	ldd	r24, Y+18	; 0x12
    151c:	28 2f       	mov	r18, r24
    151e:	22 95       	swap	r18
    1520:	2f 70       	andi	r18, 0x0F	; 15
    1522:	9b 89       	ldd	r25, Y+19	; 0x13
    1524:	39 2f       	mov	r19, r25
    1526:	32 95       	swap	r19
    1528:	30 7f       	andi	r19, 0xF0	; 240
    152a:	32 2b       	or	r19, r18
    152c:	29 2f       	mov	r18, r25
    152e:	22 95       	swap	r18
    1530:	2f 70       	andi	r18, 0x0F	; 15
    1532:	23 70       	andi	r18, 0x03	; 3
    1534:	30 93 e2 02 	sts	0x02E2, r19
    1538:	20 93 e3 02 	sts	0x02E3, r18
	current_patch.vco1_mix = loaded_patch.vco1_mix;
    153c:	df 01       	movw	r26, r30
    153e:	5a 97       	sbiw	r26, 0x1a	; 26
    1540:	4a 81       	ldd	r20, Y+2	; 0x02
    1542:	46 95       	lsr	r20
    1544:	46 95       	lsr	r20
    1546:	2b 81       	ldd	r18, Y+3	; 0x03
    1548:	32 2f       	mov	r19, r18
    154a:	32 95       	swap	r19
    154c:	33 0f       	add	r19, r19
    154e:	33 0f       	add	r19, r19
    1550:	30 7c       	andi	r19, 0xC0	; 192
    1552:	43 2b       	or	r20, r19
    1554:	32 2f       	mov	r19, r18
    1556:	36 95       	lsr	r19
    1558:	36 95       	lsr	r19
    155a:	33 70       	andi	r19, 0x03	; 3
    155c:	4c 93       	st	X, r20
    155e:	11 96       	adiw	r26, 0x01	; 1
    1560:	3c 93       	st	X, r19
	current_patch.pitch_eg2 = loaded_patch.pitch_eg2;
    1562:	df 01       	movw	r26, r30
    1564:	58 97       	sbiw	r26, 0x18	; 24
    1566:	32 2f       	mov	r19, r18
    1568:	32 95       	swap	r19
    156a:	3f 70       	andi	r19, 0x0F	; 15
    156c:	2c 81       	ldd	r18, Y+4	; 0x04
    156e:	42 2f       	mov	r20, r18
    1570:	42 95       	swap	r20
    1572:	40 7f       	andi	r20, 0xF0	; 240
    1574:	43 2b       	or	r20, r19
    1576:	32 2f       	mov	r19, r18
    1578:	32 95       	swap	r19
    157a:	3f 70       	andi	r19, 0x0F	; 15
    157c:	33 70       	andi	r19, 0x03	; 3
    157e:	4c 93       	st	X, r20
    1580:	11 96       	adiw	r26, 0x01	; 1
    1582:	3c 93       	st	X, r19
	current_patch.pitch_vco2 = loaded_patch.pitch_vco2;
    1584:	df 01       	movw	r26, r30
    1586:	56 97       	sbiw	r26, 0x16	; 22
    1588:	22 95       	swap	r18
    158a:	26 95       	lsr	r18
    158c:	26 95       	lsr	r18
    158e:	23 70       	andi	r18, 0x03	; 3
    1590:	3d 81       	ldd	r19, Y+5	; 0x05
    1592:	43 2f       	mov	r20, r19
    1594:	44 0f       	add	r20, r20
    1596:	44 0f       	add	r20, r20
    1598:	24 2b       	or	r18, r20
    159a:	32 95       	swap	r19
    159c:	36 95       	lsr	r19
    159e:	36 95       	lsr	r19
    15a0:	33 70       	andi	r19, 0x03	; 3
    15a2:	2c 93       	st	X, r18
    15a4:	11 96       	adiw	r26, 0x01	; 1
    15a6:	3c 93       	st	X, r19
	current_patch.pitch_lfo = loaded_patch.pitch_lfo;
    15a8:	df 01       	movw	r26, r30
    15aa:	54 97       	sbiw	r26, 0x14	; 20
    15ac:	4e 81       	ldd	r20, Y+6	; 0x06
    15ae:	2f 81       	ldd	r18, Y+7	; 0x07
    15b0:	32 2f       	mov	r19, r18
    15b2:	33 70       	andi	r19, 0x03	; 3
    15b4:	4c 93       	st	X, r20
    15b6:	11 96       	adiw	r26, 0x01	; 1
    15b8:	3c 93       	st	X, r19
	current_patch.pwm_lfo = loaded_patch.pwm_lfo;
    15ba:	df 01       	movw	r26, r30
    15bc:	52 97       	sbiw	r26, 0x12	; 18
    15be:	32 2f       	mov	r19, r18
    15c0:	36 95       	lsr	r19
    15c2:	36 95       	lsr	r19
    15c4:	28 85       	ldd	r18, Y+8	; 0x08
    15c6:	42 2f       	mov	r20, r18
    15c8:	42 95       	swap	r20
    15ca:	44 0f       	add	r20, r20
    15cc:	44 0f       	add	r20, r20
    15ce:	40 7c       	andi	r20, 0xC0	; 192
    15d0:	43 2b       	or	r20, r19
    15d2:	32 2f       	mov	r19, r18
    15d4:	36 95       	lsr	r19
    15d6:	36 95       	lsr	r19
    15d8:	33 70       	andi	r19, 0x03	; 3
    15da:	4c 93       	st	X, r20
    15dc:	11 96       	adiw	r26, 0x01	; 1
    15de:	3c 93       	st	X, r19
	current_patch.pwm_eg2 = loaded_patch.pwm_eg2;
    15e0:	df 01       	movw	r26, r30
    15e2:	50 97       	sbiw	r26, 0x10	; 16
    15e4:	32 2f       	mov	r19, r18
    15e6:	32 95       	swap	r19
    15e8:	3f 70       	andi	r19, 0x0F	; 15
    15ea:	29 85       	ldd	r18, Y+9	; 0x09
    15ec:	42 2f       	mov	r20, r18
    15ee:	42 95       	swap	r20
    15f0:	40 7f       	andi	r20, 0xF0	; 240
    15f2:	43 2b       	or	r20, r19
    15f4:	32 2f       	mov	r19, r18
    15f6:	32 95       	swap	r19
    15f8:	3f 70       	andi	r19, 0x0F	; 15
    15fa:	33 70       	andi	r19, 0x03	; 3
    15fc:	4c 93       	st	X, r20
    15fe:	11 96       	adiw	r26, 0x01	; 1
    1600:	3c 93       	st	X, r19
	current_patch.vco1_pw = loaded_patch.vco1_pw;
    1602:	df 01       	movw	r26, r30
    1604:	1e 97       	sbiw	r26, 0x0e	; 14
    1606:	22 95       	swap	r18
    1608:	26 95       	lsr	r18
    160a:	26 95       	lsr	r18
    160c:	23 70       	andi	r18, 0x03	; 3
    160e:	3a 85       	ldd	r19, Y+10	; 0x0a
    1610:	43 2f       	mov	r20, r19
    1612:	44 0f       	add	r20, r20
    1614:	44 0f       	add	r20, r20
    1616:	24 2b       	or	r18, r20
    1618:	32 95       	swap	r19
    161a:	36 95       	lsr	r19
    161c:	36 95       	lsr	r19
    161e:	33 70       	andi	r19, 0x03	; 3
    1620:	2c 93       	st	X, r18
    1622:	11 96       	adiw	r26, 0x01	; 1
    1624:	3c 93       	st	X, r19
	current_patch.fine = loaded_patch.fine;
    1626:	df 01       	movw	r26, r30
    1628:	1c 97       	sbiw	r26, 0x0c	; 12
    162a:	4b 85       	ldd	r20, Y+11	; 0x0b
    162c:	2c 85       	ldd	r18, Y+12	; 0x0c
    162e:	32 2f       	mov	r19, r18
    1630:	33 70       	andi	r19, 0x03	; 3
    1632:	4c 93       	st	X, r20
    1634:	11 96       	adiw	r26, 0x01	; 1
    1636:	3c 93       	st	X, r19
	current_patch.tune = loaded_patch.tune; //probably shouldn't save master tune value. Like volume, it is a parameter that doesn't apply to a patch.
    1638:	df 01       	movw	r26, r30
    163a:	1a 97       	sbiw	r26, 0x0a	; 10
    163c:	32 2f       	mov	r19, r18
    163e:	36 95       	lsr	r19
    1640:	36 95       	lsr	r19
    1642:	2d 85       	ldd	r18, Y+13	; 0x0d
    1644:	42 2f       	mov	r20, r18
    1646:	42 95       	swap	r20
    1648:	44 0f       	add	r20, r20
    164a:	44 0f       	add	r20, r20
    164c:	40 7c       	andi	r20, 0xC0	; 192
    164e:	43 2b       	or	r20, r19
    1650:	32 2f       	mov	r19, r18
    1652:	36 95       	lsr	r19
    1654:	36 95       	lsr	r19
    1656:	33 70       	andi	r19, 0x03	; 3
    1658:	4c 93       	st	X, r20
    165a:	11 96       	adiw	r26, 0x01	; 1
    165c:	3c 93       	st	X, r19
	current_patch.lfo_rate = loaded_patch.lfo_rate;
    165e:	df 01       	movw	r26, r30
    1660:	18 97       	sbiw	r26, 0x08	; 8
    1662:	32 2f       	mov	r19, r18
    1664:	32 95       	swap	r19
    1666:	3f 70       	andi	r19, 0x0F	; 15
    1668:	2e 85       	ldd	r18, Y+14	; 0x0e
    166a:	42 2f       	mov	r20, r18
    166c:	42 95       	swap	r20
    166e:	40 7f       	andi	r20, 0xF0	; 240
    1670:	43 2b       	or	r20, r19
    1672:	32 2f       	mov	r19, r18
    1674:	32 95       	swap	r19
    1676:	3f 70       	andi	r19, 0x0F	; 15
    1678:	33 70       	andi	r19, 0x03	; 3
    167a:	4c 93       	st	X, r20
    167c:	11 96       	adiw	r26, 0x01	; 1
    167e:	3c 93       	st	X, r19
	current_patch.arp_rate = loaded_patch.arp_rate;
    1680:	df 01       	movw	r26, r30
    1682:	16 97       	sbiw	r26, 0x06	; 6
    1684:	22 95       	swap	r18
    1686:	26 95       	lsr	r18
    1688:	26 95       	lsr	r18
    168a:	23 70       	andi	r18, 0x03	; 3
    168c:	3f 85       	ldd	r19, Y+15	; 0x0f
    168e:	43 2f       	mov	r20, r19
    1690:	44 0f       	add	r20, r20
    1692:	44 0f       	add	r20, r20
    1694:	24 2b       	or	r18, r20
    1696:	32 95       	swap	r19
    1698:	36 95       	lsr	r19
    169a:	36 95       	lsr	r19
    169c:	33 70       	andi	r19, 0x03	; 3
    169e:	2c 93       	st	X, r18
    16a0:	11 96       	adiw	r26, 0x01	; 1
    16a2:	3c 93       	st	X, r19
	current_patch.glide	= loaded_patch.glide;
    16a4:	df 01       	movw	r26, r30
    16a6:	14 97       	sbiw	r26, 0x04	; 4
    16a8:	48 89       	ldd	r20, Y+16	; 0x10
    16aa:	29 89       	ldd	r18, Y+17	; 0x11
    16ac:	32 2f       	mov	r19, r18
    16ae:	33 70       	andi	r19, 0x03	; 3
    16b0:	4c 93       	st	X, r20
    16b2:	11 96       	adiw	r26, 0x01	; 1
    16b4:	3c 93       	st	X, r19
	current_patch.amp_lfo = loaded_patch.amp_lfo;
    16b6:	df 01       	movw	r26, r30
    16b8:	12 97       	sbiw	r26, 0x02	; 2
    16ba:	26 95       	lsr	r18
    16bc:	26 95       	lsr	r18
    16be:	38 2f       	mov	r19, r24
    16c0:	32 95       	swap	r19
    16c2:	33 0f       	add	r19, r19
    16c4:	33 0f       	add	r19, r19
    16c6:	30 7c       	andi	r19, 0xC0	; 192
    16c8:	23 2b       	or	r18, r19
    16ca:	86 95       	lsr	r24
    16cc:	86 95       	lsr	r24
    16ce:	83 70       	andi	r24, 0x03	; 3
    16d0:	2c 93       	st	X, r18
    16d2:	11 96       	adiw	r26, 0x01	; 1
    16d4:	8c 93       	st	X, r24
	current_patch.vco2_pw = loaded_patch.vco2_pw;
	
	current_patch.fil_eg2 = loaded_patch.fil_eg2;
    16d6:	92 95       	swap	r25
    16d8:	96 95       	lsr	r25
    16da:	96 95       	lsr	r25
    16dc:	93 70       	andi	r25, 0x03	; 3
    16de:	8c 89       	ldd	r24, Y+20	; 0x14
    16e0:	28 2f       	mov	r18, r24
    16e2:	22 0f       	add	r18, r18
    16e4:	22 0f       	add	r18, r18
    16e6:	92 2b       	or	r25, r18
    16e8:	82 95       	swap	r24
    16ea:	86 95       	lsr	r24
    16ec:	86 95       	lsr	r24
    16ee:	83 70       	andi	r24, 0x03	; 3
    16f0:	90 93 e4 02 	sts	0x02E4, r25
    16f4:	83 83       	std	Z+3, r24	; 0x03
	current_patch.res = loaded_patch.res;
    16f6:	2d 89       	ldd	r18, Y+21	; 0x15
    16f8:	8e 89       	ldd	r24, Y+22	; 0x16
    16fa:	98 2f       	mov	r25, r24
    16fc:	93 70       	andi	r25, 0x03	; 3
    16fe:	20 93 e6 02 	sts	0x02E6, r18
    1702:	95 83       	std	Z+5, r25	; 0x05
	current_patch.cutoff = loaded_patch.cutoff;
    1704:	98 2f       	mov	r25, r24
    1706:	96 95       	lsr	r25
    1708:	96 95       	lsr	r25
    170a:	8f 89       	ldd	r24, Y+23	; 0x17
    170c:	28 2f       	mov	r18, r24
    170e:	22 95       	swap	r18
    1710:	22 0f       	add	r18, r18
    1712:	22 0f       	add	r18, r18
    1714:	20 7c       	andi	r18, 0xC0	; 192
    1716:	29 2b       	or	r18, r25
    1718:	98 2f       	mov	r25, r24
    171a:	96 95       	lsr	r25
    171c:	96 95       	lsr	r25
    171e:	93 70       	andi	r25, 0x03	; 3
    1720:	20 93 e8 02 	sts	0x02E8, r18
    1724:	97 83       	std	Z+7, r25	; 0x07
	current_patch.key_track = loaded_patch.key_track;
    1726:	98 2f       	mov	r25, r24
    1728:	92 95       	swap	r25
    172a:	9f 70       	andi	r25, 0x0F	; 15
    172c:	88 8d       	ldd	r24, Y+24	; 0x18
    172e:	28 2f       	mov	r18, r24
    1730:	22 95       	swap	r18
    1732:	20 7f       	andi	r18, 0xF0	; 240
    1734:	29 2b       	or	r18, r25
    1736:	98 2f       	mov	r25, r24
    1738:	92 95       	swap	r25
    173a:	9f 70       	andi	r25, 0x0F	; 15
    173c:	93 70       	andi	r25, 0x03	; 3
    173e:	20 93 ea 02 	sts	0x02EA, r18
    1742:	91 87       	std	Z+9, r25	; 0x09
	current_patch.fil_vco2 = loaded_patch.fil_vco2;
    1744:	82 95       	swap	r24
    1746:	86 95       	lsr	r24
    1748:	86 95       	lsr	r24
    174a:	83 70       	andi	r24, 0x03	; 3
    174c:	99 8d       	ldd	r25, Y+25	; 0x19
    174e:	29 2f       	mov	r18, r25
    1750:	22 0f       	add	r18, r18
    1752:	22 0f       	add	r18, r18
    1754:	82 2b       	or	r24, r18
    1756:	92 95       	swap	r25
    1758:	96 95       	lsr	r25
    175a:	96 95       	lsr	r25
    175c:	93 70       	andi	r25, 0x03	; 3
    175e:	80 93 ec 02 	sts	0x02EC, r24
    1762:	93 87       	std	Z+11, r25	; 0x0b
	current_patch.fil_lfo = loaded_patch.fil_lfo;
    1764:	2a 8d       	ldd	r18, Y+26	; 0x1a
    1766:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1768:	98 2f       	mov	r25, r24
    176a:	93 70       	andi	r25, 0x03	; 3
    176c:	20 93 ee 02 	sts	0x02EE, r18
    1770:	95 87       	std	Z+13, r25	; 0x0d
	current_patch.noise_mix = loaded_patch.noise_mix;
    1772:	98 2f       	mov	r25, r24
    1774:	96 95       	lsr	r25
    1776:	96 95       	lsr	r25
    1778:	8c 8d       	ldd	r24, Y+28	; 0x1c
    177a:	28 2f       	mov	r18, r24
    177c:	22 95       	swap	r18
    177e:	22 0f       	add	r18, r18
    1780:	22 0f       	add	r18, r18
    1782:	20 7c       	andi	r18, 0xC0	; 192
    1784:	29 2b       	or	r18, r25
    1786:	98 2f       	mov	r25, r24
    1788:	96 95       	lsr	r25
    178a:	96 95       	lsr	r25
    178c:	93 70       	andi	r25, 0x03	; 3
    178e:	20 93 f0 02 	sts	0x02F0, r18
    1792:	97 87       	std	Z+15, r25	; 0x0f
	current_patch.attack_2 = loaded_patch.attack_2;
    1794:	98 2f       	mov	r25, r24
    1796:	92 95       	swap	r25
    1798:	9f 70       	andi	r25, 0x0F	; 15
    179a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    179c:	28 2f       	mov	r18, r24
    179e:	22 95       	swap	r18
    17a0:	20 7f       	andi	r18, 0xF0	; 240
    17a2:	29 2b       	or	r18, r25
    17a4:	98 2f       	mov	r25, r24
    17a6:	92 95       	swap	r25
    17a8:	9f 70       	andi	r25, 0x0F	; 15
    17aa:	93 70       	andi	r25, 0x03	; 3
    17ac:	20 93 f2 02 	sts	0x02F2, r18
    17b0:	91 8b       	std	Z+17, r25	; 0x11
	current_patch.attack_1 = loaded_patch.attack_1;
    17b2:	82 95       	swap	r24
    17b4:	86 95       	lsr	r24
    17b6:	86 95       	lsr	r24
    17b8:	83 70       	andi	r24, 0x03	; 3
    17ba:	9e 8d       	ldd	r25, Y+30	; 0x1e
    17bc:	29 2f       	mov	r18, r25
    17be:	22 0f       	add	r18, r18
    17c0:	22 0f       	add	r18, r18
    17c2:	82 2b       	or	r24, r18
    17c4:	92 95       	swap	r25
    17c6:	96 95       	lsr	r25
    17c8:	96 95       	lsr	r25
    17ca:	93 70       	andi	r25, 0x03	; 3
    17cc:	80 93 f4 02 	sts	0x02F4, r24
    17d0:	93 8b       	std	Z+19, r25	; 0x13
	current_patch.decay_2 = loaded_patch.decay_2;
    17d2:	2f 8d       	ldd	r18, Y+31	; 0x1f
    17d4:	88 a1       	lds	r24, 0x48
    17d6:	98 2f       	mov	r25, r24
    17d8:	93 70       	andi	r25, 0x03	; 3
    17da:	20 93 f6 02 	sts	0x02F6, r18
    17de:	95 8b       	std	Z+21, r25	; 0x15
	current_patch.decay_1 = loaded_patch.decay_1;
    17e0:	98 2f       	mov	r25, r24
    17e2:	96 95       	lsr	r25
    17e4:	96 95       	lsr	r25
    17e6:	89 a1       	lds	r24, 0x49
    17e8:	28 2f       	mov	r18, r24
    17ea:	22 95       	swap	r18
    17ec:	22 0f       	add	r18, r18
    17ee:	22 0f       	add	r18, r18
    17f0:	20 7c       	andi	r18, 0xC0	; 192
    17f2:	29 2b       	or	r18, r25
    17f4:	98 2f       	mov	r25, r24
    17f6:	96 95       	lsr	r25
    17f8:	96 95       	lsr	r25
    17fa:	93 70       	andi	r25, 0x03	; 3
    17fc:	20 93 f8 02 	sts	0x02F8, r18
    1800:	97 8b       	std	Z+23, r25	; 0x17
	current_patch.sustain_2 = loaded_patch.sustain_2;
    1802:	98 2f       	mov	r25, r24
    1804:	92 95       	swap	r25
    1806:	9f 70       	andi	r25, 0x0F	; 15
    1808:	8a a1       	lds	r24, 0x4a
    180a:	28 2f       	mov	r18, r24
    180c:	22 95       	swap	r18
    180e:	20 7f       	andi	r18, 0xF0	; 240
    1810:	29 2b       	or	r18, r25
    1812:	98 2f       	mov	r25, r24
    1814:	92 95       	swap	r25
    1816:	9f 70       	andi	r25, 0x0F	; 15
    1818:	93 70       	andi	r25, 0x03	; 3
    181a:	20 93 fa 02 	sts	0x02FA, r18
    181e:	91 8f       	std	Z+25, r25	; 0x19
	current_patch.sustain_1 = loaded_patch.sustain_1;
    1820:	82 95       	swap	r24
    1822:	86 95       	lsr	r24
    1824:	86 95       	lsr	r24
    1826:	83 70       	andi	r24, 0x03	; 3
    1828:	9b a1       	lds	r25, 0x4b
    182a:	29 2f       	mov	r18, r25
    182c:	22 0f       	add	r18, r18
    182e:	22 0f       	add	r18, r18
    1830:	82 2b       	or	r24, r18
    1832:	92 95       	swap	r25
    1834:	96 95       	lsr	r25
    1836:	96 95       	lsr	r25
    1838:	93 70       	andi	r25, 0x03	; 3
    183a:	80 93 fc 02 	sts	0x02FC, r24
    183e:	93 8f       	std	Z+27, r25	; 0x1b
	current_patch.release_2 = loaded_patch.release_2;
    1840:	2c a1       	lds	r18, 0x4c
    1842:	8d a1       	lds	r24, 0x4d
    1844:	98 2f       	mov	r25, r24
    1846:	93 70       	andi	r25, 0x03	; 3
    1848:	20 93 fe 02 	sts	0x02FE, r18
    184c:	95 8f       	std	Z+29, r25	; 0x1d
	current_patch.release_1 = loaded_patch.release_1;
    184e:	98 2f       	mov	r25, r24
    1850:	96 95       	lsr	r25
    1852:	96 95       	lsr	r25
    1854:	8e a1       	lds	r24, 0x4e
    1856:	28 2f       	mov	r18, r24
    1858:	22 95       	swap	r18
    185a:	22 0f       	add	r18, r18
    185c:	22 0f       	add	r18, r18
    185e:	20 7c       	andi	r18, 0xC0	; 192
    1860:	29 2b       	or	r18, r25
    1862:	86 95       	lsr	r24
    1864:	86 95       	lsr	r24
    1866:	98 2f       	mov	r25, r24
    1868:	93 70       	andi	r25, 0x03	; 3
    186a:	20 93 00 03 	sts	0x0300, r18
    186e:	97 8f       	std	Z+31, r25	; 0x1f
	
	
	current_patch.byte_1 = loaded_patch.byte_1;
    1870:	7f a1       	lds	r23, 0x4f
    1872:	70 93 02 03 	sts	0x0302, r23
	current_patch.byte_2 = loaded_patch.byte_2;
    1876:	68 a5       	lds	r22, 0x68
    1878:	60 93 03 03 	sts	0x0303, r22
	current_patch.byte_3 = loaded_patch.byte_3;
    187c:	89 a5       	lds	r24, 0x69
    187e:	80 93 04 03 	sts	0x0304, r24
	current_patch.byte_4 = loaded_patch.byte_4;
    1882:	9a a5       	lds	r25, 0x6a
    1884:	90 93 05 03 	sts	0x0305, r25
	current_patch.byte_5 = loaded_patch.byte_5;
    1888:	1b a5       	lds	r17, 0x6b
    188a:	10 93 06 03 	sts	0x0306, r17
	
	//using De Bruijn sequence to determine which bit is set. For alphabet size k = 2 (binary - 0 and 1) and n = 3. 2^3 = 8. The minimum number of bits required to represent the 5 octave positions
	uint8_t vco1_lookup[] = {7, 2, 5, 0, 6, 4, 3, 1}; // *modified* De Bruijn lookup table for octave number, see: http://stackoverflow.com/questions/14429661/determine-which-single-bit-in-the-byte-is-set
    188e:	de 01       	movw	r26, r28
    1890:	9c 96       	adiw	r26, 0x2c	; 44
    1892:	ef ef       	ldi	r30, 0xFF	; 255
    1894:	f1 e0       	ldi	r31, 0x01	; 1
    1896:	28 e0       	ldi	r18, 0x08	; 8
    1898:	01 90       	ld	r0, Z+
    189a:	0d 92       	st	X+, r0
    189c:	21 50       	subi	r18, 0x01	; 1
    189e:	e1 f7       	brne	.-8      	; 0x1898 <load_patch+0x3be>
	//lookup table modified from standard 8 bit De Bruijn sequence to handle non sequential order of octave LEDs in byte_4
	uint8_t vco1_bitfield = current_patch.byte_4 & 0b00011111; //clear top 3 bits, which are used for VCO2 octave lookup - probably don't need to clear these bits
    18a0:	e9 2f       	mov	r30, r25
    18a2:	ef 71       	andi	r30, 0x1F	; 31
	uint8_t bit_index = ((vco1_bitfield*0x1D) >> 4) & 0x7;	//0x1D 0b11101 is the De Bruijn sequence for 8 bits 
    18a4:	f0 e0       	ldi	r31, 0x00	; 0
    18a6:	9f 01       	movw	r18, r30
    18a8:	22 0f       	add	r18, r18
    18aa:	33 1f       	adc	r19, r19
    18ac:	22 0f       	add	r18, r18
    18ae:	33 1f       	adc	r19, r19
    18b0:	a9 01       	movw	r20, r18
    18b2:	44 0f       	add	r20, r20
    18b4:	55 1f       	adc	r21, r21
    18b6:	44 0f       	add	r20, r20
    18b8:	55 1f       	adc	r21, r21
    18ba:	44 0f       	add	r20, r20
    18bc:	55 1f       	adc	r21, r21
    18be:	42 1b       	sub	r20, r18
    18c0:	53 0b       	sbc	r21, r19
    18c2:	4e 0f       	add	r20, r30
    18c4:	5f 1f       	adc	r21, r31
    18c6:	55 95       	asr	r21
    18c8:	47 95       	ror	r20
    18ca:	55 95       	asr	r21
    18cc:	47 95       	ror	r20
    18ce:	55 95       	asr	r21
    18d0:	47 95       	ror	r20
    18d2:	55 95       	asr	r21
    18d4:	47 95       	ror	r20
    18d6:	47 70       	andi	r20, 0x07	; 7
	octave_index.vco1 = vco1_lookup[bit_index];	
    18d8:	fe 01       	movw	r30, r28
    18da:	e4 0f       	add	r30, r20
    18dc:	f1 1d       	adc	r31, r1
    18de:	24 a5       	lds	r18, 0x64
    18e0:	20 93 0c 03 	sts	0x030C, r18
	
	uint8_t vco2_lookup[] = {7, 4, 5, 3, 6, 2, 1, 0}; 
    18e4:	de 01       	movw	r26, r28
    18e6:	d4 96       	adiw	r26, 0x34	; 52
    18e8:	e7 e0       	ldi	r30, 0x07	; 7
    18ea:	f2 e0       	ldi	r31, 0x02	; 2
    18ec:	28 e0       	ldi	r18, 0x08	; 8
    18ee:	01 90       	ld	r0, Z+
    18f0:	0d 92       	st	X+, r0
    18f2:	21 50       	subi	r18, 0x01	; 1
    18f4:	e1 f7       	brne	.-8      	; 0x18ee <load_patch+0x414>
																																				 //bit order 4   3    2    1   0
	uint8_t vco2_bitfield = ((current_patch.byte_4 & 0b11100000) >> 3) | (current_patch.byte_3 & 0b00000011); //combine  all VCO2 octave bits into one byte: 8', 16', 32', 4', 2'
    18f6:	29 2f       	mov	r18, r25
    18f8:	30 e0       	ldi	r19, 0x00	; 0
    18fa:	20 7e       	andi	r18, 0xE0	; 224
    18fc:	30 70       	andi	r19, 0x00	; 0
    18fe:	35 95       	asr	r19
    1900:	27 95       	ror	r18
    1902:	35 95       	asr	r19
    1904:	27 95       	ror	r18
    1906:	35 95       	asr	r19
    1908:	27 95       	ror	r18
    190a:	83 70       	andi	r24, 0x03	; 3
    190c:	28 2b       	or	r18, r24
	bit_index = ((vco2_bitfield*0x1D) >> 4) & 0x7;																								     //index 2   1    0    3   4
    190e:	42 2f       	mov	r20, r18
    1910:	50 e0       	ldi	r21, 0x00	; 0
    1912:	ca 01       	movw	r24, r20
    1914:	88 0f       	add	r24, r24
    1916:	99 1f       	adc	r25, r25
    1918:	88 0f       	add	r24, r24
    191a:	99 1f       	adc	r25, r25
    191c:	9c 01       	movw	r18, r24
    191e:	22 0f       	add	r18, r18
    1920:	33 1f       	adc	r19, r19
    1922:	22 0f       	add	r18, r18
    1924:	33 1f       	adc	r19, r19
    1926:	22 0f       	add	r18, r18
    1928:	33 1f       	adc	r19, r19
    192a:	28 1b       	sub	r18, r24
    192c:	39 0b       	sbc	r19, r25
    192e:	42 0f       	add	r20, r18
    1930:	53 1f       	adc	r21, r19
    1932:	ca 01       	movw	r24, r20
    1934:	95 95       	asr	r25
    1936:	87 95       	ror	r24
    1938:	95 95       	asr	r25
    193a:	87 95       	ror	r24
    193c:	95 95       	asr	r25
    193e:	87 95       	ror	r24
    1940:	95 95       	asr	r25
    1942:	87 95       	ror	r24
    1944:	87 70       	andi	r24, 0x07	; 7
	octave_index.vco2 = vco2_lookup[bit_index];
    1946:	fe 01       	movw	r30, r28
    1948:	e8 0f       	add	r30, r24
    194a:	f1 1d       	adc	r31, r1
    194c:	84 a9       	sts	0x44, r24
    194e:	80 93 0d 03 	sts	0x030D, r24
	
	uint8_t lfo_lookup[] = {0, 0, 2, 2, 1, 3, 3, 1}; //bits 7, 5, 4, 6 are irrelevant here. Complier seems to be reformatting this table???
    1952:	de 01       	movw	r26, r28
    1954:	dc 96       	adiw	r26, 0x3c	; 60
    1956:	ef e0       	ldi	r30, 0x0F	; 15
    1958:	f2 e0       	ldi	r31, 0x02	; 2
    195a:	88 e0       	ldi	r24, 0x08	; 8
    195c:	01 90       	ld	r0, Z+
    195e:	0d 92       	st	X+, r0
    1960:	81 50       	subi	r24, 0x01	; 1
    1962:	e1 f7       	brne	.-8      	; 0x195c <load_patch+0x482>
	uint8_t lfo_bitfield = current_patch.byte_2 & 0b11110000; //shave off 4 LSBs. Really could use 4 bit De Bruijn sequence here
    1964:	60 7f       	andi	r22, 0xF0	; 240
	bit_index = ((lfo_bitfield*0x1D) >> 4) & 0x7;
    1966:	46 2f       	mov	r20, r22
    1968:	50 e0       	ldi	r21, 0x00	; 0
    196a:	ca 01       	movw	r24, r20
    196c:	88 0f       	add	r24, r24
    196e:	99 1f       	adc	r25, r25
    1970:	88 0f       	add	r24, r24
    1972:	99 1f       	adc	r25, r25
    1974:	9c 01       	movw	r18, r24
    1976:	22 0f       	add	r18, r18
    1978:	33 1f       	adc	r19, r19
    197a:	22 0f       	add	r18, r18
    197c:	33 1f       	adc	r19, r19
    197e:	22 0f       	add	r18, r18
    1980:	33 1f       	adc	r19, r19
    1982:	28 1b       	sub	r18, r24
    1984:	39 0b       	sbc	r19, r25
    1986:	42 0f       	add	r20, r18
    1988:	53 1f       	adc	r21, r19
    198a:	ca 01       	movw	r24, r20
    198c:	95 95       	asr	r25
    198e:	87 95       	ror	r24
    1990:	95 95       	asr	r25
    1992:	87 95       	ror	r24
    1994:	95 95       	asr	r25
    1996:	87 95       	ror	r24
    1998:	95 95       	asr	r25
    199a:	87 95       	ror	r24
    199c:	87 70       	andi	r24, 0x07	; 7
	lfo_shape_index = lfo_lookup[bit_index];
    199e:	fe 01       	movw	r30, r28
    19a0:	e8 0f       	add	r30, r24
    19a2:	f1 1d       	adc	r31, r1
    19a4:	84 ad       	sts	0x64, r24
    19a6:	80 93 0e 03 	sts	0x030E, r24
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    19aa:	21 2f       	mov	r18, r17
    19ac:	26 95       	lsr	r18
    19ae:	27 95       	ror	r18
    19b0:	22 27       	eor	r18, r18
    19b2:	27 95       	ror	r18
    19b4:	81 2f       	mov	r24, r17
    19b6:	81 70       	andi	r24, 0x01	; 1
    19b8:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
    19ba:	81 2f       	mov	r24, r17
    19bc:	86 95       	lsr	r24
    19be:	86 95       	lsr	r24
    19c0:	90 e0       	ldi	r25, 0x00	; 0
    19c2:	81 70       	andi	r24, 0x01	; 1
    19c4:	90 70       	andi	r25, 0x00	; 0
    19c6:	88 0f       	add	r24, r24
    19c8:	99 1f       	adc	r25, r25
    19ca:	88 0f       	add	r24, r24
    19cc:	99 1f       	adc	r25, r25
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    19ce:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
							((current_patch.byte_5 >> VCO1_TRI) & 1) << VCO1_TRI_SW |
    19d0:	81 2f       	mov	r24, r17
    19d2:	86 95       	lsr	r24
    19d4:	86 95       	lsr	r24
    19d6:	86 95       	lsr	r24
    19d8:	90 e0       	ldi	r25, 0x00	; 0
    19da:	81 70       	andi	r24, 0x01	; 1
    19dc:	90 70       	andi	r25, 0x00	; 0
    19de:	88 0f       	add	r24, r24
    19e0:	99 1f       	adc	r25, r25
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    19e2:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
							((current_patch.byte_5 >> VCO1_TRI) & 1) << VCO1_TRI_SW |
							((current_patch.byte_5 >> VCO1_PULSE) & 1) << VCO1_PULSE_SW |
							((current_patch.byte_5 >> VCO2_SAW) & 1) << VCO2_SAW_SW |
    19e4:	81 2f       	mov	r24, r17
    19e6:	82 95       	swap	r24
    19e8:	8f 70       	andi	r24, 0x0F	; 15
    19ea:	90 e0       	ldi	r25, 0x00	; 0
    19ec:	81 70       	andi	r24, 0x01	; 1
    19ee:	90 70       	andi	r25, 0x00	; 0
    19f0:	82 95       	swap	r24
    19f2:	92 95       	swap	r25
    19f4:	90 7f       	andi	r25, 0xF0	; 240
    19f6:	98 27       	eor	r25, r24
    19f8:	80 7f       	andi	r24, 0xF0	; 240
    19fa:	98 27       	eor	r25, r24
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    19fc:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
							((current_patch.byte_5 >> VCO1_TRI) & 1) << VCO1_TRI_SW |
							((current_patch.byte_5 >> VCO1_PULSE) & 1) << VCO1_PULSE_SW |
							((current_patch.byte_5 >> VCO2_SAW) & 1) << VCO2_SAW_SW |
							((current_patch.byte_5 >> VCO2_TRI) & 1) << VCO2_TRI_SW |
    19fe:	81 2f       	mov	r24, r17
    1a00:	82 95       	swap	r24
    1a02:	86 95       	lsr	r24
    1a04:	87 70       	andi	r24, 0x07	; 7
    1a06:	90 e0       	ldi	r25, 0x00	; 0
    1a08:	81 70       	andi	r24, 0x01	; 1
    1a0a:	90 70       	andi	r25, 0x00	; 0
    1a0c:	88 0f       	add	r24, r24
    1a0e:	99 1f       	adc	r25, r25
    1a10:	82 95       	swap	r24
    1a12:	92 95       	swap	r25
    1a14:	90 7f       	andi	r25, 0xF0	; 240
    1a16:	98 27       	eor	r25, r24
    1a18:	80 7f       	andi	r24, 0xF0	; 240
    1a1a:	98 27       	eor	r25, r24
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1a1c:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
							((current_patch.byte_5 >> VCO1_TRI) & 1) << VCO1_TRI_SW |
							((current_patch.byte_5 >> VCO1_PULSE) & 1) << VCO1_PULSE_SW |
							((current_patch.byte_5 >> VCO2_SAW) & 1) << VCO2_SAW_SW |
							((current_patch.byte_5 >> VCO2_TRI) & 1) << VCO2_TRI_SW |
							((current_patch.byte_5 >> VCO2_PULSE) & 1) << VCO2_PULSE_SW;
    1a1e:	81 2f       	mov	r24, r17
    1a20:	82 95       	swap	r24
    1a22:	86 95       	lsr	r24
    1a24:	86 95       	lsr	r24
    1a26:	83 70       	andi	r24, 0x03	; 3
    1a28:	90 e0       	ldi	r25, 0x00	; 0
    1a2a:	81 70       	andi	r24, 0x01	; 1
    1a2c:	90 70       	andi	r25, 0x00	; 0
    1a2e:	00 24       	eor	r0, r0
    1a30:	96 95       	lsr	r25
    1a32:	87 95       	ror	r24
    1a34:	07 94       	ror	r0
    1a36:	96 95       	lsr	r25
    1a38:	87 95       	ror	r24
    1a3a:	07 94       	ror	r0
    1a3c:	98 2f       	mov	r25, r24
    1a3e:	80 2d       	mov	r24, r0
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1a40:	82 2b       	or	r24, r18
    1a42:	80 93 82 03 	sts	0x0382, r24
							((current_patch.byte_5 >> VCO2_PULSE) & 1) << VCO2_PULSE_SW;
							
	switch_states.byte2 &= 0b11110011; //preserve PROG switches states, clear BMOD and EG2 states
	
	switch_states.byte2 |=	((current_patch.byte_5 >> BMOD) & 1) << BMOD_SW |
							((current_patch.byte_1 >> EG2_INV) & 1) << EG2_INV_SW;	
    1a46:	87 2f       	mov	r24, r23
    1a48:	90 e0       	ldi	r25, 0x00	; 0
    1a4a:	81 70       	andi	r24, 0x01	; 1
    1a4c:	90 70       	andi	r25, 0x00	; 0
    1a4e:	88 0f       	add	r24, r24
    1a50:	99 1f       	adc	r25, r25
    1a52:	88 0f       	add	r24, r24
    1a54:	99 1f       	adc	r25, r25
    1a56:	88 0f       	add	r24, r24
    1a58:	99 1f       	adc	r25, r25
							((current_patch.byte_5 >> VCO1_PULSE) & 1) << VCO1_PULSE_SW |
							((current_patch.byte_5 >> VCO2_SAW) & 1) << VCO2_SAW_SW |
							((current_patch.byte_5 >> VCO2_TRI) & 1) << VCO2_TRI_SW |
							((current_patch.byte_5 >> VCO2_PULSE) & 1) << VCO2_PULSE_SW;
							
	switch_states.byte2 &= 0b11110011; //preserve PROG switches states, clear BMOD and EG2 states
    1a5a:	90 91 84 03 	lds	r25, 0x0384
    1a5e:	93 7f       	andi	r25, 0xF3	; 243
	
	switch_states.byte2 |=	((current_patch.byte_5 >> BMOD) & 1) << BMOD_SW |
    1a60:	89 2b       	or	r24, r25
    1a62:	11 1f       	adc	r17, r17
    1a64:	11 27       	eor	r17, r17
    1a66:	11 1f       	adc	r17, r17
    1a68:	11 0f       	add	r17, r17
    1a6a:	11 0f       	add	r17, r17
    1a6c:	81 2b       	or	r24, r17
    1a6e:	80 93 84 03 	sts	0x0384, r24
													
	//spi_sw_byte0_current_state = spi_sw_byte0_previous_state = switch_states.byte0;
	//
	//spi_sw_byte1_current_state = spi_sw_byte1_previous_state = switch_states.byte1;						
			
	lock_pots();
    1a72:	0e 94 4f 08 	call	0x109e	; 0x109e <lock_pots>
	
	//if (current_patch.mode == MANUAL) switch_states.byte2 &= ~(1<< PROG_MANUAL_SW); //if in MANUAL mode, turn off MANUAL LED
	switch_states.byte2 &= ~(1<<PROG_MANUAL_SW);
    1a76:	80 91 84 03 	lds	r24, 0x0384
    1a7a:	8f 77       	andi	r24, 0x7F	; 127
    1a7c:	80 93 84 03 	sts	0x0384, r24
	
	current_patch.mode = MEMORY;
    1a80:	10 92 0b 03 	sts	0x030B, r1
	
}
    1a84:	cd 5b       	subi	r28, 0xBD	; 189
    1a86:	df 4f       	sbci	r29, 0xFF	; 255
    1a88:	0f b6       	in	r0, 0x3f	; 63
    1a8a:	f8 94       	cli
    1a8c:	de bf       	out	0x3e, r29	; 62
    1a8e:	0f be       	out	0x3f, r0	; 63
    1a90:	cd bf       	out	0x3d, r28	; 61
    1a92:	df 91       	pop	r29
    1a94:	cf 91       	pop	r28
    1a96:	1f 91       	pop	r17
    1a98:	08 95       	ret

00001a9a <transpose_note>:

uint8_t transpose_note (uint8_t note, uint8_t vco) {
	
	uint8_t n = 0;
	
	n = octave_index.vco1;
    1a9a:	90 91 0c 03 	lds	r25, 0x030C
	if (vco == VCO2) n = octave_index.vco2;
    1a9e:	60 3f       	cpi	r22, 0xF0	; 240
    1aa0:	11 f4       	brne	.+4      	; 0x1aa6 <transpose_note+0xc>
    1aa2:	90 91 0d 03 	lds	r25, 0x030D

	note = (n*12) + note; //calculate MIDI note after octave addition
    1aa6:	29 2f       	mov	r18, r25
    1aa8:	22 0f       	add	r18, r18
    1aaa:	92 0f       	add	r25, r18
    1aac:	99 0f       	add	r25, r25
    1aae:	99 0f       	add	r25, r25
    1ab0:	89 0f       	add	r24, r25
			
		note = 136;
			
	}
		
	return note;	
    1ab2:	89 38       	cpi	r24, 0x89	; 137
    1ab4:	08 f0       	brcs	.+2      	; 0x1ab8 <transpose_note+0x1e>
    1ab6:	88 e8       	ldi	r24, 0x88	; 136
	
}
    1ab8:	08 95       	ret

00001aba <update_octave_range>:

void update_octave_range(void) {
	
	if ((switch_states.byte0 >> VCO1_OCTAVE_UP_SW) & 1) {
    1aba:	80 91 82 03 	lds	r24, 0x0382
    1abe:	98 2f       	mov	r25, r24
    1ac0:	96 95       	lsr	r25
    1ac2:	96 95       	lsr	r25
    1ac4:	96 95       	lsr	r25
    1ac6:	90 ff       	sbrs	r25, 0
    1ac8:	0e c0       	rjmp	.+28     	; 0x1ae6 <update_octave_range+0x2c>
		
		if (++octave_index.vco1 == 5) octave_index.vco1 = 4;
    1aca:	90 91 0c 03 	lds	r25, 0x030C
    1ace:	9f 5f       	subi	r25, 0xFF	; 255
    1ad0:	90 93 0c 03 	sts	0x030C, r25
    1ad4:	95 30       	cpi	r25, 0x05	; 5
    1ad6:	19 f4       	brne	.+6      	; 0x1ade <update_octave_range+0x24>
    1ad8:	94 e0       	ldi	r25, 0x04	; 4
    1ada:	90 93 0c 03 	sts	0x030C, r25
		switch_states.byte0 ^= (1<<VCO1_OCTAVE_UP_SW); //toggle switch state bit
    1ade:	98 e0       	ldi	r25, 0x08	; 8
    1ae0:	89 27       	eor	r24, r25
    1ae2:	80 93 82 03 	sts	0x0382, r24
		
	}
	
	if ((switch_states.byte1 >> VCO1_OCTAVE_DOWN_SW) & 1) { //this didn't work initially because VCO1_OCTAVE_DOWN_SW pull down resistor wasn't installed on PCB!!!
    1ae6:	80 91 83 03 	lds	r24, 0x0383
    1aea:	98 2f       	mov	r25, r24
    1aec:	96 95       	lsr	r25
    1aee:	96 95       	lsr	r25
    1af0:	96 95       	lsr	r25
    1af2:	90 ff       	sbrs	r25, 0
    1af4:	0b c0       	rjmp	.+22     	; 0x1b0c <update_octave_range+0x52>
	
		if (octave_index.vco1 == 0) {} else {octave_index.vco1--;}
    1af6:	90 91 0c 03 	lds	r25, 0x030C
    1afa:	99 23       	and	r25, r25
    1afc:	19 f0       	breq	.+6      	; 0x1b04 <update_octave_range+0x4a>
    1afe:	91 50       	subi	r25, 0x01	; 1
    1b00:	90 93 0c 03 	sts	0x030C, r25
		switch_states.byte1 ^= (1<<VCO1_OCTAVE_DOWN_SW);
    1b04:	98 e0       	ldi	r25, 0x08	; 8
    1b06:	89 27       	eor	r24, r25
    1b08:	80 93 83 03 	sts	0x0383, r24

	}
	
	current_patch.byte_4 = 0; //clear the whole damn byte as all bits are set below
	current_patch.byte_4 |= (1<<vco1_octave[octave_index.vco1]); //set octave	
    1b0c:	80 91 0c 03 	lds	r24, 0x030C
    1b10:	e1 e2       	ldi	r30, 0x21	; 33
    1b12:	f2 e0       	ldi	r31, 0x02	; 2
    1b14:	e8 0f       	add	r30, r24
    1b16:	f1 1d       	adc	r31, r1
    1b18:	81 e0       	ldi	r24, 0x01	; 1
    1b1a:	90 e0       	ldi	r25, 0x00	; 0
    1b1c:	00 80       	ld	r0, Z
    1b1e:	02 c0       	rjmp	.+4      	; 0x1b24 <update_octave_range+0x6a>
    1b20:	88 0f       	add	r24, r24
    1b22:	99 1f       	adc	r25, r25
    1b24:	0a 94       	dec	r0
    1b26:	e2 f7       	brpl	.-8      	; 0x1b20 <update_octave_range+0x66>
    1b28:	58 2f       	mov	r21, r24
    1b2a:	80 93 05 03 	sts	0x0305, r24
	
	if ((switch_states.byte1 >> VCO2_OCTAVE_UP_SW) & 1) {
    1b2e:	90 91 83 03 	lds	r25, 0x0383
    1b32:	29 2f       	mov	r18, r25
    1b34:	26 95       	lsr	r18
    1b36:	26 95       	lsr	r18
    1b38:	20 ff       	sbrs	r18, 0
    1b3a:	0e c0       	rjmp	.+28     	; 0x1b58 <update_octave_range+0x9e>
		
		if (++octave_index.vco2 == 5) octave_index.vco2 = 4;
    1b3c:	80 91 0d 03 	lds	r24, 0x030D
    1b40:	8f 5f       	subi	r24, 0xFF	; 255
    1b42:	80 93 0d 03 	sts	0x030D, r24
    1b46:	85 30       	cpi	r24, 0x05	; 5
    1b48:	19 f4       	brne	.+6      	; 0x1b50 <update_octave_range+0x96>
    1b4a:	84 e0       	ldi	r24, 0x04	; 4
    1b4c:	80 93 0d 03 	sts	0x030D, r24
		switch_states.byte1 ^= (1<<VCO2_OCTAVE_UP_SW); //toggle switch state bit		
    1b50:	84 e0       	ldi	r24, 0x04	; 4
    1b52:	98 27       	eor	r25, r24
    1b54:	90 93 83 03 	sts	0x0383, r25
	}	
	
	if ((switch_states.byte1 >> VCO2_OCTAVE_DOWN_SW) & 1) {
    1b58:	90 91 83 03 	lds	r25, 0x0383
    1b5c:	29 2f       	mov	r18, r25
    1b5e:	26 95       	lsr	r18
    1b60:	20 ff       	sbrs	r18, 0
    1b62:	0b c0       	rjmp	.+22     	; 0x1b7a <update_octave_range+0xc0>
		
		if (octave_index.vco2 == 0) {} else {octave_index.vco2--;}
    1b64:	80 91 0d 03 	lds	r24, 0x030D
    1b68:	88 23       	and	r24, r24
    1b6a:	19 f0       	breq	.+6      	; 0x1b72 <update_octave_range+0xb8>
    1b6c:	81 50       	subi	r24, 0x01	; 1
    1b6e:	80 93 0d 03 	sts	0x030D, r24
		switch_states.byte1 ^= (1<<VCO2_OCTAVE_DOWN_SW);
    1b72:	82 e0       	ldi	r24, 0x02	; 2
    1b74:	98 27       	eor	r25, r24
    1b76:	90 93 83 03 	sts	0x0383, r25
		
	}
			
	current_patch.byte_3 &= 0b11111100; //clear bottom 2 bits for patch byte_3, which are for VCO2 2' and 4'
    1b7a:	40 91 04 03 	lds	r20, 0x0304
    1b7e:	4c 7f       	andi	r20, 0xFC	; 252
    1b80:	40 93 04 03 	sts	0x0304, r20
	
	if (octave_index.vco2 > 2) { //VCO2 2' and 4' LEDs are on LED latch 3
    1b84:	90 91 0d 03 	lds	r25, 0x030D
    1b88:	93 30       	cpi	r25, 0x03	; 3
    1b8a:	88 f0       	brcs	.+34     	; 0x1bae <update_octave_range+0xf4>

						
		current_patch.byte_3 |= (1<<vco2_octave[octave_index.vco2]);	
    1b8c:	ec e1       	ldi	r30, 0x1C	; 28
    1b8e:	f2 e0       	ldi	r31, 0x02	; 2
    1b90:	e9 0f       	add	r30, r25
    1b92:	f1 1d       	adc	r31, r1
    1b94:	21 e0       	ldi	r18, 0x01	; 1
    1b96:	30 e0       	ldi	r19, 0x00	; 0
    1b98:	c9 01       	movw	r24, r18
    1b9a:	00 80       	ld	r0, Z
    1b9c:	02 c0       	rjmp	.+4      	; 0x1ba2 <update_octave_range+0xe8>
    1b9e:	88 0f       	add	r24, r24
    1ba0:	99 1f       	adc	r25, r25
    1ba2:	0a 94       	dec	r0
    1ba4:	e2 f7       	brpl	.-8      	; 0x1b9e <update_octave_range+0xe4>
    1ba6:	84 2b       	or	r24, r20
    1ba8:	80 93 04 03 	sts	0x0304, r24
    1bac:	08 95       	ret
				
	} else { //VCO2 8', 16' and 32' are on LED latch 4
		
		current_patch.byte_4 |= (1<<vco2_octave[octave_index.vco2]); //set octave
    1bae:	ec e1       	ldi	r30, 0x1C	; 28
    1bb0:	f2 e0       	ldi	r31, 0x02	; 2
    1bb2:	e9 0f       	add	r30, r25
    1bb4:	f1 1d       	adc	r31, r1
    1bb6:	21 e0       	ldi	r18, 0x01	; 1
    1bb8:	30 e0       	ldi	r19, 0x00	; 0
    1bba:	c9 01       	movw	r24, r18
    1bbc:	00 80       	ld	r0, Z
    1bbe:	02 c0       	rjmp	.+4      	; 0x1bc4 <update_octave_range+0x10a>
    1bc0:	88 0f       	add	r24, r24
    1bc2:	99 1f       	adc	r25, r25
    1bc4:	0a 94       	dec	r0
    1bc6:	e2 f7       	brpl	.-8      	; 0x1bc0 <update_octave_range+0x106>
    1bc8:	85 2b       	or	r24, r21
    1bca:	80 93 05 03 	sts	0x0305, r24
    1bce:	08 95       	ret

00001bd0 <update_lfo_shape>:
	
}	
	
void update_lfo_shape(void) {

	if ((switch_states.byte1 >> LFO_SHAPE_SW) & 1) {
    1bd0:	80 91 83 03 	lds	r24, 0x0383
    1bd4:	88 23       	and	r24, r24
    1bd6:	64 f4       	brge	.+24     	; 0x1bf0 <update_lfo_shape+0x20>
	
		switch_states.byte1 ^= (1<<LFO_SHAPE_SW); //toggle switch state
    1bd8:	80 58       	subi	r24, 0x80	; 128
    1bda:	80 93 83 03 	sts	0x0383, r24
		if (++lfo_shape_index == 5) lfo_shape_index = 0;
    1bde:	80 91 0e 03 	lds	r24, 0x030E
    1be2:	8f 5f       	subi	r24, 0xFF	; 255
    1be4:	80 93 0e 03 	sts	0x030E, r24
    1be8:	85 30       	cpi	r24, 0x05	; 5
    1bea:	11 f4       	brne	.+4      	; 0x1bf0 <update_lfo_shape+0x20>
    1bec:	10 92 0e 03 	sts	0x030E, r1
	}
	
	current_patch.byte_2 &= 0b00001111; //clear top 4 bits
	current_patch.byte_2 |= 1 << lfo[lfo_shape_index].led_addr;
    1bf0:	e0 91 0e 03 	lds	r30, 0x030E
    1bf4:	f0 e0       	ldi	r31, 0x00	; 0
    1bf6:	ee 0f       	add	r30, r30
    1bf8:	ff 1f       	adc	r31, r31
    1bfa:	ea 5d       	subi	r30, 0xDA	; 218
    1bfc:	fd 4f       	sbci	r31, 0xFD	; 253
    1bfe:	81 e0       	ldi	r24, 0x01	; 1
    1c00:	90 e0       	ldi	r25, 0x00	; 0
    1c02:	01 80       	ldd	r0, Z+1	; 0x01
    1c04:	02 c0       	rjmp	.+4      	; 0x1c0a <update_lfo_shape+0x3a>
    1c06:	88 0f       	add	r24, r24
    1c08:	99 1f       	adc	r25, r25
    1c0a:	0a 94       	dec	r0
    1c0c:	e2 f7       	brpl	.-8      	; 0x1c06 <update_lfo_shape+0x36>
	
		switch_states.byte1 ^= (1<<LFO_SHAPE_SW); //toggle switch state
		if (++lfo_shape_index == 5) lfo_shape_index = 0;
	}
	
	current_patch.byte_2 &= 0b00001111; //clear top 4 bits
    1c0e:	90 91 03 03 	lds	r25, 0x0303
    1c12:	9f 70       	andi	r25, 0x0F	; 15
	current_patch.byte_2 |= 1 << lfo[lfo_shape_index].led_addr;
    1c14:	89 2b       	or	r24, r25
    1c16:	80 93 03 03 	sts	0x0303, r24
	DATA_BUS = lfo[lfo_shape_index].waveform_addr;
    1c1a:	80 81       	ld	r24, Z
    1c1c:	82 b9       	out	0x02, r24	; 2
	LFO_LATCH_PORT |= (1<<LFO_SW_LATCH);
    1c1e:	ed ed       	ldi	r30, 0xDD	; 221
    1c20:	f0 e0       	ldi	r31, 0x00	; 0
    1c22:	80 81       	ld	r24, Z
    1c24:	80 62       	ori	r24, 0x20	; 32
    1c26:	80 83       	st	Z, r24
	LFO_LATCH_PORT &= ~(1<<LFO_SW_LATCH);
    1c28:	80 81       	ld	r24, Z
    1c2a:	8f 7d       	andi	r24, 0xDF	; 223
    1c2c:	80 83       	st	Z, r24
	
}		
    1c2e:	08 95       	ret

00001c30 <update_lfo_sync>:
	
void update_lfo_sync(void) {
	
	static uint8_t lfo_sync_mode = 0;
	
	if ((switch_states.byte1 >> LFO_SYNC_SW) & 1) {
    1c30:	80 91 83 03 	lds	r24, 0x0383
    1c34:	80 ff       	sbrs	r24, 0
    1c36:	0f c0       	rjmp	.+30     	; 0x1c56 <update_lfo_sync+0x26>
			
		switch_states.byte1 ^= (1<<LFO_SYNC_SW); //toggle switch state
    1c38:	91 e0       	ldi	r25, 0x01	; 1
    1c3a:	89 27       	eor	r24, r25
    1c3c:	80 93 83 03 	sts	0x0383, r24
		if (++lfo_sync_mode == 5) lfo_sync_mode = 0;
    1c40:	80 91 0f 03 	lds	r24, 0x030F
    1c44:	8f 5f       	subi	r24, 0xFF	; 255
    1c46:	80 93 0f 03 	sts	0x030F, r24
    1c4a:	85 30       	cpi	r24, 0x05	; 5
    1c4c:	11 f4       	brne	.+4      	; 0x1c52 <update_lfo_sync+0x22>
    1c4e:	10 92 0f 03 	sts	0x030F, r1
		midi_clock.ppqn_counter = 0; //reset counter
    1c52:	10 92 d7 03 	sts	0x03D7, r1
	}
	
	current_patch.byte_2 &= 0b11110000; //clear bottom 4 bits
    1c56:	60 91 03 03 	lds	r22, 0x0303
    1c5a:	60 7f       	andi	r22, 0xF0	; 240
    1c5c:	60 93 03 03 	sts	0x0303, r22
	if (lfo_sync_mode) current_patch.byte_2 |= (1<<(lfo_sync_mode -1)); //this allows an off state when lfo_sync_mode = 0;
    1c60:	20 91 0f 03 	lds	r18, 0x030F
    1c64:	22 23       	and	r18, r18
    1c66:	71 f0       	breq	.+28     	; 0x1c84 <update_lfo_sync+0x54>
    1c68:	30 e0       	ldi	r19, 0x00	; 0
    1c6a:	21 50       	subi	r18, 0x01	; 1
    1c6c:	30 40       	sbci	r19, 0x00	; 0
    1c6e:	41 e0       	ldi	r20, 0x01	; 1
    1c70:	50 e0       	ldi	r21, 0x00	; 0
    1c72:	ca 01       	movw	r24, r20
    1c74:	02 c0       	rjmp	.+4      	; 0x1c7a <update_lfo_sync+0x4a>
    1c76:	88 0f       	add	r24, r24
    1c78:	99 1f       	adc	r25, r25
    1c7a:	2a 95       	dec	r18
    1c7c:	e2 f7       	brpl	.-8      	; 0x1c76 <update_lfo_sync+0x46>
    1c7e:	86 2b       	or	r24, r22
    1c80:	80 93 03 03 	sts	0x0303, r24
	
	//now parse out clock divide from patch byte_2
	switch (current_patch.byte_2 & 0b00001111) {
    1c84:	80 91 03 03 	lds	r24, 0x0303
    1c88:	90 e0       	ldi	r25, 0x00	; 0
    1c8a:	8f 70       	andi	r24, 0x0F	; 15
    1c8c:	90 70       	andi	r25, 0x00	; 0
    1c8e:	82 30       	cpi	r24, 0x02	; 2
    1c90:	91 05       	cpc	r25, r1
    1c92:	89 f0       	breq	.+34     	; 0x1cb6 <update_lfo_sync+0x86>
    1c94:	83 30       	cpi	r24, 0x03	; 3
    1c96:	91 05       	cpc	r25, r1
    1c98:	24 f4       	brge	.+8      	; 0x1ca2 <update_lfo_sync+0x72>
    1c9a:	81 30       	cpi	r24, 0x01	; 1
    1c9c:	91 05       	cpc	r25, r1
    1c9e:	b9 f4       	brne	.+46     	; 0x1cce <update_lfo_sync+0x9e>
    1ca0:	07 c0       	rjmp	.+14     	; 0x1cb0 <update_lfo_sync+0x80>
    1ca2:	84 30       	cpi	r24, 0x04	; 4
    1ca4:	91 05       	cpc	r25, r1
    1ca6:	59 f0       	breq	.+22     	; 0x1cbe <update_lfo_sync+0x8e>
    1ca8:	88 30       	cpi	r24, 0x08	; 8
    1caa:	91 05       	cpc	r25, r1
    1cac:	81 f4       	brne	.+32     	; 0x1cce <update_lfo_sync+0x9e>
    1cae:	0b c0       	rjmp	.+22     	; 0x1cc6 <update_lfo_sync+0x96>
		
		case 0b0001:
			midi_clock.divider = 0; //key sync mode - need to turn midi sync off here. How?
    1cb0:	10 92 d6 03 	sts	0x03D6, r1
			
			break;
    1cb4:	08 95       	ret
			
		case 0b0010: //turn these case conditions into constants. #define 0b0010 DIV_24
			midi_clock.divider = 24; //1:4
    1cb6:	88 e1       	ldi	r24, 0x18	; 24
    1cb8:	80 93 d6 03 	sts	0x03D6, r24
			break;
    1cbc:	08 95       	ret
			
		case 0b0100:
			midi_clock.divider = 12; //1:8
    1cbe:	8c e0       	ldi	r24, 0x0C	; 12
    1cc0:	80 93 d6 03 	sts	0x03D6, r24
			break;
    1cc4:	08 95       	ret
			
		case 0b1000:
			midi_clock.divider = 6; //1:16	 		
    1cc6:	86 e0       	ldi	r24, 0x06	; 6
    1cc8:	80 93 d6 03 	sts	0x03D6, r24
			break;
    1ccc:	08 95       	ret
		
		default:
			midi_clock.divider = 0; //need to turn midi sync off here. How?
    1cce:	10 92 d6 03 	sts	0x03D6, r1
    1cd2:	08 95       	ret

00001cd4 <update_arp_sync>:

void update_arp_sync(void) {
	
	static uint8_t arp_sync_mode = 0;
	
	if ((switch_states.byte1 >> ARP_SYNC_SW) & 1) {
    1cd4:	80 91 83 03 	lds	r24, 0x0383
    1cd8:	98 2f       	mov	r25, r24
    1cda:	92 95       	swap	r25
    1cdc:	96 95       	lsr	r25
    1cde:	96 95       	lsr	r25
    1ce0:	93 70       	andi	r25, 0x03	; 3
    1ce2:	90 ff       	sbrs	r25, 0
    1ce4:	0f c0       	rjmp	.+30     	; 0x1d04 <update_arp_sync+0x30>
		
		switch_states.byte1 ^= (1<<ARP_SYNC_SW); //toggle switch state
    1ce6:	90 e4       	ldi	r25, 0x40	; 64
    1ce8:	89 27       	eor	r24, r25
    1cea:	80 93 83 03 	sts	0x0383, r24
		if (++arp_sync_mode == 5) arp_sync_mode = 0;
    1cee:	80 91 10 03 	lds	r24, 0x0310
    1cf2:	8f 5f       	subi	r24, 0xFF	; 255
    1cf4:	80 93 10 03 	sts	0x0310, r24
    1cf8:	85 30       	cpi	r24, 0x05	; 5
    1cfa:	11 f4       	brne	.+4      	; 0x1d00 <update_arp_sync+0x2c>
    1cfc:	10 92 10 03 	sts	0x0310, r1
		system_clock.ppqn_counter = 0; //reset counter
    1d00:	10 92 d1 03 	sts	0x03D1, r1
	}
	
	current_patch.byte_3 &= 0b11000011; //clear middle 4 bits
    1d04:	60 91 04 03 	lds	r22, 0x0304
    1d08:	63 7c       	andi	r22, 0xC3	; 195
    1d0a:	60 93 04 03 	sts	0x0304, r22
	if (arp_sync_mode) current_patch.byte_3 |= 1<<(arp_sync_mode + 1); //this allows an off state when arp_sync_mode = 0. Is that what's really needed?
    1d0e:	20 91 10 03 	lds	r18, 0x0310
    1d12:	22 23       	and	r18, r18
    1d14:	71 f0       	breq	.+28     	; 0x1d32 <update_arp_sync+0x5e>
    1d16:	30 e0       	ldi	r19, 0x00	; 0
    1d18:	2f 5f       	subi	r18, 0xFF	; 255
    1d1a:	3f 4f       	sbci	r19, 0xFF	; 255
    1d1c:	41 e0       	ldi	r20, 0x01	; 1
    1d1e:	50 e0       	ldi	r21, 0x00	; 0
    1d20:	ca 01       	movw	r24, r20
    1d22:	02 c0       	rjmp	.+4      	; 0x1d28 <update_arp_sync+0x54>
    1d24:	88 0f       	add	r24, r24
    1d26:	99 1f       	adc	r25, r25
    1d28:	2a 95       	dec	r18
    1d2a:	e2 f7       	brpl	.-8      	; 0x1d24 <update_arp_sync+0x50>
    1d2c:	86 2b       	or	r24, r22
    1d2e:	80 93 04 03 	sts	0x0304, r24
	
	switch (current_patch.byte_3 & 0b00111100) {
    1d32:	80 91 04 03 	lds	r24, 0x0304
    1d36:	90 e0       	ldi	r25, 0x00	; 0
    1d38:	8c 73       	andi	r24, 0x3C	; 60
    1d3a:	90 70       	andi	r25, 0x00	; 0
    1d3c:	88 30       	cpi	r24, 0x08	; 8
    1d3e:	91 05       	cpc	r25, r1
    1d40:	91 f0       	breq	.+36     	; 0x1d66 <update_arp_sync+0x92>
    1d42:	89 30       	cpi	r24, 0x09	; 9
    1d44:	91 05       	cpc	r25, r1
    1d46:	24 f4       	brge	.+8      	; 0x1d50 <update_arp_sync+0x7c>
    1d48:	84 30       	cpi	r24, 0x04	; 4
    1d4a:	91 05       	cpc	r25, r1
    1d4c:	c1 f4       	brne	.+48     	; 0x1d7e <update_arp_sync+0xaa>
    1d4e:	07 c0       	rjmp	.+14     	; 0x1d5e <update_arp_sync+0x8a>
    1d50:	80 31       	cpi	r24, 0x10	; 16
    1d52:	91 05       	cpc	r25, r1
    1d54:	61 f0       	breq	.+24     	; 0x1d6e <update_arp_sync+0x9a>
    1d56:	80 32       	cpi	r24, 0x20	; 32
    1d58:	91 05       	cpc	r25, r1
    1d5a:	89 f4       	brne	.+34     	; 0x1d7e <update_arp_sync+0xaa>
    1d5c:	0c c0       	rjmp	.+24     	; 0x1d76 <update_arp_sync+0xa2>
			
		case 0b00000100:
			system_clock.divider = 48; //1:2
    1d5e:	80 e3       	ldi	r24, 0x30	; 48
    1d60:	80 93 d0 03 	sts	0x03D0, r24
			break;
    1d64:	08 95       	ret
			
		case 0b00001000:
			system_clock.divider = 24; //1:4
    1d66:	88 e1       	ldi	r24, 0x18	; 24
    1d68:	80 93 d0 03 	sts	0x03D0, r24
			break;
    1d6c:	08 95       	ret
			
		case 0b00010000:		
			system_clock.divider = 12; //1:8
    1d6e:	8c e0       	ldi	r24, 0x0C	; 12
    1d70:	80 93 d0 03 	sts	0x03D0, r24
			break;
    1d74:	08 95       	ret
			
		case 0b00100000:
			system_clock.divider = 6; //1:16	
    1d76:	86 e0       	ldi	r24, 0x06	; 6
    1d78:	80 93 d0 03 	sts	0x03D0, r24
			break;
    1d7c:	08 95       	ret
			
		default:
			system_clock.divider = 2; //should be 1 but this never turns arp_sync_led off - need to fix this	
    1d7e:	82 e0       	ldi	r24, 0x02	; 2
    1d80:	80 93 d0 03 	sts	0x03D0, r24
    1d84:	08 95       	ret

00001d86 <update_arp_range>:

void update_arp_range(void) {
	
	static uint8_t arp_range = 0;
	
	if ((switch_states.byte1 == (1<<ARP_RANGE_SW)) & 1) {
    1d86:	80 91 83 03 	lds	r24, 0x0383
    1d8a:	80 31       	cpi	r24, 0x10	; 16
    1d8c:	69 f4       	brne	.+26     	; 0x1da8 <update_arp_range+0x22>
		
		switch_states.byte1 ^= (1<<ARP_RANGE_SW); //toggle switch bit
    1d8e:	10 92 83 03 	sts	0x0383, r1
		
		if (++arp_range == 4) arp_range = 0;
    1d92:	80 91 11 03 	lds	r24, 0x0311
    1d96:	8f 5f       	subi	r24, 0xFF	; 255
    1d98:	80 93 11 03 	sts	0x0311, r24
    1d9c:	84 30       	cpi	r24, 0x04	; 4
    1d9e:	11 f4       	brne	.+4      	; 0x1da4 <update_arp_range+0x1e>
    1da0:	10 92 11 03 	sts	0x0311, r1
		arp.step_position = 0; //reset step position if range changes
    1da4:	10 92 8a 03 	sts	0x038A, r1
						
	}
	
	//arp range LEDs 3 and 2 are in byte_3, bits 7 and 6, respectively. arp range LED 1 is bit 1 of byte_1
	
	current_patch.byte_1 &= ~(1<<ARP_RANGE_1); //clear arp range 1 LED
    1da8:	80 91 02 03 	lds	r24, 0x0302
    1dac:	8d 7f       	andi	r24, 0xFD	; 253
    1dae:	80 93 02 03 	sts	0x0302, r24
	current_patch.byte_3 &= 0b00111111; //clear bits 6 and7, arp range 3 and 2
    1db2:	80 91 04 03 	lds	r24, 0x0304
    1db6:	8f 73       	andi	r24, 0x3F	; 63
    1db8:	80 93 04 03 	sts	0x0304, r24
	
	arp.range = arp_range;
    1dbc:	80 91 11 03 	lds	r24, 0x0311
    1dc0:	80 93 88 03 	sts	0x0388, r24
	
	update_arp_sequence(); //update sequence with new settings
    1dc4:	0e 94 a3 00 	call	0x146	; 0x146 <update_arp_sequence>
	
	switch (arp_range) { //this just updates LEDs. no struct to handle arp range yet
    1dc8:	80 91 11 03 	lds	r24, 0x0311
    1dcc:	82 30       	cpi	r24, 0x02	; 2
    1dce:	51 f0       	breq	.+20     	; 0x1de4 <update_arp_range+0x5e>
    1dd0:	83 30       	cpi	r24, 0x03	; 3
    1dd2:	71 f0       	breq	.+28     	; 0x1df0 <update_arp_range+0x6a>
    1dd4:	81 30       	cpi	r24, 0x01	; 1
    1dd6:	89 f4       	brne	.+34     	; 0x1dfa <update_arp_range+0x74>
			
			break;
			
		case 1:
		
			current_patch.byte_1 |= (1<<ARP_RANGE_1); //set range 1 LED. LED was in the wrong way!
    1dd8:	80 91 02 03 	lds	r24, 0x0302
    1ddc:	82 60       	ori	r24, 0x02	; 2
    1dde:	80 93 02 03 	sts	0x0302, r24
			break;
    1de2:	08 95       	ret
			
		case 2:
		
			current_patch.byte_3 |= (1<<ARP_RANGE_2);		
    1de4:	80 91 04 03 	lds	r24, 0x0304
    1de8:	80 64       	ori	r24, 0x40	; 64
    1dea:	80 93 04 03 	sts	0x0304, r24
			break;
    1dee:	08 95       	ret
			
			
		case 3: 
			
			current_patch.byte_3 |= (1<<ARP_RANGE_3);
    1df0:	80 91 04 03 	lds	r24, 0x0304
    1df4:	80 68       	ori	r24, 0x80	; 128
    1df6:	80 93 04 03 	sts	0x0304, r24
    1dfa:	08 95       	ret

00001dfc <update_arp_mode>:

void update_arp_mode(void) {

	static uint8_t arp_mode = 0;
	
	if ((switch_states.byte1 >> ARP_MODE_SW) & 1) {
    1dfc:	80 91 83 03 	lds	r24, 0x0383
    1e00:	98 2f       	mov	r25, r24
    1e02:	92 95       	swap	r25
    1e04:	96 95       	lsr	r25
    1e06:	97 70       	andi	r25, 0x07	; 7
    1e08:	90 ff       	sbrs	r25, 0
    1e0a:	0f c0       	rjmp	.+30     	; 0x1e2a <update_arp_mode+0x2e>
		
		switch_states.byte1 ^= (1<<ARP_MODE_SW); //toggle switch state
    1e0c:	90 e2       	ldi	r25, 0x20	; 32
    1e0e:	89 27       	eor	r24, r25
    1e10:	80 93 83 03 	sts	0x0383, r24
		if (++arp_mode == 5) arp_mode = 0;
    1e14:	80 91 12 03 	lds	r24, 0x0312
    1e18:	8f 5f       	subi	r24, 0xFF	; 255
    1e1a:	80 93 12 03 	sts	0x0312, r24
    1e1e:	85 30       	cpi	r24, 0x05	; 5
    1e20:	11 f4       	brne	.+4      	; 0x1e26 <update_arp_mode+0x2a>
    1e22:	10 92 12 03 	sts	0x0312, r1
		arp.step_position = 0; //reset step position if mode changes
    1e26:	10 92 8a 03 	sts	0x038A, r1
		
	}

	arp.clock_source = INTERNAL_CLOCK;	
    1e2a:	81 e0       	ldi	r24, 0x01	; 1
    1e2c:	80 93 8e 03 	sts	0x038E, r24

	current_patch.byte_1 &= 0b11000011; //clear middle 4 bits UP, DOWN, RANDOM, MODE correspond to bits 6>>2
    1e30:	90 91 02 03 	lds	r25, 0x0302
    1e34:	93 7c       	andi	r25, 0xC3	; 195
    1e36:	90 93 02 03 	sts	0x0302, r25
	
	switch(arp_mode) {
    1e3a:	80 91 12 03 	lds	r24, 0x0312
    1e3e:	81 30       	cpi	r24, 0x01	; 1
    1e40:	81 f0       	breq	.+32     	; 0x1e62 <update_arp_mode+0x66>
    1e42:	81 30       	cpi	r24, 0x01	; 1
    1e44:	28 f0       	brcs	.+10     	; 0x1e50 <update_arp_mode+0x54>
    1e46:	82 30       	cpi	r24, 0x02	; 2
    1e48:	91 f0       	breq	.+36     	; 0x1e6e <update_arp_mode+0x72>
    1e4a:	83 30       	cpi	r24, 0x03	; 3
    1e4c:	f1 f4       	brne	.+60     	; 0x1e8a <update_arp_mode+0x8e>
    1e4e:	16 c0       	rjmp	.+44     	; 0x1e7c <update_arp_mode+0x80>
		
		case 0:
		
			//turn arp off
			arp.clock_source = OFF;
    1e50:	82 e0       	ldi	r24, 0x02	; 2
    1e52:	80 93 8e 03 	sts	0x038E, r24
			if (gate_buffer == 0) PORTF &= ~(1<<GATE); //turn gate off.
    1e56:	80 91 b4 02 	lds	r24, 0x02B4
    1e5a:	88 23       	and	r24, r24
    1e5c:	e1 f4       	brne	.+56     	; 0x1e96 <update_arp_mode+0x9a>
    1e5e:	89 98       	cbi	0x11, 1	; 17
    1e60:	1a c0       	rjmp	.+52     	; 0x1e96 <update_arp_mode+0x9a>
			break;
			
		case 1:
		
			current_patch.byte_1 |= (1<<ARP_MODE_UP) | (1<<ARP_ON);
    1e62:	94 62       	ori	r25, 0x24	; 36
    1e64:	90 93 02 03 	sts	0x0302, r25
			arp.mode = UP;
    1e68:	10 92 8f 03 	sts	0x038F, r1
			break;	
    1e6c:	14 c0       	rjmp	.+40     	; 0x1e96 <update_arp_mode+0x9a>
		
		case 2:
			current_patch.byte_1 |= (1<<ARP_MODE_DN) | (1<<ARP_ON);
    1e6e:	94 61       	ori	r25, 0x14	; 20
    1e70:	90 93 02 03 	sts	0x0302, r25
			arp.mode = DOWN;
    1e74:	81 e0       	ldi	r24, 0x01	; 1
    1e76:	80 93 8f 03 	sts	0x038F, r24
			break;
    1e7a:	0d c0       	rjmp	.+26     	; 0x1e96 <update_arp_mode+0x9a>
			
		case 3:
			current_patch.byte_1 |= (1<<ARP_MODE_UP) | (1<<ARP_MODE_DN) | (1<<ARP_ON);
    1e7c:	94 63       	ori	r25, 0x34	; 52
    1e7e:	90 93 02 03 	sts	0x0302, r25
			arp.mode = UP_DOWN;
    1e82:	82 e0       	ldi	r24, 0x02	; 2
    1e84:	80 93 8f 03 	sts	0x038F, r24
			break;
    1e88:	06 c0       	rjmp	.+12     	; 0x1e96 <update_arp_mode+0x9a>
			
		default:
			current_patch.byte_1 |= (1<<ARP_MODE_RD) | (1<<ARP_ON);
    1e8a:	9c 60       	ori	r25, 0x0C	; 12
    1e8c:	90 93 02 03 	sts	0x0302, r25
			arp.mode = RANDOM;
    1e90:	83 e0       	ldi	r24, 0x03	; 3
    1e92:	80 93 8f 03 	sts	0x038F, r24
			
					
		
	}
	
	update_arp_sequence(); //update arp sequence with new mode
    1e96:	0e 94 a3 00 	call	0x146	; 0x146 <update_arp_sequence>
	



}
    1e9a:	08 95       	ret

00001e9c <update_patch>:
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    1e9c:	90 91 82 03 	lds	r25, 0x0382
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
							((switch_states.byte0 >> VCO1_PULSE_SW) & 1) << VCO1_PULSE |
							((switch_states.byte0 >> VCO2_SAW_SW) & 1) << VCO2_SAW |
							((switch_states.byte0 >> VCO2_TRI_SW) & 1) << VCO2_TRI |
							((switch_states.byte0 >> VCO2_PULSE_SW) & 1) << VCO2_PULSE |
							((switch_states.byte2 >> BMOD_SW) & 1) << BMOD;
    1ea0:	80 91 84 03 	lds	r24, 0x0384
    1ea4:	86 95       	lsr	r24
    1ea6:	86 95       	lsr	r24
    1ea8:	68 2f       	mov	r22, r24
    1eaa:	67 95       	ror	r22
    1eac:	66 27       	eor	r22, r22
    1eae:	67 95       	ror	r22
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    1eb0:	29 2f       	mov	r18, r25
    1eb2:	21 70       	andi	r18, 0x01	; 1
    1eb4:	26 2b       	or	r18, r22
    1eb6:	69 2f       	mov	r22, r25
    1eb8:	66 1f       	adc	r22, r22
    1eba:	66 27       	eor	r22, r22
    1ebc:	66 1f       	adc	r22, r22
    1ebe:	66 0f       	add	r22, r22
    1ec0:	62 2b       	or	r22, r18
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
    1ec2:	29 2f       	mov	r18, r25
    1ec4:	26 95       	lsr	r18
    1ec6:	26 95       	lsr	r18
    1ec8:	30 e0       	ldi	r19, 0x00	; 0
    1eca:	21 70       	andi	r18, 0x01	; 1
    1ecc:	30 70       	andi	r19, 0x00	; 0
    1ece:	d9 01       	movw	r26, r18
    1ed0:	aa 0f       	add	r26, r26
    1ed2:	bb 1f       	adc	r27, r27
    1ed4:	aa 0f       	add	r26, r26
    1ed6:	bb 1f       	adc	r27, r27
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    1ed8:	6a 2b       	or	r22, r26
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
    1eda:	a9 2f       	mov	r26, r25
    1edc:	a6 95       	lsr	r26
    1ede:	b0 e0       	ldi	r27, 0x00	; 0
    1ee0:	a1 70       	andi	r26, 0x01	; 1
    1ee2:	b0 70       	andi	r27, 0x00	; 0
    1ee4:	fd 01       	movw	r30, r26
    1ee6:	ee 0f       	add	r30, r30
    1ee8:	ff 1f       	adc	r31, r31
    1eea:	ee 0f       	add	r30, r30
    1eec:	ff 1f       	adc	r31, r31
    1eee:	ee 0f       	add	r30, r30
    1ef0:	ff 1f       	adc	r31, r31
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    1ef2:	a6 2f       	mov	r26, r22
    1ef4:	ae 2b       	or	r26, r30
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
							((switch_states.byte0 >> VCO1_PULSE_SW) & 1) << VCO1_PULSE |
							((switch_states.byte0 >> VCO2_SAW_SW) & 1) << VCO2_SAW |
    1ef6:	e9 2f       	mov	r30, r25
    1ef8:	e2 95       	swap	r30
    1efa:	ef 70       	andi	r30, 0x0F	; 15
    1efc:	f0 e0       	ldi	r31, 0x00	; 0
    1efe:	e1 70       	andi	r30, 0x01	; 1
    1f00:	f0 70       	andi	r31, 0x00	; 0
    1f02:	bf 01       	movw	r22, r30
    1f04:	62 95       	swap	r22
    1f06:	72 95       	swap	r23
    1f08:	70 7f       	andi	r23, 0xF0	; 240
    1f0a:	76 27       	eor	r23, r22
    1f0c:	60 7f       	andi	r22, 0xF0	; 240
    1f0e:	76 27       	eor	r23, r22
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    1f10:	ea 2f       	mov	r30, r26
    1f12:	e6 2b       	or	r30, r22
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
							((switch_states.byte0 >> VCO1_PULSE_SW) & 1) << VCO1_PULSE |
							((switch_states.byte0 >> VCO2_SAW_SW) & 1) << VCO2_SAW |
							((switch_states.byte0 >> VCO2_TRI_SW) & 1) << VCO2_TRI |
    1f14:	69 2f       	mov	r22, r25
    1f16:	62 95       	swap	r22
    1f18:	66 95       	lsr	r22
    1f1a:	67 70       	andi	r22, 0x07	; 7
    1f1c:	70 e0       	ldi	r23, 0x00	; 0
    1f1e:	61 70       	andi	r22, 0x01	; 1
    1f20:	70 70       	andi	r23, 0x00	; 0
    1f22:	ab 01       	movw	r20, r22
    1f24:	44 0f       	add	r20, r20
    1f26:	55 1f       	adc	r21, r21
    1f28:	42 95       	swap	r20
    1f2a:	52 95       	swap	r21
    1f2c:	50 7f       	andi	r21, 0xF0	; 240
    1f2e:	54 27       	eor	r21, r20
    1f30:	40 7f       	andi	r20, 0xF0	; 240
    1f32:	54 27       	eor	r21, r20
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    1f34:	6e 2f       	mov	r22, r30
    1f36:	64 2b       	or	r22, r20
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
							((switch_states.byte0 >> VCO1_PULSE_SW) & 1) << VCO1_PULSE |
							((switch_states.byte0 >> VCO2_SAW_SW) & 1) << VCO2_SAW |
							((switch_states.byte0 >> VCO2_TRI_SW) & 1) << VCO2_TRI |
							((switch_states.byte0 >> VCO2_PULSE_SW) & 1) << VCO2_PULSE |
    1f38:	49 2f       	mov	r20, r25
    1f3a:	42 95       	swap	r20
    1f3c:	46 95       	lsr	r20
    1f3e:	46 95       	lsr	r20
    1f40:	43 70       	andi	r20, 0x03	; 3
    1f42:	50 e0       	ldi	r21, 0x00	; 0
    1f44:	41 70       	andi	r20, 0x01	; 1
    1f46:	50 70       	andi	r21, 0x00	; 0
    1f48:	9a 01       	movw	r18, r20
    1f4a:	00 24       	eor	r0, r0
    1f4c:	36 95       	lsr	r19
    1f4e:	27 95       	ror	r18
    1f50:	07 94       	ror	r0
    1f52:	36 95       	lsr	r19
    1f54:	27 95       	ror	r18
    1f56:	07 94       	ror	r0
    1f58:	32 2f       	mov	r19, r18
    1f5a:	20 2d       	mov	r18, r0
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    1f5c:	26 2b       	or	r18, r22
    1f5e:	20 93 06 03 	sts	0x0306, r18
			
	//update analog switch latch:
	//need to incorporate BMOD_LATCH_BIT switch state into data byte sent to analog switch latch
	//3rd switch bit is VCO1_OCTAVE_UP_SW state, which isn't used by analog switch latch
	uint8_t analog_sw_byte = switch_states.byte0;
	uint8_t BMOD_SW_ON = (switch_states.byte2 >> BMOD_SW) & 1;
    1f62:	81 70       	andi	r24, 0x01	; 1
	analog_sw_byte ^= (-BMOD_SW_ON ^ analog_sw_byte) & (1<<3);//set third bit dependent on BMOD switch state
    1f64:	81 95       	neg	r24
    1f66:	89 27       	eor	r24, r25
    1f68:	88 70       	andi	r24, 0x08	; 8
	update_analog_switch_latch(analog_sw_byte);
    1f6a:	89 27       	eor	r24, r25
    1f6c:	0e 94 b7 16 	call	0x2d6e	; 0x2d6e <update_analog_switch_latch>
					
	//set EG2 INV bit. This changes the nth bit to x from: http://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit-in-c-c
	//need to make sure this doesn't interfere with anything else on this port
	uint8_t EG2_INV_ON = (switch_states.byte2 >> EG2_INV_SW) & 1;	
	EG2_POL_PORT ^= (-EG2_INV_ON ^ EG2_POL_PORT) & (1<<EG2_POL);
    1f70:	ed ed       	ldi	r30, 0xDD	; 221
    1f72:	f0 e0       	ldi	r31, 0x00	; 0
    1f74:	20 81       	ld	r18, Z
	analog_sw_byte ^= (-BMOD_SW_ON ^ analog_sw_byte) & (1<<3);//set third bit dependent on BMOD switch state
	update_analog_switch_latch(analog_sw_byte);
					
	//set EG2 INV bit. This changes the nth bit to x from: http://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit-in-c-c
	//need to make sure this doesn't interfere with anything else on this port
	uint8_t EG2_INV_ON = (switch_states.byte2 >> EG2_INV_SW) & 1;	
    1f76:	90 91 84 03 	lds	r25, 0x0384
    1f7a:	96 95       	lsr	r25
    1f7c:	96 95       	lsr	r25
    1f7e:	96 95       	lsr	r25
    1f80:	91 70       	andi	r25, 0x01	; 1
	EG2_POL_PORT ^= (-EG2_INV_ON ^ EG2_POL_PORT) & (1<<EG2_POL);
    1f82:	91 95       	neg	r25
    1f84:	80 81       	ld	r24, Z
    1f86:	89 27       	eor	r24, r25
    1f88:	80 71       	andi	r24, 0x10	; 16
    1f8a:	82 27       	eor	r24, r18
    1f8c:	80 83       	st	Z, r24
	current_patch.byte_1 ^= (-EG2_INV_ON ^ current_patch.byte_1) & (1 << EG2_INV); //don't forget to set it in patch or it won't be saved!
    1f8e:	e2 e0       	ldi	r30, 0x02	; 2
    1f90:	f3 e0       	ldi	r31, 0x03	; 3
    1f92:	80 81       	ld	r24, Z
    1f94:	98 27       	eor	r25, r24
    1f96:	91 70       	andi	r25, 0x01	; 1
    1f98:	89 27       	eor	r24, r25
    1f9a:	80 83       	st	Z, r24
	
	//parse octave switch data
	update_octave_range();
    1f9c:	0e 94 5d 0d 	call	0x1aba	; 0x1aba <update_octave_range>
	
	//parse LFO data
	update_lfo_shape();
    1fa0:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <update_lfo_shape>
	
	//parse LFO sync data
	update_lfo_sync();
    1fa4:	0e 94 18 0e 	call	0x1c30	; 0x1c30 <update_lfo_sync>

	//update arp settings
	update_arp_sync();
    1fa8:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <update_arp_sync>
	update_arp_range();
    1fac:	0e 94 c3 0e 	call	0x1d86	; 0x1d86 <update_arp_range>
	update_arp_mode();
    1fb0:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <update_arp_mode>
	//update_patch_programmer();		
				

		
	
}
    1fb4:	08 95       	ret

00001fb6 <update_patch_programmer>:





void update_patch_programmer(void) { //maybe best to use a switch/case statement here instead of a series of if/elses?
    1fb6:	cf 93       	push	r28
    1fb8:	df 93       	push	r29
	
	if (current_patch.mode == CAL) //temporary tune button hack by pressing and holding PROG DOWN switch
    1fba:	90 91 0b 03 	lds	r25, 0x030B
    1fbe:	95 30       	cpi	r25, 0x05	; 5
    1fc0:	01 f5       	brne	.+64     	; 0x2002 <update_patch_programmer+0x4c>
	{
		
		
		//TURN OFF LFO OUTPUT
		DATA_BUS = 0b00000111; //turn off LFO waveform
    1fc2:	87 e0       	ldi	r24, 0x07	; 7
    1fc4:	82 b9       	out	0x02, r24	; 2
		LFO_LATCH_PORT |= (1<<LFO_SW_LATCH);
    1fc6:	cd ed       	ldi	r28, 0xDD	; 221
    1fc8:	d0 e0       	ldi	r29, 0x00	; 0
    1fca:	88 81       	ld	r24, Y
    1fcc:	80 62       	ori	r24, 0x20	; 32
    1fce:	88 83       	st	Y, r24
		LFO_LATCH_PORT &= ~(1<<LFO_SW_LATCH);
    1fd0:	88 81       	ld	r24, Y
    1fd2:	8f 7d       	andi	r24, 0xDF	; 223
    1fd4:	88 83       	st	Y, r24
		DATA_BUS = 0;
    1fd6:	12 b8       	out	0x02, r1	; 2
		
		tune();
    1fd8:	0e 94 5a 16 	call	0x2cb4	; 0x2cb4 <tune>
		
		DATA_BUS = LFO_TRI_ADDR;
    1fdc:	12 b8       	out	0x02, r1	; 2
		LFO_LATCH_PORT |= (1<<LFO_SW_LATCH);
    1fde:	88 81       	ld	r24, Y
    1fe0:	80 62       	ori	r24, 0x20	; 32
    1fe2:	88 83       	st	Y, r24
		LFO_LATCH_PORT &= ~(1<<LFO_SW_LATCH);
    1fe4:	88 81       	ld	r24, Y
    1fe6:	8f 7d       	andi	r24, 0xDF	; 223
    1fe8:	88 83       	st	Y, r24
		DATA_BUS = 0;
    1fea:	12 b8       	out	0x02, r1	; 2
		current_patch.byte_2 &= 0b00001111; //clear top 4 bits
    1fec:	80 91 03 03 	lds	r24, 0x0303
    1ff0:	8f 70       	andi	r24, 0x0F	; 15
		current_patch.byte_2 |= (1<<LFO_TRI);
    1ff2:	80 68       	ori	r24, 0x80	; 128
    1ff4:	80 93 03 03 	sts	0x0303, r24
		
		setup_system_clock(); //restore system clock settings
    1ff8:	0e 94 e9 01 	call	0x3d2	; 0x3d2 <setup_system_clock>

		current_patch.mode = MEMORY;
    1ffc:	10 92 0b 03 	sts	0x030B, r1
		
		return;
    2000:	63 c0       	rjmp	.+198    	; 0x20c8 <update_patch_programmer+0x112>
		
	}
	

	
	if ((switch_states.byte2>> PROG_UP_SW) & 1) {
    2002:	80 91 84 03 	lds	r24, 0x0384
    2006:	28 2f       	mov	r18, r24
    2008:	22 95       	swap	r18
    200a:	26 95       	lsr	r18
    200c:	26 95       	lsr	r18
    200e:	23 70       	andi	r18, 0x03	; 3
    2010:	20 ff       	sbrs	r18, 0
    2012:	15 c0       	rjmp	.+42     	; 0x203e <update_patch_programmer+0x88>
		
		switch_states.byte2 ^= (1<<PROG_UP_SW); //toggle switch state bit
    2014:	20 e4       	ldi	r18, 0x40	; 64
    2016:	82 27       	eor	r24, r18
    2018:	80 93 84 03 	sts	0x0384, r24
		
		if (++current_patch.number == NUM_PATCHES + 1) {			
    201c:	80 91 07 03 	lds	r24, 0x0307
    2020:	8f 5f       	subi	r24, 0xFF	; 255
    2022:	80 93 07 03 	sts	0x0307, r24
    2026:	85 32       	cpi	r24, 0x25	; 37
    2028:	21 f4       	brne	.+8      	; 0x2032 <update_patch_programmer+0x7c>
			
			current_patch.number = NUM_PATCHES; //max patch number
    202a:	84 e2       	ldi	r24, 0x24	; 36
    202c:	80 93 07 03 	sts	0x0307, r24
    2030:	06 c0       	rjmp	.+12     	; 0x203e <update_patch_programmer+0x88>
		
					
		} else if (current_patch.mode != WRITE) { //load next patch if not in WRITE mode
    2032:	93 30       	cpi	r25, 0x03	; 3
    2034:	21 f0       	breq	.+8      	; 0x203e <update_patch_programmer+0x88>
			
			load_patch(current_patch.number);
    2036:	0e 94 6d 0a 	call	0x14da	; 0x14da <load_patch>
			update_patch();
    203a:	0e 94 4e 0f 	call	0x1e9c	; 0x1e9c <update_patch>
			
		}		
		
	}
	
	if ((switch_states.byte2 >> PROG_DOWN_SW) & 1) {
    203e:	80 91 84 03 	lds	r24, 0x0384
    2042:	98 2f       	mov	r25, r24
    2044:	92 95       	swap	r25
    2046:	96 95       	lsr	r25
    2048:	97 70       	andi	r25, 0x07	; 7
    204a:	90 ff       	sbrs	r25, 0
    204c:	15 c0       	rjmp	.+42     	; 0x2078 <update_patch_programmer+0xc2>
	
		switch_states.byte2 ^= (1<<PROG_DOWN_SW); //toggle switch state bit
    204e:	90 e2       	ldi	r25, 0x20	; 32
    2050:	89 27       	eor	r24, r25
    2052:	80 93 84 03 	sts	0x0384, r24

		if (current_patch.number == 1) {} else {current_patch.number--;}
    2056:	80 91 07 03 	lds	r24, 0x0307
    205a:	81 30       	cpi	r24, 0x01	; 1
    205c:	19 f0       	breq	.+6      	; 0x2064 <update_patch_programmer+0xae>
    205e:	81 50       	subi	r24, 0x01	; 1
    2060:	80 93 07 03 	sts	0x0307, r24
		
		if (current_patch.mode != WRITE) {
    2064:	80 91 0b 03 	lds	r24, 0x030B
    2068:	83 30       	cpi	r24, 0x03	; 3
    206a:	31 f0       	breq	.+12     	; 0x2078 <update_patch_programmer+0xc2>
			
			load_patch(current_patch.number); 
    206c:	80 91 07 03 	lds	r24, 0x0307
    2070:	0e 94 6d 0a 	call	0x14da	; 0x14da <load_patch>
			update_patch();
    2074:	0e 94 4e 0f 	call	0x1e9c	; 0x1e9c <update_patch>
		}			
	}
	
	
	if ((switch_states.byte2 >> PROG_WRITE_SW) & 1) {
    2078:	80 91 84 03 	lds	r24, 0x0384
    207c:	98 2f       	mov	r25, r24
    207e:	92 95       	swap	r25
    2080:	9f 70       	andi	r25, 0x0F	; 15
    2082:	90 ff       	sbrs	r25, 0
    2084:	15 c0       	rjmp	.+42     	; 0x20b0 <update_patch_programmer+0xfa>
		
		switch_states.byte2 ^= (1<<PROG_WRITE_SW);
    2086:	90 e1       	ldi	r25, 0x10	; 16
    2088:	89 27       	eor	r24, r25
    208a:	80 93 84 03 	sts	0x0384, r24
		if (current_patch.mode != WRITE) {
    208e:	90 91 0b 03 	lds	r25, 0x030B
    2092:	93 30       	cpi	r25, 0x03	; 3
    2094:	49 f0       	breq	.+18     	; 0x20a8 <update_patch_programmer+0xf2>
			switch_states.byte2 &= ~(1<< PROG_MANUAL_SW); //turn off manual mode
    2096:	8f 77       	andi	r24, 0x7F	; 127
    2098:	80 93 84 03 	sts	0x0384, r24
			current_patch.mode = WRITE;
    209c:	83 e0       	ldi	r24, 0x03	; 3
    209e:	80 93 0b 03 	sts	0x030B, r24
			lock_pots();
    20a2:	0e 94 4f 08 	call	0x109e	; 0x109e <lock_pots>
    20a6:	04 c0       	rjmp	.+8      	; 0x20b0 <update_patch_programmer+0xfa>
			
			
		} else {
			
			save_patch(current_patch.number); //write the patch
    20a8:	80 91 07 03 	lds	r24, 0x0307
    20ac:	0e 94 7a 08 	call	0x10f4	; 0x10f4 <save_patch>
		//save_patch(current_patch.number);
		
		
	}
	
	if (((switch_states.byte2 >> PROG_MANUAL_SW) & 1)) {
    20b0:	80 91 84 03 	lds	r24, 0x0384
    20b4:	88 23       	and	r24, r24
    20b6:	44 f4       	brge	.+16     	; 0x20c8 <update_patch_programmer+0x112>
			
		switch_states.byte2 |= (1<< PROG_MANUAL_SW);
    20b8:	80 68       	ori	r24, 0x80	; 128
    20ba:	80 93 84 03 	sts	0x0384, r24
		current_patch.mode = MANUAL;
    20be:	81 e0       	ldi	r24, 0x01	; 1
    20c0:	80 93 0b 03 	sts	0x030B, r24
		unlock_pots();
    20c4:	0e 94 69 08 	call	0x10d2	; 0x10d2 <unlock_pots>
	}
	//value_to_display = current_patch.number;	
	//value_to_display = vco1_init_cv>>1;
	
	
}	
    20c8:	df 91       	pop	r29
    20ca:	cf 91       	pop	r28
    20cc:	08 95       	ret

000020ce <initialize_voice_for_tuning>:
	

void initialize_voice_for_tuning(void) { //this function sets all CVs required for oscillator tuning
	

	set_control_voltage(&volume_cv, MIN); //turn volume all the way down
    20ce:	88 ed       	ldi	r24, 0xD8	; 216
    20d0:	91 e0       	ldi	r25, 0x01	; 1
    20d2:	60 e0       	ldi	r22, 0x00	; 0
    20d4:	70 e0       	ldi	r23, 0x00	; 0
    20d6:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	//turn off all pitch modulation
	set_control_voltage(&pitch_lfo_cv, MIN);
    20da:	81 ee       	ldi	r24, 0xE1	; 225
    20dc:	91 e0       	ldi	r25, 0x01	; 1
    20de:	60 e0       	ldi	r22, 0x00	; 0
    20e0:	70 e0       	ldi	r23, 0x00	; 0
    20e2:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&pitch_eg2_cv, MIN);
    20e6:	82 ee       	ldi	r24, 0xE2	; 226
    20e8:	91 e0       	ldi	r25, 0x01	; 1
    20ea:	60 e0       	ldi	r22, 0x00	; 0
    20ec:	70 e0       	ldi	r23, 0x00	; 0
    20ee:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&pitch_vco2_cv, MIN);
    20f2:	87 eb       	ldi	r24, 0xB7	; 183
    20f4:	92 e0       	ldi	r25, 0x02	; 2
    20f6:	60 e0       	ldi	r22, 0x00	; 0
    20f8:	70 e0       	ldi	r23, 0x00	; 0
    20fa:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	//turn off glide
	set_control_voltage(&glide_cv, MIN);
    20fe:	8a ed       	ldi	r24, 0xDA	; 218
    2100:	91 e0       	ldi	r25, 0x01	; 1
    2102:	60 e0       	ldi	r22, 0x00	; 0
    2104:	70 e0       	ldi	r23, 0x00	; 0
    2106:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	//turn off all pulse width modulation
	set_control_voltage(&pwm_eg2_cv, MIN);
    210a:	8f ed       	ldi	r24, 0xDF	; 223
    210c:	91 e0       	ldi	r25, 0x01	; 1
    210e:	60 e0       	ldi	r22, 0x00	; 0
    2110:	70 e0       	ldi	r23, 0x00	; 0
    2112:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&pwm_lfo_cv, MIN);
    2116:	80 ee       	ldi	r24, 0xE0	; 224
    2118:	91 e0       	ldi	r25, 0x01	; 1
    211a:	60 e0       	ldi	r22, 0x00	; 0
    211c:	70 e0       	ldi	r23, 0x00	; 0
    211e:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	//turn off all filter modulation
	set_control_voltage(&fil_lfo_cv, MIN);
    2122:	81 ed       	ldi	r24, 0xD1	; 209
    2124:	91 e0       	ldi	r25, 0x01	; 1
    2126:	60 e0       	ldi	r22, 0x00	; 0
    2128:	70 e0       	ldi	r23, 0x00	; 0
    212a:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&fil_eg2_cv, MIN);
    212e:	86 ed       	ldi	r24, 0xD6	; 214
    2130:	91 e0       	ldi	r25, 0x01	; 1
    2132:	60 e0       	ldi	r22, 0x00	; 0
    2134:	70 e0       	ldi	r23, 0x00	; 0
    2136:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&fil_vco2_cv, MIN);
    213a:	82 ed       	ldi	r24, 0xD2	; 210
    213c:	91 e0       	ldi	r25, 0x01	; 1
    213e:	60 e0       	ldi	r22, 0x00	; 0
    2140:	70 e0       	ldi	r23, 0x00	; 0
    2142:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&key_track_cv, MIN);
    2146:	83 ed       	ldi	r24, 0xD3	; 211
    2148:	91 e0       	ldi	r25, 0x01	; 1
    214a:	60 e0       	ldi	r22, 0x00	; 0
    214c:	70 e0       	ldi	r23, 0x00	; 0
    214e:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	//open filter with no resonance
	set_control_voltage(&cutoff_cv, MAX);
    2152:	84 ed       	ldi	r24, 0xD4	; 212
    2154:	91 e0       	ldi	r25, 0x01	; 1
    2156:	6f ef       	ldi	r22, 0xFF	; 255
    2158:	7f e3       	ldi	r23, 0x3F	; 63
    215a:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&res_cv, MIN);
    215e:	85 ed       	ldi	r24, 0xD5	; 213
    2160:	91 e0       	ldi	r25, 0x01	; 1
    2162:	60 e0       	ldi	r22, 0x00	; 0
    2164:	70 e0       	ldi	r23, 0x00	; 0
    2166:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	//turn off VCA LFO modulation
	set_control_voltage(&amp_lfo_cv, MIN);
    216a:	89 ed       	ldi	r24, 0xD9	; 217
    216c:	91 e0       	ldi	r25, 0x01	; 1
    216e:	60 e0       	ldi	r22, 0x00	; 0
    2170:	70 e0       	ldi	r23, 0x00	; 0
    2172:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	//initialize VCA envelope
	set_control_voltage(&attack_1_cv, MIN);
    2176:	8e ec       	ldi	r24, 0xCE	; 206
    2178:	91 e0       	ldi	r25, 0x01	; 1
    217a:	60 e0       	ldi	r22, 0x00	; 0
    217c:	70 e0       	ldi	r23, 0x00	; 0
    217e:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&decay_1_cv, MIN);
    2182:	8c ec       	ldi	r24, 0xCC	; 204
    2184:	91 e0       	ldi	r25, 0x01	; 1
    2186:	60 e0       	ldi	r22, 0x00	; 0
    2188:	70 e0       	ldi	r23, 0x00	; 0
    218a:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&sustain_1_cv, MAX);
    218e:	8a ec       	ldi	r24, 0xCA	; 202
    2190:	91 e0       	ldi	r25, 0x01	; 1
    2192:	6f ef       	ldi	r22, 0xFF	; 255
    2194:	7f e3       	ldi	r23, 0x3F	; 63
    2196:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&release_1_cv, MIN);
    219a:	88 ec       	ldi	r24, 0xC8	; 200
    219c:	91 e0       	ldi	r25, 0x01	; 1
    219e:	60 e0       	ldi	r22, 0x00	; 0
    21a0:	70 e0       	ldi	r23, 0x00	; 0
    21a2:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	//turn off noise
	set_control_voltage(&noise_mix_cv, MIN);
    21a6:	80 ed       	ldi	r24, 0xD0	; 208
    21a8:	91 e0       	ldi	r25, 0x01	; 1
    21aa:	60 e0       	ldi	r22, 0x00	; 0
    21ac:	70 e0       	ldi	r23, 0x00	; 0
    21ae:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&vco1_mix_cv, MIN);
    21b2:	83 ee       	ldi	r24, 0xE3	; 227
    21b4:	91 e0       	ldi	r25, 0x01	; 1
    21b6:	60 e0       	ldi	r22, 0x00	; 0
    21b8:	70 e0       	ldi	r23, 0x00	; 0
    21ba:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&vco2_mix_cv, MIN);
    21be:	84 ee       	ldi	r24, 0xE4	; 228
    21c0:	91 e0       	ldi	r25, 0x01	; 1
    21c2:	60 e0       	ldi	r22, 0x00	; 0
    21c4:	70 e0       	ldi	r23, 0x00	; 0
    21c6:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
}	
    21ca:	08 95       	ret

000021cc <set_vco_init_cv>:
	
uint16_t set_vco_init_cv(uint8_t vco, uint16_t base_reference) { 
    21cc:	2f 92       	push	r2
    21ce:	3f 92       	push	r3
    21d0:	4f 92       	push	r4
    21d2:	5f 92       	push	r5
    21d4:	6f 92       	push	r6
    21d6:	7f 92       	push	r7
    21d8:	8f 92       	push	r8
    21da:	9f 92       	push	r9
    21dc:	af 92       	push	r10
    21de:	bf 92       	push	r11
    21e0:	cf 92       	push	r12
    21e2:	df 92       	push	r13
    21e4:	ef 92       	push	r14
    21e6:	ff 92       	push	r15
    21e8:	0f 93       	push	r16
    21ea:	1f 93       	push	r17
    21ec:	cf 93       	push	r28
    21ee:	df 93       	push	r29
    21f0:	cd b7       	in	r28, 0x3d	; 61
    21f2:	de b7       	in	r29, 0x3e	; 62
    21f4:	2c 97       	sbiw	r28, 0x0c	; 12
    21f6:	0f b6       	in	r0, 0x3f	; 63
    21f8:	f8 94       	cli
    21fa:	de bf       	out	0x3e, r29	; 62
    21fc:	0f be       	out	0x3f, r0	; 63
    21fe:	cd bf       	out	0x3d, r28	; 61
    2200:	08 2f       	mov	r16, r24
    2202:	78 87       	std	Y+8, r23	; 0x08
    2204:	6f 83       	std	Y+7, r22	; 0x07

	uint16_t init_cv = 0;
	timer1_clock |= (1<<CS11) | (1<<CS10);
    2206:	80 91 7f 03 	lds	r24, 0x037F
    220a:	83 60       	ori	r24, 0x03	; 3
    220c:	80 93 7f 03 	sts	0x037F, r24
	 
	//TO DO: disable UART so MIDI data doesn't interrupt tuning
	
	//setup control voltages	
	initialize_voice_for_tuning();
    2210:	0e 94 67 10 	call	0x20ce	; 0x20ce <initialize_voice_for_tuning>
	struct control_voltage *vco_init_cv;
	struct control_voltage *vco_mix_cv;
	struct control_voltage *vco_pw_cv;
	struct control_voltage *vco_pitch_cv;

	count_finished = FALSE;
    2214:	10 92 7e 03 	sts	0x037E, r1
	
	if (vco == VCO1) { //turn on VCO1 pulse
    2218:	0f 30       	cpi	r16, 0x0F	; 15
    221a:	e1 f4       	brne	.+56     	; 0x2254 <set_vco_init_cv+0x88>
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
		vco_mix_cv = &vco1_mix_cv;
		vco_pw_cv = &vco1_pw_cv;
		vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
    221c:	0f 2e       	mov	r0, r31
    221e:	f6 ee       	ldi	r31, 0xE6	; 230
    2220:	4f 2e       	mov	r4, r31
    2222:	f1 e0       	ldi	r31, 0x01	; 1
    2224:	5f 2e       	mov	r5, r31
    2226:	f0 2d       	mov	r31, r0
	if (vco == VCO1) { //turn on VCO1 pulse
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
		vco_mix_cv = &vco1_mix_cv;
		vco_pw_cv = &vco1_pw_cv;
    2228:	0f 2e       	mov	r0, r31
    222a:	fe ed       	ldi	r31, 0xDE	; 222
    222c:	2f 2e       	mov	r2, r31
    222e:	f1 e0       	ldi	r31, 0x01	; 1
    2230:	3f 2e       	mov	r3, r31
    2232:	f0 2d       	mov	r31, r0
	
	if (vco == VCO1) { //turn on VCO1 pulse
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
		vco_mix_cv = &vco1_mix_cv;
    2234:	23 ee       	ldi	r18, 0xE3	; 227
    2236:	31 e0       	ldi	r19, 0x01	; 1
    2238:	3a 83       	std	Y+2, r19	; 0x02
    223a:	29 83       	std	Y+1, r18	; 0x01
	count_finished = FALSE;
	
	if (vco == VCO1) { //turn on VCO1 pulse
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
    223c:	0f 2e       	mov	r0, r31
    223e:	fc ed       	ldi	r31, 0xDC	; 220
    2240:	8f 2e       	mov	r8, r31
    2242:	f1 e0       	ldi	r31, 0x01	; 1
    2244:	9f 2e       	mov	r9, r31
    2246:	f0 2d       	mov	r31, r0
		vco_mix_cv = &vco1_mix_cv;
		vco_pw_cv = &vco1_pw_cv;
		vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
		reference_count = base_reference;//38222; //make this an argument passed to function
		eeprom_addr = &vco1_init_cv_eeprom;
    2248:	82 e7       	ldi	r24, 0x72	; 114
    224a:	96 e0       	ldi	r25, 0x06	; 6
    224c:	9a 87       	std	Y+10, r25	; 0x0a
    224e:	89 87       	std	Y+9, r24	; 0x09

	count_finished = FALSE;
	
	if (vco == VCO1) { //turn on VCO1 pulse
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
    2250:	81 e0       	ldi	r24, 0x01	; 1
    2252:	1b c0       	rjmp	.+54     	; 0x228a <set_vco_init_cv+0xbe>
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
		vco_mix_cv = &vco2_mix_cv;
		vco_pw_cv = &vco2_pw_cv;
		vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
    2254:	0f 2e       	mov	r0, r31
    2256:	f5 ee       	ldi	r31, 0xE5	; 229
    2258:	4f 2e       	mov	r4, r31
    225a:	f1 e0       	ldi	r31, 0x01	; 1
    225c:	5f 2e       	mov	r5, r31
    225e:	f0 2d       	mov	r31, r0
	} else { //turn on VCO2 pulse	
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
		vco_mix_cv = &vco2_mix_cv;
		vco_pw_cv = &vco2_pw_cv;
    2260:	0f 2e       	mov	r0, r31
    2262:	f7 ed       	ldi	r31, 0xD7	; 215
    2264:	2f 2e       	mov	r2, r31
    2266:	f1 e0       	ldi	r31, 0x01	; 1
    2268:	3f 2e       	mov	r3, r31
    226a:	f0 2d       	mov	r31, r0
		
	} else { //turn on VCO2 pulse	
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
		vco_mix_cv = &vco2_mix_cv;
    226c:	e4 ee       	ldi	r30, 0xE4	; 228
    226e:	f1 e0       	ldi	r31, 0x01	; 1
    2270:	fa 83       	std	Y+2, r31	; 0x02
    2272:	e9 83       	std	Y+1, r30	; 0x01
		eeprom_addr = &vco1_init_cv_eeprom;
		
	} else { //turn on VCO2 pulse	
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
    2274:	0f 2e       	mov	r0, r31
    2276:	fd ed       	ldi	r31, 0xDD	; 221
    2278:	8f 2e       	mov	r8, r31
    227a:	f1 e0       	ldi	r31, 0x01	; 1
    227c:	9f 2e       	mov	r9, r31
    227e:	f0 2d       	mov	r31, r0
		vco_mix_cv = &vco2_mix_cv;
		vco_pw_cv = &vco2_pw_cv;
		vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
		reference_count = base_reference;
		eeprom_addr = &vco2_init_cv_eeprom;
    2280:	20 e7       	ldi	r18, 0x70	; 112
    2282:	36 e0       	ldi	r19, 0x06	; 6
    2284:	3a 87       	std	Y+10, r19	; 0x0a
    2286:	29 87       	std	Y+9, r18	; 0x09
		reference_count = base_reference;//38222; //make this an argument passed to function
		eeprom_addr = &vco1_init_cv_eeprom;
		
	} else { //turn on VCO2 pulse	
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
    2288:	80 e4       	ldi	r24, 0x40	; 64
		reference_count = base_reference;
		eeprom_addr = &vco2_init_cv_eeprom;
	}
	
	//latch switch data
	DATA_BUS = switch_byte;
    228a:	82 b9       	out	0x02, r24	; 2
	VCO_SW_LATCH_PORT |= (1<<VCO_SW_LATCH);
    228c:	ed ed       	ldi	r30, 0xDD	; 221
    228e:	f0 e0       	ldi	r31, 0x00	; 0
    2290:	80 81       	ld	r24, Z
    2292:	80 64       	ori	r24, 0x40	; 64
    2294:	80 83       	st	Z, r24
	//_delay_us(1); //why is this delay here????
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    2296:	80 81       	ld	r24, Z
    2298:	8f 7b       	andi	r24, 0xBF	; 191
    229a:	80 83       	st	Z, r24
	DATA_BUS = 0;
    229c:	12 b8       	out	0x02, r1	; 2

	PORTF |= (1<<GATE); //turn gate on
    229e:	89 9a       	sbi	0x11, 1	; 17
	
	//set up timer/counter0 to be clocked by T0 input
	
	TCCR0A |= (1<<CS02) | (1<<CS01) | (1<<CS00) | (1<<WGM01); //clocked by external T0 pin, rising edge + clear timer on compare match
    22a0:	84 b5       	in	r24, 0x24	; 36
    22a2:	8f 60       	ori	r24, 0x0F	; 15
    22a4:	84 bd       	out	0x24, r24	; 36
	OCR0A = 1; //output compare register - set to number of periods to be counted. OCR0A needs to be set to (periods_to_be_counted - 1)
    22a6:	81 e0       	ldi	r24, 0x01	; 1
    22a8:	87 bd       	out	0x27, r24	; 39
	//set OCR0A to 1 here means first ISR interrupt will occur after 2 periods, it is then set to 0 to count only single periods
	//for reasons I don't understand yet, starting with OCR0A set to 0 results in a multi-second delay before first compare match ISR is called ***ACTUALLY, THIS MAY BE RELATED TO LEAVING Timer0 RUNNING. COULD TRY TO SET OCR0A TO 0 NOW and SEE IF IT WORKS
	TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt	
    22aa:	ee e6       	ldi	r30, 0x6E	; 110
    22ac:	f0 e0       	ldi	r31, 0x00	; 0
    22ae:	90 81       	ld	r25, Z
    22b0:	92 60       	ori	r25, 0x02	; 2
    22b2:	90 83       	st	Z, r25
	period = 1; //only counting 1 period 
    22b4:	80 93 80 03 	sts	0x0380, r24
	for (int dac_bit = 13; dac_bit >= 0; dac_bit--) {
    22b8:	8d e0       	ldi	r24, 0x0D	; 13
    22ba:	90 e0       	ldi	r25, 0x00	; 0
    22bc:	9c 83       	std	Y+4, r25	; 0x04
    22be:	8b 83       	std	Y+3, r24	; 0x03
		//enable watchdog timer
		//WDTCR |= (1<<WDP2) | (1<<WDP1) | (1<<WDP0) | (1<<WDE)| (1<<WDCE);
		wdt_enable(WDTO_2S);
		while (count_finished == FALSE) { //need to have a watchdog timer here to escape while loop if it takes too long
			
			update_display(vco + 1, DEC);
    22c0:	80 2f       	mov	r24, r16
    22c2:	90 e0       	ldi	r25, 0x00	; 0
    22c4:	8c 01       	movw	r16, r24
    22c6:	0f 5f       	subi	r16, 0xFF	; 255
    22c8:	1f 4f       	sbci	r17, 0xFF	; 255
		
			set_control_voltage(vco_init_cv, init_cv);
			set_control_voltage(vco_pw_cv, MAX);
			set_control_voltage(&volume_cv, MIN);
    22ca:	0f 2e       	mov	r0, r31
    22cc:	f8 ed       	ldi	r31, 0xD8	; 216
    22ce:	ef 2e       	mov	r14, r31
    22d0:	f1 e0       	ldi	r31, 0x01	; 1
    22d2:	ff 2e       	mov	r15, r31
    22d4:	f0 2d       	mov	r31, r0
			set_control_voltage(&cutoff_cv, MAX);
    22d6:	0f 2e       	mov	r0, r31
    22d8:	f4 ed       	ldi	r31, 0xD4	; 212
    22da:	cf 2e       	mov	r12, r31
    22dc:	f1 e0       	ldi	r31, 0x01	; 1
    22de:	df 2e       	mov	r13, r31
    22e0:	f0 2d       	mov	r31, r0
			set_control_voltage(&sustain_1_cv, MAX);
    22e2:	0f 2e       	mov	r0, r31
    22e4:	fa ec       	ldi	r31, 0xCA	; 202
    22e6:	af 2e       	mov	r10, r31
    22e8:	f1 e0       	ldi	r31, 0x01	; 1
    22ea:	bf 2e       	mov	r11, r31
    22ec:	f0 2d       	mov	r31, r0
			set_control_voltage(&sustain_2_cv, MAX); //can't remember is EG1 for VCA or EG2????
    22ee:	0f 2e       	mov	r0, r31
    22f0:	fb ec       	ldi	r31, 0xCB	; 203
    22f2:	6f 2e       	mov	r6, r31
    22f4:	f1 e0       	ldi	r31, 0x01	; 1
    22f6:	7f 2e       	mov	r7, r31
    22f8:	f0 2d       	mov	r31, r0
    22fa:	e0 e0       	ldi	r30, 0x00	; 0
    22fc:	f0 e0       	ldi	r31, 0x00	; 0
    22fe:	fc 87       	std	Y+12, r31	; 0x0c
    2300:	eb 87       	std	Y+11, r30	; 0x0b
	//for reasons I don't understand yet, starting with OCR0A set to 0 results in a multi-second delay before first compare match ISR is called ***ACTUALLY, THIS MAY BE RELATED TO LEAVING Timer0 RUNNING. COULD TRY TO SET OCR0A TO 0 NOW and SEE IF IT WORKS
	TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt	
	period = 1; //only counting 1 period 
	for (int dac_bit = 13; dac_bit >= 0; dac_bit--) {
	
		init_cv |= (1<<dac_bit);
    2302:	21 e0       	ldi	r18, 0x01	; 1
    2304:	30 e0       	ldi	r19, 0x00	; 0
    2306:	0b 80       	ldd	r0, Y+3	; 0x03
    2308:	02 c0       	rjmp	.+4      	; 0x230e <set_vco_init_cv+0x142>
    230a:	22 0f       	add	r18, r18
    230c:	33 1f       	adc	r19, r19
    230e:	0a 94       	dec	r0
    2310:	e2 f7       	brpl	.-8      	; 0x230a <set_vco_init_cv+0x13e>
    2312:	3e 83       	std	Y+6, r19	; 0x06
    2314:	2d 83       	std	Y+5, r18	; 0x05
    2316:	8b 85       	ldd	r24, Y+11	; 0x0b
    2318:	9c 85       	ldd	r25, Y+12	; 0x0c
    231a:	82 2b       	or	r24, r18
    231c:	93 2b       	or	r25, r19
    231e:	9c 87       	std	Y+12, r25	; 0x0c
    2320:	8b 87       	std	Y+11, r24	; 0x0b
		
		set_control_voltage(vco_init_cv, init_cv);
    2322:	c4 01       	movw	r24, r8
    2324:	6b 85       	ldd	r22, Y+11	; 0x0b
    2326:	7c 85       	ldd	r23, Y+12	; 0x0c
    2328:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
		
		
		count_finished = FALSE;
    232c:	10 92 7e 03 	sts	0x037E, r1
		period_counter = 0;
    2330:	10 92 81 03 	sts	0x0381, r1
		//TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
		//enable watchdog timer
		//WDTCR |= (1<<WDP2) | (1<<WDP1) | (1<<WDP0) | (1<<WDE)| (1<<WDCE);
		wdt_enable(WDTO_2S);
    2334:	8f e0       	ldi	r24, 0x0F	; 15
    2336:	e8 e1       	ldi	r30, 0x18	; 24
    2338:	f0 e0       	ldi	r31, 0x00	; 0
    233a:	0f b6       	in	r0, 0x3f	; 63
    233c:	f8 94       	cli
    233e:	a8 95       	wdr
    2340:	e0 93 60 00 	sts	0x0060, r30
    2344:	0f be       	out	0x3f, r0	; 63
    2346:	80 93 60 00 	sts	0x0060, r24
		while (count_finished == FALSE) { //need to have a watchdog timer here to escape while loop if it takes too long
    234a:	80 91 7e 03 	lds	r24, 0x037E
    234e:	88 23       	and	r24, r24
    2350:	89 f5       	brne	.+98     	; 0x23b4 <set_vco_init_cv+0x1e8>
			
			update_display(vco + 1, DEC);
    2352:	c8 01       	movw	r24, r16
    2354:	60 e0       	ldi	r22, 0x00	; 0
    2356:	0e 94 35 03 	call	0x66a	; 0x66a <update_display>
		
			set_control_voltage(vco_init_cv, init_cv);
    235a:	c4 01       	movw	r24, r8
    235c:	6b 85       	ldd	r22, Y+11	; 0x0b
    235e:	7c 85       	ldd	r23, Y+12	; 0x0c
    2360:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
			set_control_voltage(vco_pw_cv, MAX);
    2364:	c1 01       	movw	r24, r2
    2366:	6f ef       	ldi	r22, 0xFF	; 255
    2368:	7f e3       	ldi	r23, 0x3F	; 63
    236a:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
			set_control_voltage(&volume_cv, MIN);
    236e:	c7 01       	movw	r24, r14
    2370:	60 e0       	ldi	r22, 0x00	; 0
    2372:	70 e0       	ldi	r23, 0x00	; 0
    2374:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
			set_control_voltage(&cutoff_cv, MAX);
    2378:	c6 01       	movw	r24, r12
    237a:	6f ef       	ldi	r22, 0xFF	; 255
    237c:	7f e3       	ldi	r23, 0x3F	; 63
    237e:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
			set_control_voltage(&sustain_1_cv, MAX);
    2382:	c5 01       	movw	r24, r10
    2384:	6f ef       	ldi	r22, 0xFF	; 255
    2386:	7f e3       	ldi	r23, 0x3F	; 63
    2388:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
			set_control_voltage(&sustain_2_cv, MAX); //can't remember is EG1 for VCA or EG2????
    238c:	c3 01       	movw	r24, r6
    238e:	6f ef       	ldi	r22, 0xFF	; 255
    2390:	7f e3       	ldi	r23, 0x3F	; 63
    2392:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
			set_control_voltage(vco_mix_cv, MAX);
    2396:	89 81       	ldd	r24, Y+1	; 0x01
    2398:	9a 81       	ldd	r25, Y+2	; 0x02
    239a:	6f ef       	ldi	r22, 0xFF	; 255
    239c:	7f e3       	ldi	r23, 0x3F	; 63
    239e:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
			set_control_voltage(vco_pitch_cv, 0);	
    23a2:	c2 01       	movw	r24, r4
    23a4:	60 e0       	ldi	r22, 0x00	; 0
    23a6:	70 e0       	ldi	r23, 0x00	; 0
    23a8:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
		period_counter = 0;
		//TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
		//enable watchdog timer
		//WDTCR |= (1<<WDP2) | (1<<WDP1) | (1<<WDP0) | (1<<WDE)| (1<<WDCE);
		wdt_enable(WDTO_2S);
		while (count_finished == FALSE) { //need to have a watchdog timer here to escape while loop if it takes too long
    23ac:	80 91 7e 03 	lds	r24, 0x037E
    23b0:	88 23       	and	r24, r24
    23b2:	79 f2       	breq	.-98     	; 0x2352 <set_vco_init_cv+0x186>
			
		}
		//turn off watchdog timer
		//WDTCR |= (1<<WDCE) | (1<<WDE);
		//WDTCR = 0x00;
		wdt_disable();
    23b4:	88 e1       	ldi	r24, 0x18	; 24
    23b6:	0f b6       	in	r0, 0x3f	; 63
    23b8:	f8 94       	cli
    23ba:	80 93 60 00 	sts	0x0060, r24
    23be:	10 92 60 00 	sts	0x0060, r1
    23c2:	0f be       	out	0x3f, r0	; 63
		//remember that as INIT_CV goes up, pitch goes down, so looking for osc_count >= reference_count instead of <= as is the case for normal oscillator tuning
		//similarily, OR no_overflow == FALSE *not* AND no_overflow == FALSE to clear bits that make initial pitch too low
		if ((osc_count > reference_count)  || (no_overflow == FALSE)) init_cv &= ~(1 << dac_bit);
    23c4:	80 91 7c 03 	lds	r24, 0x037C
    23c8:	90 91 7d 03 	lds	r25, 0x037D
    23cc:	ef 81       	ldd	r30, Y+7	; 0x07
    23ce:	f8 85       	ldd	r31, Y+8	; 0x08
    23d0:	e8 17       	cp	r30, r24
    23d2:	f9 07       	cpc	r31, r25
    23d4:	20 f0       	brcs	.+8      	; 0x23de <set_vco_init_cv+0x212>
    23d6:	80 91 af 02 	lds	r24, 0x02AF
    23da:	88 23       	and	r24, r24
    23dc:	51 f4       	brne	.+20     	; 0x23f2 <set_vco_init_cv+0x226>
    23de:	8d 81       	ldd	r24, Y+5	; 0x05
    23e0:	9e 81       	ldd	r25, Y+6	; 0x06
    23e2:	80 95       	com	r24
    23e4:	90 95       	com	r25
    23e6:	2b 85       	ldd	r18, Y+11	; 0x0b
    23e8:	3c 85       	ldd	r19, Y+12	; 0x0c
    23ea:	28 23       	and	r18, r24
    23ec:	39 23       	and	r19, r25
    23ee:	3c 87       	std	Y+12, r19	; 0x0c
    23f0:	2b 87       	std	Y+11, r18	; 0x0b
		no_overflow = TRUE;
    23f2:	81 e0       	ldi	r24, 0x01	; 1
    23f4:	80 93 af 02 	sts	0x02AF, r24
	OCR0A = 1; //output compare register - set to number of periods to be counted. OCR0A needs to be set to (periods_to_be_counted - 1)
	//set OCR0A to 1 here means first ISR interrupt will occur after 2 periods, it is then set to 0 to count only single periods
	//for reasons I don't understand yet, starting with OCR0A set to 0 results in a multi-second delay before first compare match ISR is called ***ACTUALLY, THIS MAY BE RELATED TO LEAVING Timer0 RUNNING. COULD TRY TO SET OCR0A TO 0 NOW and SEE IF IT WORKS
	TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt	
	period = 1; //only counting 1 period 
	for (int dac_bit = 13; dac_bit >= 0; dac_bit--) {
    23f8:	8b 81       	ldd	r24, Y+3	; 0x03
    23fa:	9c 81       	ldd	r25, Y+4	; 0x04
    23fc:	01 97       	sbiw	r24, 0x01	; 1
    23fe:	9c 83       	std	Y+4, r25	; 0x04
    2400:	8b 83       	std	Y+3, r24	; 0x03
    2402:	ef ef       	ldi	r30, 0xFF	; 255
    2404:	8f 3f       	cpi	r24, 0xFF	; 255
    2406:	9e 07       	cpc	r25, r30
    2408:	09 f0       	breq	.+2      	; 0x240c <set_vco_init_cv+0x240>
    240a:	7b cf       	rjmp	.-266    	; 0x2302 <set_vco_init_cv+0x136>
    240c:	2b 85       	ldd	r18, Y+11	; 0x0b
    240e:	3c 85       	ldd	r19, Y+12	; 0x0c
    2410:	3e 83       	std	Y+6, r19	; 0x06
    2412:	2d 83       	std	Y+5, r18	; 0x05
		no_overflow = TRUE;
		
	}		
	
	//none of these help with clicking when returning from this function and starting to read pots	
	set_control_voltage(&release_1_cv, MIN); //this will hopefully reduce popping after returning from initializing pitch CV
    2414:	88 ec       	ldi	r24, 0xC8	; 200
    2416:	91 e0       	ldi	r25, 0x01	; 1
    2418:	60 e0       	ldi	r22, 0x00	; 0
    241a:	70 e0       	ldi	r23, 0x00	; 0
    241c:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&release_2_cv, MIN);
    2420:	89 ec       	ldi	r24, 0xC9	; 201
    2422:	91 e0       	ldi	r25, 0x01	; 1
    2424:	60 e0       	ldi	r22, 0x00	; 0
    2426:	70 e0       	ldi	r23, 0x00	; 0
    2428:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&cutoff_cv, MIN);
    242c:	84 ed       	ldi	r24, 0xD4	; 212
    242e:	91 e0       	ldi	r25, 0x01	; 1
    2430:	60 e0       	ldi	r22, 0x00	; 0
    2432:	70 e0       	ldi	r23, 0x00	; 0
    2434:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&volume_cv, MIN);
    2438:	88 ed       	ldi	r24, 0xD8	; 216
    243a:	91 e0       	ldi	r25, 0x01	; 1
    243c:	60 e0       	ldi	r22, 0x00	; 0
    243e:	70 e0       	ldi	r23, 0x00	; 0
    2440:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
		
	PORTF &= ~(1<<GATE); //turn gate off
    2444:	89 98       	cbi	0x11, 1	; 17
	
	TIMSK0 &= ~(1<<OCIE0A); //turn off compare match A interrupt
    2446:	ee e6       	ldi	r30, 0x6E	; 110
    2448:	f0 e0       	ldi	r31, 0x00	; 0
    244a:	80 81       	ld	r24, Z
    244c:	8d 7f       	andi	r24, 0xFD	; 253
    244e:	80 83       	st	Z, r24
	TCCR0A = 0; //turn off timer0 period timer
    2450:	14 bc       	out	0x24, r1	; 36
	//} else {
		//
		//eeprom_update_word(&vco2_init_cv_eeprom, init_cv);
	//}				
		
	eeprom_update_word(eeprom_addr, init_cv);
    2452:	89 85       	ldd	r24, Y+9	; 0x09
    2454:	9a 85       	ldd	r25, Y+10	; 0x0a
    2456:	6d 81       	ldd	r22, Y+5	; 0x05
    2458:	7e 81       	ldd	r23, Y+6	; 0x06
    245a:	0e 94 d0 1e 	call	0x3da0	; 0x3da0 <__eeupd_word_m6450a>
	//value_to_display = eeprom_read_word(&vco1_init_cv_eeprom);	

	
	return init_cv;
	
}
    245e:	8d 81       	ldd	r24, Y+5	; 0x05
    2460:	9e 81       	ldd	r25, Y+6	; 0x06
    2462:	2c 96       	adiw	r28, 0x0c	; 12
    2464:	0f b6       	in	r0, 0x3f	; 63
    2466:	f8 94       	cli
    2468:	de bf       	out	0x3e, r29	; 62
    246a:	0f be       	out	0x3f, r0	; 63
    246c:	cd bf       	out	0x3d, r28	; 61
    246e:	df 91       	pop	r29
    2470:	cf 91       	pop	r28
    2472:	1f 91       	pop	r17
    2474:	0f 91       	pop	r16
    2476:	ff 90       	pop	r15
    2478:	ef 90       	pop	r14
    247a:	df 90       	pop	r13
    247c:	cf 90       	pop	r12
    247e:	bf 90       	pop	r11
    2480:	af 90       	pop	r10
    2482:	9f 90       	pop	r9
    2484:	8f 90       	pop	r8
    2486:	7f 90       	pop	r7
    2488:	6f 90       	pop	r6
    248a:	5f 90       	pop	r5
    248c:	4f 90       	pop	r4
    248e:	3f 90       	pop	r3
    2490:	2f 90       	pop	r2
    2492:	08 95       	ret

00002494 <tune_8ths>:



void tune_8ths(uint8_t vco) {
    2494:	2f 92       	push	r2
    2496:	3f 92       	push	r3
    2498:	4f 92       	push	r4
    249a:	5f 92       	push	r5
    249c:	6f 92       	push	r6
    249e:	7f 92       	push	r7
    24a0:	8f 92       	push	r8
    24a2:	9f 92       	push	r9
    24a4:	af 92       	push	r10
    24a6:	bf 92       	push	r11
    24a8:	cf 92       	push	r12
    24aa:	df 92       	push	r13
    24ac:	ef 92       	push	r14
    24ae:	ff 92       	push	r15
    24b0:	0f 93       	push	r16
    24b2:	1f 93       	push	r17
    24b4:	cf 93       	push	r28
    24b6:	df 93       	push	r29
    24b8:	cd b7       	in	r28, 0x3d	; 61
    24ba:	de b7       	in	r29, 0x3e	; 62
    24bc:	c0 54       	subi	r28, 0x40	; 64
    24be:	d0 40       	sbci	r29, 0x00	; 0
    24c0:	0f b6       	in	r0, 0x3f	; 63
    24c2:	f8 94       	cli
    24c4:	de bf       	out	0x3e, r29	; 62
    24c6:	0f be       	out	0x3f, r0	; 63
    24c8:	cd bf       	out	0x3d, r28	; 61
    24ca:	08 2f       	mov	r16, r24
		uint8_t period;
		uint16_t count;
	
		};

	struct pitch_reference reference[16] = 
    24cc:	de 01       	movw	r26, r28
    24ce:	11 96       	adiw	r26, 0x01	; 1
    24d0:	e0 e3       	ldi	r30, 0x30	; 48
    24d2:	f2 e0       	ldi	r31, 0x02	; 2
    24d4:	80 e3       	ldi	r24, 0x30	; 48
    24d6:	01 90       	ld	r0, Z+
    24d8:	0d 92       	st	X+, r0
    24da:	81 50       	subi	r24, 0x01	; 1
    24dc:	e1 f7       	brne	.-8      	; 0x24d6 <tune_8ths+0x42>
	
		//to do:
		//disable UART so MIDI data doesn't interrupt tuning
	
		//setup control voltages	
		initialize_voice_for_tuning();
    24de:	0e 94 67 10 	call	0x20ce	; 0x20ce <initialize_voice_for_tuning>
		struct control_voltage *vco_init_cv;
		struct control_voltage *vco_mix_cv;
		struct control_voltage *vco_pw_cv;
		struct control_voltage *vco_pitch_cv;	

		if (vco == VCO1) { //set up parameters for VCO1 tuning
    24e2:	0f 30       	cpi	r16, 0x0F	; 15
    24e4:	11 f5       	brne	.+68     	; 0x252a <tune_8ths+0x96>
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
			vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 1; //allows second digit to display VCO being tuned
			init_cv = vco1_init_cv;
    24e6:	40 90 79 03 	lds	r4, 0x0379
    24ea:	50 90 7a 03 	lds	r5, 0x037A
			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
			vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
    24ee:	0f 2e       	mov	r0, r31
    24f0:	f6 ee       	ldi	r31, 0xE6	; 230
    24f2:	8f 2e       	mov	r8, r31
    24f4:	f1 e0       	ldi	r31, 0x01	; 1
    24f6:	9f 2e       	mov	r9, r31
    24f8:	f0 2d       	mov	r31, r0

			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
    24fa:	0f 2e       	mov	r0, r31
    24fc:	fe ed       	ldi	r31, 0xDE	; 222
    24fe:	2f 2e       	mov	r2, r31
    2500:	f1 e0       	ldi	r31, 0x01	; 1
    2502:	3f 2e       	mov	r3, r31
    2504:	f0 2d       	mov	r31, r0
		if (vco == VCO1) { //set up parameters for VCO1 tuning

			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
    2506:	23 ee       	ldi	r18, 0xE3	; 227
    2508:	31 e0       	ldi	r19, 0x01	; 1
    250a:	3a ab       	sts	0x5a, r19
    250c:	29 ab       	sts	0x59, r18

		if (vco == VCO1) { //set up parameters for VCO1 tuning

			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
    250e:	0f 2e       	mov	r0, r31
    2510:	fc ed       	ldi	r31, 0xDC	; 220
    2512:	6f 2e       	mov	r6, r31
    2514:	f1 e0       	ldi	r31, 0x01	; 1
    2516:	7f 2e       	mov	r7, r31
    2518:	f0 2d       	mov	r31, r0
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
			vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 1; //allows second digit to display VCO being tuned
			init_cv = vco1_init_cv;
			vco_pitch_table = vco1_pitch_table;
    251a:	05 e5       	ldi	r16, 0x55	; 85
    251c:	13 e0       	ldi	r17, 0x03	; 3
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
			vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 1; //allows second digit to display VCO being tuned
    251e:	cc 24       	eor	r12, r12
    2520:	c3 94       	inc	r12
		struct control_voltage *vco_pitch_cv;	

		if (vco == VCO1) { //set up parameters for VCO1 tuning

			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
    2522:	ee 24       	eor	r14, r14
    2524:	68 94       	set
    2526:	e1 f8       	bld	r14, 1
    2528:	22 c0       	rjmp	.+68     	; 0x256e <tune_8ths+0xda>
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
			vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 2; //allows second digit to display VCO being tuned
			init_cv = vco2_init_cv;
    252a:	40 90 77 03 	lds	r4, 0x0377
    252e:	50 90 78 03 	lds	r5, 0x0378
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
			vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
    2532:	0f 2e       	mov	r0, r31
    2534:	f5 ee       	ldi	r31, 0xE5	; 229
    2536:	8f 2e       	mov	r8, r31
    2538:	f1 e0       	ldi	r31, 0x01	; 1
    253a:	9f 2e       	mov	r9, r31
    253c:	f0 2d       	mov	r31, r0
		
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
    253e:	0f 2e       	mov	r0, r31
    2540:	f7 ed       	ldi	r31, 0xD7	; 215
    2542:	2f 2e       	mov	r2, r31
    2544:	f1 e0       	ldi	r31, 0x01	; 1
    2546:	3f 2e       	mov	r3, r31
    2548:	f0 2d       	mov	r31, r0
		} else { //set up parameters for VCO2 tuning
		
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
    254a:	44 ee       	ldi	r20, 0xE4	; 228
    254c:	51 e0       	ldi	r21, 0x01	; 1
    254e:	5a ab       	sts	0x5a, r21
    2550:	49 ab       	sts	0x59, r20
		
		} else { //set up parameters for VCO2 tuning
		
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
    2552:	0f 2e       	mov	r0, r31
    2554:	fd ed       	ldi	r31, 0xDD	; 221
    2556:	6f 2e       	mov	r6, r31
    2558:	f1 e0       	ldi	r31, 0x01	; 1
    255a:	7f 2e       	mov	r7, r31
    255c:	f0 2d       	mov	r31, r0
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
			vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 2; //allows second digit to display VCO being tuned
			init_cv = vco2_init_cv;
			vco_pitch_table = vco2_pitch_table;
    255e:	03 e3       	ldi	r16, 0x33	; 51
    2560:	13 e0       	ldi	r17, 0x03	; 3
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
			vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 2; //allows second digit to display VCO being tuned
    2562:	cc 24       	eor	r12, r12
    2564:	68 94       	set
    2566:	c1 f8       	bld	r12, 1
		
		
		} else { //set up parameters for VCO2 tuning
		
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
    2568:	ee 24       	eor	r14, r14
    256a:	68 94       	set
    256c:	e5 f8       	bld	r14, 5
		}
	


		//set VCO init offset CV
		set_control_voltage(vco_init_cv, init_cv);
    256e:	c3 01       	movw	r24, r6
    2570:	b2 01       	movw	r22, r4
    2572:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
		
	
		//latch switch data
		DATA_BUS = switch_byte;
    2576:	e2 b8       	out	0x02, r14	; 2
		VCO_SW_LATCH_PORT |= (1<<VCO_SW_LATCH);
    2578:	ed ed       	ldi	r30, 0xDD	; 221
    257a:	f0 e0       	ldi	r31, 0x00	; 0
    257c:	80 81       	ld	r24, Z
    257e:	80 64       	ori	r24, 0x40	; 64
    2580:	80 83       	st	Z, r24
		//_delay_us(1); //why is this delay here????
		VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    2582:	80 81       	ld	r24, Z
    2584:	8f 7b       	andi	r24, 0xBF	; 191
    2586:	80 83       	st	Z, r24
		DATA_BUS = 0;
    2588:	12 b8       	out	0x02, r1	; 2

		PORTF |= (1<<GATE); //turn gate on
    258a:	89 9a       	sbi	0x11, 1	; 17
			
		period = 1; //need to initialize to minimum period number here
    258c:	81 e0       	ldi	r24, 0x01	; 1
    258e:	80 93 80 03 	sts	0x0380, r24
		
		compare_match_counter = 0;	
    2592:	10 92 7b 03 	sts	0x037B, r1
			
				//enable watchdog timer
				wdt_enable(WDTO_2S);
				while (count_finished == FALSE) {
					//update_display(vco_number + period + (compare_match_counter>>4)*100, DEC);
					update_display(vco_number*100 + period, DEC);//
    2596:	8c 2d       	mov	r24, r12
    2598:	90 e0       	ldi	r25, 0x00	; 0
    259a:	24 e6       	ldi	r18, 0x64	; 100
    259c:	30 e0       	ldi	r19, 0x00	; 0
    259e:	82 9f       	mul	r24, r18
    25a0:	d0 01       	movw	r26, r0
    25a2:	83 9f       	mul	r24, r19
    25a4:	b0 0d       	add	r27, r0
    25a6:	92 9f       	mul	r25, r18
    25a8:	b0 0d       	add	r27, r0
    25aa:	11 24       	eor	r1, r1
    25ac:	bc ab       	sts	0x5c, r27
    25ae:	ab ab       	sts	0x5b, r26
    25b0:	fe 01       	movw	r30, r28
    25b2:	31 96       	adiw	r30, 0x01	; 1
    25b4:	fc af       	sts	0x7c, r31
    25b6:	eb af       	sts	0x7b, r30
	
}



void tune_8ths(uint8_t vco) {
    25b8:	98 01       	movw	r18, r16
    25ba:	2e 5f       	subi	r18, 0xFE	; 254
    25bc:	3f 4f       	sbci	r19, 0xFF	; 255
    25be:	21 96       	adiw	r28, 0x01	; 1
    25c0:	3f af       	sts	0x7f, r19
    25c2:	2e af       	sts	0x7e, r18
    25c4:	21 97       	sbiw	r28, 0x01	; 1
		PORTF |= (1<<GATE); //turn gate on
			
		period = 1; //need to initialize to minimum period number here
		
		compare_match_counter = 0;	
		for (int note_number = 0; note_number <= 15; note_number++) 
    25c6:	1e ae       	sts	0xbe, r17
    25c8:	1d ae       	sts	0xbd, r17
					//not sure what's really necessary here - definitely pitch and init_cv, but what else?
					set_control_voltage(vco_init_cv, init_cv);
					set_control_voltage(vco_pitch_cv, osc_pitch_cv);
					//set_control_voltage(&pitch_lfo_cv, MIN);
					//set_control_voltage(vco_pw_cv, MAX); //not necessary as SAW is being used to clock comparator
					set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
    25ca:	0f 2e       	mov	r0, r31
    25cc:	f8 ed       	ldi	r31, 0xD8	; 216
    25ce:	ef 2e       	mov	r14, r31
    25d0:	f1 e0       	ldi	r31, 0x01	; 1
    25d2:	ff 2e       	mov	r15, r31
    25d4:	f0 2d       	mov	r31, r0
					set_control_voltage(&cutoff_cv, MAX);
    25d6:	0f 2e       	mov	r0, r31
    25d8:	f4 ed       	ldi	r31, 0xD4	; 212
    25da:	cf 2e       	mov	r12, r31
    25dc:	f1 e0       	ldi	r31, 0x01	; 1
    25de:	df 2e       	mov	r13, r31
    25e0:	f0 2d       	mov	r31, r0
					//set_control_voltage(&res_cv, MIN);
					set_control_voltage(&sustain_1_cv, MAX);
    25e2:	0f 2e       	mov	r0, r31
    25e4:	fa ec       	ldi	r31, 0xCA	; 202
    25e6:	af 2e       	mov	r10, r31
    25e8:	f1 e0       	ldi	r31, 0x01	; 1
    25ea:	bf 2e       	mov	r11, r31
    25ec:	f0 2d       	mov	r31, r0
	
}



void tune_8ths(uint8_t vco) {
    25ee:	eb ad       	sts	0x6b, r30
    25f0:	fc ad       	sts	0x6c, r31
		period = 1; //need to initialize to minimum period number here
		
		compare_match_counter = 0;	
		for (int note_number = 0; note_number <= 15; note_number++) 
			{
			period = reference[note_number].period;
    25f2:	80 81       	ld	r24, Z
    25f4:	80 93 80 03 	sts	0x0380, r24
			//period timer needs to be initialized here and turned off after each note's SAR to prevent glitching caused by leaving timer0 running
			TCCR0A |= (1<<CS02) | (1<<CS01) | (1<<CS00) | (1<<WGM01); //clocked by external T0 pin, rising edge + clear timer on compare match
    25f8:	84 b5       	in	r24, 0x24	; 36
    25fa:	8f 60       	ori	r24, 0x0F	; 15
    25fc:	84 bd       	out	0x24, r24	; 36
			OCR0A = 1; //output compare register - set to number of periods to be counted. OCR0A needs to be set to (periods_to_be_counted - 1) ***COULD PROBABLY CHANGE THIS TO 0 NOW*** - NOPE. NEEDS TO BE 1!!!
    25fe:	81 e0       	ldi	r24, 0x01	; 1
    2600:	87 bd       	out	0x27, r24	; 39
			//TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
			TCNT0 = 0; //make sure timer/counter0 is actually 0. 
    2602:	16 bc       	out	0x26, r1	; 38
			
			if (note_number <= 2) {
    2604:	4d ad       	sts	0x6d, r20
    2606:	5e ad       	sts	0x6e, r21
    2608:	43 30       	cpi	r20, 0x03	; 3
    260a:	51 05       	cpc	r21, r1
    260c:	24 f4       	brge	.+8      	; 0x2616 <tune_8ths+0x182>
	
				//set timer/counter1 to /64 0.3125 MHz
				timer1_clock = (1<<CS11) | (1<<CS10);
    260e:	83 e0       	ldi	r24, 0x03	; 3
    2610:	80 93 7f 03 	sts	0x037F, r24
    2614:	03 c0       	rjmp	.+6      	; 0x261c <tune_8ths+0x188>
	
			} else {
	
				//set timer/counter1 to /8 2.5 MHz
				timer1_clock = (1<<CS11);
    2616:	82 e0       	ldi	r24, 0x02	; 2
    2618:	80 93 7f 03 	sts	0x037F, r24
	
			}
			//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
			uint16_t reference_count = reference[note_number].count;
    261c:	81 81       	ldd	r24, Z+1	; 0x01
    261e:	92 81       	ldd	r25, Z+2	; 0x02
    2620:	9a af       	sts	0x7a, r25
    2622:	89 af       	sts	0x79, r24
			uint16_t osc_pitch_cv = 0;
			for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
    2624:	ad e0       	ldi	r26, 0x0D	; 13
    2626:	b0 e0       	ldi	r27, 0x00	; 0
    2628:	be ab       	sts	0x5e, r27
    262a:	ad ab       	sts	0x5d, r26
				timer1_clock = (1<<CS11);
	
			}
			//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
			uint16_t reference_count = reference[note_number].count;
			uint16_t osc_pitch_cv = 0;
    262c:	00 e0       	ldi	r16, 0x00	; 0
    262e:	10 e0       	ldi	r17, 0x00	; 0
			for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
				
				osc_pitch_cv |= (1<<dac_bit);
    2630:	e1 e0       	ldi	r30, 0x01	; 1
    2632:	f0 e0       	ldi	r31, 0x00	; 0
    2634:	0d a8       	sts	0x8d, r16
    2636:	02 c0       	rjmp	.+4      	; 0x263c <tune_8ths+0x1a8>
    2638:	ee 0f       	add	r30, r30
    263a:	ff 1f       	adc	r31, r31
    263c:	0a 94       	dec	r0
    263e:	e2 f7       	brpl	.-8      	; 0x2638 <tune_8ths+0x1a4>
    2640:	f8 af       	sts	0x78, r31
    2642:	ef ab       	sts	0x5f, r30
    2644:	0e 2b       	or	r16, r30
    2646:	1f 2b       	or	r17, r31
				TIMSK0 &= ~(1<<OCIE0A); //turn off output compare match A interrupt
    2648:	ae e6       	ldi	r26, 0x6E	; 110
    264a:	b0 e0       	ldi	r27, 0x00	; 0
    264c:	8c 91       	ld	r24, X
    264e:	8d 7f       	andi	r24, 0xFD	; 253
    2650:	8c 93       	st	X, r24
				set_control_voltage(vco_pitch_cv, osc_pitch_cv);
    2652:	c4 01       	movw	r24, r8
    2654:	b8 01       	movw	r22, r16
    2656:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    265a:	e3 ef       	ldi	r30, 0xF3	; 243
    265c:	f1 e0       	ldi	r31, 0x01	; 1
    265e:	31 97       	sbiw	r30, 0x01	; 1
    2660:	f1 f7       	brne	.-4      	; 0x265e <tune_8ths+0x1ca>
    2662:	00 c0       	rjmp	.+0      	; 0x2664 <tune_8ths+0x1d0>
    2664:	00 00       	nop
				_delay_ms(2); //add delay here to allow pitch to slew to its final value
				TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
    2666:	ae e6       	ldi	r26, 0x6E	; 110
    2668:	b0 e0       	ldi	r27, 0x00	; 0
    266a:	8c 91       	ld	r24, X
    266c:	82 60       	ori	r24, 0x02	; 2
    266e:	8c 93       	st	X, r24
				//TCNT0 = 0;
				
				count_finished = FALSE;
    2670:	10 92 7e 03 	sts	0x037E, r1
				period_counter = 0;
    2674:	10 92 81 03 	sts	0x0381, r1
			
				//enable watchdog timer
				wdt_enable(WDTO_2S);
    2678:	e8 e1       	ldi	r30, 0x18	; 24
    267a:	f0 e0       	ldi	r31, 0x00	; 0
    267c:	2f e0       	ldi	r18, 0x0F	; 15
    267e:	0f b6       	in	r0, 0x3f	; 63
    2680:	f8 94       	cli
    2682:	a8 95       	wdr
    2684:	e0 93 60 00 	sts	0x0060, r30
    2688:	0f be       	out	0x3f, r0	; 63
    268a:	20 93 60 00 	sts	0x0060, r18
				while (count_finished == FALSE) {
    268e:	80 91 7e 03 	lds	r24, 0x037E
    2692:	88 23       	and	r24, r24
    2694:	81 f5       	brne	.+96     	; 0x26f6 <tune_8ths+0x262>
					//update_display(vco_number + period + (compare_match_counter>>4)*100, DEC);
					update_display(vco_number*100 + period, DEC);//
    2696:	80 91 80 03 	lds	r24, 0x0380
    269a:	4b a9       	sts	0x4b, r20
    269c:	5c a9       	sts	0x4c, r21
    269e:	48 0f       	add	r20, r24
    26a0:	51 1d       	adc	r21, r1
    26a2:	ca 01       	movw	r24, r20
    26a4:	60 e0       	ldi	r22, 0x00	; 0
    26a6:	0e 94 35 03 	call	0x66a	; 0x66a <update_display>
					//update_display(value_to_display, DEC);	
					//need to have a watchdog timer here to escape while loop if it takes too long
				
					//not sure what's really necessary here - definitely pitch and init_cv, but what else?
					set_control_voltage(vco_init_cv, init_cv);
    26aa:	c3 01       	movw	r24, r6
    26ac:	b2 01       	movw	r22, r4
    26ae:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
					set_control_voltage(vco_pitch_cv, osc_pitch_cv);
    26b2:	c4 01       	movw	r24, r8
    26b4:	b8 01       	movw	r22, r16
    26b6:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
					//set_control_voltage(&pitch_lfo_cv, MIN);
					//set_control_voltage(vco_pw_cv, MAX); //not necessary as SAW is being used to clock comparator
					set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
    26ba:	c7 01       	movw	r24, r14
    26bc:	60 e0       	ldi	r22, 0x00	; 0
    26be:	70 e0       	ldi	r23, 0x00	; 0
    26c0:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
					set_control_voltage(&cutoff_cv, MAX);
    26c4:	c6 01       	movw	r24, r12
    26c6:	6f ef       	ldi	r22, 0xFF	; 255
    26c8:	7f e3       	ldi	r23, 0x3F	; 63
    26ca:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
					//set_control_voltage(&res_cv, MIN);
					set_control_voltage(&sustain_1_cv, MAX);
    26ce:	c5 01       	movw	r24, r10
    26d0:	6f ef       	ldi	r22, 0xFF	; 255
    26d2:	7f e3       	ldi	r23, 0x3F	; 63
    26d4:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
					//set_control_voltage(&attack_1_cv, MIN); //keep attack at minimum
					set_control_voltage(vco_pw_cv, 8192);
    26d8:	c1 01       	movw	r24, r2
    26da:	60 e0       	ldi	r22, 0x00	; 0
    26dc:	70 e2       	ldi	r23, 0x20	; 32
    26de:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
					set_control_voltage(vco_mix_cv, MAX);
    26e2:	89 a9       	sts	0x49, r24
    26e4:	9a a9       	sts	0x4a, r25
    26e6:	6f ef       	ldi	r22, 0xFF	; 255
    26e8:	7f e3       	ldi	r23, 0x3F	; 63
    26ea:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
				count_finished = FALSE;
				period_counter = 0;
			
				//enable watchdog timer
				wdt_enable(WDTO_2S);
				while (count_finished == FALSE) {
    26ee:	80 91 7e 03 	lds	r24, 0x037E
    26f2:	88 23       	and	r24, r24
    26f4:	81 f2       	breq	.-96     	; 0x2696 <tune_8ths+0x202>

			
			
				}							
				//turn off watchdog timer
				wdt_disable();
    26f6:	58 e1       	ldi	r21, 0x18	; 24
    26f8:	0f b6       	in	r0, 0x3f	; 63
    26fa:	f8 94       	cli
    26fc:	50 93 60 00 	sts	0x0060, r21
    2700:	10 92 60 00 	sts	0x0060, r1
    2704:	0f be       	out	0x3f, r0	; 63
				//Omar changed this from <= to < which makes sense. <= was an error because if it's equal you don't want to clear the bit
				if ((osc_count <= reference_count) && (no_overflow == TRUE)) osc_pitch_cv &= ~(1<<dac_bit);
    2706:	80 91 7c 03 	lds	r24, 0x037C
    270a:	90 91 7d 03 	lds	r25, 0x037D
    270e:	a9 ad       	sts	0x69, r26
    2710:	ba ad       	sts	0x6a, r27
    2712:	a8 17       	cp	r26, r24
    2714:	b9 07       	cpc	r27, r25
    2716:	50 f0       	brcs	.+20     	; 0x272c <tune_8ths+0x298>
    2718:	80 91 af 02 	lds	r24, 0x02AF
    271c:	81 30       	cpi	r24, 0x01	; 1
    271e:	31 f4       	brne	.+12     	; 0x272c <tune_8ths+0x298>
    2720:	8f a9       	sts	0x4f, r24
    2722:	98 ad       	sts	0x68, r25
    2724:	80 95       	com	r24
    2726:	90 95       	com	r25
    2728:	08 23       	and	r16, r24
    272a:	19 23       	and	r17, r25
				
				if (osc_count == reference_count && no_overflow == TRUE) {
    272c:	80 91 7c 03 	lds	r24, 0x037C
    2730:	90 91 7d 03 	lds	r25, 0x037D
    2734:	e9 ad       	sts	0x69, r30
    2736:	fa ad       	sts	0x6a, r31
    2738:	8e 17       	cp	r24, r30
    273a:	9f 07       	cpc	r25, r31
    273c:	21 f4       	brne	.+8      	; 0x2746 <tune_8ths+0x2b2>
    273e:	80 91 af 02 	lds	r24, 0x02AF
    2742:	81 30       	cpi	r24, 0x01	; 1
    2744:	71 f0       	breq	.+28     	; 0x2762 <tune_8ths+0x2ce>
					break;	//if you hit the reference count then get out of here		
				}				
				no_overflow = TRUE;
    2746:	f1 e0       	ldi	r31, 0x01	; 1
    2748:	f0 93 af 02 	sts	0x02AF, r31
	
			}
			//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
			uint16_t reference_count = reference[note_number].count;
			uint16_t osc_pitch_cv = 0;
			for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
    274c:	2d a9       	sts	0x4d, r18
    274e:	3e a9       	sts	0x4e, r19
    2750:	21 50       	subi	r18, 0x01	; 1
    2752:	30 40       	sbci	r19, 0x00	; 0
    2754:	3e ab       	sts	0x5e, r19
    2756:	2d ab       	sts	0x5d, r18
    2758:	4f ef       	ldi	r20, 0xFF	; 255
    275a:	2f 3f       	cpi	r18, 0xFF	; 255
    275c:	34 07       	cpc	r19, r20
    275e:	09 f0       	breq	.+2      	; 0x2762 <tune_8ths+0x2ce>
    2760:	67 cf       	rjmp	.-306    	; 0x2630 <tune_8ths+0x19c>
			
			
			}
		
			//vco_pitch_table[octave*12 + note_number] = osc_pitch_cv; //store the note control voltage in the pitch table
			*(vco_pitch_table + (note_number+1)) = osc_pitch_cv;		
    2762:	21 96       	adiw	r28, 0x01	; 1
    2764:	ae ad       	sts	0x6e, r26
    2766:	bf ad       	sts	0x6f, r27
    2768:	21 97       	sbiw	r28, 0x01	; 1
    276a:	0d 93       	st	X+, r16
    276c:	1d 93       	st	X+, r17
    276e:	21 96       	adiw	r28, 0x01	; 1
    2770:	bf af       	sts	0x7f, r27
    2772:	ae af       	sts	0x7e, r26
    2774:	21 97       	sbiw	r28, 0x01	; 1
			
			//need to turn timer off here. This seems to have stopped periodic glitching of first note of first VCO tuned.
			TIMSK0 &= ~(1<<OCIE0A); //turn off timer0 compare match A interrupt
    2776:	ee e6       	ldi	r30, 0x6E	; 110
    2778:	f0 e0       	ldi	r31, 0x00	; 0
    277a:	80 81       	ld	r24, Z
    277c:	8d 7f       	andi	r24, 0xFD	; 253
    277e:	80 83       	st	Z, r24
			TCCR0A = 0; //turn off timer0
    2780:	14 bc       	out	0x24, r1	; 36
		PORTF |= (1<<GATE); //turn gate on
			
		period = 1; //need to initialize to minimum period number here
		
		compare_match_counter = 0;	
		for (int note_number = 0; note_number <= 15; note_number++) 
    2782:	2d ad       	sts	0x6d, r18
    2784:	3e ad       	sts	0x6e, r19
    2786:	2f 5f       	subi	r18, 0xFF	; 255
    2788:	3f 4f       	sbci	r19, 0xFF	; 255
    278a:	3e af       	sts	0x7e, r19
    278c:	2d af       	sts	0x7d, r18
    278e:	4b ad       	sts	0x6b, r20
    2790:	5c ad       	sts	0x6c, r21
    2792:	4d 5f       	subi	r20, 0xFD	; 253
    2794:	5f 4f       	sbci	r21, 0xFF	; 255
    2796:	5c af       	sts	0x7c, r21
    2798:	4b af       	sts	0x7b, r20
    279a:	20 31       	cpi	r18, 0x10	; 16
    279c:	31 05       	cpc	r19, r1
    279e:	09 f0       	breq	.+2      	; 0x27a2 <tune_8ths+0x30e>
    27a0:	26 cf       	rjmp	.-436    	; 0x25ee <tune_8ths+0x15a>
		}
	
		
		//eeprom_update_block((const void*)vco_pitch_table, (void*)vco_pitch_table_eeprom, sizeof(vco_pitch_table));
		//vco_pitch_table[0] = 0;
		PORTF &= ~(1<<GATE); //turn gate off
    27a2:	89 98       	cbi	0x11, 1	; 17
		
		
	
	
	}
    27a4:	c0 5c       	subi	r28, 0xC0	; 192
    27a6:	df 4f       	sbci	r29, 0xFF	; 255
    27a8:	0f b6       	in	r0, 0x3f	; 63
    27aa:	f8 94       	cli
    27ac:	de bf       	out	0x3e, r29	; 62
    27ae:	0f be       	out	0x3f, r0	; 63
    27b0:	cd bf       	out	0x3d, r28	; 61
    27b2:	df 91       	pop	r29
    27b4:	cf 91       	pop	r28
    27b6:	1f 91       	pop	r17
    27b8:	0f 91       	pop	r16
    27ba:	ff 90       	pop	r15
    27bc:	ef 90       	pop	r14
    27be:	df 90       	pop	r13
    27c0:	cf 90       	pop	r12
    27c2:	bf 90       	pop	r11
    27c4:	af 90       	pop	r10
    27c6:	9f 90       	pop	r9
    27c8:	8f 90       	pop	r8
    27ca:	7f 90       	pop	r7
    27cc:	6f 90       	pop	r6
    27ce:	5f 90       	pop	r5
    27d0:	4f 90       	pop	r4
    27d2:	3f 90       	pop	r3
    27d4:	2f 90       	pop	r2
    27d6:	08 95       	ret

000027d8 <tune_filter>:
	
void tune_filter(void) {
    27d8:	2f 92       	push	r2
    27da:	3f 92       	push	r3
    27dc:	4f 92       	push	r4
    27de:	5f 92       	push	r5
    27e0:	6f 92       	push	r6
    27e2:	7f 92       	push	r7
    27e4:	8f 92       	push	r8
    27e6:	9f 92       	push	r9
    27e8:	af 92       	push	r10
    27ea:	bf 92       	push	r11
    27ec:	cf 92       	push	r12
    27ee:	df 92       	push	r13
    27f0:	ef 92       	push	r14
    27f2:	ff 92       	push	r15
    27f4:	0f 93       	push	r16
    27f6:	1f 93       	push	r17
    27f8:	cf 93       	push	r28
    27fa:	df 93       	push	r29
    27fc:	cd b7       	in	r28, 0x3d	; 61
    27fe:	de b7       	in	r29, 0x3e	; 62
    2800:	e9 97       	sbiw	r28, 0x39	; 57
    2802:	0f b6       	in	r0, 0x3f	; 63
    2804:	f8 94       	cli
    2806:	de bf       	out	0x3e, r29	; 62
    2808:	0f be       	out	0x3f, r0	; 63
    280a:	cd bf       	out	0x3d, r28	; 61
		uint8_t period;
		uint16_t count;
		
	};

	struct pitch_reference reference[15] =
    280c:	de 01       	movw	r26, r28
    280e:	11 96       	adiw	r26, 0x01	; 1
    2810:	e0 e6       	ldi	r30, 0x60	; 96
    2812:	f2 e0       	ldi	r31, 0x02	; 2
    2814:	8d e2       	ldi	r24, 0x2D	; 45
    2816:	01 90       	ld	r0, Z+
    2818:	0d 92       	st	X+, r0
    281a:	81 50       	subi	r24, 0x01	; 1
    281c:	e1 f7       	brne	.-8      	; 0x2816 <tune_filter+0x3e>
		
	};

	
	//initialize CVs for filter tuning
	set_control_voltage(&volume_cv, MIN); //turn volume all the way down
    281e:	88 ed       	ldi	r24, 0xD8	; 216
    2820:	91 e0       	ldi	r25, 0x01	; 1
    2822:	60 e0       	ldi	r22, 0x00	; 0
    2824:	70 e0       	ldi	r23, 0x00	; 0
    2826:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	//turn off all pitch modulation
	set_control_voltage(&pitch_lfo_cv, MIN);
    282a:	81 ee       	ldi	r24, 0xE1	; 225
    282c:	91 e0       	ldi	r25, 0x01	; 1
    282e:	60 e0       	ldi	r22, 0x00	; 0
    2830:	70 e0       	ldi	r23, 0x00	; 0
    2832:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&pitch_eg2_cv, MIN);
    2836:	82 ee       	ldi	r24, 0xE2	; 226
    2838:	91 e0       	ldi	r25, 0x01	; 1
    283a:	60 e0       	ldi	r22, 0x00	; 0
    283c:	70 e0       	ldi	r23, 0x00	; 0
    283e:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&pitch_vco2_cv, MIN);
    2842:	87 eb       	ldi	r24, 0xB7	; 183
    2844:	92 e0       	ldi	r25, 0x02	; 2
    2846:	60 e0       	ldi	r22, 0x00	; 0
    2848:	70 e0       	ldi	r23, 0x00	; 0
    284a:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	//turn off glide
	set_control_voltage(&glide_cv, MIN);
    284e:	8a ed       	ldi	r24, 0xDA	; 218
    2850:	91 e0       	ldi	r25, 0x01	; 1
    2852:	60 e0       	ldi	r22, 0x00	; 0
    2854:	70 e0       	ldi	r23, 0x00	; 0
    2856:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	//turn off all pulse width modulation
	set_control_voltage(&pwm_eg2_cv, MIN);
    285a:	8f ed       	ldi	r24, 0xDF	; 223
    285c:	91 e0       	ldi	r25, 0x01	; 1
    285e:	60 e0       	ldi	r22, 0x00	; 0
    2860:	70 e0       	ldi	r23, 0x00	; 0
    2862:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&pwm_lfo_cv, MIN);
    2866:	80 ee       	ldi	r24, 0xE0	; 224
    2868:	91 e0       	ldi	r25, 0x01	; 1
    286a:	60 e0       	ldi	r22, 0x00	; 0
    286c:	70 e0       	ldi	r23, 0x00	; 0
    286e:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	//turn off all filter modulation
	set_control_voltage(&fil_lfo_cv, MIN);
    2872:	81 ed       	ldi	r24, 0xD1	; 209
    2874:	91 e0       	ldi	r25, 0x01	; 1
    2876:	60 e0       	ldi	r22, 0x00	; 0
    2878:	70 e0       	ldi	r23, 0x00	; 0
    287a:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&fil_eg2_cv, MIN);
    287e:	86 ed       	ldi	r24, 0xD6	; 214
    2880:	91 e0       	ldi	r25, 0x01	; 1
    2882:	60 e0       	ldi	r22, 0x00	; 0
    2884:	70 e0       	ldi	r23, 0x00	; 0
    2886:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&fil_vco2_cv, MIN);
    288a:	82 ed       	ldi	r24, 0xD2	; 210
    288c:	91 e0       	ldi	r25, 0x01	; 1
    288e:	60 e0       	ldi	r22, 0x00	; 0
    2890:	70 e0       	ldi	r23, 0x00	; 0
    2892:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&key_track_cv, MIN);
    2896:	83 ed       	ldi	r24, 0xD3	; 211
    2898:	91 e0       	ldi	r25, 0x01	; 1
    289a:	60 e0       	ldi	r22, 0x00	; 0
    289c:	70 e0       	ldi	r23, 0x00	; 0
    289e:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	//open filter with max resonance
	set_control_voltage(&cutoff_cv, MAX); //need to start with MAX to get filter oscillating
    28a2:	84 ed       	ldi	r24, 0xD4	; 212
    28a4:	91 e0       	ldi	r25, 0x01	; 1
    28a6:	6f ef       	ldi	r22, 0xFF	; 255
    28a8:	7f e3       	ldi	r23, 0x3F	; 63
    28aa:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&res_cv, MAX);
    28ae:	85 ed       	ldi	r24, 0xD5	; 213
    28b0:	91 e0       	ldi	r25, 0x01	; 1
    28b2:	6f ef       	ldi	r22, 0xFF	; 255
    28b4:	7f e3       	ldi	r23, 0x3F	; 63
    28b6:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	//turn off VCA LFO modulation
	set_control_voltage(&amp_lfo_cv, MIN);
    28ba:	89 ed       	ldi	r24, 0xD9	; 217
    28bc:	91 e0       	ldi	r25, 0x01	; 1
    28be:	60 e0       	ldi	r22, 0x00	; 0
    28c0:	70 e0       	ldi	r23, 0x00	; 0
    28c2:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	//initialize VCA envelope
	set_control_voltage(&attack_1_cv, MIN);
    28c6:	8e ec       	ldi	r24, 0xCE	; 206
    28c8:	91 e0       	ldi	r25, 0x01	; 1
    28ca:	60 e0       	ldi	r22, 0x00	; 0
    28cc:	70 e0       	ldi	r23, 0x00	; 0
    28ce:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&decay_1_cv, MIN);
    28d2:	8c ec       	ldi	r24, 0xCC	; 204
    28d4:	91 e0       	ldi	r25, 0x01	; 1
    28d6:	60 e0       	ldi	r22, 0x00	; 0
    28d8:	70 e0       	ldi	r23, 0x00	; 0
    28da:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&sustain_1_cv, MAX);
    28de:	8a ec       	ldi	r24, 0xCA	; 202
    28e0:	91 e0       	ldi	r25, 0x01	; 1
    28e2:	6f ef       	ldi	r22, 0xFF	; 255
    28e4:	7f e3       	ldi	r23, 0x3F	; 63
    28e6:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&release_1_cv, MIN);
    28ea:	88 ec       	ldi	r24, 0xC8	; 200
    28ec:	91 e0       	ldi	r25, 0x01	; 1
    28ee:	60 e0       	ldi	r22, 0x00	; 0
    28f0:	70 e0       	ldi	r23, 0x00	; 0
    28f2:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	//turn off noise, VCO1 and VCO2
	set_control_voltage(&noise_mix_cv, MIN);
    28f6:	80 ed       	ldi	r24, 0xD0	; 208
    28f8:	91 e0       	ldi	r25, 0x01	; 1
    28fa:	60 e0       	ldi	r22, 0x00	; 0
    28fc:	70 e0       	ldi	r23, 0x00	; 0
    28fe:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&vco1_mix_cv, MIN);
    2902:	83 ee       	ldi	r24, 0xE3	; 227
    2904:	91 e0       	ldi	r25, 0x01	; 1
    2906:	60 e0       	ldi	r22, 0x00	; 0
    2908:	70 e0       	ldi	r23, 0x00	; 0
    290a:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
	set_control_voltage(&vco2_mix_cv, MIN);
    290e:	84 ee       	ldi	r24, 0xE4	; 228
    2910:	91 e0       	ldi	r25, 0x01	; 1
    2912:	60 e0       	ldi	r22, 0x00	; 0
    2914:	70 e0       	ldi	r23, 0x00	; 0
    2916:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>


	//latch switch data
	DATA_BUS = 0; //turn off all VCO waveforms
    291a:	12 b8       	out	0x02, r1	; 2
	VCO_SW_LATCH_PORT |= (1<<VCO_SW_LATCH);
    291c:	ed ed       	ldi	r30, 0xDD	; 221
    291e:	f0 e0       	ldi	r31, 0x00	; 0
    2920:	80 81       	ld	r24, Z
    2922:	80 64       	ori	r24, 0x40	; 64
    2924:	80 83       	st	Z, r24
	//_delay_us(1); //why is this delay here????
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    2926:	80 81       	ld	r24, Z
    2928:	8f 7b       	andi	r24, 0xBF	; 191
    292a:	80 83       	st	Z, r24
	//DATA_BUS = 0;


	period = 1; //need to initialize to minimum period number here
    292c:	81 e0       	ldi	r24, 0x01	; 1
    292e:	80 93 80 03 	sts	0x0380, r24
	PORTF |= (1<<GATE); //turn gate on
    2932:	89 9a       	sbi	0x11, 1	; 17
    2934:	9e 01       	movw	r18, r28
    2936:	2f 5f       	subi	r18, 0xFF	; 255
    2938:	3f 4f       	sbci	r19, 0xFF	; 255
    293a:	3d ab       	sts	0x5d, r19
    293c:	2c ab       	sts	0x5c, r18
    293e:	85 e1       	ldi	r24, 0x15	; 21
    2940:	93 e0       	ldi	r25, 0x03	; 3
    2942:	99 af       	sts	0x79, r25
    2944:	88 af       	sts	0x78, r24
	
	
	
	for (int note_number = 0; note_number <= 14; note_number++)
    2946:	1f aa       	sts	0x9f, r17
    2948:	1e aa       	sts	0x9e, r17
		uint16_t pitch_cv = 0;
		for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
		
			pitch_cv |= (1<<dac_bit);

			set_control_voltage(&cutoff_cv, pitch_cv);
    294a:	0f 2e       	mov	r0, r31
    294c:	f4 ed       	ldi	r31, 0xD4	; 212
    294e:	af 2e       	mov	r10, r31
    2950:	f1 e0       	ldi	r31, 0x01	; 1
    2952:	bf 2e       	mov	r11, r31
    2954:	f0 2d       	mov	r31, r0
				//value_to_display = TCNT0;
				//update_display(value_to_display, DEC);
				
		
				set_control_voltage(&cutoff_cv, pitch_cv);
				set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
    2956:	0f 2e       	mov	r0, r31
    2958:	f8 ed       	ldi	r31, 0xD8	; 216
    295a:	6f 2e       	mov	r6, r31
    295c:	f1 e0       	ldi	r31, 0x01	; 1
    295e:	7f 2e       	mov	r7, r31
    2960:	f0 2d       	mov	r31, r0
				set_control_voltage(&res_cv, MAX);
    2962:	0f 2e       	mov	r0, r31
    2964:	f5 ed       	ldi	r31, 0xD5	; 213
    2966:	4f 2e       	mov	r4, r31
    2968:	f1 e0       	ldi	r31, 0x01	; 1
    296a:	5f 2e       	mov	r5, r31
    296c:	f0 2d       	mov	r31, r0
				set_control_voltage(&sustain_1_cv, MAX);
    296e:	0f 2e       	mov	r0, r31
    2970:	fa ec       	ldi	r31, 0xCA	; 202
    2972:	2f 2e       	mov	r2, r31
    2974:	f1 e0       	ldi	r31, 0x01	; 1
    2976:	3f 2e       	mov	r3, r31
    2978:	f0 2d       	mov	r31, r0
		
	
	
	}
	
void tune_filter(void) {
    297a:	ac a9       	sts	0x4c, r26
    297c:	bd a9       	sts	0x4d, r27
	
	
	
	for (int note_number = 0; note_number <= 14; note_number++)
	{
		period = reference[note_number].period;
    297e:	8c 91       	ld	r24, X
    2980:	80 93 80 03 	sts	0x0380, r24
		//period timer needs to be initialized here and turned off after each note's SAR to prevent glitching caused by leaving timer0 running
		TCCR0A |= (1<<CS02) | (1<<CS01) | (1<<CS00) | (1<<WGM01); //clocked by external T0 pin, rising edge + clear timer on compare match
    2984:	84 b5       	in	r24, 0x24	; 36
    2986:	8f 60       	ori	r24, 0x0F	; 15
    2988:	84 bd       	out	0x24, r24	; 36
		OCR0A = 1; //output compare register - set to number of periods to be counted. OCR0A needs to be set to (periods_to_be_counted - 1) ***COULD PROBABLY CHANGE THIS TO 0 NOW*** - NOPE. NEEDS TO BE 1!!!
    298a:	81 e0       	ldi	r24, 0x01	; 1
    298c:	87 bd       	out	0x27, r24	; 39
		TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
    298e:	ee e6       	ldi	r30, 0x6E	; 110
    2990:	f0 e0       	ldi	r31, 0x00	; 0
    2992:	80 81       	ld	r24, Z
    2994:	82 60       	ori	r24, 0x02	; 2
    2996:	80 83       	st	Z, r24
		TCNT0 = 0; //make sure timer/counter0 is actually 0.
    2998:	16 bc       	out	0x26, r1	; 38
		
		if (note_number <= 1) {
    299a:	ee a9       	sts	0x4e, r30
    299c:	ff a9       	sts	0x4f, r31
    299e:	e2 30       	cpi	r30, 0x02	; 2
    29a0:	f1 05       	cpc	r31, r1
    29a2:	24 f4       	brge	.+8      	; 0x29ac <tune_filter+0x1d4>
			
			//set timer/counter1 to /64 0.3125 MHz
			timer1_clock = (1<<CS11) | (1<<CS10);
    29a4:	83 e0       	ldi	r24, 0x03	; 3
    29a6:	80 93 7f 03 	sts	0x037F, r24
    29aa:	03 c0       	rjmp	.+6      	; 0x29b2 <tune_filter+0x1da>
			
		} else {
			
			//set timer/counter1 to /8 2.5 MHz
			timer1_clock = (1<<CS11);
    29ac:	82 e0       	ldi	r24, 0x02	; 2
    29ae:	80 93 7f 03 	sts	0x037F, r24
			
		}
		//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
		uint16_t reference_count = reference[note_number].count;
    29b2:	11 96       	adiw	r26, 0x01	; 1
    29b4:	2d 91       	ld	r18, X+
    29b6:	3c 91       	ld	r19, X
    29b8:	12 97       	sbiw	r26, 0x02	; 2
    29ba:	3b ab       	sts	0x5b, r19
    29bc:	2a ab       	sts	0x5a, r18
		uint16_t pitch_cv = 0;
		for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
    29be:	8d e0       	ldi	r24, 0x0D	; 13
    29c0:	90 e0       	ldi	r25, 0x00	; 0
    29c2:	9f a7       	lds	r25, 0x7f
    29c4:	8e a7       	lds	r24, 0x7e
			timer1_clock = (1<<CS11);
			
		}
		//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
		uint16_t reference_count = reference[note_number].count;
		uint16_t pitch_cv = 0;
    29c6:	ee 24       	eor	r14, r14
    29c8:	ff 24       	eor	r15, r15
				set_control_voltage(&cutoff_cv, pitch_cv);
				set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
				set_control_voltage(&res_cv, MAX);
				set_control_voltage(&sustain_1_cv, MAX);
				set_control_voltage(&attack_1_cv, MIN); //keep attack at minimum
				set_control_voltage(&fil_lfo_cv, MIN);	//keep all filter modulation at a minimum
    29ca:	0f 2e       	mov	r0, r31
    29cc:	f1 ed       	ldi	r31, 0xD1	; 209
    29ce:	cf 2e       	mov	r12, r31
    29d0:	f1 e0       	ldi	r31, 0x01	; 1
    29d2:	df 2e       	mov	r13, r31
    29d4:	f0 2d       	mov	r31, r0
				set_control_voltage(&fil_eg2_cv, MIN);
    29d6:	0f 2e       	mov	r0, r31
    29d8:	f6 ed       	ldi	r31, 0xD6	; 214
    29da:	8f 2e       	mov	r8, r31
    29dc:	f1 e0       	ldi	r31, 0x01	; 1
    29de:	9f 2e       	mov	r9, r31
    29e0:	f0 2d       	mov	r31, r0
		//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
		uint16_t reference_count = reference[note_number].count;
		uint16_t pitch_cv = 0;
		for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
		
			pitch_cv |= (1<<dac_bit);
    29e2:	81 e0       	ldi	r24, 0x01	; 1
    29e4:	90 e0       	ldi	r25, 0x00	; 0
    29e6:	fc 01       	movw	r30, r24
    29e8:	0e a4       	lds	r16, 0xae
    29ea:	02 c0       	rjmp	.+4      	; 0x29f0 <tune_filter+0x218>
    29ec:	ee 0f       	add	r30, r30
    29ee:	ff 1f       	adc	r31, r31
    29f0:	0a 94       	dec	r0
    29f2:	e2 f7       	brpl	.-8      	; 0x29ec <tune_filter+0x214>
    29f4:	f9 ab       	sts	0x59, r31
    29f6:	e8 ab       	sts	0x58, r30
    29f8:	ee 2a       	or	r14, r30
    29fa:	ff 2a       	or	r15, r31

			set_control_voltage(&cutoff_cv, pitch_cv);
    29fc:	c5 01       	movw	r24, r10
    29fe:	b7 01       	movw	r22, r14
    2a00:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
			count_finished = FALSE;
    2a04:	10 92 7e 03 	sts	0x037E, r1
			period_counter = 0;
    2a08:	10 92 81 03 	sts	0x0381, r1
		
			//enable watchdog timer
			wdt_enable(WDTO_2S);
    2a0c:	8f e0       	ldi	r24, 0x0F	; 15
    2a0e:	28 e1       	ldi	r18, 0x18	; 24
    2a10:	30 e0       	ldi	r19, 0x00	; 0
    2a12:	0f b6       	in	r0, 0x3f	; 63
    2a14:	f8 94       	cli
    2a16:	a8 95       	wdr
    2a18:	20 93 60 00 	sts	0x0060, r18
    2a1c:	0f be       	out	0x3f, r0	; 63
    2a1e:	80 93 60 00 	sts	0x0060, r24
			while (count_finished == FALSE) {
    2a22:	80 91 7e 03 	lds	r24, 0x037E
    2a26:	88 23       	and	r24, r24
    2a28:	b1 f5       	brne	.+108    	; 0x2a96 <tune_filter+0x2be>
				set_control_voltage(&res_cv, MAX);
				set_control_voltage(&sustain_1_cv, MAX);
				set_control_voltage(&attack_1_cv, MIN); //keep attack at minimum
				set_control_voltage(&fil_lfo_cv, MIN);	//keep all filter modulation at a minimum
				set_control_voltage(&fil_eg2_cv, MIN);
				set_control_voltage(&fil_vco2_cv, MIN);
    2a2a:	02 ed       	ldi	r16, 0xD2	; 210
    2a2c:	11 e0       	ldi	r17, 0x01	; 1
		
			//enable watchdog timer
			wdt_enable(WDTO_2S);
			while (count_finished == FALSE) {
				//update_display(vco_number + period + (compare_match_counter>>4)*100, DEC);
				update_display(300 + period, DEC);//
    2a2e:	80 91 80 03 	lds	r24, 0x0380
    2a32:	90 e0       	ldi	r25, 0x00	; 0
    2a34:	84 5d       	subi	r24, 0xD4	; 212
    2a36:	9e 4f       	sbci	r25, 0xFE	; 254
    2a38:	60 e0       	ldi	r22, 0x00	; 0
    2a3a:	0e 94 35 03 	call	0x66a	; 0x66a <update_display>
				//value_to_display = TCNT0;
				//update_display(value_to_display, DEC);
				
		
				set_control_voltage(&cutoff_cv, pitch_cv);
    2a3e:	c5 01       	movw	r24, r10
    2a40:	b7 01       	movw	r22, r14
    2a42:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
				set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
    2a46:	c3 01       	movw	r24, r6
    2a48:	60 e0       	ldi	r22, 0x00	; 0
    2a4a:	70 e0       	ldi	r23, 0x00	; 0
    2a4c:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
				set_control_voltage(&res_cv, MAX);
    2a50:	c2 01       	movw	r24, r4
    2a52:	6f ef       	ldi	r22, 0xFF	; 255
    2a54:	7f e3       	ldi	r23, 0x3F	; 63
    2a56:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
				set_control_voltage(&sustain_1_cv, MAX);
    2a5a:	c1 01       	movw	r24, r2
    2a5c:	6f ef       	ldi	r22, 0xFF	; 255
    2a5e:	7f e3       	ldi	r23, 0x3F	; 63
    2a60:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
				set_control_voltage(&attack_1_cv, MIN); //keep attack at minimum
    2a64:	8e ec       	ldi	r24, 0xCE	; 206
    2a66:	91 e0       	ldi	r25, 0x01	; 1
    2a68:	60 e0       	ldi	r22, 0x00	; 0
    2a6a:	70 e0       	ldi	r23, 0x00	; 0
    2a6c:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
				set_control_voltage(&fil_lfo_cv, MIN);	//keep all filter modulation at a minimum
    2a70:	c6 01       	movw	r24, r12
    2a72:	60 e0       	ldi	r22, 0x00	; 0
    2a74:	70 e0       	ldi	r23, 0x00	; 0
    2a76:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
				set_control_voltage(&fil_eg2_cv, MIN);
    2a7a:	c4 01       	movw	r24, r8
    2a7c:	60 e0       	ldi	r22, 0x00	; 0
    2a7e:	70 e0       	ldi	r23, 0x00	; 0
    2a80:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
				set_control_voltage(&fil_vco2_cv, MIN);
    2a84:	c8 01       	movw	r24, r16
    2a86:	60 e0       	ldi	r22, 0x00	; 0
    2a88:	70 e0       	ldi	r23, 0x00	; 0
    2a8a:	0e 94 01 02 	call	0x402	; 0x402 <set_control_voltage>
			count_finished = FALSE;
			period_counter = 0;
		
			//enable watchdog timer
			wdt_enable(WDTO_2S);
			while (count_finished == FALSE) {
    2a8e:	80 91 7e 03 	lds	r24, 0x037E
    2a92:	88 23       	and	r24, r24
    2a94:	61 f2       	breq	.-104    	; 0x2a2e <tune_filter+0x256>
				set_control_voltage(&fil_eg2_cv, MIN);
				set_control_voltage(&fil_vco2_cv, MIN);
						
			}
			//turn off watchdog timer
			wdt_disable();
    2a96:	88 e1       	ldi	r24, 0x18	; 24
    2a98:	0f b6       	in	r0, 0x3f	; 63
    2a9a:	f8 94       	cli
    2a9c:	80 93 60 00 	sts	0x0060, r24
    2aa0:	10 92 60 00 	sts	0x0060, r1
    2aa4:	0f be       	out	0x3f, r0	; 63
			//Omar changed this from <= to < which makes sense. <= was an error because if it's equal you don't want to clear the bit
			if ((osc_count <= reference_count) && (no_overflow == TRUE))pitch_cv &= ~(1<<dac_bit);
    2aa6:	80 91 7c 03 	lds	r24, 0x037C
    2aaa:	90 91 7d 03 	lds	r25, 0x037D
    2aae:	2a a9       	sts	0x4a, r18
    2ab0:	3b a9       	sts	0x4b, r19
    2ab2:	28 17       	cp	r18, r24
    2ab4:	39 07       	cpc	r19, r25
    2ab6:	50 f0       	brcs	.+20     	; 0x2acc <tune_filter+0x2f4>
    2ab8:	80 91 af 02 	lds	r24, 0x02AF
    2abc:	81 30       	cpi	r24, 0x01	; 1
    2abe:	31 f4       	brne	.+12     	; 0x2acc <tune_filter+0x2f4>
    2ac0:	88 a9       	sts	0x48, r24
    2ac2:	99 a9       	sts	0x49, r25
    2ac4:	80 95       	com	r24
    2ac6:	90 95       	com	r25
    2ac8:	e8 22       	and	r14, r24
    2aca:	f9 22       	and	r15, r25
		
			if (osc_count == reference_count && no_overflow == TRUE) {
    2acc:	80 91 7c 03 	lds	r24, 0x037C
    2ad0:	90 91 7d 03 	lds	r25, 0x037D
    2ad4:	ea a9       	sts	0x4a, r30
    2ad6:	fb a9       	sts	0x4b, r31
    2ad8:	8e 17       	cp	r24, r30
    2ada:	9f 07       	cpc	r25, r31
    2adc:	21 f4       	brne	.+8      	; 0x2ae6 <tune_filter+0x30e>
    2ade:	80 91 af 02 	lds	r24, 0x02AF
    2ae2:	81 30       	cpi	r24, 0x01	; 1
    2ae4:	71 f0       	breq	.+28     	; 0x2b02 <tune_filter+0x32a>
				break;	//if you hit the reference count then get out of here
			}
			no_overflow = TRUE;
    2ae6:	81 e0       	ldi	r24, 0x01	; 1
    2ae8:	80 93 af 02 	sts	0x02AF, r24
			
		}
		//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
		uint16_t reference_count = reference[note_number].count;
		uint16_t pitch_cv = 0;
		for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
    2aec:	2e a5       	lds	r18, 0x6e
    2aee:	3f a5       	lds	r19, 0x6f
    2af0:	21 50       	subi	r18, 0x01	; 1
    2af2:	30 40       	sbci	r19, 0x00	; 0
    2af4:	3f a7       	lds	r19, 0x7f
    2af6:	2e a7       	lds	r18, 0x7e
    2af8:	8f ef       	ldi	r24, 0xFF	; 255
    2afa:	2f 3f       	cpi	r18, 0xFF	; 255
    2afc:	38 07       	cpc	r19, r24
    2afe:	09 f0       	breq	.+2      	; 0x2b02 <tune_filter+0x32a>
    2b00:	70 cf       	rjmp	.-288    	; 0x29e2 <tune_filter+0x20a>
		
		
	}
	
	
	filter_pitch_table[note_number+1] = pitch_cv + 32; //32 is an offset that is trying to fix a bug somewhere else. This fix seems to work, but why 2^5 shift is required doesn't make sense to me yet. Need to look into this further
    2b02:	ee a9       	sts	0x4e, r30
    2b04:	ff a9       	sts	0x4f, r31
    2b06:	31 96       	adiw	r30, 0x01	; 1
    2b08:	ff ab       	sts	0x5f, r31
    2b0a:	ee ab       	sts	0x5e, r30
    2b0c:	c7 01       	movw	r24, r14
    2b0e:	80 96       	adiw	r24, 0x20	; 32
    2b10:	e8 ad       	sts	0x68, r30
    2b12:	f9 ad       	sts	0x69, r31
    2b14:	81 93       	st	Z+, r24
    2b16:	91 93       	st	Z+, r25
    2b18:	f9 af       	sts	0x79, r31
    2b1a:	e8 af       	sts	0x78, r30
	
	//need to turn timer off here. This seems to have stopped periodic glitching of first note of first VCO tuned.
	TIMSK0 &= ~(1<<OCIE0A); //turn off timer0 compare match A interrupt
    2b1c:	ee e6       	ldi	r30, 0x6E	; 110
    2b1e:	f0 e0       	ldi	r31, 0x00	; 0
    2b20:	80 81       	ld	r24, Z
    2b22:	8d 7f       	andi	r24, 0xFD	; 253
    2b24:	80 83       	st	Z, r24
	TCCR0A = 0; //turn off timer0
    2b26:	14 bc       	out	0x24, r1	; 36
    2b28:	2c a9       	sts	0x4c, r18
    2b2a:	3d a9       	sts	0x4d, r19
    2b2c:	2d 5f       	subi	r18, 0xFD	; 253
    2b2e:	3f 4f       	sbci	r19, 0xFF	; 255
    2b30:	3d ab       	sts	0x5d, r19
    2b32:	2c ab       	sts	0x5c, r18
	period = 1; //need to initialize to minimum period number here
	PORTF |= (1<<GATE); //turn gate on
	
	
	
	for (int note_number = 0; note_number <= 14; note_number++)
    2b34:	8e a9       	sts	0x4e, r24
    2b36:	9f a9       	sts	0x4f, r25
    2b38:	8f 30       	cpi	r24, 0x0F	; 15
    2b3a:	91 05       	cpc	r25, r1
    2b3c:	09 f0       	breq	.+2      	; 0x2b40 <tune_filter+0x368>
    2b3e:	1d cf       	rjmp	.-454    	; 0x297a <tune_filter+0x1a2>
}


//eeprom_update_block((const void*)filter_pitch_table, (void*)filter_pitch_table_eeprom, sizeof(filter_pitch_table));

PORTF &= ~(1<<GATE); //turn gate off
    2b40:	89 98       	cbi	0x11, 1	; 17
	
	
}	
    2b42:	e9 96       	adiw	r28, 0x39	; 57
    2b44:	0f b6       	in	r0, 0x3f	; 63
    2b46:	f8 94       	cli
    2b48:	de bf       	out	0x3e, r29	; 62
    2b4a:	0f be       	out	0x3f, r0	; 63
    2b4c:	cd bf       	out	0x3d, r28	; 61
    2b4e:	df 91       	pop	r29
    2b50:	cf 91       	pop	r28
    2b52:	1f 91       	pop	r17
    2b54:	0f 91       	pop	r16
    2b56:	ff 90       	pop	r15
    2b58:	ef 90       	pop	r14
    2b5a:	df 90       	pop	r13
    2b5c:	cf 90       	pop	r12
    2b5e:	bf 90       	pop	r11
    2b60:	af 90       	pop	r10
    2b62:	9f 90       	pop	r9
    2b64:	8f 90       	pop	r8
    2b66:	7f 90       	pop	r7
    2b68:	6f 90       	pop	r6
    2b6a:	5f 90       	pop	r5
    2b6c:	4f 90       	pop	r4
    2b6e:	3f 90       	pop	r3
    2b70:	2f 90       	pop	r2
    2b72:	08 95       	ret

00002b74 <save_tuning_tables>:


void save_tuning_tables(void) { //write tuning tables to memory
	
	eeprom_update_block((const void*)filter_pitch_table, (void*)filter_pitch_table_eeprom, sizeof(filter_pitch_table));
    2b74:	83 e1       	ldi	r24, 0x13	; 19
    2b76:	93 e0       	ldi	r25, 0x03	; 3
    2b78:	6c e0       	ldi	r22, 0x0C	; 12
    2b7a:	76 e0       	ldi	r23, 0x06	; 6
    2b7c:	40 e2       	ldi	r20, 0x20	; 32
    2b7e:	50 e0       	ldi	r21, 0x00	; 0
    2b80:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <__eeupd_block_m6450a>
	eeprom_update_block((const void*)vco1_pitch_table, (void*)vco1_pitch_table_eeprom, sizeof(vco1_pitch_table));
    2b84:	85 e5       	ldi	r24, 0x55	; 85
    2b86:	93 e0       	ldi	r25, 0x03	; 3
    2b88:	6e e4       	ldi	r22, 0x4E	; 78
    2b8a:	76 e0       	ldi	r23, 0x06	; 6
    2b8c:	42 e2       	ldi	r20, 0x22	; 34
    2b8e:	50 e0       	ldi	r21, 0x00	; 0
    2b90:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <__eeupd_block_m6450a>
	eeprom_update_block((const void*)vco2_pitch_table, (void*)vco2_pitch_table_eeprom, sizeof(vco2_pitch_table));
    2b94:	83 e3       	ldi	r24, 0x33	; 51
    2b96:	93 e0       	ldi	r25, 0x03	; 3
    2b98:	6c e2       	ldi	r22, 0x2C	; 44
    2b9a:	76 e0       	ldi	r23, 0x06	; 6
    2b9c:	42 e2       	ldi	r20, 0x22	; 34
    2b9e:	50 e0       	ldi	r21, 0x00	; 0
    2ba0:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <__eeupd_block_m6450a>
	
	
}
    2ba4:	08 95       	ret

00002ba6 <load_tuning_tables>:

void load_tuning_tables(void) { //retrieve tuning tables from memory
	
	
	vco1_init_cv = eeprom_read_word(&vco1_init_cv_eeprom);
    2ba6:	82 e7       	ldi	r24, 0x72	; 114
    2ba8:	96 e0       	ldi	r25, 0x06	; 6
    2baa:	0e 94 a9 1e 	call	0x3d52	; 0x3d52 <__eerd_word_m6450a>
    2bae:	90 93 7a 03 	sts	0x037A, r25
    2bb2:	80 93 79 03 	sts	0x0379, r24
	vco2_init_cv = eeprom_read_word(&vco2_init_cv_eeprom);
    2bb6:	80 e7       	ldi	r24, 0x70	; 112
    2bb8:	96 e0       	ldi	r25, 0x06	; 6
    2bba:	0e 94 a9 1e 	call	0x3d52	; 0x3d52 <__eerd_word_m6450a>
    2bbe:	90 93 78 03 	sts	0x0378, r25
    2bc2:	80 93 77 03 	sts	0x0377, r24
	//uint16_t eeprom_addr = 0;
	//vco1_init_cv = eeprom_read_word((uint16_t*)eeprom_addr);
	//eeprom_addr += sizeof(vco2_init_cv);
	//vco2_init_cv = eeprom_read_word((uint16_t*)eeprom_addr);
	eeprom_read_block((void*)vco1_pitch_table, (const void*)vco1_pitch_table_eeprom, sizeof(vco1_pitch_table));
    2bc6:	85 e5       	ldi	r24, 0x55	; 85
    2bc8:	93 e0       	ldi	r25, 0x03	; 3
    2bca:	6e e4       	ldi	r22, 0x4E	; 78
    2bcc:	76 e0       	ldi	r23, 0x06	; 6
    2bce:	42 e2       	ldi	r20, 0x22	; 34
    2bd0:	50 e0       	ldi	r21, 0x00	; 0
    2bd2:	0e 94 99 1e 	call	0x3d32	; 0x3d32 <__eerd_block_m6450a>
	eeprom_read_block((void*)vco2_pitch_table, (const void*)vco2_pitch_table_eeprom, sizeof(vco2_pitch_table));
    2bd6:	83 e3       	ldi	r24, 0x33	; 51
    2bd8:	93 e0       	ldi	r25, 0x03	; 3
    2bda:	6c e2       	ldi	r22, 0x2C	; 44
    2bdc:	76 e0       	ldi	r23, 0x06	; 6
    2bde:	42 e2       	ldi	r20, 0x22	; 34
    2be0:	50 e0       	ldi	r21, 0x00	; 0
    2be2:	0e 94 99 1e 	call	0x3d32	; 0x3d32 <__eerd_block_m6450a>
	eeprom_read_block((void*)filter_pitch_table, (const void*)filter_pitch_table_eeprom, sizeof(filter_pitch_table));
    2be6:	83 e1       	ldi	r24, 0x13	; 19
    2be8:	93 e0       	ldi	r25, 0x03	; 3
    2bea:	6c e0       	ldi	r22, 0x0C	; 12
    2bec:	76 e0       	ldi	r23, 0x06	; 6
    2bee:	40 e2       	ldi	r20, 0x20	; 32
    2bf0:	50 e0       	ldi	r21, 0x00	; 0
    2bf2:	0e 94 99 1e 	call	0x3d32	; 0x3d32 <__eerd_block_m6450a>
	
	//value_to_display = vco1_init_cv_eeprom;
	
}			
    2bf6:	08 95       	ret

00002bf8 <interpolate_pitch_cv>:
	
uint16_t interpolate_pitch_cv(uint8_t note, uint16_t *pitch_table) {
	
	uint8_t pitch_index = note>>3;
    2bf8:	98 2f       	mov	r25, r24
    2bfa:	96 95       	lsr	r25
    2bfc:	96 95       	lsr	r25
    2bfe:	96 95       	lsr	r25
	uint8_t delta_note = note - pitch_index*8; //will range from 0 to 7
		
	uint16_t y0 = pitch_table[pitch_index -1];
    2c00:	29 2f       	mov	r18, r25
    2c02:	30 e0       	ldi	r19, 0x00	; 0
    2c04:	f9 01       	movw	r30, r18
    2c06:	31 97       	sbiw	r30, 0x01	; 1
    2c08:	ee 0f       	add	r30, r30
    2c0a:	ff 1f       	adc	r31, r31
    2c0c:	e6 0f       	add	r30, r22
    2c0e:	f7 1f       	adc	r31, r23
    2c10:	01 90       	ld	r0, Z+
    2c12:	f0 81       	ld	r31, Z
    2c14:	e0 2d       	mov	r30, r0
	uint16_t y1 = pitch_table[pitch_index];
    2c16:	22 0f       	add	r18, r18
    2c18:	33 1f       	adc	r19, r19
    2c1a:	26 0f       	add	r18, r22
    2c1c:	37 1f       	adc	r19, r23
	
	uint16_t interpolated_pitch_cv = y0 + (((y1 - y0)*delta_note)>>3); //mind order of operations here: + is evaluated before >>	also, might be possible to optimize this with 16MUL8SHIFT8 from Anushri ASM util
    2c1e:	d9 01       	movw	r26, r18
    2c20:	4d 91       	ld	r20, X+
    2c22:	5c 91       	ld	r21, X
    2c24:	11 97       	sbiw	r26, 0x01	; 1
    2c26:	4e 1b       	sub	r20, r30
    2c28:	5f 0b       	sbc	r21, r31
}			
	
uint16_t interpolate_pitch_cv(uint8_t note, uint16_t *pitch_table) {
	
	uint8_t pitch_index = note>>3;
	uint8_t delta_note = note - pitch_index*8; //will range from 0 to 7
    2c2a:	99 0f       	add	r25, r25
    2c2c:	99 0f       	add	r25, r25
    2c2e:	99 0f       	add	r25, r25
    2c30:	89 1b       	sub	r24, r25
		
	uint16_t y0 = pitch_table[pitch_index -1];
	uint16_t y1 = pitch_table[pitch_index];
	
	uint16_t interpolated_pitch_cv = y0 + (((y1 - y0)*delta_note)>>3); //mind order of operations here: + is evaluated before >>	also, might be possible to optimize this with 16MUL8SHIFT8 from Anushri ASM util
    2c32:	90 e0       	ldi	r25, 0x00	; 0
    2c34:	48 9f       	mul	r20, r24
    2c36:	90 01       	movw	r18, r0
    2c38:	49 9f       	mul	r20, r25
    2c3a:	30 0d       	add	r19, r0
    2c3c:	58 9f       	mul	r21, r24
    2c3e:	30 0d       	add	r19, r0
    2c40:	11 24       	eor	r1, r1
    2c42:	36 95       	lsr	r19
    2c44:	27 95       	ror	r18
    2c46:	36 95       	lsr	r19
    2c48:	27 95       	ror	r18
    2c4a:	36 95       	lsr	r19
    2c4c:	27 95       	ror	r18
    2c4e:	e2 0f       	add	r30, r18
    2c50:	f3 1f       	adc	r31, r19
	
	
	
	return interpolated_pitch_cv;
	
}
    2c52:	8e 2f       	mov	r24, r30
    2c54:	9f 2f       	mov	r25, r31
    2c56:	08 95       	ret

00002c58 <set_one_volt_per_octave>:

void set_one_volt_per_octave(void) { //does this get stored in RAM? Should it go in progmem instead?
    2c58:	cf 93       	push	r28
    2c5a:	df 93       	push	r29
    2c5c:	cd b7       	in	r28, 0x3d	; 61
    2c5e:	de b7       	in	r29, 0x3e	; 62
    2c60:	a2 97       	sbiw	r28, 0x22	; 34
    2c62:	0f b6       	in	r0, 0x3f	; 63
    2c64:	f8 94       	cli
    2c66:	de bf       	out	0x3e, r29	; 62
    2c68:	0f be       	out	0x3f, r0	; 63
    2c6a:	cd bf       	out	0x3d, r28	; 61
	
	uint16_t vpo_pitch_table[17] = {
    2c6c:	de 01       	movw	r26, r28
    2c6e:	11 96       	adiw	r26, 0x01	; 1
    2c70:	ed e8       	ldi	r30, 0x8D	; 141
    2c72:	f2 e0       	ldi	r31, 0x02	; 2
    2c74:	82 e2       	ldi	r24, 0x22	; 34
    2c76:	01 90       	ld	r0, Z+
    2c78:	0d 92       	st	X+, r0
    2c7a:	81 50       	subi	r24, 0x01	; 1
    2c7c:	e1 f7       	brne	.-8      	; 0x2c76 <set_one_volt_per_octave+0x1e>
		16384
		
	};
	
	
	memcpy((void*)vco1_pitch_table, (const void*)vpo_pitch_table, (size_t)sizeof(vpo_pitch_table));
    2c7e:	a5 e5       	ldi	r26, 0x55	; 85
    2c80:	b3 e0       	ldi	r27, 0x03	; 3
    2c82:	fe 01       	movw	r30, r28
    2c84:	31 96       	adiw	r30, 0x01	; 1
    2c86:	82 e2       	ldi	r24, 0x22	; 34
    2c88:	01 90       	ld	r0, Z+
    2c8a:	0d 92       	st	X+, r0
    2c8c:	81 50       	subi	r24, 0x01	; 1
    2c8e:	e1 f7       	brne	.-8      	; 0x2c88 <set_one_volt_per_octave+0x30>
	memcpy((void*)vco2_pitch_table, (const void*)vpo_pitch_table, (size_t)sizeof(vpo_pitch_table));
    2c90:	a3 e3       	ldi	r26, 0x33	; 51
    2c92:	b3 e0       	ldi	r27, 0x03	; 3
    2c94:	fe 01       	movw	r30, r28
    2c96:	31 96       	adiw	r30, 0x01	; 1
    2c98:	82 e2       	ldi	r24, 0x22	; 34
    2c9a:	01 90       	ld	r0, Z+
    2c9c:	0d 92       	st	X+, r0
    2c9e:	81 50       	subi	r24, 0x01	; 1
    2ca0:	e1 f7       	brne	.-8      	; 0x2c9a <set_one_volt_per_octave+0x42>
	
	
}
    2ca2:	a2 96       	adiw	r28, 0x22	; 34
    2ca4:	0f b6       	in	r0, 0x3f	; 63
    2ca6:	f8 94       	cli
    2ca8:	de bf       	out	0x3e, r29	; 62
    2caa:	0f be       	out	0x3f, r0	; 63
    2cac:	cd bf       	out	0x3d, r28	; 61
    2cae:	df 91       	pop	r29
    2cb0:	cf 91       	pop	r28
    2cb2:	08 95       	ret

00002cb4 <tune>:
void tune(void) {
	

			
			//turn off Timer1 output compare match now, it is used by the system clock
			TIMSK1 &= (1<<OCIE1A);
    2cb4:	ef e6       	ldi	r30, 0x6F	; 111
    2cb6:	f0 e0       	ldi	r31, 0x00	; 0
    2cb8:	80 81       	ld	r24, Z
    2cba:	82 70       	andi	r24, 0x02	; 2
    2cbc:	80 83       	st	Z, r24
			//get rid of CTC here for Timer1 too
			TCCR1B &= ~(1<<WGM12); //turn off CTC
    2cbe:	e1 e8       	ldi	r30, 0x81	; 129
    2cc0:	f0 e0       	ldi	r31, 0x00	; 0
    2cc2:	80 81       	ld	r24, Z
    2cc4:	87 7f       	andi	r24, 0xF7	; 247
    2cc6:	80 83       	st	Z, r24
			
			vco1_init_cv = set_vco_init_cv(VCO1, 24079);
    2cc8:	8f e0       	ldi	r24, 0x0F	; 15
    2cca:	6f e0       	ldi	r22, 0x0F	; 15
    2ccc:	7e e5       	ldi	r23, 0x5E	; 94
    2cce:	0e 94 e6 10 	call	0x21cc	; 0x21cc <set_vco_init_cv>
    2cd2:	90 93 7a 03 	sts	0x037A, r25
    2cd6:	80 93 79 03 	sts	0x0379, r24
			vco2_init_cv = set_vco_init_cv(VCO2, 24079);
    2cda:	80 ef       	ldi	r24, 0xF0	; 240
    2cdc:	6f e0       	ldi	r22, 0x0F	; 15
    2cde:	7e e5       	ldi	r23, 0x5E	; 94
    2ce0:	0e 94 e6 10 	call	0x21cc	; 0x21cc <set_vco_init_cv>
    2ce4:	90 93 78 03 	sts	0x0378, r25
    2ce8:	80 93 77 03 	sts	0x0377, r24
			//vco1_init_cv = vco2_init_cv;
			tune_8ths(VCO1);
    2cec:	8f e0       	ldi	r24, 0x0F	; 15
    2cee:	0e 94 4a 12 	call	0x2494	; 0x2494 <tune_8ths>
			tune_8ths(VCO2);
    2cf2:	80 ef       	ldi	r24, 0xF0	; 240
    2cf4:	0e 94 4a 12 	call	0x2494	; 0x2494 <tune_8ths>
			tune_filter();
    2cf8:	0e 94 ec 13 	call	0x27d8	; 0x27d8 <tune_filter>
			save_tuning_tables();
    2cfc:	0e 94 ba 15 	call	0x2b74	; 0x2b74 <save_tuning_tables>
    2d00:	8f e4       	ldi	r24, 0x4F	; 79
    2d02:	93 ec       	ldi	r25, 0xC3	; 195
    2d04:	01 97       	sbiw	r24, 0x01	; 1
    2d06:	f1 f7       	brne	.-4      	; 0x2d04 <tune+0x50>
    2d08:	00 c0       	rjmp	.+0      	; 0x2d0a <tune+0x56>
    2d0a:	00 00       	nop
			_delay_ms(200);	//give some time for release to decay to avoid pops
			
			//need to restore Timer1 settings. This currently happens after the function is called, but should really be included here
	
    2d0c:	08 95       	ret

00002d0e <read_switch_port>:
uint8_t read_switch_port(void) {
	
	static uint8_t previous_port_state = 0;
	static uint16_t prog_hold_counter = 0;
	
	uint8_t current_port_state = SWITCH_PORT; //read switch state byte
    2d0e:	8f b1       	in	r24, 0x0f	; 15
	switch_press |= current_port_state & 0b00001100; //mask for four PROG buttons 
    2d10:	98 2f       	mov	r25, r24
    2d12:	9c 70       	andi	r25, 0x0C	; 12
    2d14:	20 91 c5 02 	lds	r18, 0x02C5
    2d18:	92 2b       	or	r25, r18
    2d1a:	90 93 c5 02 	sts	0x02C5, r25
	
	if ((current_port_state >> PROG_DOWN_SW) & 1) { //press and hold handler for PROG DOWN switch. Should have a general framework for handling switch presses and holds
    2d1e:	98 2f       	mov	r25, r24
    2d20:	92 95       	swap	r25
    2d22:	96 95       	lsr	r25
    2d24:	97 70       	andi	r25, 0x07	; 7
    2d26:	90 ff       	sbrs	r25, 0
    2d28:	16 c0       	rjmp	.+44     	; 0x2d56 <read_switch_port+0x48>
		
		if (++prog_hold_counter == 600) { //problem here is that the hold time is dependent on main loop execution speed. Could maybe somehow link this to Timer1, which is running at constant /1024
    2d2a:	20 91 85 03 	lds	r18, 0x0385
    2d2e:	30 91 86 03 	lds	r19, 0x0386
    2d32:	2f 5f       	subi	r18, 0xFF	; 255
    2d34:	3f 4f       	sbci	r19, 0xFF	; 255
    2d36:	30 93 86 03 	sts	0x0386, r19
    2d3a:	20 93 85 03 	sts	0x0385, r18
    2d3e:	92 e0       	ldi	r25, 0x02	; 2
    2d40:	28 35       	cpi	r18, 0x58	; 88
    2d42:	39 07       	cpc	r19, r25
    2d44:	61 f4       	brne	.+24     	; 0x2d5e <read_switch_port+0x50>
			
			prog_hold_counter = 0; //shouldn't need this as prog_hold_counter will overflow to 0 on next press
    2d46:	10 92 86 03 	sts	0x0386, r1
    2d4a:	10 92 85 03 	sts	0x0385, r1
			current_patch.mode = CAL;
    2d4e:	95 e0       	ldi	r25, 0x05	; 5
    2d50:	90 93 0b 03 	sts	0x030B, r25
    2d54:	04 c0       	rjmp	.+8      	; 0x2d5e <read_switch_port+0x50>
			
		}
		
	} else { prog_hold_counter = 0;} //reset counter to 0
    2d56:	10 92 86 03 	sts	0x0386, r1
    2d5a:	10 92 85 03 	sts	0x0385, r1
		
	//this toggle code works, but I haven't figured out how it works
	//source: http://forum.allaboutcircuits.com/threads/help-with-programming-uc-toggle-led-using-one-switch.51602/	
	current_port_state ^= previous_port_state;
    2d5e:	90 91 87 03 	lds	r25, 0x0387
    2d62:	89 27       	eor	r24, r25
	previous_port_state ^= current_port_state;
    2d64:	98 27       	eor	r25, r24
    2d66:	90 93 87 03 	sts	0x0387, r25
	current_port_state &= previous_port_state;
	
	return current_port_state;
	
}
    2d6a:	89 23       	and	r24, r25
    2d6c:	08 95       	ret

00002d6e <update_analog_switch_latch>:

void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    2d6e:	ed ed       	ldi	r30, 0xDD	; 221
    2d70:	f0 e0       	ldi	r31, 0x00	; 0
    2d72:	90 81       	ld	r25, Z
    2d74:	9f 7b       	andi	r25, 0xBF	; 191
    2d76:	90 83       	st	Z, r25
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
	((switch_state_byte >> VCO_SYNC_SW) & 1) << VCO_SYNC_LATCH_BIT |
	((switch_state_byte >> VCO1_SAW_SW) & 1) << VCO1_SAW_LATCH_BIT |
	((switch_state_byte >> VCO1_TRI_SW) & 1) << VCO1_TRI_LATCH_BIT |
	((switch_state_byte >> VCO1_PULSE_SW) & 1) << VCO1_PULSE_LATCH_BIT |
    2d78:	28 2f       	mov	r18, r24
    2d7a:	30 e0       	ldi	r19, 0x00	; 0
    2d7c:	21 70       	andi	r18, 0x01	; 1
    2d7e:	30 70       	andi	r19, 0x00	; 0
    2d80:	22 0f       	add	r18, r18
    2d82:	33 1f       	adc	r19, r19
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
	((switch_state_byte >> VCO2_TRI_SW) & 1) << VCO2_TRI_LATCH_BIT |
    2d84:	68 2f       	mov	r22, r24
    2d86:	62 95       	swap	r22
    2d88:	66 95       	lsr	r22
    2d8a:	67 70       	andi	r22, 0x07	; 7
    2d8c:	67 95       	ror	r22
    2d8e:	66 27       	eor	r22, r22
    2d90:	67 95       	ror	r22
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2d92:	26 2b       	or	r18, r22
    2d94:	98 2f       	mov	r25, r24
    2d96:	96 95       	lsr	r25
    2d98:	96 95       	lsr	r25
    2d9a:	91 70       	andi	r25, 0x01	; 1
    2d9c:	29 2b       	or	r18, r25
	((switch_state_byte >> VCO_SYNC_SW) & 1) << VCO_SYNC_LATCH_BIT |
    2d9e:	68 2f       	mov	r22, r24
    2da0:	66 1f       	adc	r22, r22
    2da2:	66 27       	eor	r22, r22
    2da4:	66 1f       	adc	r22, r22
    2da6:	66 0f       	add	r22, r22
    2da8:	66 0f       	add	r22, r22
    2daa:	66 0f       	add	r22, r22
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2dac:	26 2b       	or	r18, r22
	((switch_state_byte >> VCO_SYNC_SW) & 1) << VCO_SYNC_LATCH_BIT |
	((switch_state_byte >> VCO1_SAW_SW) & 1) << VCO1_SAW_LATCH_BIT |
	((switch_state_byte >> VCO1_TRI_SW) & 1) << VCO1_TRI_LATCH_BIT |
    2dae:	a8 2f       	mov	r26, r24
    2db0:	a6 95       	lsr	r26
    2db2:	b0 e0       	ldi	r27, 0x00	; 0
    2db4:	a1 70       	andi	r26, 0x01	; 1
    2db6:	b0 70       	andi	r27, 0x00	; 0
    2db8:	bd 01       	movw	r22, r26
    2dba:	66 0f       	add	r22, r22
    2dbc:	77 1f       	adc	r23, r23
    2dbe:	66 0f       	add	r22, r22
    2dc0:	77 1f       	adc	r23, r23
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2dc2:	26 2b       	or	r18, r22
	((switch_state_byte >> VCO_SYNC_SW) & 1) << VCO_SYNC_LATCH_BIT |
	((switch_state_byte >> VCO1_SAW_SW) & 1) << VCO1_SAW_LATCH_BIT |
	((switch_state_byte >> VCO1_TRI_SW) & 1) << VCO1_TRI_LATCH_BIT |
	((switch_state_byte >> VCO1_PULSE_SW) & 1) << VCO1_PULSE_LATCH_BIT |
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
    2dc4:	68 2f       	mov	r22, r24
    2dc6:	62 95       	swap	r22
    2dc8:	6f 70       	andi	r22, 0x0F	; 15
    2dca:	70 e0       	ldi	r23, 0x00	; 0
    2dcc:	61 70       	andi	r22, 0x01	; 1
    2dce:	70 70       	andi	r23, 0x00	; 0
    2dd0:	ab 01       	movw	r20, r22
    2dd2:	00 24       	eor	r0, r0
    2dd4:	56 95       	lsr	r21
    2dd6:	47 95       	ror	r20
    2dd8:	07 94       	ror	r0
    2dda:	56 95       	lsr	r21
    2ddc:	47 95       	ror	r20
    2dde:	07 94       	ror	r0
    2de0:	54 2f       	mov	r21, r20
    2de2:	40 2d       	mov	r20, r0
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2de4:	62 2f       	mov	r22, r18
    2de6:	64 2b       	or	r22, r20
	((switch_state_byte >> VCO1_SAW_SW) & 1) << VCO1_SAW_LATCH_BIT |
	((switch_state_byte >> VCO1_TRI_SW) & 1) << VCO1_TRI_LATCH_BIT |
	((switch_state_byte >> VCO1_PULSE_SW) & 1) << VCO1_PULSE_LATCH_BIT |
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
	((switch_state_byte >> VCO2_TRI_SW) & 1) << VCO2_TRI_LATCH_BIT |
	((switch_state_byte >> VCO2_PULSE_SW) & 1) << VCO2_PULSE_LATCH_BIT |
    2de8:	48 2f       	mov	r20, r24
    2dea:	42 95       	swap	r20
    2dec:	46 95       	lsr	r20
    2dee:	46 95       	lsr	r20
    2df0:	43 70       	andi	r20, 0x03	; 3
    2df2:	50 e0       	ldi	r21, 0x00	; 0
    2df4:	41 70       	andi	r20, 0x01	; 1
    2df6:	50 70       	andi	r21, 0x00	; 0
    2df8:	9a 01       	movw	r18, r20
    2dfa:	22 0f       	add	r18, r18
    2dfc:	33 1f       	adc	r19, r19
    2dfe:	22 95       	swap	r18
    2e00:	32 95       	swap	r19
    2e02:	30 7f       	andi	r19, 0xF0	; 240
    2e04:	32 27       	eor	r19, r18
    2e06:	20 7f       	andi	r18, 0xF0	; 240
    2e08:	32 27       	eor	r19, r18
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2e0a:	46 2f       	mov	r20, r22
    2e0c:	42 2b       	or	r20, r18
	((switch_state_byte >> VCO1_PULSE_SW) & 1) << VCO1_PULSE_LATCH_BIT |
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
	((switch_state_byte >> VCO2_TRI_SW) & 1) << VCO2_TRI_LATCH_BIT |
	((switch_state_byte >> VCO2_PULSE_SW) & 1) << VCO2_PULSE_LATCH_BIT |
	//BMOD_SW_ON << BMOD_LATCH_BIT;
	((switch_state_byte >> 3) & 1) << BMOD_LATCH_BIT;
    2e0e:	86 95       	lsr	r24
    2e10:	86 95       	lsr	r24
    2e12:	86 95       	lsr	r24
    2e14:	28 2f       	mov	r18, r24
    2e16:	30 e0       	ldi	r19, 0x00	; 0
    2e18:	21 70       	andi	r18, 0x01	; 1
    2e1a:	30 70       	andi	r19, 0x00	; 0
    2e1c:	c9 01       	movw	r24, r18
    2e1e:	82 95       	swap	r24
    2e20:	92 95       	swap	r25
    2e22:	90 7f       	andi	r25, 0xF0	; 240
    2e24:	98 27       	eor	r25, r24
    2e26:	80 7f       	andi	r24, 0xF0	; 240
    2e28:	98 27       	eor	r25, r24
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2e2a:	84 2b       	or	r24, r20
    2e2c:	82 b9       	out	0x02, r24	; 2
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
	((switch_state_byte >> VCO2_TRI_SW) & 1) << VCO2_TRI_LATCH_BIT |
	((switch_state_byte >> VCO2_PULSE_SW) & 1) << VCO2_PULSE_LATCH_BIT |
	//BMOD_SW_ON << BMOD_LATCH_BIT;
	((switch_state_byte >> 3) & 1) << BMOD_LATCH_BIT;
	VCO_SW_LATCH_PORT |= (1<<VCO_SW_LATCH);
    2e2e:	80 81       	ld	r24, Z
    2e30:	80 64       	ori	r24, 0x40	; 64
    2e32:	80 83       	st	Z, r24
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    2e34:	80 81       	ld	r24, Z
    2e36:	8f 7b       	andi	r24, 0xBF	; 191
    2e38:	80 83       	st	Z, r24
	DATA_BUS = 0;
    2e3a:	12 b8       	out	0x02, r1	; 2
	
	
    2e3c:	08 95       	ret

00002e3e <bytequeue_init>:
//along with avr-bytequeue.  If not, see <http://www.gnu.org/licenses/>.

#include "bytequeue.h"
#include "interrupt_setting.h"

void bytequeue_init(byteQueue_t * queue, uint8_t * dataArray, byteQueueIndex_t arrayLen){
    2e3e:	fc 01       	movw	r30, r24
   queue->length = arrayLen;
    2e40:	42 83       	std	Z+2, r20	; 0x02
   queue->data = dataArray;
    2e42:	74 83       	std	Z+4, r23	; 0x04
    2e44:	63 83       	std	Z+3, r22	; 0x03
   queue->start = queue->end = 0;
    2e46:	11 82       	std	Z+1, r1	; 0x01
    2e48:	10 82       	st	Z, r1
}
    2e4a:	08 95       	ret

00002e4c <bytequeue_enqueue>:

bool bytequeue_enqueue(byteQueue_t * queue, uint8_t item){
    2e4c:	1f 93       	push	r17
    2e4e:	cf 93       	push	r28
    2e50:	df 93       	push	r29
    2e52:	ec 01       	movw	r28, r24
    2e54:	16 2f       	mov	r17, r22
   interrupt_setting_t setting = store_and_clear_interrupt();
    2e56:	0e 94 95 17 	call	0x2f2a	; 0x2f2a <store_and_clear_interrupt>
    2e5a:	28 2f       	mov	r18, r24
   //full
   if(((queue->end + 1) % queue->length) == queue->start){
    2e5c:	39 81       	ldd	r19, Y+1	; 0x01
    2e5e:	83 2f       	mov	r24, r19
    2e60:	90 e0       	ldi	r25, 0x00	; 0
    2e62:	01 96       	adiw	r24, 0x01	; 1
    2e64:	6a 81       	ldd	r22, Y+2	; 0x02
    2e66:	70 e0       	ldi	r23, 0x00	; 0
    2e68:	0e 94 0d 1e 	call	0x3c1a	; 0x3c1a <__divmodhi4>
    2e6c:	48 81       	ld	r20, Y
    2e6e:	50 e0       	ldi	r21, 0x00	; 0
    2e70:	84 17       	cp	r24, r20
    2e72:	95 07       	cpc	r25, r21
    2e74:	29 f4       	brne	.+10     	; 0x2e80 <bytequeue_enqueue+0x34>
      restore_interrupt_setting(setting);
    2e76:	82 2f       	mov	r24, r18
    2e78:	0e 94 98 17 	call	0x2f30	; 0x2f30 <restore_interrupt_setting>
      return false;
    2e7c:	80 e0       	ldi	r24, 0x00	; 0
    2e7e:	11 c0       	rjmp	.+34     	; 0x2ea2 <bytequeue_enqueue+0x56>
   } else {
      queue->data[queue->end] = item;
    2e80:	eb 81       	ldd	r30, Y+3	; 0x03
    2e82:	fc 81       	ldd	r31, Y+4	; 0x04
    2e84:	e3 0f       	add	r30, r19
    2e86:	f1 1d       	adc	r31, r1
    2e88:	10 83       	st	Z, r17
      queue->end = (queue->end + 1) % queue->length;
    2e8a:	89 81       	ldd	r24, Y+1	; 0x01
    2e8c:	90 e0       	ldi	r25, 0x00	; 0
    2e8e:	01 96       	adiw	r24, 0x01	; 1
    2e90:	6a 81       	ldd	r22, Y+2	; 0x02
    2e92:	70 e0       	ldi	r23, 0x00	; 0
    2e94:	0e 94 0d 1e 	call	0x3c1a	; 0x3c1a <__divmodhi4>
    2e98:	89 83       	std	Y+1, r24	; 0x01
      restore_interrupt_setting(setting);
    2e9a:	82 2f       	mov	r24, r18
    2e9c:	0e 94 98 17 	call	0x2f30	; 0x2f30 <restore_interrupt_setting>
      return true;
    2ea0:	81 e0       	ldi	r24, 0x01	; 1
   }
}
    2ea2:	df 91       	pop	r29
    2ea4:	cf 91       	pop	r28
    2ea6:	1f 91       	pop	r17
    2ea8:	08 95       	ret

00002eaa <bytequeue_length>:

byteQueueIndex_t bytequeue_length(byteQueue_t * queue){
    2eaa:	cf 93       	push	r28
    2eac:	df 93       	push	r29
    2eae:	ec 01       	movw	r28, r24
   byteQueueIndex_t len;
   interrupt_setting_t setting = store_and_clear_interrupt();
    2eb0:	0e 94 95 17 	call	0x2f2a	; 0x2f2a <store_and_clear_interrupt>
   if(queue->end >= queue->start)
    2eb4:	29 81       	ldd	r18, Y+1	; 0x01
    2eb6:	98 81       	ld	r25, Y
    2eb8:	29 17       	cp	r18, r25
    2eba:	18 f0       	brcs	.+6      	; 0x2ec2 <bytequeue_length+0x18>
      len = queue->end - queue->start;
    2ebc:	c2 2f       	mov	r28, r18
    2ebe:	c9 1b       	sub	r28, r25
    2ec0:	03 c0       	rjmp	.+6      	; 0x2ec8 <bytequeue_length+0x1e>
   else
      len = (queue->length - queue->start) + queue->end;
    2ec2:	ca 81       	ldd	r28, Y+2	; 0x02
    2ec4:	c2 0f       	add	r28, r18
    2ec6:	c9 1b       	sub	r28, r25
   restore_interrupt_setting(setting);
    2ec8:	0e 94 98 17 	call	0x2f30	; 0x2f30 <restore_interrupt_setting>
   return len;
}
    2ecc:	8c 2f       	mov	r24, r28
    2ece:	df 91       	pop	r29
    2ed0:	cf 91       	pop	r28
    2ed2:	08 95       	ret

00002ed4 <bytequeue_get>:

//we don't need to avoid interrupts if there is only one reader
uint8_t bytequeue_get(byteQueue_t * queue, byteQueueIndex_t index){
    2ed4:	fc 01       	movw	r30, r24
   return queue->data[(queue->start + index) % queue->length];
    2ed6:	20 81       	ld	r18, Z
    2ed8:	86 2f       	mov	r24, r22
    2eda:	90 e0       	ldi	r25, 0x00	; 0
    2edc:	82 0f       	add	r24, r18
    2ede:	91 1d       	adc	r25, r1
    2ee0:	62 81       	ldd	r22, Z+2	; 0x02
    2ee2:	70 e0       	ldi	r23, 0x00	; 0
    2ee4:	0e 94 0d 1e 	call	0x3c1a	; 0x3c1a <__divmodhi4>
    2ee8:	03 80       	ldd	r0, Z+3	; 0x03
    2eea:	f4 81       	ldd	r31, Z+4	; 0x04
    2eec:	e0 2d       	mov	r30, r0
    2eee:	e8 0f       	add	r30, r24
    2ef0:	f9 1f       	adc	r31, r25
}
    2ef2:	80 81       	ld	r24, Z
    2ef4:	08 95       	ret

00002ef6 <bytequeue_remove>:

//we just update the start index to remove elements
void bytequeue_remove(byteQueue_t * queue, byteQueueIndex_t numToRemove){
    2ef6:	1f 93       	push	r17
    2ef8:	cf 93       	push	r28
    2efa:	df 93       	push	r29
    2efc:	ec 01       	movw	r28, r24
    2efe:	16 2f       	mov	r17, r22
   interrupt_setting_t setting = store_and_clear_interrupt();
    2f00:	0e 94 95 17 	call	0x2f2a	; 0x2f2a <store_and_clear_interrupt>
    2f04:	48 2f       	mov	r20, r24
   queue->start = (queue->start + numToRemove) % queue->length;
    2f06:	88 81       	ld	r24, Y
    2f08:	21 2f       	mov	r18, r17
    2f0a:	30 e0       	ldi	r19, 0x00	; 0
    2f0c:	28 0f       	add	r18, r24
    2f0e:	31 1d       	adc	r19, r1
    2f10:	6a 81       	ldd	r22, Y+2	; 0x02
    2f12:	c9 01       	movw	r24, r18
    2f14:	70 e0       	ldi	r23, 0x00	; 0
    2f16:	0e 94 0d 1e 	call	0x3c1a	; 0x3c1a <__divmodhi4>
    2f1a:	88 83       	st	Y, r24
   restore_interrupt_setting(setting);
    2f1c:	84 2f       	mov	r24, r20
    2f1e:	0e 94 98 17 	call	0x2f30	; 0x2f30 <restore_interrupt_setting>
}
    2f22:	df 91       	pop	r29
    2f24:	cf 91       	pop	r28
    2f26:	1f 91       	pop	r17
    2f28:	08 95       	ret

00002f2a <store_and_clear_interrupt>:

#include "interrupt_setting.h"
#include <avr/interrupt.h>

interrupt_setting_t store_and_clear_interrupt(void) {
   uint8_t sreg = SREG;
    2f2a:	8f b7       	in	r24, 0x3f	; 63
   cli();
    2f2c:	f8 94       	cli
   return sreg;
}
    2f2e:	08 95       	ret

00002f30 <restore_interrupt_setting>:

void restore_interrupt_setting(interrupt_setting_t setting) {
   SREG = setting;
    2f30:	8f bf       	out	0x3f, r24	; 63
}
    2f32:	08 95       	ret

00002f34 <midi_is_statusbyte>:
#define NULL 0
#endif

bool midi_is_statusbyte(uint8_t theByte){
   return (bool)(theByte & MIDI_STATUSMASK);
}
    2f34:	88 1f       	adc	r24, r24
    2f36:	88 27       	eor	r24, r24
    2f38:	88 1f       	adc	r24, r24
    2f3a:	08 95       	ret

00002f3c <midi_is_realtime>:

bool midi_is_realtime(uint8_t theByte){
   return (theByte >= MIDI_CLOCK);
    2f3c:	91 e0       	ldi	r25, 0x01	; 1
    2f3e:	88 3f       	cpi	r24, 0xF8	; 248
    2f40:	08 f4       	brcc	.+2      	; 0x2f44 <midi_is_realtime+0x8>
    2f42:	90 e0       	ldi	r25, 0x00	; 0
}
    2f44:	89 2f       	mov	r24, r25
    2f46:	08 95       	ret

00002f48 <midi_packet_length>:

midi_packet_length_t midi_packet_length(uint8_t status){
   switch(status & 0xF0){
    2f48:	28 2f       	mov	r18, r24
    2f4a:	30 e0       	ldi	r19, 0x00	; 0
    2f4c:	20 7f       	andi	r18, 0xF0	; 240
    2f4e:	30 70       	andi	r19, 0x00	; 0
    2f50:	20 3c       	cpi	r18, 0xC0	; 192
    2f52:	31 05       	cpc	r19, r1
    2f54:	e9 f1       	breq	.+122    	; 0x2fd0 <midi_packet_length+0x88>
    2f56:	21 3c       	cpi	r18, 0xC1	; 193
    2f58:	31 05       	cpc	r19, r1
    2f5a:	8c f4       	brge	.+34     	; 0x2f7e <midi_packet_length+0x36>
    2f5c:	20 39       	cpi	r18, 0x90	; 144
    2f5e:	31 05       	cpc	r19, r1
    2f60:	e1 f0       	breq	.+56     	; 0x2f9a <midi_packet_length+0x52>
    2f62:	21 39       	cpi	r18, 0x91	; 145
    2f64:	31 05       	cpc	r19, r1
    2f66:	24 f4       	brge	.+8      	; 0x2f70 <midi_packet_length+0x28>
    2f68:	20 38       	cpi	r18, 0x80	; 128
    2f6a:	31 05       	cpc	r19, r1
    2f6c:	79 f5       	brne	.+94     	; 0x2fcc <midi_packet_length+0x84>
    2f6e:	15 c0       	rjmp	.+42     	; 0x2f9a <midi_packet_length+0x52>
    2f70:	20 3a       	cpi	r18, 0xA0	; 160
    2f72:	31 05       	cpc	r19, r1
    2f74:	91 f0       	breq	.+36     	; 0x2f9a <midi_packet_length+0x52>
    2f76:	20 3b       	cpi	r18, 0xB0	; 176
    2f78:	31 05       	cpc	r19, r1
    2f7a:	41 f5       	brne	.+80     	; 0x2fcc <midi_packet_length+0x84>
    2f7c:	0e c0       	rjmp	.+28     	; 0x2f9a <midi_packet_length+0x52>
    2f7e:	20 3e       	cpi	r18, 0xE0	; 224
    2f80:	31 05       	cpc	r19, r1
    2f82:	59 f0       	breq	.+22     	; 0x2f9a <midi_packet_length+0x52>
    2f84:	21 3e       	cpi	r18, 0xE1	; 225
    2f86:	31 05       	cpc	r19, r1
    2f88:	24 f4       	brge	.+8      	; 0x2f92 <midi_packet_length+0x4a>
    2f8a:	20 3d       	cpi	r18, 0xD0	; 208
    2f8c:	31 05       	cpc	r19, r1
    2f8e:	f1 f4       	brne	.+60     	; 0x2fcc <midi_packet_length+0x84>
    2f90:	1f c0       	rjmp	.+62     	; 0x2fd0 <midi_packet_length+0x88>
    2f92:	20 3f       	cpi	r18, 0xF0	; 240
    2f94:	31 05       	cpc	r19, r1
    2f96:	d1 f4       	brne	.+52     	; 0x2fcc <midi_packet_length+0x84>
    2f98:	02 c0       	rjmp	.+4      	; 0x2f9e <midi_packet_length+0x56>
      case MIDI_CC:
      case MIDI_NOTEON:
      case MIDI_NOTEOFF:
      case MIDI_AFTERTOUCH:
      case MIDI_PITCHBEND:
         return THREE3;
    2f9a:	83 e0       	ldi	r24, 0x03	; 3
    2f9c:	08 95       	ret
      case MIDI_PROGCHANGE:
      case MIDI_CHANPRESSURE:
      case MIDI_SONGSELECT:
         return TWO2;
      case 0xF0:
         switch(status) {
    2f9e:	86 3f       	cpi	r24, 0xF6	; 246
    2fa0:	79 f0       	breq	.+30     	; 0x2fc0 <midi_packet_length+0x78>
    2fa2:	87 3f       	cpi	r24, 0xF7	; 247
    2fa4:	38 f4       	brcc	.+14     	; 0x2fb4 <midi_packet_length+0x6c>
    2fa6:	82 3f       	cpi	r24, 0xF2	; 242
    2fa8:	a9 f0       	breq	.+42     	; 0x2fd4 <midi_packet_length+0x8c>
    2faa:	83 3f       	cpi	r24, 0xF3	; 243
    2fac:	59 f0       	breq	.+22     	; 0x2fc4 <midi_packet_length+0x7c>
    2fae:	81 3f       	cpi	r24, 0xF1	; 241
    2fb0:	59 f4       	brne	.+22     	; 0x2fc8 <midi_packet_length+0x80>
    2fb2:	08 c0       	rjmp	.+16     	; 0x2fc4 <midi_packet_length+0x7c>
    2fb4:	88 3f       	cpi	r24, 0xF8	; 248
    2fb6:	40 f0       	brcs	.+16     	; 0x2fc8 <midi_packet_length+0x80>
    2fb8:	8d 3f       	cpi	r24, 0xFD	; 253
    2fba:	10 f0       	brcs	.+4      	; 0x2fc0 <midi_packet_length+0x78>
    2fbc:	8e 3f       	cpi	r24, 0xFE	; 254
    2fbe:	20 f0       	brcs	.+8      	; 0x2fc8 <midi_packet_length+0x80>
            case MIDI_CONTINUE:
            case MIDI_STOP:
            case MIDI_ACTIVESENSE:
            case MIDI_RESET:
            case MIDI_TUNEREQUEST:
               return ONE1;
    2fc0:	81 e0       	ldi	r24, 0x01	; 1
    2fc2:	08 95       	ret
            case MIDI_SONGPOSITION:
               return THREE3;
            case MIDI_TC_QUARTERFRAME:
            case MIDI_SONGSELECT:
               return TWO2;
    2fc4:	82 e0       	ldi	r24, 0x02	; 2
    2fc6:	08 95       	ret
            case SYSEX_END:
            case SYSEX_BEGIN:
            default:
               return UNDEFINED;
    2fc8:	80 e0       	ldi	r24, 0x00	; 0
    2fca:	08 95       	ret
         }
      default:
         return UNDEFINED;
    2fcc:	80 e0       	ldi	r24, 0x00	; 0
    2fce:	08 95       	ret
      case MIDI_PITCHBEND:
         return THREE3;
      case MIDI_PROGCHANGE:
      case MIDI_CHANPRESSURE:
      case MIDI_SONGSELECT:
         return TWO2;
    2fd0:	82 e0       	ldi	r24, 0x02	; 2
    2fd2:	08 95       	ret
            case MIDI_ACTIVESENSE:
            case MIDI_RESET:
            case MIDI_TUNEREQUEST:
               return ONE1;
            case MIDI_SONGPOSITION:
               return THREE3;
    2fd4:	83 e0       	ldi	r24, 0x03	; 3
               return UNDEFINED;
         }
      default:
         return UNDEFINED;
   }
}
    2fd6:	08 95       	ret

00002fd8 <midi_send_cc>:

void midi_send_cc(MidiDevice * device, uint8_t chan, uint8_t num, uint8_t val){
    2fd8:	0f 93       	push	r16
    2fda:	34 2f       	mov	r19, r20
    2fdc:	02 2f       	mov	r16, r18
   //CC Status: 0xB0 to 0xBF where the low nibble is the MIDI channel.
   //CC Data: Controller Num, Controller Val
   device->send_func(device, 3,
    2fde:	46 2f       	mov	r20, r22
    2fe0:	4f 70       	andi	r20, 0x0F	; 15
    2fe2:	40 6b       	ori	r20, 0xB0	; 176
    2fe4:	23 2f       	mov	r18, r19
    2fe6:	2f 77       	andi	r18, 0x7F	; 127
    2fe8:	0f 77       	andi	r16, 0x7F	; 127
    2fea:	dc 01       	movw	r26, r24
    2fec:	ed 91       	ld	r30, X+
    2fee:	fc 91       	ld	r31, X
    2ff0:	63 e0       	ldi	r22, 0x03	; 3
    2ff2:	70 e0       	ldi	r23, 0x00	; 0
    2ff4:	09 95       	icall
         MIDI_CC | (chan & MIDI_CHANMASK),
         num & 0x7F,
         val & 0x7F);
}
    2ff6:	0f 91       	pop	r16
    2ff8:	08 95       	ret

00002ffa <midi_send_noteon>:

void midi_send_noteon(MidiDevice * device, uint8_t chan, uint8_t num, uint8_t vel){
    2ffa:	0f 93       	push	r16
    2ffc:	34 2f       	mov	r19, r20
    2ffe:	02 2f       	mov	r16, r18
   //Note Data: Note Num, Note Velocity
   device->send_func(device, 3,
    3000:	46 2f       	mov	r20, r22
    3002:	4f 70       	andi	r20, 0x0F	; 15
    3004:	40 69       	ori	r20, 0x90	; 144
    3006:	23 2f       	mov	r18, r19
    3008:	2f 77       	andi	r18, 0x7F	; 127
    300a:	0f 77       	andi	r16, 0x7F	; 127
    300c:	dc 01       	movw	r26, r24
    300e:	ed 91       	ld	r30, X+
    3010:	fc 91       	ld	r31, X
    3012:	63 e0       	ldi	r22, 0x03	; 3
    3014:	70 e0       	ldi	r23, 0x00	; 0
    3016:	09 95       	icall
         MIDI_NOTEON | (chan & MIDI_CHANMASK),
         num & 0x7F,
         vel & 0x7F);
}
    3018:	0f 91       	pop	r16
    301a:	08 95       	ret

0000301c <midi_send_noteoff>:

void midi_send_noteoff(MidiDevice * device, uint8_t chan, uint8_t num, uint8_t vel){
    301c:	0f 93       	push	r16
    301e:	34 2f       	mov	r19, r20
    3020:	02 2f       	mov	r16, r18
   //Note Data: Note Num, Note Velocity
   device->send_func(device, 3,
    3022:	46 2f       	mov	r20, r22
    3024:	4f 70       	andi	r20, 0x0F	; 15
    3026:	40 68       	ori	r20, 0x80	; 128
    3028:	23 2f       	mov	r18, r19
    302a:	2f 77       	andi	r18, 0x7F	; 127
    302c:	0f 77       	andi	r16, 0x7F	; 127
    302e:	dc 01       	movw	r26, r24
    3030:	ed 91       	ld	r30, X+
    3032:	fc 91       	ld	r31, X
    3034:	63 e0       	ldi	r22, 0x03	; 3
    3036:	70 e0       	ldi	r23, 0x00	; 0
    3038:	09 95       	icall
         MIDI_NOTEOFF | (chan & MIDI_CHANMASK),
         num & 0x7F,
         vel & 0x7F);
}
    303a:	0f 91       	pop	r16
    303c:	08 95       	ret

0000303e <midi_send_aftertouch>:

void midi_send_aftertouch(MidiDevice * device, uint8_t chan, uint8_t note_num, uint8_t amt){
    303e:	0f 93       	push	r16
    3040:	34 2f       	mov	r19, r20
    3042:	02 2f       	mov	r16, r18
   device->send_func(device, 3,
    3044:	46 2f       	mov	r20, r22
    3046:	4f 70       	andi	r20, 0x0F	; 15
    3048:	40 6a       	ori	r20, 0xA0	; 160
    304a:	23 2f       	mov	r18, r19
    304c:	2f 77       	andi	r18, 0x7F	; 127
    304e:	0f 77       	andi	r16, 0x7F	; 127
    3050:	dc 01       	movw	r26, r24
    3052:	ed 91       	ld	r30, X+
    3054:	fc 91       	ld	r31, X
    3056:	63 e0       	ldi	r22, 0x03	; 3
    3058:	70 e0       	ldi	r23, 0x00	; 0
    305a:	09 95       	icall
         MIDI_AFTERTOUCH | (chan & MIDI_CHANMASK),
         note_num & 0x7F,
         amt & 0x7F);
}
    305c:	0f 91       	pop	r16
    305e:	08 95       	ret

00003060 <midi_send_pitchbend>:

//XXX does this work right?
//amt in range -0x2000, 0x1fff
//uAmt should be in range..
//0x0000 to 0x3FFF
void midi_send_pitchbend(MidiDevice * device, uint8_t chan, int16_t amt){
    3060:	0f 93       	push	r16
    3062:	1f 93       	push	r17
   uint16_t uAmt;
   //check range
   if(amt > 0x1fff){
    3064:	20 e2       	ldi	r18, 0x20	; 32
    3066:	40 30       	cpi	r20, 0x00	; 0
    3068:	52 07       	cpc	r21, r18
    306a:	44 f4       	brge	.+16     	; 0x307c <midi_send_pitchbend+0x1c>
      uAmt = 0x3FFF;
   } else if(amt < -0x2000){
    306c:	a0 ee       	ldi	r26, 0xE0	; 224
    306e:	40 30       	cpi	r20, 0x00	; 0
    3070:	5a 07       	cpc	r21, r26
    3072:	3c f0       	brlt	.+14     	; 0x3082 <midi_send_pitchbend+0x22>
      uAmt = 0;
   } else {
      uAmt = amt + 0x2000;
    3074:	8a 01       	movw	r16, r20
    3076:	00 50       	subi	r16, 0x00	; 0
    3078:	10 4e       	sbci	r17, 0xE0	; 224
    307a:	05 c0       	rjmp	.+10     	; 0x3086 <midi_send_pitchbend+0x26>
//0x0000 to 0x3FFF
void midi_send_pitchbend(MidiDevice * device, uint8_t chan, int16_t amt){
   uint16_t uAmt;
   //check range
   if(amt > 0x1fff){
      uAmt = 0x3FFF;
    307c:	0f ef       	ldi	r16, 0xFF	; 255
    307e:	1f e3       	ldi	r17, 0x3F	; 63
    3080:	02 c0       	rjmp	.+4      	; 0x3086 <midi_send_pitchbend+0x26>
   } else if(amt < -0x2000){
      uAmt = 0;
    3082:	00 e0       	ldi	r16, 0x00	; 0
    3084:	10 e0       	ldi	r17, 0x00	; 0
   } else {
      uAmt = amt + 0x2000;
   }
   device->send_func(device, 3,
    3086:	46 2f       	mov	r20, r22
    3088:	4f 70       	andi	r20, 0x0F	; 15
    308a:	40 6e       	ori	r20, 0xE0	; 224
    308c:	20 2f       	mov	r18, r16
    308e:	2f 77       	andi	r18, 0x7F	; 127
         MIDI_PITCHBEND | (chan & MIDI_CHANMASK),
         uAmt & 0x7F,
         (uAmt >> 7) & 0x7F);
    3090:	00 0f       	add	r16, r16
    3092:	01 2f       	mov	r16, r17
    3094:	00 1f       	adc	r16, r16
    3096:	11 0b       	sbc	r17, r17
    3098:	11 95       	neg	r17
   } else if(amt < -0x2000){
      uAmt = 0;
   } else {
      uAmt = amt + 0x2000;
   }
   device->send_func(device, 3,
    309a:	0f 77       	andi	r16, 0x7F	; 127
    309c:	dc 01       	movw	r26, r24
    309e:	ed 91       	ld	r30, X+
    30a0:	fc 91       	ld	r31, X
    30a2:	63 e0       	ldi	r22, 0x03	; 3
    30a4:	70 e0       	ldi	r23, 0x00	; 0
    30a6:	09 95       	icall
         MIDI_PITCHBEND | (chan & MIDI_CHANMASK),
         uAmt & 0x7F,
         (uAmt >> 7) & 0x7F);
}
    30a8:	1f 91       	pop	r17
    30aa:	0f 91       	pop	r16
    30ac:	08 95       	ret

000030ae <midi_send_programchange>:

void midi_send_programchange(MidiDevice * device, uint8_t chan, uint8_t num){
    30ae:	0f 93       	push	r16
    30b0:	24 2f       	mov	r18, r20
   device->send_func(device, 2,
    30b2:	46 2f       	mov	r20, r22
    30b4:	4f 70       	andi	r20, 0x0F	; 15
    30b6:	40 6c       	ori	r20, 0xC0	; 192
    30b8:	2f 77       	andi	r18, 0x7F	; 127
    30ba:	dc 01       	movw	r26, r24
    30bc:	ed 91       	ld	r30, X+
    30be:	fc 91       	ld	r31, X
    30c0:	62 e0       	ldi	r22, 0x02	; 2
    30c2:	70 e0       	ldi	r23, 0x00	; 0
    30c4:	00 e0       	ldi	r16, 0x00	; 0
    30c6:	09 95       	icall
         MIDI_PROGCHANGE | (chan & MIDI_CHANMASK),
         num & 0x7F,
         0);
}
    30c8:	0f 91       	pop	r16
    30ca:	08 95       	ret

000030cc <midi_send_channelpressure>:

void midi_send_channelpressure(MidiDevice * device, uint8_t chan, uint8_t amt){
    30cc:	0f 93       	push	r16
    30ce:	24 2f       	mov	r18, r20
   device->send_func(device, 2,
    30d0:	46 2f       	mov	r20, r22
    30d2:	4f 70       	andi	r20, 0x0F	; 15
    30d4:	40 6d       	ori	r20, 0xD0	; 208
    30d6:	2f 77       	andi	r18, 0x7F	; 127
    30d8:	dc 01       	movw	r26, r24
    30da:	ed 91       	ld	r30, X+
    30dc:	fc 91       	ld	r31, X
    30de:	62 e0       	ldi	r22, 0x02	; 2
    30e0:	70 e0       	ldi	r23, 0x00	; 0
    30e2:	00 e0       	ldi	r16, 0x00	; 0
    30e4:	09 95       	icall
         MIDI_CHANPRESSURE | (chan & MIDI_CHANMASK),
         amt & 0x7F,
         0);
}
    30e6:	0f 91       	pop	r16
    30e8:	08 95       	ret

000030ea <midi_send_clock>:

void midi_send_clock(MidiDevice * device){
    30ea:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_CLOCK, 0, 0);
    30ec:	dc 01       	movw	r26, r24
    30ee:	ed 91       	ld	r30, X+
    30f0:	fc 91       	ld	r31, X
    30f2:	61 e0       	ldi	r22, 0x01	; 1
    30f4:	70 e0       	ldi	r23, 0x00	; 0
    30f6:	48 ef       	ldi	r20, 0xF8	; 248
    30f8:	20 e0       	ldi	r18, 0x00	; 0
    30fa:	00 e0       	ldi	r16, 0x00	; 0
    30fc:	09 95       	icall
}
    30fe:	0f 91       	pop	r16
    3100:	08 95       	ret

00003102 <midi_send_tick>:

void midi_send_tick(MidiDevice * device){
    3102:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_TICK, 0, 0);
    3104:	dc 01       	movw	r26, r24
    3106:	ed 91       	ld	r30, X+
    3108:	fc 91       	ld	r31, X
    310a:	61 e0       	ldi	r22, 0x01	; 1
    310c:	70 e0       	ldi	r23, 0x00	; 0
    310e:	49 ef       	ldi	r20, 0xF9	; 249
    3110:	20 e0       	ldi	r18, 0x00	; 0
    3112:	00 e0       	ldi	r16, 0x00	; 0
    3114:	09 95       	icall
}
    3116:	0f 91       	pop	r16
    3118:	08 95       	ret

0000311a <midi_send_start>:

void midi_send_start(MidiDevice * device){
    311a:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_START, 0, 0);
    311c:	dc 01       	movw	r26, r24
    311e:	ed 91       	ld	r30, X+
    3120:	fc 91       	ld	r31, X
    3122:	61 e0       	ldi	r22, 0x01	; 1
    3124:	70 e0       	ldi	r23, 0x00	; 0
    3126:	4a ef       	ldi	r20, 0xFA	; 250
    3128:	20 e0       	ldi	r18, 0x00	; 0
    312a:	00 e0       	ldi	r16, 0x00	; 0
    312c:	09 95       	icall
}
    312e:	0f 91       	pop	r16
    3130:	08 95       	ret

00003132 <midi_send_continue>:

void midi_send_continue(MidiDevice * device){
    3132:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_CONTINUE, 0, 0);
    3134:	dc 01       	movw	r26, r24
    3136:	ed 91       	ld	r30, X+
    3138:	fc 91       	ld	r31, X
    313a:	61 e0       	ldi	r22, 0x01	; 1
    313c:	70 e0       	ldi	r23, 0x00	; 0
    313e:	4b ef       	ldi	r20, 0xFB	; 251
    3140:	20 e0       	ldi	r18, 0x00	; 0
    3142:	00 e0       	ldi	r16, 0x00	; 0
    3144:	09 95       	icall
}
    3146:	0f 91       	pop	r16
    3148:	08 95       	ret

0000314a <midi_send_stop>:

void midi_send_stop(MidiDevice * device){
    314a:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_STOP, 0, 0);
    314c:	dc 01       	movw	r26, r24
    314e:	ed 91       	ld	r30, X+
    3150:	fc 91       	ld	r31, X
    3152:	61 e0       	ldi	r22, 0x01	; 1
    3154:	70 e0       	ldi	r23, 0x00	; 0
    3156:	4c ef       	ldi	r20, 0xFC	; 252
    3158:	20 e0       	ldi	r18, 0x00	; 0
    315a:	00 e0       	ldi	r16, 0x00	; 0
    315c:	09 95       	icall
}
    315e:	0f 91       	pop	r16
    3160:	08 95       	ret

00003162 <midi_send_activesense>:

void midi_send_activesense(MidiDevice * device){
    3162:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_ACTIVESENSE, 0, 0);
    3164:	dc 01       	movw	r26, r24
    3166:	ed 91       	ld	r30, X+
    3168:	fc 91       	ld	r31, X
    316a:	61 e0       	ldi	r22, 0x01	; 1
    316c:	70 e0       	ldi	r23, 0x00	; 0
    316e:	4e ef       	ldi	r20, 0xFE	; 254
    3170:	20 e0       	ldi	r18, 0x00	; 0
    3172:	00 e0       	ldi	r16, 0x00	; 0
    3174:	09 95       	icall
}
    3176:	0f 91       	pop	r16
    3178:	08 95       	ret

0000317a <midi_send_reset>:

void midi_send_reset(MidiDevice * device){
    317a:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_RESET, 0, 0);
    317c:	dc 01       	movw	r26, r24
    317e:	ed 91       	ld	r30, X+
    3180:	fc 91       	ld	r31, X
    3182:	61 e0       	ldi	r22, 0x01	; 1
    3184:	70 e0       	ldi	r23, 0x00	; 0
    3186:	4f ef       	ldi	r20, 0xFF	; 255
    3188:	20 e0       	ldi	r18, 0x00	; 0
    318a:	00 e0       	ldi	r16, 0x00	; 0
    318c:	09 95       	icall
}
    318e:	0f 91       	pop	r16
    3190:	08 95       	ret

00003192 <midi_send_tcquarterframe>:

void midi_send_tcquarterframe(MidiDevice * device, uint8_t time){
    3192:	0f 93       	push	r16
   device->send_func(device, 2,
    3194:	26 2f       	mov	r18, r22
    3196:	2f 77       	andi	r18, 0x7F	; 127
    3198:	dc 01       	movw	r26, r24
    319a:	ed 91       	ld	r30, X+
    319c:	fc 91       	ld	r31, X
    319e:	62 e0       	ldi	r22, 0x02	; 2
    31a0:	70 e0       	ldi	r23, 0x00	; 0
    31a2:	41 ef       	ldi	r20, 0xF1	; 241
    31a4:	00 e0       	ldi	r16, 0x00	; 0
    31a6:	09 95       	icall
         MIDI_TC_QUARTERFRAME,
         time & 0x7F,
         0);
}
    31a8:	0f 91       	pop	r16
    31aa:	08 95       	ret

000031ac <midi_send_songposition>:

//XXX is this right?
void midi_send_songposition(MidiDevice * device, uint16_t pos){
    31ac:	0f 93       	push	r16
    31ae:	1f 93       	push	r17
   device->send_func(device, 3,
    31b0:	26 2f       	mov	r18, r22
    31b2:	2f 77       	andi	r18, 0x7F	; 127
         MIDI_SONGPOSITION,
         pos & 0x7F,
         (pos >> 7) & 0x7F);
    31b4:	8b 01       	movw	r16, r22
    31b6:	00 0f       	add	r16, r16
    31b8:	01 2f       	mov	r16, r17
    31ba:	00 1f       	adc	r16, r16
    31bc:	11 0b       	sbc	r17, r17
    31be:	11 95       	neg	r17
         0);
}

//XXX is this right?
void midi_send_songposition(MidiDevice * device, uint16_t pos){
   device->send_func(device, 3,
    31c0:	0f 77       	andi	r16, 0x7F	; 127
    31c2:	dc 01       	movw	r26, r24
    31c4:	ed 91       	ld	r30, X+
    31c6:	fc 91       	ld	r31, X
    31c8:	63 e0       	ldi	r22, 0x03	; 3
    31ca:	70 e0       	ldi	r23, 0x00	; 0
    31cc:	42 ef       	ldi	r20, 0xF2	; 242
    31ce:	09 95       	icall
         MIDI_SONGPOSITION,
         pos & 0x7F,
         (pos >> 7) & 0x7F);
}
    31d0:	1f 91       	pop	r17
    31d2:	0f 91       	pop	r16
    31d4:	08 95       	ret

000031d6 <midi_send_songselect>:

void midi_send_songselect(MidiDevice * device, uint8_t song){
    31d6:	0f 93       	push	r16
   device->send_func(device, 2,
    31d8:	26 2f       	mov	r18, r22
    31da:	2f 77       	andi	r18, 0x7F	; 127
    31dc:	dc 01       	movw	r26, r24
    31de:	ed 91       	ld	r30, X+
    31e0:	fc 91       	ld	r31, X
    31e2:	62 e0       	ldi	r22, 0x02	; 2
    31e4:	70 e0       	ldi	r23, 0x00	; 0
    31e6:	43 ef       	ldi	r20, 0xF3	; 243
    31e8:	00 e0       	ldi	r16, 0x00	; 0
    31ea:	09 95       	icall
         MIDI_SONGSELECT,
         song & 0x7F,
         0);
}
    31ec:	0f 91       	pop	r16
    31ee:	08 95       	ret

000031f0 <midi_send_tunerequest>:

void midi_send_tunerequest(MidiDevice * device){
    31f0:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_TUNEREQUEST, 0, 0);
    31f2:	dc 01       	movw	r26, r24
    31f4:	ed 91       	ld	r30, X+
    31f6:	fc 91       	ld	r31, X
    31f8:	61 e0       	ldi	r22, 0x01	; 1
    31fa:	70 e0       	ldi	r23, 0x00	; 0
    31fc:	46 ef       	ldi	r20, 0xF6	; 246
    31fe:	20 e0       	ldi	r18, 0x00	; 0
    3200:	00 e0       	ldi	r16, 0x00	; 0
    3202:	09 95       	icall
}
    3204:	0f 91       	pop	r16
    3206:	08 95       	ret

00003208 <midi_send_byte>:

void midi_send_byte(MidiDevice * device, uint8_t b){
    3208:	0f 93       	push	r16
    320a:	46 2f       	mov	r20, r22
   device->send_func(device, 1, b, 0, 0);
    320c:	dc 01       	movw	r26, r24
    320e:	ed 91       	ld	r30, X+
    3210:	fc 91       	ld	r31, X
    3212:	61 e0       	ldi	r22, 0x01	; 1
    3214:	70 e0       	ldi	r23, 0x00	; 0
    3216:	20 e0       	ldi	r18, 0x00	; 0
    3218:	00 e0       	ldi	r16, 0x00	; 0
    321a:	09 95       	icall
}
    321c:	0f 91       	pop	r16
    321e:	08 95       	ret

00003220 <midi_send_data>:

void midi_send_data(MidiDevice * device, uint16_t count, uint8_t byte0, uint8_t byte1, uint8_t byte2){
    3220:	0f 93       	push	r16
   //ensure that the count passed along is always 3 or lower
   if (count > 3) {
      //TODO how to do this correctly?
   }
   device->send_func(device, count, byte0, byte1, byte2);
    3222:	dc 01       	movw	r26, r24
    3224:	ed 91       	ld	r30, X+
    3226:	fc 91       	ld	r31, X
    3228:	09 95       	icall
}
    322a:	0f 91       	pop	r16
    322c:	08 95       	ret

0000322e <midi_send_array>:

void midi_send_array(MidiDevice * device, uint16_t count, uint8_t * array) {
    322e:	6f 92       	push	r6
    3230:	7f 92       	push	r7
    3232:	8f 92       	push	r8
    3234:	9f 92       	push	r9
    3236:	af 92       	push	r10
    3238:	bf 92       	push	r11
    323a:	cf 92       	push	r12
    323c:	df 92       	push	r13
    323e:	ef 92       	push	r14
    3240:	ff 92       	push	r15
    3242:	0f 93       	push	r16
    3244:	1f 93       	push	r17
    3246:	cf 93       	push	r28
    3248:	df 93       	push	r29
    324a:	00 d0       	rcall	.+0      	; 0x324c <midi_send_array+0x1e>
    324c:	0f 92       	push	r0
    324e:	cd b7       	in	r28, 0x3d	; 61
    3250:	de b7       	in	r29, 0x3e	; 62
    3252:	4c 01       	movw	r8, r24
    3254:	6b 01       	movw	r12, r22
    3256:	5a 01       	movw	r10, r20
  uint16_t i;
  for (i = 0; i < count; i += 3) {
    3258:	61 15       	cp	r22, r1
    325a:	71 05       	cpc	r23, r1
    325c:	41 f1       	breq	.+80     	; 0x32ae <midi_send_array+0x80>
    325e:	ee 24       	eor	r14, r14
    3260:	ff 24       	eor	r15, r15
    uint8_t b[3] = { 0, 0, 0 };
    uint16_t to_send = count - i;
    to_send = (to_send > 3) ? 3 : to_send;
    3262:	0f 2e       	mov	r0, r31
    3264:	f3 e0       	ldi	r31, 0x03	; 3
    3266:	6f 2e       	mov	r6, r31
    3268:	77 24       	eor	r7, r7
    326a:	f0 2d       	mov	r31, r0
}

void midi_send_array(MidiDevice * device, uint16_t count, uint8_t * array) {
  uint16_t i;
  for (i = 0; i < count; i += 3) {
    uint8_t b[3] = { 0, 0, 0 };
    326c:	19 82       	std	Y+1, r1	; 0x01
    326e:	1a 82       	std	Y+2, r1	; 0x02
    3270:	1b 82       	std	Y+3, r1	; 0x03
    uint16_t to_send = count - i;
    3272:	86 01       	movw	r16, r12
    3274:	0e 19       	sub	r16, r14
    3276:	1f 09       	sbc	r17, r15
    to_send = (to_send > 3) ? 3 : to_send;
    3278:	04 30       	cpi	r16, 0x04	; 4
    327a:	11 05       	cpc	r17, r1
    327c:	08 f0       	brcs	.+2      	; 0x3280 <midi_send_array+0x52>
    327e:	83 01       	movw	r16, r6
      //TODO how to do this correctly?
   }
   device->send_func(device, count, byte0, byte1, byte2);
}

void midi_send_array(MidiDevice * device, uint16_t count, uint8_t * array) {
    3280:	b5 01       	movw	r22, r10
    3282:	6e 0d       	add	r22, r14
    3284:	7f 1d       	adc	r23, r15
  uint16_t i;
  for (i = 0; i < count; i += 3) {
    uint8_t b[3] = { 0, 0, 0 };
    uint16_t to_send = count - i;
    to_send = (to_send > 3) ? 3 : to_send;
    memcpy(b, array + i, to_send);
    3286:	ce 01       	movw	r24, r28
    3288:	01 96       	adiw	r24, 0x01	; 1
    328a:	40 2f       	mov	r20, r16
    328c:	51 2f       	mov	r21, r17
    328e:	0e 94 7e 1e 	call	0x3cfc	; 0x3cfc <memcpy>
    midi_send_data(device, to_send, b[0], b[1], b[2]);
    3292:	c4 01       	movw	r24, r8
    3294:	b8 01       	movw	r22, r16
    3296:	49 81       	ldd	r20, Y+1	; 0x01
    3298:	2a 81       	ldd	r18, Y+2	; 0x02
    329a:	0b 81       	ldd	r16, Y+3	; 0x03
    329c:	0e 94 10 19 	call	0x3220	; 0x3220 <midi_send_data>
   device->send_func(device, count, byte0, byte1, byte2);
}

void midi_send_array(MidiDevice * device, uint16_t count, uint8_t * array) {
  uint16_t i;
  for (i = 0; i < count; i += 3) {
    32a0:	83 e0       	ldi	r24, 0x03	; 3
    32a2:	90 e0       	ldi	r25, 0x00	; 0
    32a4:	e8 0e       	add	r14, r24
    32a6:	f9 1e       	adc	r15, r25
    32a8:	ec 14       	cp	r14, r12
    32aa:	fd 04       	cpc	r15, r13
    32ac:	f8 f2       	brcs	.-66     	; 0x326c <midi_send_array+0x3e>
    uint16_t to_send = count - i;
    to_send = (to_send > 3) ? 3 : to_send;
    memcpy(b, array + i, to_send);
    midi_send_data(device, to_send, b[0], b[1], b[2]);
  }
}
    32ae:	0f 90       	pop	r0
    32b0:	0f 90       	pop	r0
    32b2:	0f 90       	pop	r0
    32b4:	df 91       	pop	r29
    32b6:	cf 91       	pop	r28
    32b8:	1f 91       	pop	r17
    32ba:	0f 91       	pop	r16
    32bc:	ff 90       	pop	r15
    32be:	ef 90       	pop	r14
    32c0:	df 90       	pop	r13
    32c2:	cf 90       	pop	r12
    32c4:	bf 90       	pop	r11
    32c6:	af 90       	pop	r10
    32c8:	9f 90       	pop	r9
    32ca:	8f 90       	pop	r8
    32cc:	7f 90       	pop	r7
    32ce:	6f 90       	pop	r6
    32d0:	08 95       	ret

000032d2 <midi_register_cc_callback>:


void midi_register_cc_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_cc_callback = func;
    32d2:	fc 01       	movw	r30, r24
    32d4:	73 83       	std	Z+3, r23	; 0x03
    32d6:	62 83       	std	Z+2, r22	; 0x02
}
    32d8:	08 95       	ret

000032da <midi_register_noteon_callback>:

void midi_register_noteon_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_noteon_callback = func;
    32da:	fc 01       	movw	r30, r24
    32dc:	75 83       	std	Z+5, r23	; 0x05
    32de:	64 83       	std	Z+4, r22	; 0x04
}
    32e0:	08 95       	ret

000032e2 <midi_register_noteoff_callback>:

void midi_register_noteoff_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_noteoff_callback = func;
    32e2:	fc 01       	movw	r30, r24
    32e4:	77 83       	std	Z+7, r23	; 0x07
    32e6:	66 83       	std	Z+6, r22	; 0x06
}
    32e8:	08 95       	ret

000032ea <midi_register_aftertouch_callback>:

void midi_register_aftertouch_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_aftertouch_callback = func;
    32ea:	fc 01       	movw	r30, r24
    32ec:	71 87       	std	Z+9, r23	; 0x09
    32ee:	60 87       	std	Z+8, r22	; 0x08
}
    32f0:	08 95       	ret

000032f2 <midi_register_pitchbend_callback>:

void midi_register_pitchbend_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_pitchbend_callback = func;
    32f2:	fc 01       	movw	r30, r24
    32f4:	73 87       	std	Z+11, r23	; 0x0b
    32f6:	62 87       	std	Z+10, r22	; 0x0a
}
    32f8:	08 95       	ret

000032fa <midi_register_songposition_callback>:

void midi_register_songposition_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_songposition_callback = func;
    32fa:	fc 01       	movw	r30, r24
    32fc:	75 87       	std	Z+13, r23	; 0x0d
    32fe:	64 87       	std	Z+12, r22	; 0x0c
}
    3300:	08 95       	ret

00003302 <midi_register_progchange_callback>:

void midi_register_progchange_callback(MidiDevice * device, midi_two_byte_func_t func) {
   device->input_progchange_callback = func;
    3302:	fc 01       	movw	r30, r24
    3304:	77 87       	std	Z+15, r23	; 0x0f
    3306:	66 87       	std	Z+14, r22	; 0x0e
}
    3308:	08 95       	ret

0000330a <midi_register_chanpressure_callback>:

void midi_register_chanpressure_callback(MidiDevice * device, midi_two_byte_func_t func) {
   device->input_chanpressure_callback = func;
    330a:	fc 01       	movw	r30, r24
    330c:	71 8b       	std	Z+17, r23	; 0x11
    330e:	60 8b       	std	Z+16, r22	; 0x10
}
    3310:	08 95       	ret

00003312 <midi_register_songselect_callback>:

void midi_register_songselect_callback(MidiDevice * device, midi_two_byte_func_t func) {
   device->input_songselect_callback = func;
    3312:	fc 01       	movw	r30, r24
    3314:	73 8b       	std	Z+19, r23	; 0x13
    3316:	62 8b       	std	Z+18, r22	; 0x12
}
    3318:	08 95       	ret

0000331a <midi_register_tc_quarterframe_callback>:

void midi_register_tc_quarterframe_callback(MidiDevice * device, midi_two_byte_func_t func) {
   device->input_tc_quarterframe_callback = func;
    331a:	fc 01       	movw	r30, r24
    331c:	75 8b       	std	Z+21, r23	; 0x15
    331e:	64 8b       	std	Z+20, r22	; 0x14
}
    3320:	08 95       	ret

00003322 <midi_register_realtime_callback>:

void midi_register_realtime_callback(MidiDevice * device, midi_one_byte_func_t func){
   device->input_realtime_callback = func;
    3322:	fc 01       	movw	r30, r24
    3324:	77 8b       	std	Z+23, r23	; 0x17
    3326:	66 8b       	std	Z+22, r22	; 0x16
}
    3328:	08 95       	ret

0000332a <midi_register_tunerequest_callback>:

void midi_register_tunerequest_callback(MidiDevice * device, midi_one_byte_func_t func){
   device->input_tunerequest_callback = func;
    332a:	fc 01       	movw	r30, r24
    332c:	71 8f       	std	Z+25, r23	; 0x19
    332e:	60 8f       	std	Z+24, r22	; 0x18
}
    3330:	08 95       	ret

00003332 <midi_register_sysex_callback>:

void midi_register_sysex_callback(MidiDevice * device, midi_sysex_func_t func) {
   device->input_sysex_callback = func;
    3332:	fc 01       	movw	r30, r24
    3334:	73 8f       	std	Z+27, r23	; 0x1b
    3336:	62 8f       	std	Z+26, r22	; 0x1a
}
    3338:	08 95       	ret

0000333a <midi_register_fallthrough_callback>:

void midi_register_fallthrough_callback(MidiDevice * device, midi_var_byte_func_t func){
   device->input_fallthrough_callback = func;
    333a:	fc 01       	movw	r30, r24
    333c:	75 8f       	std	Z+29, r23	; 0x1d
    333e:	64 8f       	std	Z+28, r22	; 0x1c
}
    3340:	08 95       	ret

00003342 <midi_register_catchall_callback>:

void midi_register_catchall_callback(MidiDevice * device, midi_var_byte_func_t func){
   device->input_catchall_callback = func;
    3342:	fc 01       	movw	r30, r24
    3344:	77 8f       	std	Z+31, r23	; 0x1f
    3346:	66 8f       	std	Z+30, r22	; 0x1e
}
    3348:	08 95       	ret

0000334a <midi_device_init>:

//forward declarations, internally used to call the callbacks
void midi_input_callbacks(MidiDevice * device, uint16_t cnt, uint8_t byte0, uint8_t byte1, uint8_t byte2);
void midi_process_byte(MidiDevice * device, uint8_t input);

void midi_device_init(MidiDevice * device){
    334a:	cf 93       	push	r28
    334c:	df 93       	push	r29
    334e:	ec 01       	movw	r28, r24
  device->input_state = IDLE;
    3350:	1d a2       	lds	r17, 0x9d
  device->input_count = 0;
    3352:	1f a2       	lds	r17, 0x9f
    3354:	1e a2       	lds	r17, 0x9e
  bytequeue_init(&device->input_queue, device->input_queue_data, MIDI_INPUT_QUEUE_LENGTH);
    3356:	bc 01       	movw	r22, r24
    3358:	68 5d       	subi	r22, 0xD8	; 216
    335a:	7f 4f       	sbci	r23, 0xFF	; 255
    335c:	88 51       	subi	r24, 0x18	; 24
    335e:	9f 4f       	sbci	r25, 0xFF	; 255
    3360:	40 ec       	ldi	r20, 0xC0	; 192
    3362:	0e 94 1f 17 	call	0x2e3e	; 0x2e3e <bytequeue_init>

  //three byte funcs
  device->input_cc_callback = NULL;
    3366:	1b 82       	std	Y+3, r1	; 0x03
    3368:	1a 82       	std	Y+2, r1	; 0x02
  device->input_noteon_callback = NULL;
    336a:	1d 82       	std	Y+5, r1	; 0x05
    336c:	1c 82       	std	Y+4, r1	; 0x04
  device->input_noteoff_callback = NULL;
    336e:	1f 82       	std	Y+7, r1	; 0x07
    3370:	1e 82       	std	Y+6, r1	; 0x06
  device->input_aftertouch_callback = NULL;
    3372:	19 86       	std	Y+9, r1	; 0x09
    3374:	18 86       	std	Y+8, r1	; 0x08
  device->input_pitchbend_callback = NULL;
    3376:	1b 86       	std	Y+11, r1	; 0x0b
    3378:	1a 86       	std	Y+10, r1	; 0x0a
  device->input_songposition_callback = NULL;
    337a:	1d 86       	std	Y+13, r1	; 0x0d
    337c:	1c 86       	std	Y+12, r1	; 0x0c

  //two byte funcs
  device->input_progchange_callback = NULL;
    337e:	1f 86       	std	Y+15, r1	; 0x0f
    3380:	1e 86       	std	Y+14, r1	; 0x0e
  device->input_chanpressure_callback = NULL;
    3382:	19 8a       	std	Y+17, r1	; 0x11
    3384:	18 8a       	std	Y+16, r1	; 0x10
  device->input_songselect_callback = NULL;
    3386:	1b 8a       	std	Y+19, r1	; 0x13
    3388:	1a 8a       	std	Y+18, r1	; 0x12
  device->input_tc_quarterframe_callback = NULL;
    338a:	1d 8a       	std	Y+21, r1	; 0x15
    338c:	1c 8a       	std	Y+20, r1	; 0x14

  //one byte funcs
  device->input_realtime_callback = NULL;
    338e:	1f 8a       	std	Y+23, r1	; 0x17
    3390:	1e 8a       	std	Y+22, r1	; 0x16
  device->input_tunerequest_callback = NULL;
    3392:	19 8e       	std	Y+25, r1	; 0x19
    3394:	18 8e       	std	Y+24, r1	; 0x18

  //var byte functions
  device->input_sysex_callback = NULL;
    3396:	1b 8e       	std	Y+27, r1	; 0x1b
    3398:	1a 8e       	std	Y+26, r1	; 0x1a
  device->input_fallthrough_callback = NULL;
    339a:	1d 8e       	std	Y+29, r1	; 0x1d
    339c:	1c 8e       	std	Y+28, r1	; 0x1c
  device->input_catchall_callback = NULL;
    339e:	1f 8e       	std	Y+31, r1	; 0x1f
    33a0:	1e 8e       	std	Y+30, r1	; 0x1e

  device->pre_input_process_callback = NULL;
    33a2:	19 a2       	lds	r17, 0x99
    33a4:	18 a2       	lds	r17, 0x98
}
    33a6:	df 91       	pop	r29
    33a8:	cf 91       	pop	r28
    33aa:	08 95       	ret

000033ac <midi_device_input>:

void midi_device_input(MidiDevice * device, uint8_t cnt, uint8_t * input) {
    33ac:	ef 92       	push	r14
    33ae:	ff 92       	push	r15
    33b0:	0f 93       	push	r16
    33b2:	1f 93       	push	r17
    33b4:	cf 93       	push	r28
    33b6:	df 93       	push	r29
    33b8:	d6 2f       	mov	r29, r22
  uint8_t i;
  for (i = 0; i < cnt; i++)
    33ba:	66 23       	and	r22, r22
    33bc:	99 f0       	breq	.+38     	; 0x33e4 <midi_device_input+0x38>
    33be:	04 2f       	mov	r16, r20
    33c0:	15 2f       	mov	r17, r21
    33c2:	c0 e0       	ldi	r28, 0x00	; 0
    bytequeue_enqueue(&device->input_queue, input[i]);
    33c4:	0f 2e       	mov	r0, r31
    33c6:	f8 ee       	ldi	r31, 0xE8	; 232
    33c8:	ef 2e       	mov	r14, r31
    33ca:	ff 24       	eor	r15, r15
    33cc:	f0 2d       	mov	r31, r0
    33ce:	e8 0e       	add	r14, r24
    33d0:	f9 1e       	adc	r15, r25
    33d2:	f8 01       	movw	r30, r16
    33d4:	61 91       	ld	r22, Z+
    33d6:	8f 01       	movw	r16, r30
    33d8:	c7 01       	movw	r24, r14
    33da:	0e 94 26 17 	call	0x2e4c	; 0x2e4c <bytequeue_enqueue>
  device->pre_input_process_callback = NULL;
}

void midi_device_input(MidiDevice * device, uint8_t cnt, uint8_t * input) {
  uint8_t i;
  for (i = 0; i < cnt; i++)
    33de:	cf 5f       	subi	r28, 0xFF	; 255
    33e0:	cd 17       	cp	r28, r29
    33e2:	b9 f7       	brne	.-18     	; 0x33d2 <midi_device_input+0x26>
    bytequeue_enqueue(&device->input_queue, input[i]);
}
    33e4:	df 91       	pop	r29
    33e6:	cf 91       	pop	r28
    33e8:	1f 91       	pop	r17
    33ea:	0f 91       	pop	r16
    33ec:	ff 90       	pop	r15
    33ee:	ef 90       	pop	r14
    33f0:	08 95       	ret

000033f2 <midi_device_set_send_func>:

void midi_device_set_send_func(MidiDevice * device, midi_var_byte_func_t send_func){
  device->send_func = send_func;
    33f2:	fc 01       	movw	r30, r24
    33f4:	71 83       	std	Z+1, r23	; 0x01
    33f6:	60 83       	st	Z, r22
}
    33f8:	08 95       	ret

000033fa <midi_device_set_pre_input_process_func>:

void midi_device_set_pre_input_process_func(MidiDevice * device, midi_no_byte_func_t pre_process_func){
  device->pre_input_process_callback = pre_process_func;
    33fa:	fc 01       	movw	r30, r24
    33fc:	71 a3       	lds	r23, 0x51
    33fe:	60 a3       	lds	r22, 0x50
}
    3400:	08 95       	ret

00003402 <midi_input_callbacks>:
      }
    }
  }
}

void midi_input_callbacks(MidiDevice * device, uint16_t cnt, uint8_t byte0, uint8_t byte1, uint8_t byte2) {
    3402:	af 92       	push	r10
    3404:	bf 92       	push	r11
    3406:	cf 92       	push	r12
    3408:	df 92       	push	r13
    340a:	ef 92       	push	r14
    340c:	ff 92       	push	r15
    340e:	0f 93       	push	r16
    3410:	1f 93       	push	r17
    3412:	cf 93       	push	r28
    3414:	df 93       	push	r29
    3416:	00 d0       	rcall	.+0      	; 0x3418 <midi_input_callbacks+0x16>
    3418:	0f 92       	push	r0
    341a:	cd b7       	in	r28, 0x3d	; 61
    341c:	de b7       	in	r29, 0x3e	; 62
    341e:	6c 01       	movw	r12, r24
    3420:	5b 01       	movw	r10, r22
    3422:	f4 2e       	mov	r15, r20
    3424:	e2 2e       	mov	r14, r18
    3426:	10 2f       	mov	r17, r16
  //did we end up calling a callback?
  bool called = false;
  if (device->input_state == SYSEX_MESSAGE) {
    3428:	dc 01       	movw	r26, r24
    342a:	95 96       	adiw	r26, 0x25	; 37
    342c:	8c 91       	ld	r24, X
    342e:	95 97       	sbiw	r26, 0x25	; 37
    3430:	84 30       	cpi	r24, 0x04	; 4
    3432:	e9 f4       	brne	.+58     	; 0x346e <midi_input_callbacks+0x6c>
    if (device->input_sysex_callback) {
    3434:	5a 96       	adiw	r26, 0x1a	; 26
    3436:	ed 91       	ld	r30, X+
    3438:	fc 91       	ld	r31, X
    343a:	5b 97       	sbiw	r26, 0x1b	; 27
    343c:	30 97       	sbiw	r30, 0x00	; 0
    343e:	09 f4       	brne	.+2      	; 0x3442 <midi_input_callbacks+0x40>
    3440:	ee c0       	rjmp	.+476    	; 0x361e <midi_input_callbacks+0x21c>
      const uint16_t start = ((cnt - 1) / 3) * 3;
    3442:	cb 01       	movw	r24, r22
    3444:	01 97       	sbiw	r24, 0x01	; 1
    3446:	63 e0       	ldi	r22, 0x03	; 3
    3448:	70 e0       	ldi	r23, 0x00	; 0
    344a:	0e 94 f9 1d 	call	0x3bf2	; 0x3bf2 <__udivmodhi4>
    344e:	cb 01       	movw	r24, r22
    3450:	88 0f       	add	r24, r24
    3452:	99 1f       	adc	r25, r25
    3454:	68 0f       	add	r22, r24
    3456:	79 1f       	adc	r23, r25
      const uint8_t length = (cnt - start);
      uint8_t data[3];
      data[0] = byte0;
    3458:	49 83       	std	Y+1, r20	; 0x01
      data[1] = byte1;
    345a:	2a 83       	std	Y+2, r18	; 0x02
      data[2] = byte2;
    345c:	0b 83       	std	Y+3, r16	; 0x03
  //did we end up calling a callback?
  bool called = false;
  if (device->input_state == SYSEX_MESSAGE) {
    if (device->input_sysex_callback) {
      const uint16_t start = ((cnt - 1) / 3) * 3;
      const uint8_t length = (cnt - start);
    345e:	4a 2d       	mov	r20, r10
    3460:	46 1b       	sub	r20, r22
      uint8_t data[3];
      data[0] = byte0;
      data[1] = byte1;
      data[2] = byte2;
      device->input_sysex_callback(device, start, length, data);
    3462:	c6 01       	movw	r24, r12
    3464:	9e 01       	movw	r18, r28
    3466:	2f 5f       	subi	r18, 0xFF	; 255
    3468:	3f 4f       	sbci	r19, 0xFF	; 255
    346a:	09 95       	icall
    346c:	c8 c0       	rjmp	.+400    	; 0x35fe <midi_input_callbacks+0x1fc>
      called = true;
    }
  } else {
    switch (cnt) {
    346e:	62 30       	cpi	r22, 0x02	; 2
    3470:	71 05       	cpc	r23, r1
    3472:	09 f4       	brne	.+2      	; 0x3476 <midi_input_callbacks+0x74>
    3474:	5f c0       	rjmp	.+190    	; 0x3534 <midi_input_callbacks+0x132>
    3476:	63 30       	cpi	r22, 0x03	; 3
    3478:	71 05       	cpc	r23, r1
    347a:	29 f0       	breq	.+10     	; 0x3486 <midi_input_callbacks+0x84>
    347c:	61 30       	cpi	r22, 0x01	; 1
    347e:	71 05       	cpc	r23, r1
    3480:	09 f0       	breq	.+2      	; 0x3484 <midi_input_callbacks+0x82>
    3482:	b3 c0       	rjmp	.+358    	; 0x35ea <midi_input_callbacks+0x1e8>
    3484:	99 c0       	rjmp	.+306    	; 0x35b8 <midi_input_callbacks+0x1b6>
      case 3:
        {
          midi_three_byte_func_t func = NULL;
          switch (byte0 & 0xF0) {
    3486:	84 2f       	mov	r24, r20
    3488:	90 e0       	ldi	r25, 0x00	; 0
    348a:	80 7f       	andi	r24, 0xF0	; 240
    348c:	90 70       	andi	r25, 0x00	; 0
    348e:	80 3a       	cpi	r24, 0xA0	; 160
    3490:	91 05       	cpc	r25, r1
    3492:	29 f1       	breq	.+74     	; 0x34de <midi_input_callbacks+0xdc>
    3494:	81 3a       	cpi	r24, 0xA1	; 161
    3496:	91 05       	cpc	r25, r1
    3498:	3c f4       	brge	.+14     	; 0x34a8 <midi_input_callbacks+0xa6>
    349a:	80 38       	cpi	r24, 0x80	; 128
    349c:	91 05       	cpc	r25, r1
    349e:	c9 f0       	breq	.+50     	; 0x34d2 <midi_input_callbacks+0xd0>
    34a0:	80 39       	cpi	r24, 0x90	; 144
    34a2:	91 05       	cpc	r25, r1
    34a4:	91 f5       	brne	.+100    	; 0x350a <midi_input_callbacks+0x108>
    34a6:	0f c0       	rjmp	.+30     	; 0x34c6 <midi_input_callbacks+0xc4>
    34a8:	80 3e       	cpi	r24, 0xE0	; 224
    34aa:	91 05       	cpc	r25, r1
    34ac:	f1 f0       	breq	.+60     	; 0x34ea <midi_input_callbacks+0xe8>
    34ae:	80 3f       	cpi	r24, 0xF0	; 240
    34b0:	91 05       	cpc	r25, r1
    34b2:	09 f1       	breq	.+66     	; 0x34f6 <midi_input_callbacks+0xf4>
    34b4:	80 3b       	cpi	r24, 0xB0	; 176
    34b6:	91 05       	cpc	r25, r1
    34b8:	41 f5       	brne	.+80     	; 0x350a <midi_input_callbacks+0x108>
            case MIDI_CC:
              func = device->input_cc_callback;
    34ba:	d6 01       	movw	r26, r12
    34bc:	12 96       	adiw	r26, 0x02	; 2
    34be:	ed 91       	ld	r30, X+
    34c0:	fc 91       	ld	r31, X
    34c2:	13 97       	sbiw	r26, 0x03	; 3
              break;
    34c4:	24 c0       	rjmp	.+72     	; 0x350e <midi_input_callbacks+0x10c>
            case MIDI_NOTEON:
              func = device->input_noteon_callback;
    34c6:	d6 01       	movw	r26, r12
    34c8:	14 96       	adiw	r26, 0x04	; 4
    34ca:	ed 91       	ld	r30, X+
    34cc:	fc 91       	ld	r31, X
    34ce:	15 97       	sbiw	r26, 0x05	; 5
              break;
    34d0:	1e c0       	rjmp	.+60     	; 0x350e <midi_input_callbacks+0x10c>
            case MIDI_NOTEOFF:
              func = device->input_noteoff_callback;
    34d2:	d6 01       	movw	r26, r12
    34d4:	16 96       	adiw	r26, 0x06	; 6
    34d6:	ed 91       	ld	r30, X+
    34d8:	fc 91       	ld	r31, X
    34da:	17 97       	sbiw	r26, 0x07	; 7
              break;
    34dc:	18 c0       	rjmp	.+48     	; 0x350e <midi_input_callbacks+0x10c>
            case MIDI_AFTERTOUCH:
              func = device->input_aftertouch_callback;
    34de:	d6 01       	movw	r26, r12
    34e0:	18 96       	adiw	r26, 0x08	; 8
    34e2:	ed 91       	ld	r30, X+
    34e4:	fc 91       	ld	r31, X
    34e6:	19 97       	sbiw	r26, 0x09	; 9
              break;
    34e8:	12 c0       	rjmp	.+36     	; 0x350e <midi_input_callbacks+0x10c>
            case MIDI_PITCHBEND:
              func = device->input_pitchbend_callback;
    34ea:	d6 01       	movw	r26, r12
    34ec:	1a 96       	adiw	r26, 0x0a	; 10
    34ee:	ed 91       	ld	r30, X+
    34f0:	fc 91       	ld	r31, X
    34f2:	1b 97       	sbiw	r26, 0x0b	; 11
              break;
    34f4:	0c c0       	rjmp	.+24     	; 0x350e <midi_input_callbacks+0x10c>
            case 0xF0:
              if (byte0 == MIDI_SONGPOSITION)
    34f6:	b2 ef       	ldi	r27, 0xF2	; 242
    34f8:	4b 17       	cp	r20, r27
    34fa:	09 f0       	breq	.+2      	; 0x34fe <midi_input_callbacks+0xfc>
    34fc:	90 c0       	rjmp	.+288    	; 0x361e <midi_input_callbacks+0x21c>
                func = device->input_songposition_callback;
    34fe:	d6 01       	movw	r26, r12
    3500:	1c 96       	adiw	r26, 0x0c	; 12
    3502:	ed 91       	ld	r30, X+
    3504:	fc 91       	ld	r31, X
    3506:	1d 97       	sbiw	r26, 0x0d	; 13
    3508:	02 c0       	rjmp	.+4      	; 0x350e <midi_input_callbacks+0x10c>
    }
  } else {
    switch (cnt) {
      case 3:
        {
          midi_three_byte_func_t func = NULL;
    350a:	e0 e0       	ldi	r30, 0x00	; 0
    350c:	f0 e0       	ldi	r31, 0x00	; 0
                func = device->input_songposition_callback;
              break;
            default:
              break;
          }
          if(func) {
    350e:	30 97       	sbiw	r30, 0x00	; 0
    3510:	09 f4       	brne	.+2      	; 0x3514 <midi_input_callbacks+0x112>
    3512:	85 c0       	rjmp	.+266    	; 0x361e <midi_input_callbacks+0x21c>
            //mask off the channel for non song position functions
            if (byte0 == MIDI_SONGPOSITION)
    3514:	b2 ef       	ldi	r27, 0xF2	; 242
    3516:	fb 16       	cp	r15, r27
    3518:	31 f4       	brne	.+12     	; 0x3526 <midi_input_callbacks+0x124>
              func(device, byte0, byte1, byte2);
    351a:	c6 01       	movw	r24, r12
    351c:	62 ef       	ldi	r22, 0xF2	; 242
    351e:	4e 2d       	mov	r20, r14
    3520:	21 2f       	mov	r18, r17
    3522:	09 95       	icall
    3524:	6c c0       	rjmp	.+216    	; 0x35fe <midi_input_callbacks+0x1fc>
            else
              func(device, byte0 & 0x0F, byte1, byte2);
    3526:	6f 2d       	mov	r22, r15
    3528:	6f 70       	andi	r22, 0x0F	; 15
    352a:	c6 01       	movw	r24, r12
    352c:	4e 2d       	mov	r20, r14
    352e:	21 2f       	mov	r18, r17
    3530:	09 95       	icall
    3532:	65 c0       	rjmp	.+202    	; 0x35fe <midi_input_callbacks+0x1fc>
        }
        break;
      case 2:
        {
          midi_two_byte_func_t func = NULL;
          switch (byte0 & 0xF0) {
    3534:	84 2f       	mov	r24, r20
    3536:	90 e0       	ldi	r25, 0x00	; 0
    3538:	80 7f       	andi	r24, 0xF0	; 240
    353a:	90 70       	andi	r25, 0x00	; 0
    353c:	80 3d       	cpi	r24, 0xD0	; 208
    353e:	91 05       	cpc	r25, r1
    3540:	61 f0       	breq	.+24     	; 0x355a <midi_input_callbacks+0x158>
    3542:	80 3f       	cpi	r24, 0xF0	; 240
    3544:	91 05       	cpc	r25, r1
    3546:	79 f0       	breq	.+30     	; 0x3566 <midi_input_callbacks+0x164>
    3548:	80 3c       	cpi	r24, 0xC0	; 192
    354a:	91 05       	cpc	r25, r1
    354c:	f9 f4       	brne	.+62     	; 0x358c <midi_input_callbacks+0x18a>
            case MIDI_PROGCHANGE:
              func = device->input_progchange_callback;
    354e:	d6 01       	movw	r26, r12
    3550:	1e 96       	adiw	r26, 0x0e	; 14
    3552:	ed 91       	ld	r30, X+
    3554:	fc 91       	ld	r31, X
    3556:	1f 97       	sbiw	r26, 0x0f	; 15
              break;
    3558:	1b c0       	rjmp	.+54     	; 0x3590 <midi_input_callbacks+0x18e>
            case MIDI_CHANPRESSURE:
              func = device->input_chanpressure_callback;
    355a:	d6 01       	movw	r26, r12
    355c:	50 96       	adiw	r26, 0x10	; 16
    355e:	ed 91       	ld	r30, X+
    3560:	fc 91       	ld	r31, X
    3562:	51 97       	sbiw	r26, 0x11	; 17
              break;
    3564:	15 c0       	rjmp	.+42     	; 0x3590 <midi_input_callbacks+0x18e>
            case 0xF0:
              if (byte0 == MIDI_SONGSELECT)
    3566:	b3 ef       	ldi	r27, 0xF3	; 243
    3568:	4b 17       	cp	r20, r27
    356a:	31 f4       	brne	.+12     	; 0x3578 <midi_input_callbacks+0x176>
                func = device->input_songselect_callback;
    356c:	d6 01       	movw	r26, r12
    356e:	52 96       	adiw	r26, 0x12	; 18
    3570:	ed 91       	ld	r30, X+
    3572:	fc 91       	ld	r31, X
    3574:	53 97       	sbiw	r26, 0x13	; 19
    3576:	0c c0       	rjmp	.+24     	; 0x3590 <midi_input_callbacks+0x18e>
              else if (byte0 == MIDI_TC_QUARTERFRAME)
    3578:	b1 ef       	ldi	r27, 0xF1	; 241
    357a:	4b 17       	cp	r20, r27
    357c:	09 f0       	breq	.+2      	; 0x3580 <midi_input_callbacks+0x17e>
    357e:	4f c0       	rjmp	.+158    	; 0x361e <midi_input_callbacks+0x21c>
                func = device->input_tc_quarterframe_callback;
    3580:	d6 01       	movw	r26, r12
    3582:	54 96       	adiw	r26, 0x14	; 20
    3584:	ed 91       	ld	r30, X+
    3586:	fc 91       	ld	r31, X
    3588:	55 97       	sbiw	r26, 0x15	; 21
    358a:	02 c0       	rjmp	.+4      	; 0x3590 <midi_input_callbacks+0x18e>
          }
        }
        break;
      case 2:
        {
          midi_two_byte_func_t func = NULL;
    358c:	e0 e0       	ldi	r30, 0x00	; 0
    358e:	f0 e0       	ldi	r31, 0x00	; 0
                func = device->input_tc_quarterframe_callback;
              break;
            default:
              break;
          }
          if(func) {
    3590:	30 97       	sbiw	r30, 0x00	; 0
    3592:	09 f4       	brne	.+2      	; 0x3596 <midi_input_callbacks+0x194>
    3594:	44 c0       	rjmp	.+136    	; 0x361e <midi_input_callbacks+0x21c>
            //mask off the channel
            if (byte0 == MIDI_SONGSELECT || byte0 == MIDI_TC_QUARTERFRAME)
    3596:	b3 ef       	ldi	r27, 0xF3	; 243
    3598:	fb 16       	cp	r15, r27
    359a:	19 f0       	breq	.+6      	; 0x35a2 <midi_input_callbacks+0x1a0>
    359c:	81 ef       	ldi	r24, 0xF1	; 241
    359e:	f8 16       	cp	r15, r24
    35a0:	29 f4       	brne	.+10     	; 0x35ac <midi_input_callbacks+0x1aa>
              func(device, byte0, byte1);
    35a2:	c6 01       	movw	r24, r12
    35a4:	6f 2d       	mov	r22, r15
    35a6:	4e 2d       	mov	r20, r14
    35a8:	09 95       	icall
    35aa:	29 c0       	rjmp	.+82     	; 0x35fe <midi_input_callbacks+0x1fc>
            else
              func(device, byte0 & 0x0F, byte1);
    35ac:	6f 2d       	mov	r22, r15
    35ae:	6f 70       	andi	r22, 0x0F	; 15
    35b0:	c6 01       	movw	r24, r12
    35b2:	4e 2d       	mov	r20, r14
    35b4:	09 95       	icall
    35b6:	23 c0       	rjmp	.+70     	; 0x35fe <midi_input_callbacks+0x1fc>
        }
        break;
      case 1:
        {
          midi_one_byte_func_t func = NULL;
          if (midi_is_realtime(byte0))
    35b8:	84 2f       	mov	r24, r20
    35ba:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <midi_is_realtime>
    35be:	88 23       	and	r24, r24
    35c0:	31 f0       	breq	.+12     	; 0x35ce <midi_input_callbacks+0x1cc>
            func = device->input_realtime_callback;
    35c2:	d6 01       	movw	r26, r12
    35c4:	56 96       	adiw	r26, 0x16	; 22
    35c6:	ed 91       	ld	r30, X+
    35c8:	fc 91       	ld	r31, X
    35ca:	57 97       	sbiw	r26, 0x17	; 23
    35cc:	08 c0       	rjmp	.+16     	; 0x35de <midi_input_callbacks+0x1dc>
          else if (byte0 == MIDI_TUNEREQUEST)
    35ce:	b6 ef       	ldi	r27, 0xF6	; 246
    35d0:	fb 16       	cp	r15, r27
    35d2:	29 f5       	brne	.+74     	; 0x361e <midi_input_callbacks+0x21c>
            func = device->input_tunerequest_callback;
    35d4:	d6 01       	movw	r26, r12
    35d6:	58 96       	adiw	r26, 0x18	; 24
    35d8:	ed 91       	ld	r30, X+
    35da:	fc 91       	ld	r31, X
    35dc:	59 97       	sbiw	r26, 0x19	; 25
          if (func) {
    35de:	30 97       	sbiw	r30, 0x00	; 0
    35e0:	f1 f0       	breq	.+60     	; 0x361e <midi_input_callbacks+0x21c>
            func(device, byte0);
    35e2:	c6 01       	movw	r24, r12
    35e4:	6f 2d       	mov	r22, r15
    35e6:	09 95       	icall
    35e8:	0a c0       	rjmp	.+20     	; 0x35fe <midi_input_callbacks+0x1fc>
          }
        }
        break;
      default:
        //just in case
        if (cnt > 3)
    35ea:	64 30       	cpi	r22, 0x04	; 4
    35ec:	71 05       	cpc	r23, r1
    35ee:	a8 f4       	brcc	.+42     	; 0x361a <midi_input_callbacks+0x218>
    35f0:	16 c0       	rjmp	.+44     	; 0x361e <midi_input_callbacks+0x21c>
  }

  //if there is fallthrough default callback and we haven't called a more specific one, 
  //call the fallthrough
  if (!called && device->input_fallthrough_callback)
    device->input_fallthrough_callback(device, cnt, byte0, byte1, byte2);
    35f2:	c6 01       	movw	r24, r12
    35f4:	b5 01       	movw	r22, r10
    35f6:	4f 2d       	mov	r20, r15
    35f8:	2e 2d       	mov	r18, r14
    35fa:	01 2f       	mov	r16, r17
    35fc:	09 95       	icall
  //always call the catch all if it exists
  if (device->input_catchall_callback)
    35fe:	d6 01       	movw	r26, r12
    3600:	5e 96       	adiw	r26, 0x1e	; 30
    3602:	ed 91       	ld	r30, X+
    3604:	fc 91       	ld	r31, X
    3606:	5f 97       	sbiw	r26, 0x1f	; 31
    3608:	30 97       	sbiw	r30, 0x00	; 0
    360a:	89 f0       	breq	.+34     	; 0x362e <midi_input_callbacks+0x22c>
    device->input_catchall_callback(device, cnt, byte0, byte1, byte2);
    360c:	c6 01       	movw	r24, r12
    360e:	b5 01       	movw	r22, r10
    3610:	4f 2d       	mov	r20, r15
    3612:	2e 2d       	mov	r18, r14
    3614:	01 2f       	mov	r16, r17
    3616:	09 95       	icall
    3618:	0a c0       	rjmp	.+20     	; 0x362e <midi_input_callbacks+0x22c>
        }
        break;
      default:
        //just in case
        if (cnt > 3)
          cnt = 0;
    361a:	aa 24       	eor	r10, r10
    361c:	bb 24       	eor	r11, r11
    }
  }

  //if there is fallthrough default callback and we haven't called a more specific one, 
  //call the fallthrough
  if (!called && device->input_fallthrough_callback)
    361e:	d6 01       	movw	r26, r12
    3620:	5c 96       	adiw	r26, 0x1c	; 28
    3622:	ed 91       	ld	r30, X+
    3624:	fc 91       	ld	r31, X
    3626:	5d 97       	sbiw	r26, 0x1d	; 29
    3628:	30 97       	sbiw	r30, 0x00	; 0
    362a:	19 f7       	brne	.-58     	; 0x35f2 <midi_input_callbacks+0x1f0>
    362c:	e8 cf       	rjmp	.-48     	; 0x35fe <midi_input_callbacks+0x1fc>
    device->input_fallthrough_callback(device, cnt, byte0, byte1, byte2);
  //always call the catch all if it exists
  if (device->input_catchall_callback)
    device->input_catchall_callback(device, cnt, byte0, byte1, byte2);
}
    362e:	0f 90       	pop	r0
    3630:	0f 90       	pop	r0
    3632:	0f 90       	pop	r0
    3634:	df 91       	pop	r29
    3636:	cf 91       	pop	r28
    3638:	1f 91       	pop	r17
    363a:	0f 91       	pop	r16
    363c:	ff 90       	pop	r15
    363e:	ef 90       	pop	r14
    3640:	df 90       	pop	r13
    3642:	cf 90       	pop	r12
    3644:	bf 90       	pop	r11
    3646:	af 90       	pop	r10
    3648:	08 95       	ret

0000364a <midi_process_byte>:
    midi_process_byte(device, val);
    bytequeue_remove(&device->input_queue, 1);
  }
}

void midi_process_byte(MidiDevice * device, uint8_t input) {
    364a:	ef 92       	push	r14
    364c:	ff 92       	push	r15
    364e:	0f 93       	push	r16
    3650:	cf 93       	push	r28
    3652:	df 93       	push	r29
    3654:	7c 01       	movw	r14, r24
    3656:	c6 2f       	mov	r28, r22
  if (midi_is_realtime(input)) {
    3658:	86 2f       	mov	r24, r22
    365a:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <midi_is_realtime>
    365e:	88 23       	and	r24, r24
    3660:	91 f0       	breq	.+36     	; 0x3686 <midi_process_byte+0x3c>
    //call callback, store and restore state
    input_state_t state = device->input_state;
    3662:	d7 01       	movw	r26, r14
    3664:	95 96       	adiw	r26, 0x25	; 37
    3666:	dc 91       	ld	r29, X
    3668:	95 97       	sbiw	r26, 0x25	; 37
    device->input_state = ONE_BYTE_MESSAGE;
    366a:	81 e0       	ldi	r24, 0x01	; 1
    366c:	95 96       	adiw	r26, 0x25	; 37
    366e:	8c 93       	st	X, r24
    midi_input_callbacks(device, 1, input, 0, 0);
    3670:	c7 01       	movw	r24, r14
    3672:	61 e0       	ldi	r22, 0x01	; 1
    3674:	70 e0       	ldi	r23, 0x00	; 0
    3676:	4c 2f       	mov	r20, r28
    3678:	20 e0       	ldi	r18, 0x00	; 0
    367a:	00 e0       	ldi	r16, 0x00	; 0
    367c:	0e 94 01 1a 	call	0x3402	; 0x3402 <midi_input_callbacks>
    device->input_state = state;
    3680:	f7 01       	movw	r30, r14
    3682:	d5 a3       	lds	r29, 0x55
    3684:	b7 c0       	rjmp	.+366    	; 0x37f4 <midi_process_byte+0x1aa>
  } else if (midi_is_statusbyte(input)) {
    3686:	8c 2f       	mov	r24, r28
    3688:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <midi_is_statusbyte>
    368c:	88 23       	and	r24, r24
    368e:	09 f4       	brne	.+2      	; 0x3692 <midi_process_byte+0x48>
    3690:	73 c0       	rjmp	.+230    	; 0x3778 <midi_process_byte+0x12e>
    //store the byte
    if (device->input_state != SYSEX_MESSAGE) {
    3692:	d7 01       	movw	r26, r14
    3694:	95 96       	adiw	r26, 0x25	; 37
    3696:	8c 91       	ld	r24, X
    3698:	95 97       	sbiw	r26, 0x25	; 37
    369a:	84 30       	cpi	r24, 0x04	; 4
    369c:	49 f0       	breq	.+18     	; 0x36b0 <midi_process_byte+0x66>
      device->input_buffer[0] = input;
    369e:	92 96       	adiw	r26, 0x22	; 34
    36a0:	cc 93       	st	X, r28
    36a2:	92 97       	sbiw	r26, 0x22	; 34
      device->input_count = 1;
    36a4:	81 e0       	ldi	r24, 0x01	; 1
    36a6:	90 e0       	ldi	r25, 0x00	; 0
    36a8:	97 96       	adiw	r26, 0x27	; 39
    36aa:	9c 93       	st	X, r25
    36ac:	8e 93       	st	-X, r24
    36ae:	96 97       	sbiw	r26, 0x26	; 38
    }
    switch (midi_packet_length(input)) {
    36b0:	8c 2f       	mov	r24, r28
    36b2:	0e 94 a4 17 	call	0x2f48	; 0x2f48 <midi_packet_length>
    36b6:	81 30       	cpi	r24, 0x01	; 1
    36b8:	41 f0       	breq	.+16     	; 0x36ca <midi_process_byte+0x80>
    36ba:	81 30       	cpi	r24, 0x01	; 1
    36bc:	00 f1       	brcs	.+64     	; 0x36fe <midi_process_byte+0xb4>
    36be:	82 30       	cpi	r24, 0x02	; 2
    36c0:	a1 f0       	breq	.+40     	; 0x36ea <midi_process_byte+0xa0>
    36c2:	83 30       	cpi	r24, 0x03	; 3
    36c4:	09 f0       	breq	.+2      	; 0x36c8 <midi_process_byte+0x7e>
    36c6:	4f c0       	rjmp	.+158    	; 0x3766 <midi_process_byte+0x11c>
    36c8:	14 c0       	rjmp	.+40     	; 0x36f2 <midi_process_byte+0xa8>
      case ONE1:
        device->input_state = ONE_BYTE_MESSAGE;;
    36ca:	81 e0       	ldi	r24, 0x01	; 1
    36cc:	f7 01       	movw	r30, r14
    36ce:	85 a3       	lds	r24, 0x55
        midi_input_callbacks(device, 1, input, 0, 0);
    36d0:	c7 01       	movw	r24, r14
    36d2:	61 e0       	ldi	r22, 0x01	; 1
    36d4:	70 e0       	ldi	r23, 0x00	; 0
    36d6:	4c 2f       	mov	r20, r28
    36d8:	20 e0       	ldi	r18, 0x00	; 0
    36da:	00 e0       	ldi	r16, 0x00	; 0
    36dc:	0e 94 01 1a 	call	0x3402	; 0x3402 <midi_input_callbacks>
        device->input_state = IDLE;
    36e0:	d7 01       	movw	r26, r14
    36e2:	95 96       	adiw	r26, 0x25	; 37
    36e4:	1c 92       	st	X, r1
    36e6:	95 97       	sbiw	r26, 0x25	; 37
        break;
    36e8:	85 c0       	rjmp	.+266    	; 0x37f4 <midi_process_byte+0x1aa>
      case TWO2:
        device->input_state = TWO_BYTE_MESSAGE;
    36ea:	82 e0       	ldi	r24, 0x02	; 2
    36ec:	f7 01       	movw	r30, r14
    36ee:	85 a3       	lds	r24, 0x55
        break;
    36f0:	81 c0       	rjmp	.+258    	; 0x37f4 <midi_process_byte+0x1aa>
      case THREE3:
        device->input_state = THREE_BYTE_MESSAGE;
    36f2:	83 e0       	ldi	r24, 0x03	; 3
    36f4:	d7 01       	movw	r26, r14
    36f6:	95 96       	adiw	r26, 0x25	; 37
    36f8:	8c 93       	st	X, r24
    36fa:	95 97       	sbiw	r26, 0x25	; 37
        break;
    36fc:	7b c0       	rjmp	.+246    	; 0x37f4 <midi_process_byte+0x1aa>
      case UNDEFINED:
        switch(input) {
    36fe:	c0 3f       	cpi	r28, 0xF0	; 240
    3700:	19 f0       	breq	.+6      	; 0x3708 <midi_process_byte+0xbe>
    3702:	c7 3f       	cpi	r28, 0xF7	; 247
    3704:	59 f5       	brne	.+86     	; 0x375c <midi_process_byte+0x112>
    3706:	0a c0       	rjmp	.+20     	; 0x371c <midi_process_byte+0xd2>
          case SYSEX_BEGIN:
            device->input_state = SYSEX_MESSAGE;
    3708:	84 e0       	ldi	r24, 0x04	; 4
    370a:	f7 01       	movw	r30, r14
    370c:	85 a3       	lds	r24, 0x55
            device->input_buffer[0] = input;
    370e:	80 ef       	ldi	r24, 0xF0	; 240
    3710:	82 a3       	lds	r24, 0x52
            device->input_count = 1;
    3712:	81 e0       	ldi	r24, 0x01	; 1
    3714:	90 e0       	ldi	r25, 0x00	; 0
    3716:	97 a3       	lds	r25, 0x57
    3718:	86 a3       	lds	r24, 0x56
            break;
    371a:	6c c0       	rjmp	.+216    	; 0x37f4 <midi_process_byte+0x1aa>
          case SYSEX_END:
            //send what is left in the input buffer, set idle
            device->input_buffer[device->input_count % 3] = input;
    371c:	d7 01       	movw	r26, r14
    371e:	96 96       	adiw	r26, 0x26	; 38
    3720:	2d 91       	ld	r18, X+
    3722:	3c 91       	ld	r19, X
    3724:	97 97       	sbiw	r26, 0x27	; 39
    3726:	c9 01       	movw	r24, r18
    3728:	63 e0       	ldi	r22, 0x03	; 3
    372a:	70 e0       	ldi	r23, 0x00	; 0
    372c:	0e 94 f9 1d 	call	0x3bf2	; 0x3bf2 <__udivmodhi4>
    3730:	f7 01       	movw	r30, r14
    3732:	e8 0f       	add	r30, r24
    3734:	f9 1f       	adc	r31, r25
    3736:	87 ef       	ldi	r24, 0xF7	; 247
    3738:	82 a3       	lds	r24, 0x52
            device->input_count += 1;
    373a:	b9 01       	movw	r22, r18
    373c:	6f 5f       	subi	r22, 0xFF	; 255
    373e:	7f 4f       	sbci	r23, 0xFF	; 255
    3740:	f7 01       	movw	r30, r14
    3742:	77 a3       	lds	r23, 0x57
    3744:	66 a3       	lds	r22, 0x56
            //call the callback
            midi_input_callbacks(device, device->input_count, 
    3746:	c7 01       	movw	r24, r14
    3748:	42 a1       	lds	r20, 0x42
    374a:	23 a1       	lds	r18, 0x43
    374c:	04 a1       	lds	r16, 0x44
    374e:	0e 94 01 1a 	call	0x3402	; 0x3402 <midi_input_callbacks>
                device->input_buffer[0], device->input_buffer[1], device->input_buffer[2]);
            device->input_state = IDLE;
    3752:	d7 01       	movw	r26, r14
    3754:	95 96       	adiw	r26, 0x25	; 37
    3756:	1c 92       	st	X, r1
    3758:	95 97       	sbiw	r26, 0x25	; 37
            break;
    375a:	4c c0       	rjmp	.+152    	; 0x37f4 <midi_process_byte+0x1aa>
          default:
            device->input_state = IDLE;
    375c:	f7 01       	movw	r30, r14
    375e:	15 a2       	lds	r17, 0x95
            device->input_count = 0;
    3760:	17 a2       	lds	r17, 0x97
    3762:	16 a2       	lds	r17, 0x96
    3764:	47 c0       	rjmp	.+142    	; 0x37f4 <midi_process_byte+0x1aa>
        }

        break;
      default:
        device->input_state = IDLE;
    3766:	d7 01       	movw	r26, r14
    3768:	95 96       	adiw	r26, 0x25	; 37
    376a:	1c 92       	st	X, r1
    376c:	95 97       	sbiw	r26, 0x25	; 37
        device->input_count = 0;
    376e:	97 96       	adiw	r26, 0x27	; 39
    3770:	1c 92       	st	X, r1
    3772:	1e 92       	st	-X, r1
    3774:	96 97       	sbiw	r26, 0x26	; 38
        break;
    3776:	3e c0       	rjmp	.+124    	; 0x37f4 <midi_process_byte+0x1aa>
    }
  } else {
    if (device->input_state != IDLE) {
    3778:	f7 01       	movw	r30, r14
    377a:	25 a1       	lds	r18, 0x45
    377c:	22 23       	and	r18, r18
    377e:	d1 f1       	breq	.+116    	; 0x37f4 <midi_process_byte+0x1aa>
      //store the byte
      device->input_buffer[device->input_count % 3] = input;
    3780:	06 a0       	lds	r16, 0x86
    3782:	f7 a1       	lds	r31, 0x47
    3784:	e0 2d       	mov	r30, r0
    3786:	cf 01       	movw	r24, r30
    3788:	63 e0       	ldi	r22, 0x03	; 3
    378a:	70 e0       	ldi	r23, 0x00	; 0
    378c:	0e 94 f9 1d 	call	0x3bf2	; 0x3bf2 <__udivmodhi4>
    3790:	ac 01       	movw	r20, r24
    3792:	8e 0d       	add	r24, r14
    3794:	9f 1d       	adc	r25, r15
    3796:	dc 01       	movw	r26, r24
    3798:	92 96       	adiw	r26, 0x22	; 34
    379a:	cc 93       	st	X, r28
    379c:	92 97       	sbiw	r26, 0x22	; 34
      //increment count
      uint16_t prev = device->input_count;
      device->input_count += 1;
    379e:	bf 01       	movw	r22, r30
    37a0:	6f 5f       	subi	r22, 0xFF	; 255
    37a2:	7f 4f       	sbci	r23, 0xFF	; 255
    37a4:	f7 01       	movw	r30, r14
    37a6:	77 a3       	lds	r23, 0x57
    37a8:	66 a3       	lds	r22, 0x56

      switch(prev % 3) {
    37aa:	41 30       	cpi	r20, 0x01	; 1
    37ac:	51 05       	cpc	r21, r1
    37ae:	91 f0       	breq	.+36     	; 0x37d4 <midi_process_byte+0x18a>
    37b0:	42 30       	cpi	r20, 0x02	; 2
    37b2:	51 05       	cpc	r21, r1
    37b4:	f9 f4       	brne	.+62     	; 0x37f4 <midi_process_byte+0x1aa>
        case 2:
          //call callback
          midi_input_callbacks(device, device->input_count,
    37b6:	c7 01       	movw	r24, r14
    37b8:	42 a1       	lds	r20, 0x42
    37ba:	23 a1       	lds	r18, 0x43
    37bc:	04 a1       	lds	r16, 0x44
    37be:	0e 94 01 1a 	call	0x3402	; 0x3402 <midi_input_callbacks>
              device->input_buffer[0], device->input_buffer[1], device->input_buffer[2]);
          if (device->input_state != SYSEX_MESSAGE) {
    37c2:	f7 01       	movw	r30, r14
    37c4:	85 a1       	lds	r24, 0x45
    37c6:	84 30       	cpi	r24, 0x04	; 4
    37c8:	a9 f0       	breq	.+42     	; 0x37f4 <midi_process_byte+0x1aa>
            //set to 1, keeping status byte, allowing for running status
            device->input_count = 1;
    37ca:	81 e0       	ldi	r24, 0x01	; 1
    37cc:	90 e0       	ldi	r25, 0x00	; 0
    37ce:	97 a3       	lds	r25, 0x57
    37d0:	86 a3       	lds	r24, 0x56
    37d2:	10 c0       	rjmp	.+32     	; 0x37f4 <midi_process_byte+0x1aa>
          }
          break;
        case 1:
          if (device->input_state == TWO_BYTE_MESSAGE) {
    37d4:	22 30       	cpi	r18, 0x02	; 2
    37d6:	71 f4       	brne	.+28     	; 0x37f4 <midi_process_byte+0x1aa>
            //call callback
            midi_input_callbacks(device, device->input_count,
    37d8:	c7 01       	movw	r24, r14
    37da:	42 a1       	lds	r20, 0x42
    37dc:	23 a1       	lds	r18, 0x43
    37de:	00 e0       	ldi	r16, 0x00	; 0
    37e0:	0e 94 01 1a 	call	0x3402	; 0x3402 <midi_input_callbacks>
                device->input_buffer[0], device->input_buffer[1], 0);
            if (device->input_state != SYSEX_MESSAGE) {
    37e4:	f7 01       	movw	r30, r14
    37e6:	85 a1       	lds	r24, 0x45
    37e8:	84 30       	cpi	r24, 0x04	; 4
    37ea:	21 f0       	breq	.+8      	; 0x37f4 <midi_process_byte+0x1aa>
              //set to 1, keeping status byte, allowing for running status
              device->input_count = 1;
    37ec:	81 e0       	ldi	r24, 0x01	; 1
    37ee:	90 e0       	ldi	r25, 0x00	; 0
    37f0:	97 a3       	lds	r25, 0x57
    37f2:	86 a3       	lds	r24, 0x56
          //one byte messages are dealt with directly
          break;
      }
    }
  }
}
    37f4:	df 91       	pop	r29
    37f6:	cf 91       	pop	r28
    37f8:	0f 91       	pop	r16
    37fa:	ff 90       	pop	r15
    37fc:	ef 90       	pop	r14
    37fe:	08 95       	ret

00003800 <midi_device_process>:

void midi_device_set_pre_input_process_func(MidiDevice * device, midi_no_byte_func_t pre_process_func){
  device->pre_input_process_callback = pre_process_func;
}

void midi_device_process(MidiDevice * device) {
    3800:	cf 92       	push	r12
    3802:	df 92       	push	r13
    3804:	ef 92       	push	r14
    3806:	ff 92       	push	r15
    3808:	0f 93       	push	r16
    380a:	1f 93       	push	r17
    380c:	cf 93       	push	r28
    380e:	df 93       	push	r29
    3810:	6c 01       	movw	r12, r24
  //call the pre_input_process_callback if there is one
  if(device->pre_input_process_callback)
    3812:	dc 01       	movw	r26, r24
    3814:	90 96       	adiw	r26, 0x20	; 32
    3816:	ed 91       	ld	r30, X+
    3818:	fc 91       	ld	r31, X
    381a:	91 97       	sbiw	r26, 0x21	; 33
    381c:	30 97       	sbiw	r30, 0x00	; 0
    381e:	09 f0       	breq	.+2      	; 0x3822 <midi_device_process+0x22>
    device->pre_input_process_callback(device);
    3820:	09 95       	icall

  //pull stuff off the queue and process
  byteQueueIndex_t len = bytequeue_length(&device->input_queue);
    3822:	0f 2e       	mov	r0, r31
    3824:	f8 ee       	ldi	r31, 0xE8	; 232
    3826:	ef 2e       	mov	r14, r31
    3828:	ff 24       	eor	r15, r15
    382a:	f0 2d       	mov	r31, r0
    382c:	ec 0c       	add	r14, r12
    382e:	fd 1c       	adc	r15, r13
    3830:	c7 01       	movw	r24, r14
    3832:	0e 94 55 17 	call	0x2eaa	; 0x2eaa <bytequeue_length>
  uint16_t i;
  //TODO limit number of bytes processed?
  for(i = 0; i < len; i++) {
    3836:	c8 2f       	mov	r28, r24
    3838:	d0 e0       	ldi	r29, 0x00	; 0
    383a:	20 97       	sbiw	r28, 0x00	; 0
    383c:	99 f0       	breq	.+38     	; 0x3864 <midi_device_process+0x64>
    383e:	00 e0       	ldi	r16, 0x00	; 0
    3840:	10 e0       	ldi	r17, 0x00	; 0
    uint8_t val = bytequeue_get(&device->input_queue, 0);
    3842:	c7 01       	movw	r24, r14
    3844:	60 e0       	ldi	r22, 0x00	; 0
    3846:	0e 94 6a 17 	call	0x2ed4	; 0x2ed4 <bytequeue_get>
    384a:	68 2f       	mov	r22, r24
    midi_process_byte(device, val);
    384c:	c6 01       	movw	r24, r12
    384e:	0e 94 25 1b 	call	0x364a	; 0x364a <midi_process_byte>
    bytequeue_remove(&device->input_queue, 1);
    3852:	c7 01       	movw	r24, r14
    3854:	61 e0       	ldi	r22, 0x01	; 1
    3856:	0e 94 7b 17 	call	0x2ef6	; 0x2ef6 <bytequeue_remove>

  //pull stuff off the queue and process
  byteQueueIndex_t len = bytequeue_length(&device->input_queue);
  uint16_t i;
  //TODO limit number of bytes processed?
  for(i = 0; i < len; i++) {
    385a:	0f 5f       	subi	r16, 0xFF	; 255
    385c:	1f 4f       	sbci	r17, 0xFF	; 255
    385e:	0c 17       	cp	r16, r28
    3860:	1d 07       	cpc	r17, r29
    3862:	78 f3       	brcs	.-34     	; 0x3842 <midi_device_process+0x42>
    uint8_t val = bytequeue_get(&device->input_queue, 0);
    midi_process_byte(device, val);
    bytequeue_remove(&device->input_queue, 1);
  }
}
    3864:	df 91       	pop	r29
    3866:	cf 91       	pop	r28
    3868:	1f 91       	pop	r17
    386a:	0f 91       	pop	r16
    386c:	ff 90       	pop	r15
    386e:	ef 90       	pop	r14
    3870:	df 90       	pop	r13
    3872:	cf 90       	pop	r12
    3874:	08 95       	ret

00003876 <sysex_encoded_length>:
//You should have received a copy of the GNU General Public License
//along with avr-midi.  If not, see <http://www.gnu.org/licenses/>.

#include "sysex_tools.h"

uint16_t sysex_encoded_length(uint16_t decoded_length){
    3876:	9c 01       	movw	r18, r24
   uint8_t remainder = decoded_length % 7;
    3878:	67 e0       	ldi	r22, 0x07	; 7
    387a:	70 e0       	ldi	r23, 0x00	; 0
    387c:	0e 94 f9 1d 	call	0x3bf2	; 0x3bf2 <__udivmodhi4>
    3880:	48 2f       	mov	r20, r24
   if (remainder)
    3882:	88 23       	and	r24, r24
    3884:	81 f0       	breq	.+32     	; 0x38a6 <sysex_encoded_length+0x30>
      return (decoded_length / 7) * 8 + remainder + 1;
    3886:	c9 01       	movw	r24, r18
    3888:	67 e0       	ldi	r22, 0x07	; 7
    388a:	70 e0       	ldi	r23, 0x00	; 0
    388c:	0e 94 f9 1d 	call	0x3bf2	; 0x3bf2 <__udivmodhi4>
    3890:	cb 01       	movw	r24, r22
    3892:	88 0f       	add	r24, r24
    3894:	99 1f       	adc	r25, r25
    3896:	88 0f       	add	r24, r24
    3898:	99 1f       	adc	r25, r25
    389a:	88 0f       	add	r24, r24
    389c:	99 1f       	adc	r25, r25
    389e:	01 96       	adiw	r24, 0x01	; 1
    38a0:	84 0f       	add	r24, r20
    38a2:	91 1d       	adc	r25, r1
    38a4:	08 95       	ret
   else
      return (decoded_length / 7) * 8;
    38a6:	c9 01       	movw	r24, r18
    38a8:	67 e0       	ldi	r22, 0x07	; 7
    38aa:	70 e0       	ldi	r23, 0x00	; 0
    38ac:	0e 94 f9 1d 	call	0x3bf2	; 0x3bf2 <__udivmodhi4>
    38b0:	cb 01       	movw	r24, r22
    38b2:	88 0f       	add	r24, r24
    38b4:	99 1f       	adc	r25, r25
    38b6:	88 0f       	add	r24, r24
    38b8:	99 1f       	adc	r25, r25
    38ba:	88 0f       	add	r24, r24
    38bc:	99 1f       	adc	r25, r25
}
    38be:	08 95       	ret

000038c0 <sysex_decoded_length>:

uint16_t sysex_decoded_length(uint16_t encoded_length){
   uint8_t remainder = encoded_length % 8;
    38c0:	48 2f       	mov	r20, r24
    38c2:	47 70       	andi	r20, 0x07	; 7
   if (remainder)
    38c4:	a1 f0       	breq	.+40     	; 0x38ee <sysex_decoded_length+0x2e>
      return (encoded_length / 8) * 7 + remainder - 1;
    38c6:	9c 01       	movw	r18, r24
    38c8:	36 95       	lsr	r19
    38ca:	27 95       	ror	r18
    38cc:	36 95       	lsr	r19
    38ce:	27 95       	ror	r18
    38d0:	36 95       	lsr	r19
    38d2:	27 95       	ror	r18
    38d4:	c9 01       	movw	r24, r18
    38d6:	88 0f       	add	r24, r24
    38d8:	99 1f       	adc	r25, r25
    38da:	88 0f       	add	r24, r24
    38dc:	99 1f       	adc	r25, r25
    38de:	88 0f       	add	r24, r24
    38e0:	99 1f       	adc	r25, r25
    38e2:	82 1b       	sub	r24, r18
    38e4:	93 0b       	sbc	r25, r19
    38e6:	01 97       	sbiw	r24, 0x01	; 1
    38e8:	84 0f       	add	r24, r20
    38ea:	91 1d       	adc	r25, r1
    38ec:	08 95       	ret
   else
      return (encoded_length / 8) * 7;
    38ee:	9c 01       	movw	r18, r24
    38f0:	36 95       	lsr	r19
    38f2:	27 95       	ror	r18
    38f4:	36 95       	lsr	r19
    38f6:	27 95       	ror	r18
    38f8:	36 95       	lsr	r19
    38fa:	27 95       	ror	r18
    38fc:	c9 01       	movw	r24, r18
    38fe:	88 0f       	add	r24, r24
    3900:	99 1f       	adc	r25, r25
    3902:	88 0f       	add	r24, r24
    3904:	99 1f       	adc	r25, r25
    3906:	88 0f       	add	r24, r24
    3908:	99 1f       	adc	r25, r25
    390a:	82 1b       	sub	r24, r18
    390c:	93 0b       	sbc	r25, r19
}
    390e:	08 95       	ret

00003910 <sysex_encode>:

uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
    3910:	2f 92       	push	r2
    3912:	3f 92       	push	r3
    3914:	4f 92       	push	r4
    3916:	5f 92       	push	r5
    3918:	6f 92       	push	r6
    391a:	7f 92       	push	r7
    391c:	8f 92       	push	r8
    391e:	9f 92       	push	r9
    3920:	af 92       	push	r10
    3922:	bf 92       	push	r11
    3924:	cf 92       	push	r12
    3926:	df 92       	push	r13
    3928:	ef 92       	push	r14
    392a:	ff 92       	push	r15
    392c:	0f 93       	push	r16
    392e:	1f 93       	push	r17
    3930:	cf 93       	push	r28
    3932:	df 93       	push	r29
    3934:	00 d0       	rcall	.+0      	; 0x3936 <sysex_encode+0x26>
    3936:	00 d0       	rcall	.+0      	; 0x3938 <sysex_encode+0x28>
    3938:	00 d0       	rcall	.+0      	; 0x393a <sysex_encode+0x2a>
    393a:	cd b7       	in	r28, 0x3d	; 61
    393c:	de b7       	in	r29, 0x3e	; 62
    393e:	1c 01       	movw	r2, r24
    3940:	7a 83       	std	Y+2, r23	; 0x02
    3942:	69 83       	std	Y+1, r22	; 0x01
    3944:	3a 01       	movw	r6, r20
   uint16_t encoded_full = length / 7; //number of full 8 byte sections from 7 bytes of input
    3946:	ca 01       	movw	r24, r20
    3948:	67 e0       	ldi	r22, 0x07	; 7
    394a:	70 e0       	ldi	r23, 0x00	; 0
    394c:	0e 94 f9 1d 	call	0x3bf2	; 0x3bf2 <__udivmodhi4>
    3950:	2b 01       	movw	r4, r22
    3952:	5b 01       	movw	r10, r22
   uint16_t i,j;

   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
    3954:	61 15       	cp	r22, r1
    3956:	71 05       	cpc	r23, r1
    3958:	b1 f1       	breq	.+108    	; 0x39c6 <sysex_encode+0xb6>
    395a:	81 01       	movw	r16, r2
    395c:	e9 80       	ldd	r14, Y+1	; 0x01
    395e:	fa 80       	ldd	r15, Y+2	; 0x02
    3960:	cc 24       	eor	r12, r12
    3962:	dd 24       	eor	r13, r13
      uint16_t encoded_msb_idx = i * 8;
      uint16_t input_start_idx = i * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < 7; j++){
    3964:	88 24       	eor	r8, r8
    3966:	99 24       	eor	r9, r9
      return (encoded_length / 8) * 7 + remainder - 1;
   else
      return (encoded_length / 8) * 7;
}

uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
    3968:	1e 83       	std	Y+6, r17	; 0x06
    396a:	0d 83       	std	Y+5, r16	; 0x05

   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t input_start_idx = i * 7;
      encoded[encoded_msb_idx] = 0;
    396c:	f8 01       	movw	r30, r16
    396e:	11 92       	st	Z+, r1
      return (encoded_length / 8) * 7 + remainder - 1;
   else
      return (encoded_length / 8) * 7;
}

uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
    3970:	fc 82       	std	Y+4, r15	; 0x04
    3972:	eb 82       	std	Y+3, r14	; 0x03
   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t input_start_idx = i * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < 7; j++){
    3974:	a4 01       	movw	r20, r8
         uint8_t current = source[input_start_idx + j];
    3976:	ab 81       	ldd	r26, Y+3	; 0x03
    3978:	bc 81       	ldd	r27, Y+4	; 0x04
    397a:	2d 91       	ld	r18, X+
    397c:	bc 83       	std	Y+4, r27	; 0x04
    397e:	ab 83       	std	Y+3, r26	; 0x03
         encoded[encoded_msb_idx] |= (0x80 & current) >> (1 + j);
    3980:	4f 5f       	subi	r20, 0xFF	; 255
    3982:	5f 4f       	sbci	r21, 0xFF	; 255
    3984:	82 2f       	mov	r24, r18
    3986:	90 e0       	ldi	r25, 0x00	; 0
    3988:	80 78       	andi	r24, 0x80	; 128
    398a:	90 70       	andi	r25, 0x00	; 0
    398c:	bc 01       	movw	r22, r24
    398e:	04 2e       	mov	r0, r20
    3990:	02 c0       	rjmp	.+4      	; 0x3996 <sysex_encode+0x86>
    3992:	75 95       	asr	r23
    3994:	67 95       	ror	r22
    3996:	0a 94       	dec	r0
    3998:	e2 f7       	brpl	.-8      	; 0x3992 <sysex_encode+0x82>
    399a:	ad 81       	ldd	r26, Y+5	; 0x05
    399c:	be 81       	ldd	r27, Y+6	; 0x06
    399e:	8c 91       	ld	r24, X
    39a0:	86 2b       	or	r24, r22
    39a2:	8c 93       	st	X, r24
         encoded[encoded_msb_idx + 1 + j] = 0x7F & current;
    39a4:	2f 77       	andi	r18, 0x7F	; 127
    39a6:	21 93       	st	Z+, r18
   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t input_start_idx = i * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < 7; j++){
    39a8:	47 30       	cpi	r20, 0x07	; 7
    39aa:	51 05       	cpc	r21, r1
    39ac:	21 f7       	brne	.-56     	; 0x3976 <sysex_encode+0x66>
uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
   uint16_t encoded_full = length / 7; //number of full 8 byte sections from 7 bytes of input
   uint16_t i,j;

   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
    39ae:	08 94       	sec
    39b0:	c1 1c       	adc	r12, r1
    39b2:	d1 1c       	adc	r13, r1
    39b4:	08 5f       	subi	r16, 0xF8	; 248
    39b6:	1f 4f       	sbci	r17, 0xFF	; 255
    39b8:	e7 e0       	ldi	r30, 0x07	; 7
    39ba:	f0 e0       	ldi	r31, 0x00	; 0
    39bc:	ee 0e       	add	r14, r30
    39be:	ff 1e       	adc	r15, r31
    39c0:	ca 14       	cp	r12, r10
    39c2:	db 04       	cpc	r13, r11
    39c4:	89 f6       	brne	.-94     	; 0x3968 <sysex_encode+0x58>
         encoded[encoded_msb_idx + 1 + j] = 0x7F & current;
      }
   }

   //fill out the rest if there is any more
   uint8_t remainder = length % 7;
    39c6:	c3 01       	movw	r24, r6
    39c8:	67 e0       	ldi	r22, 0x07	; 7
    39ca:	70 e0       	ldi	r23, 0x00	; 0
    39cc:	0e 94 f9 1d 	call	0x3bf2	; 0x3bf2 <__udivmodhi4>
   if (remainder) {
    39d0:	88 23       	and	r24, r24
    39d2:	d9 f1       	breq	.+118    	; 0x3a4a <sysex_encode+0x13a>
      uint16_t encoded_msb_idx = encoded_full * 8;
    39d4:	82 01       	movw	r16, r4
    39d6:	00 0f       	add	r16, r16
    39d8:	11 1f       	adc	r17, r17
    39da:	00 0f       	add	r16, r16
    39dc:	11 1f       	adc	r17, r17
    39de:	00 0f       	add	r16, r16
    39e0:	11 1f       	adc	r17, r17
      uint16_t input_start_idx = encoded_full * 7;
    39e2:	78 01       	movw	r14, r16
    39e4:	e4 18       	sub	r14, r4
    39e6:	f5 08       	sbc	r15, r5
      encoded[encoded_msb_idx] = 0;
    39e8:	d1 01       	movw	r26, r2
    39ea:	a0 0f       	add	r26, r16
    39ec:	b1 1f       	adc	r27, r17
    39ee:	1c 92       	st	X, r1
      for(j = 0; j < remainder; j++){
    39f0:	68 2f       	mov	r22, r24
    39f2:	70 e0       	ldi	r23, 0x00	; 0
    39f4:	61 15       	cp	r22, r1
    39f6:	71 05       	cpc	r23, r1
    39f8:	19 f1       	breq	.+70     	; 0x3a40 <sysex_encode+0x130>
      return (encoded_length / 8) * 7 + remainder - 1;
   else
      return (encoded_length / 8) * 7;
}

uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
    39fa:	e9 81       	ldd	r30, Y+1	; 0x01
    39fc:	fa 81       	ldd	r31, Y+2	; 0x02
    39fe:	ee 0e       	add	r14, r30
    3a00:	ff 1e       	adc	r15, r31
    3a02:	c8 01       	movw	r24, r16
    3a04:	01 96       	adiw	r24, 0x01	; 1
    3a06:	28 0e       	add	r2, r24
    3a08:	39 1e       	adc	r3, r25
   uint8_t remainder = length % 7;
   if (remainder) {
      uint16_t encoded_msb_idx = encoded_full * 8;
      uint16_t input_start_idx = encoded_full * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < remainder; j++){
    3a0a:	20 e0       	ldi	r18, 0x00	; 0
    3a0c:	30 e0       	ldi	r19, 0x00	; 0
         uint8_t current = source[input_start_idx + j];
    3a0e:	f7 01       	movw	r30, r14
    3a10:	41 91       	ld	r20, Z+
    3a12:	7f 01       	movw	r14, r30
         encoded[encoded_msb_idx] |= (0x80 & current) >> (1 + j);
    3a14:	2f 5f       	subi	r18, 0xFF	; 255
    3a16:	3f 4f       	sbci	r19, 0xFF	; 255
    3a18:	84 2f       	mov	r24, r20
    3a1a:	90 e0       	ldi	r25, 0x00	; 0
    3a1c:	80 78       	andi	r24, 0x80	; 128
    3a1e:	90 70       	andi	r25, 0x00	; 0
    3a20:	02 2e       	mov	r0, r18
    3a22:	02 c0       	rjmp	.+4      	; 0x3a28 <sysex_encode+0x118>
    3a24:	95 95       	asr	r25
    3a26:	87 95       	ror	r24
    3a28:	0a 94       	dec	r0
    3a2a:	e2 f7       	brpl	.-8      	; 0x3a24 <sysex_encode+0x114>
    3a2c:	9c 91       	ld	r25, X
    3a2e:	89 2b       	or	r24, r25
    3a30:	8c 93       	st	X, r24
         encoded[encoded_msb_idx + 1 + j] = 0x7F & current;
    3a32:	4f 77       	andi	r20, 0x7F	; 127
    3a34:	f1 01       	movw	r30, r2
    3a36:	41 93       	st	Z+, r20
    3a38:	1f 01       	movw	r2, r30
   uint8_t remainder = length % 7;
   if (remainder) {
      uint16_t encoded_msb_idx = encoded_full * 8;
      uint16_t input_start_idx = encoded_full * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < remainder; j++){
    3a3a:	26 17       	cp	r18, r22
    3a3c:	37 07       	cpc	r19, r23
    3a3e:	38 f3       	brcs	.-50     	; 0x3a0e <sysex_encode+0xfe>
         uint8_t current = source[input_start_idx + j];
         encoded[encoded_msb_idx] |= (0x80 & current) >> (1 + j);
         encoded[encoded_msb_idx + 1 + j] = 0x7F & current;
      }
      return encoded_msb_idx + remainder + 1;
    3a40:	c8 01       	movw	r24, r16
    3a42:	01 96       	adiw	r24, 0x01	; 1
    3a44:	86 0f       	add	r24, r22
    3a46:	97 1f       	adc	r25, r23
    3a48:	07 c0       	rjmp	.+14     	; 0x3a58 <sysex_encode+0x148>
   } else {
      return encoded_full * 8;
    3a4a:	c2 01       	movw	r24, r4
    3a4c:	88 0f       	add	r24, r24
    3a4e:	99 1f       	adc	r25, r25
    3a50:	88 0f       	add	r24, r24
    3a52:	99 1f       	adc	r25, r25
    3a54:	88 0f       	add	r24, r24
    3a56:	99 1f       	adc	r25, r25
   }
}
    3a58:	26 96       	adiw	r28, 0x06	; 6
    3a5a:	0f b6       	in	r0, 0x3f	; 63
    3a5c:	f8 94       	cli
    3a5e:	de bf       	out	0x3e, r29	; 62
    3a60:	0f be       	out	0x3f, r0	; 63
    3a62:	cd bf       	out	0x3d, r28	; 61
    3a64:	df 91       	pop	r29
    3a66:	cf 91       	pop	r28
    3a68:	1f 91       	pop	r17
    3a6a:	0f 91       	pop	r16
    3a6c:	ff 90       	pop	r15
    3a6e:	ef 90       	pop	r14
    3a70:	df 90       	pop	r13
    3a72:	cf 90       	pop	r12
    3a74:	bf 90       	pop	r11
    3a76:	af 90       	pop	r10
    3a78:	9f 90       	pop	r9
    3a7a:	8f 90       	pop	r8
    3a7c:	7f 90       	pop	r7
    3a7e:	6f 90       	pop	r6
    3a80:	5f 90       	pop	r5
    3a82:	4f 90       	pop	r4
    3a84:	3f 90       	pop	r3
    3a86:	2f 90       	pop	r2
    3a88:	08 95       	ret

00003a8a <sysex_decode>:

uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
    3a8a:	6f 92       	push	r6
    3a8c:	7f 92       	push	r7
    3a8e:	8f 92       	push	r8
    3a90:	9f 92       	push	r9
    3a92:	af 92       	push	r10
    3a94:	bf 92       	push	r11
    3a96:	cf 92       	push	r12
    3a98:	df 92       	push	r13
    3a9a:	ef 92       	push	r14
    3a9c:	ff 92       	push	r15
    3a9e:	0f 93       	push	r16
    3aa0:	1f 93       	push	r17
    3aa2:	cf 93       	push	r28
    3aa4:	df 93       	push	r29
    3aa6:	3c 01       	movw	r6, r24
    3aa8:	4b 01       	movw	r8, r22
    3aaa:	5a 01       	movw	r10, r20
   uint16_t decoded_full = length / 8;
   uint16_t i,j;

   if (length < 2)
    3aac:	42 30       	cpi	r20, 0x02	; 2
    3aae:	51 05       	cpc	r21, r1
    3ab0:	08 f4       	brcc	.+2      	; 0x3ab4 <sysex_decode+0x2a>
    3ab2:	6f c0       	rjmp	.+222    	; 0x3b92 <sysex_decode+0x108>
      return encoded_full * 8;
   }
}

uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
   uint16_t decoded_full = length / 8;
    3ab4:	7a 01       	movw	r14, r20
    3ab6:	f6 94       	lsr	r15
    3ab8:	e7 94       	ror	r14
    3aba:	f6 94       	lsr	r15
    3abc:	e7 94       	ror	r14
    3abe:	f6 94       	lsr	r15
    3ac0:	e7 94       	ror	r14

   if (length < 2)
      return 0;

   //fill out the fully encoded sections
   for(i = 0; i < decoded_full; i++) {
    3ac2:	e1 14       	cp	r14, r1
    3ac4:	f1 04       	cpc	r15, r1
    3ac6:	29 f1       	breq	.+74     	; 0x3b12 <sysex_decode+0x88>
    3ac8:	eb 01       	movw	r28, r22
    3aca:	b3 01       	movw	r22, r6
    3acc:	00 e0       	ldi	r16, 0x00	; 0
    3ace:	10 e0       	ldi	r17, 0x00	; 0
      uint16_t encoded_msb_idx = i * 8;
      uint16_t output_start_index = i * 7;
      for(j = 0; j < 7; j++){
    3ad0:	cc 24       	eor	r12, r12
    3ad2:	dd 24       	eor	r13, r13
   } else {
      return encoded_full * 8;
   }
}

uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
    3ad4:	de 01       	movw	r26, r28
    3ad6:	11 96       	adiw	r26, 0x01	; 1
    3ad8:	fb 01       	movw	r30, r22

   //fill out the fully encoded sections
   for(i = 0; i < decoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t output_start_index = i * 7;
      for(j = 0; j < 7; j++){
    3ada:	a6 01       	movw	r20, r12
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
    3adc:	2d 91       	ld	r18, X+
    3ade:	2f 77       	andi	r18, 0x7F	; 127
    3ae0:	20 83       	st	Z, r18
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
    3ae2:	4f 5f       	subi	r20, 0xFF	; 255
    3ae4:	5f 4f       	sbci	r21, 0xFF	; 255
    3ae6:	88 81       	ld	r24, Y
    3ae8:	90 e0       	ldi	r25, 0x00	; 0
    3aea:	04 2e       	mov	r0, r20
    3aec:	02 c0       	rjmp	.+4      	; 0x3af2 <sysex_decode+0x68>
    3aee:	88 0f       	add	r24, r24
    3af0:	99 1f       	adc	r25, r25
    3af2:	0a 94       	dec	r0
    3af4:	e2 f7       	brpl	.-8      	; 0x3aee <sysex_decode+0x64>
    3af6:	80 78       	andi	r24, 0x80	; 128
    3af8:	28 2b       	or	r18, r24
    3afa:	21 93       	st	Z+, r18

   //fill out the fully encoded sections
   for(i = 0; i < decoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t output_start_index = i * 7;
      for(j = 0; j < 7; j++){
    3afc:	47 30       	cpi	r20, 0x07	; 7
    3afe:	51 05       	cpc	r21, r1
    3b00:	69 f7       	brne	.-38     	; 0x3adc <sysex_decode+0x52>

   if (length < 2)
      return 0;

   //fill out the fully encoded sections
   for(i = 0; i < decoded_full; i++) {
    3b02:	0f 5f       	subi	r16, 0xFF	; 255
    3b04:	1f 4f       	sbci	r17, 0xFF	; 255
    3b06:	28 96       	adiw	r28, 0x08	; 8
    3b08:	69 5f       	subi	r22, 0xF9	; 249
    3b0a:	7f 4f       	sbci	r23, 0xFF	; 255
    3b0c:	0e 15       	cp	r16, r14
    3b0e:	1f 05       	cpc	r17, r15
    3b10:	09 f7       	brne	.-62     	; 0x3ad4 <sysex_decode+0x4a>
      for(j = 0; j < 7; j++){
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
      }
   }
   uint8_t remainder = length % 8;
    3b12:	5a 2d       	mov	r21, r10
    3b14:	57 70       	andi	r21, 0x07	; 7
   if (remainder) {
    3b16:	99 f1       	breq	.+102    	; 0x3b7e <sysex_decode+0xf4>
      uint16_t encoded_msb_idx = decoded_full * 8;
    3b18:	e7 01       	movw	r28, r14
    3b1a:	cc 0f       	add	r28, r28
    3b1c:	dd 1f       	adc	r29, r29
    3b1e:	cc 0f       	add	r28, r28
    3b20:	dd 1f       	adc	r29, r29
    3b22:	cc 0f       	add	r28, r28
    3b24:	dd 1f       	adc	r29, r29
      uint16_t output_start_index = decoded_full * 7;
    3b26:	8e 01       	movw	r16, r28
    3b28:	0e 19       	sub	r16, r14
    3b2a:	1f 09       	sbc	r17, r15
      for(j = 0; j < (remainder - 1); j++) {
    3b2c:	65 2f       	mov	r22, r21
    3b2e:	70 e0       	ldi	r23, 0x00	; 0
    3b30:	61 50       	subi	r22, 0x01	; 1
    3b32:	70 40       	sbci	r23, 0x00	; 0
    3b34:	f9 f0       	breq	.+62     	; 0x3b74 <sysex_decode+0xea>
   } else {
      return encoded_full * 8;
   }
}

uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
    3b36:	ce 01       	movw	r24, r28
    3b38:	01 96       	adiw	r24, 0x01	; 1
    3b3a:	d4 01       	movw	r26, r8
    3b3c:	a8 0f       	add	r26, r24
    3b3e:	b9 1f       	adc	r27, r25
    3b40:	f3 01       	movw	r30, r6
    3b42:	e0 0f       	add	r30, r16
    3b44:	f1 1f       	adc	r31, r17
   }
   uint8_t remainder = length % 8;
   if (remainder) {
      uint16_t encoded_msb_idx = decoded_full * 8;
      uint16_t output_start_index = decoded_full * 7;
      for(j = 0; j < (remainder - 1); j++) {
    3b46:	20 e0       	ldi	r18, 0x00	; 0
    3b48:	30 e0       	ldi	r19, 0x00	; 0
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
    3b4a:	c8 0d       	add	r28, r8
    3b4c:	d9 1d       	adc	r29, r9
   uint8_t remainder = length % 8;
   if (remainder) {
      uint16_t encoded_msb_idx = decoded_full * 8;
      uint16_t output_start_index = decoded_full * 7;
      for(j = 0; j < (remainder - 1); j++) {
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
    3b4e:	4d 91       	ld	r20, X+
    3b50:	4f 77       	andi	r20, 0x7F	; 127
    3b52:	40 83       	st	Z, r20
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
    3b54:	2f 5f       	subi	r18, 0xFF	; 255
    3b56:	3f 4f       	sbci	r19, 0xFF	; 255
    3b58:	88 81       	ld	r24, Y
    3b5a:	90 e0       	ldi	r25, 0x00	; 0
    3b5c:	02 2e       	mov	r0, r18
    3b5e:	02 c0       	rjmp	.+4      	; 0x3b64 <sysex_decode+0xda>
    3b60:	88 0f       	add	r24, r24
    3b62:	99 1f       	adc	r25, r25
    3b64:	0a 94       	dec	r0
    3b66:	e2 f7       	brpl	.-8      	; 0x3b60 <sysex_decode+0xd6>
    3b68:	80 78       	andi	r24, 0x80	; 128
    3b6a:	48 2b       	or	r20, r24
    3b6c:	41 93       	st	Z+, r20
   }
   uint8_t remainder = length % 8;
   if (remainder) {
      uint16_t encoded_msb_idx = decoded_full * 8;
      uint16_t output_start_index = decoded_full * 7;
      for(j = 0; j < (remainder - 1); j++) {
    3b6e:	26 17       	cp	r18, r22
    3b70:	37 07       	cpc	r19, r23
    3b72:	68 f3       	brcs	.-38     	; 0x3b4e <sysex_decode+0xc4>
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
      }
      return decoded_full * 7 + remainder - 1;
    3b74:	c8 01       	movw	r24, r16
    3b76:	01 97       	sbiw	r24, 0x01	; 1
    3b78:	85 0f       	add	r24, r21
    3b7a:	91 1d       	adc	r25, r1
    3b7c:	0c c0       	rjmp	.+24     	; 0x3b96 <sysex_decode+0x10c>
   } else {
      return decoded_full * 7;
    3b7e:	c7 01       	movw	r24, r14
    3b80:	88 0f       	add	r24, r24
    3b82:	99 1f       	adc	r25, r25
    3b84:	88 0f       	add	r24, r24
    3b86:	99 1f       	adc	r25, r25
    3b88:	88 0f       	add	r24, r24
    3b8a:	99 1f       	adc	r25, r25
    3b8c:	8e 19       	sub	r24, r14
    3b8e:	9f 09       	sbc	r25, r15
    3b90:	02 c0       	rjmp	.+4      	; 0x3b96 <sysex_decode+0x10c>
uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
   uint16_t decoded_full = length / 8;
   uint16_t i,j;

   if (length < 2)
      return 0;
    3b92:	80 e0       	ldi	r24, 0x00	; 0
    3b94:	90 e0       	ldi	r25, 0x00	; 0
      }
      return decoded_full * 7 + remainder - 1;
   } else {
      return decoded_full * 7;
   }
}
    3b96:	df 91       	pop	r29
    3b98:	cf 91       	pop	r28
    3b9a:	1f 91       	pop	r17
    3b9c:	0f 91       	pop	r16
    3b9e:	ff 90       	pop	r15
    3ba0:	ef 90       	pop	r14
    3ba2:	df 90       	pop	r13
    3ba4:	cf 90       	pop	r12
    3ba6:	bf 90       	pop	r11
    3ba8:	af 90       	pop	r10
    3baa:	9f 90       	pop	r9
    3bac:	8f 90       	pop	r8
    3bae:	7f 90       	pop	r7
    3bb0:	6f 90       	pop	r6
    3bb2:	08 95       	ret

00003bb4 <__mulsi3>:
    3bb4:	62 9f       	mul	r22, r18
    3bb6:	d0 01       	movw	r26, r0
    3bb8:	73 9f       	mul	r23, r19
    3bba:	f0 01       	movw	r30, r0
    3bbc:	82 9f       	mul	r24, r18
    3bbe:	e0 0d       	add	r30, r0
    3bc0:	f1 1d       	adc	r31, r1
    3bc2:	64 9f       	mul	r22, r20
    3bc4:	e0 0d       	add	r30, r0
    3bc6:	f1 1d       	adc	r31, r1
    3bc8:	92 9f       	mul	r25, r18
    3bca:	f0 0d       	add	r31, r0
    3bcc:	83 9f       	mul	r24, r19
    3bce:	f0 0d       	add	r31, r0
    3bd0:	74 9f       	mul	r23, r20
    3bd2:	f0 0d       	add	r31, r0
    3bd4:	65 9f       	mul	r22, r21
    3bd6:	f0 0d       	add	r31, r0
    3bd8:	99 27       	eor	r25, r25
    3bda:	72 9f       	mul	r23, r18
    3bdc:	b0 0d       	add	r27, r0
    3bde:	e1 1d       	adc	r30, r1
    3be0:	f9 1f       	adc	r31, r25
    3be2:	63 9f       	mul	r22, r19
    3be4:	b0 0d       	add	r27, r0
    3be6:	e1 1d       	adc	r30, r1
    3be8:	f9 1f       	adc	r31, r25
    3bea:	bd 01       	movw	r22, r26
    3bec:	cf 01       	movw	r24, r30
    3bee:	11 24       	eor	r1, r1
    3bf0:	08 95       	ret

00003bf2 <__udivmodhi4>:
    3bf2:	aa 1b       	sub	r26, r26
    3bf4:	bb 1b       	sub	r27, r27
    3bf6:	51 e1       	ldi	r21, 0x11	; 17
    3bf8:	07 c0       	rjmp	.+14     	; 0x3c08 <__udivmodhi4_ep>

00003bfa <__udivmodhi4_loop>:
    3bfa:	aa 1f       	adc	r26, r26
    3bfc:	bb 1f       	adc	r27, r27
    3bfe:	a6 17       	cp	r26, r22
    3c00:	b7 07       	cpc	r27, r23
    3c02:	10 f0       	brcs	.+4      	; 0x3c08 <__udivmodhi4_ep>
    3c04:	a6 1b       	sub	r26, r22
    3c06:	b7 0b       	sbc	r27, r23

00003c08 <__udivmodhi4_ep>:
    3c08:	88 1f       	adc	r24, r24
    3c0a:	99 1f       	adc	r25, r25
    3c0c:	5a 95       	dec	r21
    3c0e:	a9 f7       	brne	.-22     	; 0x3bfa <__udivmodhi4_loop>
    3c10:	80 95       	com	r24
    3c12:	90 95       	com	r25
    3c14:	bc 01       	movw	r22, r24
    3c16:	cd 01       	movw	r24, r26
    3c18:	08 95       	ret

00003c1a <__divmodhi4>:
    3c1a:	97 fb       	bst	r25, 7
    3c1c:	09 2e       	mov	r0, r25
    3c1e:	07 26       	eor	r0, r23
    3c20:	0a d0       	rcall	.+20     	; 0x3c36 <__divmodhi4_neg1>
    3c22:	77 fd       	sbrc	r23, 7
    3c24:	04 d0       	rcall	.+8      	; 0x3c2e <__divmodhi4_neg2>
    3c26:	e5 df       	rcall	.-54     	; 0x3bf2 <__udivmodhi4>
    3c28:	06 d0       	rcall	.+12     	; 0x3c36 <__divmodhi4_neg1>
    3c2a:	00 20       	and	r0, r0
    3c2c:	1a f4       	brpl	.+6      	; 0x3c34 <__divmodhi4_exit>

00003c2e <__divmodhi4_neg2>:
    3c2e:	70 95       	com	r23
    3c30:	61 95       	neg	r22
    3c32:	7f 4f       	sbci	r23, 0xFF	; 255

00003c34 <__divmodhi4_exit>:
    3c34:	08 95       	ret

00003c36 <__divmodhi4_neg1>:
    3c36:	f6 f7       	brtc	.-4      	; 0x3c34 <__divmodhi4_exit>
    3c38:	90 95       	com	r25
    3c3a:	81 95       	neg	r24
    3c3c:	9f 4f       	sbci	r25, 0xFF	; 255
    3c3e:	08 95       	ret

00003c40 <do_random>:
    3c40:	a0 e0       	ldi	r26, 0x00	; 0
    3c42:	b0 e0       	ldi	r27, 0x00	; 0
    3c44:	e6 e2       	ldi	r30, 0x26	; 38
    3c46:	fe e1       	ldi	r31, 0x1E	; 30
    3c48:	0c 94 f7 1e 	jmp	0x3dee	; 0x3dee <__prologue_saves__+0xc>
    3c4c:	ec 01       	movw	r28, r24
    3c4e:	88 81       	ld	r24, Y
    3c50:	99 81       	ldd	r25, Y+1	; 0x01
    3c52:	aa 81       	ldd	r26, Y+2	; 0x02
    3c54:	bb 81       	ldd	r27, Y+3	; 0x03
    3c56:	00 97       	sbiw	r24, 0x00	; 0
    3c58:	a1 05       	cpc	r26, r1
    3c5a:	b1 05       	cpc	r27, r1
    3c5c:	21 f4       	brne	.+8      	; 0x3c66 <do_random+0x26>
    3c5e:	84 e2       	ldi	r24, 0x24	; 36
    3c60:	99 ed       	ldi	r25, 0xD9	; 217
    3c62:	ab e5       	ldi	r26, 0x5B	; 91
    3c64:	b7 e0       	ldi	r27, 0x07	; 7
    3c66:	bc 01       	movw	r22, r24
    3c68:	cd 01       	movw	r24, r26
    3c6a:	2d e1       	ldi	r18, 0x1D	; 29
    3c6c:	33 ef       	ldi	r19, 0xF3	; 243
    3c6e:	41 e0       	ldi	r20, 0x01	; 1
    3c70:	50 e0       	ldi	r21, 0x00	; 0
    3c72:	0e 94 d6 1e 	call	0x3dac	; 0x3dac <__divmodsi4>
    3c76:	49 01       	movw	r8, r18
    3c78:	5a 01       	movw	r10, r20
    3c7a:	27 ea       	ldi	r18, 0xA7	; 167
    3c7c:	31 e4       	ldi	r19, 0x41	; 65
    3c7e:	40 e0       	ldi	r20, 0x00	; 0
    3c80:	50 e0       	ldi	r21, 0x00	; 0
    3c82:	0e 94 da 1d 	call	0x3bb4	; 0x3bb4 <__mulsi3>
    3c86:	6b 01       	movw	r12, r22
    3c88:	7c 01       	movw	r14, r24
    3c8a:	c5 01       	movw	r24, r10
    3c8c:	b4 01       	movw	r22, r8
    3c8e:	2c ee       	ldi	r18, 0xEC	; 236
    3c90:	34 ef       	ldi	r19, 0xF4	; 244
    3c92:	4f ef       	ldi	r20, 0xFF	; 255
    3c94:	5f ef       	ldi	r21, 0xFF	; 255
    3c96:	0e 94 da 1d 	call	0x3bb4	; 0x3bb4 <__mulsi3>
    3c9a:	dc 01       	movw	r26, r24
    3c9c:	cb 01       	movw	r24, r22
    3c9e:	c8 0e       	add	r12, r24
    3ca0:	d9 1e       	adc	r13, r25
    3ca2:	ea 1e       	adc	r14, r26
    3ca4:	fb 1e       	adc	r15, r27
    3ca6:	f7 fe       	sbrs	r15, 7
    3ca8:	08 c0       	rjmp	.+16     	; 0x3cba <do_random+0x7a>
    3caa:	8f ef       	ldi	r24, 0xFF	; 255
    3cac:	9f ef       	ldi	r25, 0xFF	; 255
    3cae:	af ef       	ldi	r26, 0xFF	; 255
    3cb0:	bf e7       	ldi	r27, 0x7F	; 127
    3cb2:	c8 0e       	add	r12, r24
    3cb4:	d9 1e       	adc	r13, r25
    3cb6:	ea 1e       	adc	r14, r26
    3cb8:	fb 1e       	adc	r15, r27
    3cba:	c8 82       	st	Y, r12
    3cbc:	d9 82       	std	Y+1, r13	; 0x01
    3cbe:	ea 82       	std	Y+2, r14	; 0x02
    3cc0:	fb 82       	std	Y+3, r15	; 0x03
    3cc2:	97 01       	movw	r18, r14
    3cc4:	86 01       	movw	r16, r12
    3cc6:	3f 77       	andi	r19, 0x7F	; 127
    3cc8:	b8 01       	movw	r22, r16
    3cca:	c9 01       	movw	r24, r18
    3ccc:	cd b7       	in	r28, 0x3d	; 61
    3cce:	de b7       	in	r29, 0x3e	; 62
    3cd0:	ec e0       	ldi	r30, 0x0C	; 12
    3cd2:	0c 94 13 1f 	jmp	0x3e26	; 0x3e26 <__epilogue_restores__+0xc>

00003cd6 <random_r>:
    3cd6:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <do_random>
    3cda:	08 95       	ret

00003cdc <random>:
    3cdc:	80 eb       	ldi	r24, 0xB0	; 176
    3cde:	92 e0       	ldi	r25, 0x02	; 2
    3ce0:	0e 94 20 1e 	call	0x3c40	; 0x3c40 <do_random>
    3ce4:	08 95       	ret

00003ce6 <srandom>:
    3ce6:	dc 01       	movw	r26, r24
    3ce8:	cb 01       	movw	r24, r22
    3cea:	80 93 b0 02 	sts	0x02B0, r24
    3cee:	90 93 b1 02 	sts	0x02B1, r25
    3cf2:	a0 93 b2 02 	sts	0x02B2, r26
    3cf6:	b0 93 b3 02 	sts	0x02B3, r27
    3cfa:	08 95       	ret

00003cfc <memcpy>:
    3cfc:	fb 01       	movw	r30, r22
    3cfe:	dc 01       	movw	r26, r24
    3d00:	02 c0       	rjmp	.+4      	; 0x3d06 <memcpy+0xa>
    3d02:	01 90       	ld	r0, Z+
    3d04:	0d 92       	st	X+, r0
    3d06:	41 50       	subi	r20, 0x01	; 1
    3d08:	50 40       	sbci	r21, 0x00	; 0
    3d0a:	d8 f7       	brcc	.-10     	; 0x3d02 <memcpy+0x6>
    3d0c:	08 95       	ret

00003d0e <memmove>:
    3d0e:	68 17       	cp	r22, r24
    3d10:	79 07       	cpc	r23, r25
    3d12:	68 f4       	brcc	.+26     	; 0x3d2e <memmove+0x20>
    3d14:	fb 01       	movw	r30, r22
    3d16:	dc 01       	movw	r26, r24
    3d18:	e4 0f       	add	r30, r20
    3d1a:	f5 1f       	adc	r31, r21
    3d1c:	a4 0f       	add	r26, r20
    3d1e:	b5 1f       	adc	r27, r21
    3d20:	02 c0       	rjmp	.+4      	; 0x3d26 <memmove+0x18>
    3d22:	02 90       	ld	r0, -Z
    3d24:	0e 92       	st	-X, r0
    3d26:	41 50       	subi	r20, 0x01	; 1
    3d28:	50 40       	sbci	r21, 0x00	; 0
    3d2a:	d8 f7       	brcc	.-10     	; 0x3d22 <memmove+0x14>
    3d2c:	08 95       	ret
    3d2e:	0c 94 7e 1e 	jmp	0x3cfc	; 0x3cfc <memcpy>

00003d32 <__eerd_block_m6450a>:
    3d32:	dc 01       	movw	r26, r24
    3d34:	cb 01       	movw	r24, r22

00003d36 <__eerd_blraw_m6450a>:
    3d36:	fc 01       	movw	r30, r24
    3d38:	f9 99       	sbic	0x1f, 1	; 31
    3d3a:	fe cf       	rjmp	.-4      	; 0x3d38 <__eerd_blraw_m6450a+0x2>
    3d3c:	06 c0       	rjmp	.+12     	; 0x3d4a <__eerd_blraw_m6450a+0x14>
    3d3e:	f2 bd       	out	0x22, r31	; 34
    3d40:	e1 bd       	out	0x21, r30	; 33
    3d42:	f8 9a       	sbi	0x1f, 0	; 31
    3d44:	31 96       	adiw	r30, 0x01	; 1
    3d46:	00 b4       	in	r0, 0x20	; 32
    3d48:	0d 92       	st	X+, r0
    3d4a:	41 50       	subi	r20, 0x01	; 1
    3d4c:	50 40       	sbci	r21, 0x00	; 0
    3d4e:	b8 f7       	brcc	.-18     	; 0x3d3e <__eerd_blraw_m6450a+0x8>
    3d50:	08 95       	ret

00003d52 <__eerd_word_m6450a>:
    3d52:	a8 e1       	ldi	r26, 0x18	; 24
    3d54:	b0 e0       	ldi	r27, 0x00	; 0
    3d56:	42 e0       	ldi	r20, 0x02	; 2
    3d58:	50 e0       	ldi	r21, 0x00	; 0
    3d5a:	0c 94 9b 1e 	jmp	0x3d36	; 0x3d36 <__eerd_blraw_m6450a>

00003d5e <__eeupd_block_m6450a>:
    3d5e:	dc 01       	movw	r26, r24
    3d60:	a4 0f       	add	r26, r20
    3d62:	b5 1f       	adc	r27, r21
    3d64:	41 50       	subi	r20, 0x01	; 1
    3d66:	50 40       	sbci	r21, 0x00	; 0
    3d68:	48 f0       	brcs	.+18     	; 0x3d7c <__eeupd_block_m6450a+0x1e>
    3d6a:	cb 01       	movw	r24, r22
    3d6c:	84 0f       	add	r24, r20
    3d6e:	95 1f       	adc	r25, r21
    3d70:	2e 91       	ld	r18, -X
    3d72:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <__eeupd_r18_m6450a>
    3d76:	41 50       	subi	r20, 0x01	; 1
    3d78:	50 40       	sbci	r21, 0x00	; 0
    3d7a:	d0 f7       	brcc	.-12     	; 0x3d70 <__eeupd_block_m6450a+0x12>
    3d7c:	08 95       	ret

00003d7e <__eeupd_byte_m6450a>:
    3d7e:	26 2f       	mov	r18, r22

00003d80 <__eeupd_r18_m6450a>:
    3d80:	f9 99       	sbic	0x1f, 1	; 31
    3d82:	fe cf       	rjmp	.-4      	; 0x3d80 <__eeupd_r18_m6450a>
    3d84:	92 bd       	out	0x22, r25	; 34
    3d86:	81 bd       	out	0x21, r24	; 33
    3d88:	f8 9a       	sbi	0x1f, 0	; 31
    3d8a:	01 97       	sbiw	r24, 0x01	; 1
    3d8c:	00 b4       	in	r0, 0x20	; 32
    3d8e:	02 16       	cp	r0, r18
    3d90:	31 f0       	breq	.+12     	; 0x3d9e <__eeupd_r18_m6450a+0x1e>
    3d92:	20 bd       	out	0x20, r18	; 32
    3d94:	0f b6       	in	r0, 0x3f	; 63
    3d96:	f8 94       	cli
    3d98:	fa 9a       	sbi	0x1f, 2	; 31
    3d9a:	f9 9a       	sbi	0x1f, 1	; 31
    3d9c:	0f be       	out	0x3f, r0	; 63
    3d9e:	08 95       	ret

00003da0 <__eeupd_word_m6450a>:
    3da0:	01 96       	adiw	r24, 0x01	; 1
    3da2:	27 2f       	mov	r18, r23
    3da4:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <__eeupd_r18_m6450a>
    3da8:	0c 94 bf 1e 	jmp	0x3d7e	; 0x3d7e <__eeupd_byte_m6450a>

00003dac <__divmodsi4>:
    3dac:	97 fb       	bst	r25, 7
    3dae:	09 2e       	mov	r0, r25
    3db0:	05 26       	eor	r0, r21
    3db2:	0e d0       	rcall	.+28     	; 0x3dd0 <__divmodsi4_neg1>
    3db4:	57 fd       	sbrc	r21, 7
    3db6:	04 d0       	rcall	.+8      	; 0x3dc0 <__divmodsi4_neg2>
    3db8:	4b d0       	rcall	.+150    	; 0x3e50 <__udivmodsi4>
    3dba:	0a d0       	rcall	.+20     	; 0x3dd0 <__divmodsi4_neg1>
    3dbc:	00 1c       	adc	r0, r0
    3dbe:	38 f4       	brcc	.+14     	; 0x3dce <__divmodsi4_exit>

00003dc0 <__divmodsi4_neg2>:
    3dc0:	50 95       	com	r21
    3dc2:	40 95       	com	r20
    3dc4:	30 95       	com	r19
    3dc6:	21 95       	neg	r18
    3dc8:	3f 4f       	sbci	r19, 0xFF	; 255
    3dca:	4f 4f       	sbci	r20, 0xFF	; 255
    3dcc:	5f 4f       	sbci	r21, 0xFF	; 255

00003dce <__divmodsi4_exit>:
    3dce:	08 95       	ret

00003dd0 <__divmodsi4_neg1>:
    3dd0:	f6 f7       	brtc	.-4      	; 0x3dce <__divmodsi4_exit>
    3dd2:	90 95       	com	r25
    3dd4:	80 95       	com	r24
    3dd6:	70 95       	com	r23
    3dd8:	61 95       	neg	r22
    3dda:	7f 4f       	sbci	r23, 0xFF	; 255
    3ddc:	8f 4f       	sbci	r24, 0xFF	; 255
    3dde:	9f 4f       	sbci	r25, 0xFF	; 255
    3de0:	08 95       	ret

00003de2 <__prologue_saves__>:
    3de2:	2f 92       	push	r2
    3de4:	3f 92       	push	r3
    3de6:	4f 92       	push	r4
    3de8:	5f 92       	push	r5
    3dea:	6f 92       	push	r6
    3dec:	7f 92       	push	r7
    3dee:	8f 92       	push	r8
    3df0:	9f 92       	push	r9
    3df2:	af 92       	push	r10
    3df4:	bf 92       	push	r11
    3df6:	cf 92       	push	r12
    3df8:	df 92       	push	r13
    3dfa:	ef 92       	push	r14
    3dfc:	ff 92       	push	r15
    3dfe:	0f 93       	push	r16
    3e00:	1f 93       	push	r17
    3e02:	cf 93       	push	r28
    3e04:	df 93       	push	r29
    3e06:	cd b7       	in	r28, 0x3d	; 61
    3e08:	de b7       	in	r29, 0x3e	; 62
    3e0a:	ca 1b       	sub	r28, r26
    3e0c:	db 0b       	sbc	r29, r27
    3e0e:	0f b6       	in	r0, 0x3f	; 63
    3e10:	f8 94       	cli
    3e12:	de bf       	out	0x3e, r29	; 62
    3e14:	0f be       	out	0x3f, r0	; 63
    3e16:	cd bf       	out	0x3d, r28	; 61
    3e18:	09 94       	ijmp

00003e1a <__epilogue_restores__>:
    3e1a:	2a 88       	ldd	r2, Y+18	; 0x12
    3e1c:	39 88       	ldd	r3, Y+17	; 0x11
    3e1e:	48 88       	ldd	r4, Y+16	; 0x10
    3e20:	5f 84       	ldd	r5, Y+15	; 0x0f
    3e22:	6e 84       	ldd	r6, Y+14	; 0x0e
    3e24:	7d 84       	ldd	r7, Y+13	; 0x0d
    3e26:	8c 84       	ldd	r8, Y+12	; 0x0c
    3e28:	9b 84       	ldd	r9, Y+11	; 0x0b
    3e2a:	aa 84       	ldd	r10, Y+10	; 0x0a
    3e2c:	b9 84       	ldd	r11, Y+9	; 0x09
    3e2e:	c8 84       	ldd	r12, Y+8	; 0x08
    3e30:	df 80       	ldd	r13, Y+7	; 0x07
    3e32:	ee 80       	ldd	r14, Y+6	; 0x06
    3e34:	fd 80       	ldd	r15, Y+5	; 0x05
    3e36:	0c 81       	ldd	r16, Y+4	; 0x04
    3e38:	1b 81       	ldd	r17, Y+3	; 0x03
    3e3a:	aa 81       	ldd	r26, Y+2	; 0x02
    3e3c:	b9 81       	ldd	r27, Y+1	; 0x01
    3e3e:	ce 0f       	add	r28, r30
    3e40:	d1 1d       	adc	r29, r1
    3e42:	0f b6       	in	r0, 0x3f	; 63
    3e44:	f8 94       	cli
    3e46:	de bf       	out	0x3e, r29	; 62
    3e48:	0f be       	out	0x3f, r0	; 63
    3e4a:	cd bf       	out	0x3d, r28	; 61
    3e4c:	ed 01       	movw	r28, r26
    3e4e:	08 95       	ret

00003e50 <__udivmodsi4>:
    3e50:	a1 e2       	ldi	r26, 0x21	; 33
    3e52:	1a 2e       	mov	r1, r26
    3e54:	aa 1b       	sub	r26, r26
    3e56:	bb 1b       	sub	r27, r27
    3e58:	fd 01       	movw	r30, r26
    3e5a:	0d c0       	rjmp	.+26     	; 0x3e76 <__udivmodsi4_ep>

00003e5c <__udivmodsi4_loop>:
    3e5c:	aa 1f       	adc	r26, r26
    3e5e:	bb 1f       	adc	r27, r27
    3e60:	ee 1f       	adc	r30, r30
    3e62:	ff 1f       	adc	r31, r31
    3e64:	a2 17       	cp	r26, r18
    3e66:	b3 07       	cpc	r27, r19
    3e68:	e4 07       	cpc	r30, r20
    3e6a:	f5 07       	cpc	r31, r21
    3e6c:	20 f0       	brcs	.+8      	; 0x3e76 <__udivmodsi4_ep>
    3e6e:	a2 1b       	sub	r26, r18
    3e70:	b3 0b       	sbc	r27, r19
    3e72:	e4 0b       	sbc	r30, r20
    3e74:	f5 0b       	sbc	r31, r21

00003e76 <__udivmodsi4_ep>:
    3e76:	66 1f       	adc	r22, r22
    3e78:	77 1f       	adc	r23, r23
    3e7a:	88 1f       	adc	r24, r24
    3e7c:	99 1f       	adc	r25, r25
    3e7e:	1a 94       	dec	r1
    3e80:	69 f7       	brne	.-38     	; 0x3e5c <__udivmodsi4_loop>
    3e82:	60 95       	com	r22
    3e84:	70 95       	com	r23
    3e86:	80 95       	com	r24
    3e88:	90 95       	com	r25
    3e8a:	9b 01       	movw	r18, r22
    3e8c:	ac 01       	movw	r20, r24
    3e8e:	bd 01       	movw	r22, r26
    3e90:	cf 01       	movw	r24, r30
    3e92:	08 95       	ret

00003e94 <_exit>:
    3e94:	f8 94       	cli

00003e96 <__stop_program>:
    3e96:	ff cf       	rjmp	.-2      	; 0x3e96 <__stop_program>
