
monapollo-firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001b4  00800100  00004004  000040b8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004004  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000223  008002b4  008002b4  0000426c  2**0
                  ALLOC
  3 .eeprom       00000674  00810000  00810000  0000426c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00000bf4  00000000  00000000  000048e0  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      0000033e  00000000  00000000  000054d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 000003b8  00000000  00000000  00005818  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00007167  00000000  00000000  00005bd0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000019e5  00000000  00000000  0000cd37  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000024ca  00000000  00000000  0000e71c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000e20  00000000  00000000  00010be8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001a58  00000000  00000000  00011a08  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002fe1  00000000  00000000  00013460  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000138  00000000  00000000  00016441  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 32 00 	jmp	0x64	; 0x64 <__ctors_end>
       4:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
       8:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
       c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      10:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      14:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      18:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      1c:	0c 94 96 03 	jmp	0x72c	; 0x72c <__vector_7>
      20:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      24:	0c 94 8a 03 	jmp	0x714	; 0x714 <__vector_9>
      28:	0c 94 4b 03 	jmp	0x696	; 0x696 <__vector_10>
      2c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      30:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      34:	0c 94 b5 04 	jmp	0x96a	; 0x96a <__vector_13>
      38:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      3c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      40:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      44:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      48:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      4c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      50:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      54:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      58:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      5c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      60:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>

00000064 <__ctors_end>:
      64:	11 24       	eor	r1, r1
      66:	1f be       	out	0x3f, r1	; 63
      68:	cf ef       	ldi	r28, 0xFF	; 255
      6a:	d0 e1       	ldi	r29, 0x10	; 16
      6c:	de bf       	out	0x3e, r29	; 62
      6e:	cd bf       	out	0x3d, r28	; 61

00000070 <__do_copy_data>:
      70:	12 e0       	ldi	r17, 0x02	; 2
      72:	a0 e0       	ldi	r26, 0x00	; 0
      74:	b1 e0       	ldi	r27, 0x01	; 1
      76:	e4 e0       	ldi	r30, 0x04	; 4
      78:	f0 e4       	ldi	r31, 0x40	; 64
      7a:	02 c0       	rjmp	.+4      	; 0x80 <__do_copy_data+0x10>
      7c:	05 90       	lpm	r0, Z+
      7e:	0d 92       	st	X+, r0
      80:	a4 3b       	cpi	r26, 0xB4	; 180
      82:	b1 07       	cpc	r27, r17
      84:	d9 f7       	brne	.-10     	; 0x7c <__do_copy_data+0xc>

00000086 <__do_clear_bss>:
      86:	14 e0       	ldi	r17, 0x04	; 4
      88:	a4 eb       	ldi	r26, 0xB4	; 180
      8a:	b2 e0       	ldi	r27, 0x02	; 2
      8c:	01 c0       	rjmp	.+2      	; 0x90 <.do_clear_bss_start>

0000008e <.do_clear_bss_loop>:
      8e:	1d 92       	st	X+, r1

00000090 <.do_clear_bss_start>:
      90:	a7 3d       	cpi	r26, 0xD7	; 215
      92:	b1 07       	cpc	r27, r17
      94:	e1 f7       	brne	.-8      	; 0x8e <.do_clear_bss_loop>
      96:	0e 94 ea 04 	call	0x9d4	; 0x9d4 <main>
      9a:	0c 94 00 20 	jmp	0x4000	; 0x4000 <_exit>

0000009e <__bad_interrupt>:
      9e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a2 <setup_adc>:

void setup_adc(void)
{
	//ADCSRA |= (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0); //set ADC clock to 156.25 KHz for 20 MHz clock
	//ADCSRA |= (1<<ADPS2) | (1<<ADPS1); //set ADC clock to 312.5 KHz for 20 MHz clock
	ADCSRA |= (1<<ADPS2);// | (1<<ADPS0); //set ADC clock to 1.25 MHz for 20 MHz clock
      a2:	ea e7       	ldi	r30, 0x7A	; 122
      a4:	f0 e0       	ldi	r31, 0x00	; 0
      a6:	80 81       	ld	r24, Z
      a8:	84 60       	ori	r24, 0x04	; 4
      aa:	80 83       	st	Z, r24
	ADMUX |= (1<<REFS0); //set ADC reference to AVCC (+5V)
      ac:	ac e7       	ldi	r26, 0x7C	; 124
      ae:	b0 e0       	ldi	r27, 0x00	; 0
      b0:	8c 91       	ld	r24, X
      b2:	80 64       	ori	r24, 0x40	; 64
      b4:	8c 93       	st	X, r24
	
	DIDR0 |= 0x01; //disable digital input buffer for ADC0
      b6:	ae e7       	ldi	r26, 0x7E	; 126
      b8:	b0 e0       	ldi	r27, 0x00	; 0
      ba:	8c 91       	ld	r24, X
      bc:	81 60       	ori	r24, 0x01	; 1
      be:	8c 93       	st	X, r24
	
	ADCSRA |= (1<<ADEN); //enable ADC
      c0:	80 81       	ld	r24, Z
      c2:	80 68       	ori	r24, 0x80	; 128
      c4:	80 83       	st	Z, r24
}
      c6:	08 95       	ret

000000c8 <read_pot>:

uint16_t read_pot(struct potentiometer *pot) {
      c8:	fc 01       	movw	r30, r24
	
	DATA_BUS = pot->channel;
      ca:	83 81       	ldd	r24, Z+3	; 0x03
      cc:	8f 70       	andi	r24, 0x0F	; 15
      ce:	82 b9       	out	0x02, r24	; 2
	POT_MUX &= ~(1<<pot->mux_addr);
      d0:	aa ed       	ldi	r26, 0xDA	; 218
      d2:	b0 e0       	ldi	r27, 0x00	; 0
      d4:	4c 91       	ld	r20, X
      d6:	83 81       	ldd	r24, Z+3	; 0x03
      d8:	82 95       	swap	r24
      da:	8f 70       	andi	r24, 0x0F	; 15
      dc:	87 70       	andi	r24, 0x07	; 7
      de:	21 e0       	ldi	r18, 0x01	; 1
      e0:	30 e0       	ldi	r19, 0x00	; 0
      e2:	b9 01       	movw	r22, r18
      e4:	02 c0       	rjmp	.+4      	; 0xea <read_pot+0x22>
      e6:	66 0f       	add	r22, r22
      e8:	77 1f       	adc	r23, r23
      ea:	8a 95       	dec	r24
      ec:	e2 f7       	brpl	.-8      	; 0xe6 <read_pot+0x1e>
      ee:	cb 01       	movw	r24, r22
      f0:	80 95       	com	r24
      f2:	84 23       	and	r24, r20
      f4:	8c 93       	st	X, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
      f6:	7d e0       	ldi	r23, 0x0D	; 13
      f8:	7a 95       	dec	r23
      fa:	f1 f7       	brne	.-4      	; 0xf8 <read_pot+0x30>
      fc:	00 00       	nop
	_delay_us(2); //ADC settling time. Previously used 10 us, testing 2 us now. Now testing 1 us. See how it sounds. Nope. Needs to 2 us minimum to prevent crosstalk between multiplexer channels
	ADCSRA |= (1<<ADSC); //start ADC conversion
      fe:	aa e7       	ldi	r26, 0x7A	; 122
     100:	b0 e0       	ldi	r27, 0x00	; 0
     102:	8c 91       	ld	r24, X
     104:	80 64       	ori	r24, 0x40	; 64
     106:	8c 93       	st	X, r24
	while ((ADCSRA & (1<<ADSC))); //wait for ADC conversion to complete (13 cycles of ADC clock - 10.4 us for 1.25Mhz clock) - need to figure out what to do with this time - would interrupt be more efficient?
     108:	8c 91       	ld	r24, X
     10a:	86 fd       	sbrc	r24, 6
     10c:	fd cf       	rjmp	.-6      	; 0x108 <read_pot+0x40>
	POT_MUX |= (1<<pot->mux_addr); //disable pot multiplexer
     10e:	aa ed       	ldi	r26, 0xDA	; 218
     110:	b0 e0       	ldi	r27, 0x00	; 0
     112:	4c 91       	ld	r20, X
     114:	83 81       	ldd	r24, Z+3	; 0x03
     116:	82 95       	swap	r24
     118:	8f 70       	andi	r24, 0x0F	; 15
     11a:	87 70       	andi	r24, 0x07	; 7
     11c:	21 e0       	ldi	r18, 0x01	; 1
     11e:	30 e0       	ldi	r19, 0x00	; 0
     120:	b9 01       	movw	r22, r18
     122:	02 c0       	rjmp	.+4      	; 0x128 <read_pot+0x60>
     124:	66 0f       	add	r22, r22
     126:	77 1f       	adc	r23, r23
     128:	8a 95       	dec	r24
     12a:	e2 f7       	brpl	.-8      	; 0x124 <read_pot+0x5c>
     12c:	cb 01       	movw	r24, r22
     12e:	84 2b       	or	r24, r20
     130:	8c 93       	st	X, r24
	//note that ADSC reads HIGH as long as conversion is in progress, goes LOW when conversion is complete
			
			
	uint16_t adc_read = ADCL;
     132:	80 91 78 00 	lds	r24, 0x0078
     136:	90 e0       	ldi	r25, 0x00	; 0
	adc_read = adc_read | (ADCH <<8);
     138:	40 91 79 00 	lds	r20, 0x0079
     13c:	34 2f       	mov	r19, r20
     13e:	20 e0       	ldi	r18, 0x00	; 0
     140:	82 2b       	or	r24, r18
     142:	93 2b       	or	r25, r19
			
	return adc_read;
     144:	08 95       	ret

00000146 <update_arp_sequence>:
//#include "display.h"

struct arp arp;


void update_arp_sequence(void) {
     146:	4f 92       	push	r4
     148:	5f 92       	push	r5
     14a:	6f 92       	push	r6
     14c:	7f 92       	push	r7
     14e:	8f 92       	push	r8
     150:	9f 92       	push	r9
     152:	af 92       	push	r10
     154:	bf 92       	push	r11
     156:	cf 92       	push	r12
     158:	df 92       	push	r13
     15a:	ef 92       	push	r14
     15c:	ff 92       	push	r15
     15e:	0f 93       	push	r16
     160:	1f 93       	push	r17
     162:	cf 93       	push	r28
     164:	df 93       	push	r29
	


	arp.step_number = gate_buffer*(arp.range + 1);
     166:	90 91 88 03 	lds	r25, 0x0388
     16a:	9f 5f       	subi	r25, 0xFF	; 255
     16c:	80 91 b4 02 	lds	r24, 0x02B4
     170:	98 9f       	mul	r25, r24
     172:	80 2d       	mov	r24, r0
     174:	11 24       	eor	r1, r1
     176:	80 93 89 03 	sts	0x0389, r24
     17a:	88 24       	eor	r8, r8
     17c:	99 24       	eor	r9, r9
	//arp.step_position = 0; //would use this if note retrigger feature was added
	
	uint8_t step = 0;
	
	//set arp sequence
	for (int range = 0; range <= arp.range; range++) {
     17e:	66 24       	eor	r6, r6
     180:	77 24       	eor	r7, r7


	arp.step_number = gate_buffer*(arp.range + 1);
	//arp.step_position = 0; //would use this if note retrigger feature was added
	
	uint8_t step = 0;
     182:	ff 24       	eor	r15, r15
					break;
					
				case DOWN:
					
					 //handle min note out of range here
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
     184:	44 24       	eor	r4, r4
     186:	55 24       	eor	r5, r5
		for (int i = 0; i < gate_buffer; i++) { // NOTE < rather than <= - <= was causing extra iteration that was over incrementing step!!!!!
			
			uint8_t root_note = get_indexed_note(gate_buffer - i - 1); //need to get notes in reverse order out of note pool
			//uint8_t root_note = get_indexed_note(i);
				
			switch(arp.mode) {
     188:	0f 2e       	mov	r0, r31
     18a:	f7 e9       	ldi	r31, 0x97	; 151
     18c:	cf 2e       	mov	r12, r31
     18e:	f3 e0       	ldi	r31, 0x03	; 3
     190:	df 2e       	mov	r13, r31
     192:	f0 2d       	mov	r31, r0
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
						
						root_note += 12;
						
					}
					arp.sequence[step++].note = root_note - (range*12);
     194:	0f 2e       	mov	r0, r31
     196:	f8 e8       	ldi	r31, 0x88	; 136
     198:	af 2e       	mov	r10, r31
     19a:	f3 e0       	ldi	r31, 0x03	; 3
     19c:	bf 2e       	mov	r11, r31
     19e:	f0 2d       	mov	r31, r0
     1a0:	4c c0       	rjmp	.+152    	; 0x23a <update_arp_sequence+0xf4>
	//set arp sequence
	for (int range = 0; range <= arp.range; range++) {
			
		for (int i = 0; i < gate_buffer; i++) { // NOTE < rather than <= - <= was causing extra iteration that was over incrementing step!!!!!
			
			uint8_t root_note = get_indexed_note(gate_buffer - i - 1); //need to get notes in reverse order out of note pool
     1a2:	81 50       	subi	r24, 0x01	; 1
     1a4:	80 1b       	sub	r24, r16
     1a6:	0e 94 86 01 	call	0x30c	; 0x30c <get_indexed_note>
     1aa:	28 2f       	mov	r18, r24
			//uint8_t root_note = get_indexed_note(i);
				
			switch(arp.mode) {
     1ac:	f6 01       	movw	r30, r12
     1ae:	80 81       	ld	r24, Z
     1b0:	82 30       	cpi	r24, 0x02	; 2
     1b2:	41 f0       	breq	.+16     	; 0x1c4 <update_arp_sequence+0x7e>
     1b4:	83 30       	cpi	r24, 0x03	; 3
     1b6:	18 f4       	brcc	.+6      	; 0x1be <update_arp_sequence+0x78>
     1b8:	81 30       	cpi	r24, 0x01	; 1
     1ba:	49 f5       	brne	.+82     	; 0x20e <update_arp_sequence+0xc8>
     1bc:	0a c0       	rjmp	.+20     	; 0x1d2 <update_arp_sequence+0x8c>
     1be:	85 30       	cpi	r24, 0x05	; 5
     1c0:	30 f5       	brcc	.+76     	; 0x20e <update_arp_sequence+0xc8>
     1c2:	07 c0       	rjmp	.+14     	; 0x1d2 <update_arp_sequence+0x8c>
					break;
					
				case DOWN:
					
					 //handle min note out of range here
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
     1c4:	ce 01       	movw	r24, r28
     1c6:	82 0f       	add	r24, r18
     1c8:	91 1d       	adc	r25, r1
     1ca:	88 30       	cpi	r24, 0x08	; 8
     1cc:	91 05       	cpc	r25, r1
     1ce:	6c f0       	brlt	.+26     	; 0x1ea <update_arp_sequence+0xa4>
     1d0:	13 c0       	rjmp	.+38     	; 0x1f8 <update_arp_sequence+0xb2>
			switch(arp.mode) {
				
				case UP:
				case UP_DOWN:
				case RANDOM:
					arp.sequence[step++].note = root_note + (range*12); //will need to handle max note out of range here
     1d2:	8f 2d       	mov	r24, r15
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	08 96       	adiw	r24, 0x08	; 8
     1d8:	88 0f       	add	r24, r24
     1da:	99 1f       	adc	r25, r25
     1dc:	8a 0d       	add	r24, r10
     1de:	9b 1d       	adc	r25, r11
     1e0:	2e 19       	sub	r18, r14
     1e2:	fc 01       	movw	r30, r24
     1e4:	20 83       	st	Z, r18
     1e6:	f3 94       	inc	r15
				
					break;
     1e8:	12 c0       	rjmp	.+36     	; 0x20e <update_arp_sequence+0xc8>
				case DOWN:
					
					 //handle min note out of range here
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
						
						root_note += 12;
     1ea:	24 5f       	subi	r18, 0xF4	; 244
					break;
					
				case DOWN:
					
					 //handle min note out of range here
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
     1ec:	ce 01       	movw	r24, r28
     1ee:	82 0f       	add	r24, r18
     1f0:	91 1d       	adc	r25, r1
     1f2:	88 30       	cpi	r24, 0x08	; 8
     1f4:	91 05       	cpc	r25, r1
     1f6:	cc f3       	brlt	.-14     	; 0x1ea <update_arp_sequence+0xa4>
						
						root_note += 12;
						
					}
					arp.sequence[step++].note = root_note - (range*12);
     1f8:	8f 2d       	mov	r24, r15
     1fa:	90 e0       	ldi	r25, 0x00	; 0
     1fc:	08 96       	adiw	r24, 0x08	; 8
     1fe:	88 0f       	add	r24, r24
     200:	99 1f       	adc	r25, r25
     202:	8a 0d       	add	r24, r10
     204:	9b 1d       	adc	r25, r11
     206:	2e 0d       	add	r18, r14
     208:	fc 01       	movw	r30, r24
     20a:	20 83       	st	Z, r18
     20c:	f3 94       	inc	r15
	uint8_t step = 0;
	
	//set arp sequence
	for (int range = 0; range <= arp.range; range++) {
			
		for (int i = 0; i < gate_buffer; i++) { // NOTE < rather than <= - <= was causing extra iteration that was over incrementing step!!!!!
     20e:	0f 5f       	subi	r16, 0xFF	; 255
     210:	1f 4f       	sbci	r17, 0xFF	; 255
     212:	80 91 b4 02 	lds	r24, 0x02B4
     216:	28 2f       	mov	r18, r24
     218:	30 e0       	ldi	r19, 0x00	; 0
     21a:	02 17       	cp	r16, r18
     21c:	13 07       	cpc	r17, r19
     21e:	0c f2       	brlt	.-126    	; 0x1a2 <update_arp_sequence+0x5c>
	//arp.step_position = 0; //would use this if note retrigger feature was added
	
	uint8_t step = 0;
	
	//set arp sequence
	for (int range = 0; range <= arp.range; range++) {
     220:	08 94       	sec
     222:	61 1c       	adc	r6, r1
     224:	71 1c       	adc	r7, r1
     226:	84 ef       	ldi	r24, 0xF4	; 244
     228:	9f ef       	ldi	r25, 0xFF	; 255
     22a:	88 0e       	add	r8, r24
     22c:	99 1e       	adc	r9, r25
     22e:	f5 01       	movw	r30, r10
     230:	80 81       	ld	r24, Z
     232:	90 e0       	ldi	r25, 0x00	; 0
     234:	86 15       	cp	r24, r6
     236:	97 05       	cpc	r25, r7
     238:	44 f0       	brlt	.+16     	; 0x24a <update_arp_sequence+0x104>
			
		for (int i = 0; i < gate_buffer; i++) { // NOTE < rather than <= - <= was causing extra iteration that was over incrementing step!!!!!
     23a:	80 91 b4 02 	lds	r24, 0x02B4
     23e:	88 23       	and	r24, r24
     240:	79 f3       	breq	.-34     	; 0x220 <update_arp_sequence+0xda>
//#include "display.h"

struct arp arp;


void update_arp_sequence(void) {
     242:	e8 2c       	mov	r14, r8
					break;
					
				case DOWN:
					
					 //handle min note out of range here
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
     244:	e4 01       	movw	r28, r8
     246:	82 01       	movw	r16, r4
     248:	ac cf       	rjmp	.-168    	; 0x1a2 <update_arp_sequence+0x5c>
		//value_to_display = step;

	}
	
	
}
     24a:	df 91       	pop	r29
     24c:	cf 91       	pop	r28
     24e:	1f 91       	pop	r17
     250:	0f 91       	pop	r16
     252:	ff 90       	pop	r15
     254:	ef 90       	pop	r14
     256:	df 90       	pop	r13
     258:	cf 90       	pop	r12
     25a:	bf 90       	pop	r11
     25c:	af 90       	pop	r10
     25e:	9f 90       	pop	r9
     260:	8f 90       	pop	r8
     262:	7f 90       	pop	r7
     264:	6f 90       	pop	r6
     266:	5f 90       	pop	r5
     268:	4f 90       	pop	r4
     26a:	08 95       	ret

0000026c <step_arp_note>:

void step_arp_note(void) { //updates arp note according to step position in sequence
	
	arp.current_note = arp.sequence[arp.step_position].note;
     26c:	90 91 8a 03 	lds	r25, 0x038A
     270:	a9 2f       	mov	r26, r25
     272:	b0 e0       	ldi	r27, 0x00	; 0
     274:	18 96       	adiw	r26, 0x08	; 8
     276:	e8 e8       	ldi	r30, 0x88	; 136
     278:	f3 e0       	ldi	r31, 0x03	; 3
     27a:	aa 0f       	add	r26, r26
     27c:	bb 1f       	adc	r27, r27
     27e:	ae 0f       	add	r26, r30
     280:	bf 1f       	adc	r27, r31
     282:	8c 91       	ld	r24, X
     284:	85 83       	std	Z+5, r24	; 0x05
	arp.previous_note = arp.current_note;
     286:	84 83       	std	Z+4, r24	; 0x04
	
	switch (arp.mode) {
     288:	87 85       	ldd	r24, Z+15	; 0x0f
     28a:	83 30       	cpi	r24, 0x03	; 3
     28c:	19 f0       	breq	.+6      	; 0x294 <step_arp_note+0x28>
     28e:	84 30       	cpi	r24, 0x04	; 4
     290:	99 f5       	brne	.+102    	; 0x2f8 <step_arp_note+0x8c>
     292:	28 c0       	rjmp	.+80     	; 0x2e4 <step_arp_note+0x78>
		
		case UP_DOWN:
			
			if (arp.direction == UP) {
     294:	80 91 8b 03 	lds	r24, 0x038B
     298:	81 30       	cpi	r24, 0x01	; 1
     29a:	91 f4       	brne	.+36     	; 0x2c0 <step_arp_note+0x54>
				arp.step_position++;	
     29c:	9f 5f       	subi	r25, 0xFF	; 255
     29e:	90 93 8a 03 	sts	0x038A, r25
				
				if (arp.step_position >= arp.step_number) {
     2a2:	80 91 89 03 	lds	r24, 0x0389
     2a6:	98 17       	cp	r25, r24
     2a8:	80 f1       	brcs	.+96     	; 0x30a <step_arp_note+0x9e>
					arp.step_position = arp.step_number == 1 ? 0 : arp.step_number - 2; //Omar handles edge case here
     2aa:	81 30       	cpi	r24, 0x01	; 1
     2ac:	11 f0       	breq	.+4      	; 0x2b2 <step_arp_note+0x46>
     2ae:	82 50       	subi	r24, 0x02	; 2
     2b0:	01 c0       	rjmp	.+2      	; 0x2b4 <step_arp_note+0x48>
     2b2:	80 e0       	ldi	r24, 0x00	; 0
     2b4:	80 93 8a 03 	sts	0x038A, r24
					arp.direction = DOWN;
     2b8:	82 e0       	ldi	r24, 0x02	; 2
     2ba:	80 93 8b 03 	sts	0x038B, r24
     2be:	08 95       	ret
				}				
				
			} else {
				if (arp.step_position <= 0) {
     2c0:	99 23       	and	r25, r25
     2c2:	61 f4       	brne	.+24     	; 0x2dc <step_arp_note+0x70>
					
					arp.step_position = arp.step_number == 1 ? 0 : 1; //Omar handles edge case here
     2c4:	81 e0       	ldi	r24, 0x01	; 1
     2c6:	90 91 89 03 	lds	r25, 0x0389
     2ca:	91 30       	cpi	r25, 0x01	; 1
     2cc:	09 f4       	brne	.+2      	; 0x2d0 <step_arp_note+0x64>
     2ce:	80 e0       	ldi	r24, 0x00	; 0
     2d0:	80 93 8a 03 	sts	0x038A, r24
					arp.direction = UP;
     2d4:	81 e0       	ldi	r24, 0x01	; 1
     2d6:	80 93 8b 03 	sts	0x038B, r24
     2da:	08 95       	ret
					
				} else {
					arp.step_position--;
     2dc:	91 50       	subi	r25, 0x01	; 1
     2de:	90 93 8a 03 	sts	0x038A, r25
     2e2:	08 95       	ret
			
			break;
			
		case RANDOM:
		
			arp.step_position = random() % arp.step_number; //maybe >> random() result to generate 8 bit value before modulo?
     2e4:	0e 94 46 1f 	call	0x3e8c	; 0x3e8c <random>
     2e8:	60 91 89 03 	lds	r22, 0x0389
     2ec:	70 e0       	ldi	r23, 0x00	; 0
     2ee:	0e 94 c3 1e 	call	0x3d86	; 0x3d86 <__divmodhi4>
     2f2:	80 93 8a 03 	sts	0x038A, r24
		
			break;
     2f6:	08 95       	ret
			
		default:
		
			if (++arp.step_position >= arp.step_number) arp.step_position  = 0;//reset step position when at end of sequence 
     2f8:	9f 5f       	subi	r25, 0xFF	; 255
     2fa:	90 93 8a 03 	sts	0x038A, r25
     2fe:	80 91 89 03 	lds	r24, 0x0389
     302:	98 17       	cp	r25, r24
     304:	10 f0       	brcs	.+4      	; 0x30a <step_arp_note+0x9e>
     306:	10 92 8a 03 	sts	0x038A, r1
     30a:	08 95       	ret

0000030c <get_indexed_note>:

static uint8_t current_note = 0; //this acts as a buffer for the current note to maintain pitch during release stage of envelopes

uint8_t get_indexed_note(uint8_t index) {
	
	return note_pool[index].note;
     30c:	e8 2f       	mov	r30, r24
     30e:	f0 e0       	ldi	r31, 0x00	; 0
     310:	ee 0f       	add	r30, r30
     312:	ff 1f       	adc	r31, r31
     314:	e8 54       	subi	r30, 0x48	; 72
     316:	fe 4f       	sbci	r31, 0xFE	; 254
	
	
	
}
     318:	80 81       	ld	r24, Z
     31a:	08 95       	ret

0000031c <get_current_note>:
uint8_t get_current_note() { //Force inline this function? Ask Omar. BUT, this could be where interpolation is calculated!
	
	uint8_t note = 0;
	if (arp.mode) {
     31c:	80 91 97 03 	lds	r24, 0x0397
     320:	88 23       	and	r24, r24
     322:	19 f0       	breq	.+6      	; 0x32a <get_current_note+0xe>
		
		
		//do something here to determine what arp note should be
		note = arp.current_note; //yeah, like this!
     324:	80 91 8d 03 	lds	r24, 0x038D
     328:	08 95       	ret
		

		
	} else {
		
		note = current_note;
     32a:	80 91 b5 02 	lds	r24, 0x02B5
				
	}
	return note;
	
}
     32e:	08 95       	ret

00000330 <new_note>:

void new_note(uint8_t note, uint8_t velocity) {
     330:	0f 93       	push	r16
     332:	1f 93       	push	r17
     334:	cf 93       	push	r28
     336:	df 93       	push	r29
     338:	18 2f       	mov	r17, r24
     33a:	06 2f       	mov	r16, r22
	
	
	//shift contents of note_pool right by one element
	memmove(note_pool + 1, note_pool, sizeof(note_pool) -sizeof(*note_pool)); //last argument: sizeof struct - sizeof one element of struct. See http://www.cplusplus.com/forum/beginner/1936/
     33c:	8a eb       	ldi	r24, 0xBA	; 186
     33e:	91 e0       	ldi	r25, 0x01	; 1
     340:	ec 01       	movw	r28, r24
     342:	22 97       	sbiw	r28, 0x02	; 2
     344:	be 01       	movw	r22, r28
     346:	4e e0       	ldi	r20, 0x0E	; 14
     348:	50 e0       	ldi	r21, 0x00	; 0
     34a:	0e 94 5f 1f 	call	0x3ebe	; 0x3ebe <memmove>
	
	//add new note to pool
	note_pool[0].note = note;
     34e:	18 83       	st	Y, r17
	note_pool[0].velocity = velocity;
     350:	09 83       	std	Y+1, r16	; 0x01
	
	current_note = note; //set current note
     352:	10 93 b5 02 	sts	0x02B5, r17
	
} 
     356:	df 91       	pop	r29
     358:	cf 91       	pop	r28
     35a:	1f 91       	pop	r17
     35c:	0f 91       	pop	r16
     35e:	08 95       	ret

00000360 <remove_note>:
void remove_note(uint8_t note){
     360:	cf 93       	push	r28
	
	uint8_t free_slot = 0;
	uint8_t temp_note = note_pool[0].note; //holder for current note
     362:	c0 91 b8 01 	lds	r28, 0x01B8
	for (int i = 0; i <= 7; i++) { //search for note in note stack
		
		if (note_pool[i].note == note) {
     366:	c8 17       	cp	r28, r24
     368:	41 f0       	breq	.+16     	; 0x37a <remove_note+0x1a>
     36a:	ea eb       	ldi	r30, 0xBA	; 186
     36c:	f1 e0       	ldi	r31, 0x01	; 1
} 
void remove_note(uint8_t note){
	
	uint8_t free_slot = 0;
	uint8_t temp_note = note_pool[0].note; //holder for current note
	for (int i = 0; i <= 7; i++) { //search for note in note stack
     36e:	41 e0       	ldi	r20, 0x01	; 1
     370:	50 e0       	ldi	r21, 0x00	; 0
		
		if (note_pool[i].note == note) {
     372:	90 81       	ld	r25, Z
     374:	98 17       	cp	r25, r24
     376:	59 f4       	brne	.+22     	; 0x38e <remove_note+0x2e>
     378:	02 c0       	rjmp	.+4      	; 0x37e <remove_note+0x1e>
} 
void remove_note(uint8_t note){
	
	uint8_t free_slot = 0;
	uint8_t temp_note = note_pool[0].note; //holder for current note
	for (int i = 0; i <= 7; i++) { //search for note in note stack
     37a:	40 e0       	ldi	r20, 0x00	; 0
     37c:	50 e0       	ldi	r21, 0x00	; 0
		
		if (note_pool[i].note == note) {
			
			note_pool[i].note = EMPTY;
     37e:	fa 01       	movw	r30, r20
     380:	ee 0f       	add	r30, r30
     382:	ff 1f       	adc	r31, r31
     384:	e8 54       	subi	r30, 0x48	; 72
     386:	fe 4f       	sbci	r31, 0xFE	; 254
     388:	8f ef       	ldi	r24, 0xFF	; 255
     38a:	80 83       	st	Z, r24
			free_slot = i;
			break;
     38c:	07 c0       	rjmp	.+14     	; 0x39c <remove_note+0x3c>
} 
void remove_note(uint8_t note){
	
	uint8_t free_slot = 0;
	uint8_t temp_note = note_pool[0].note; //holder for current note
	for (int i = 0; i <= 7; i++) { //search for note in note stack
     38e:	4f 5f       	subi	r20, 0xFF	; 255
     390:	5f 4f       	sbci	r21, 0xFF	; 255
     392:	32 96       	adiw	r30, 0x02	; 2
     394:	48 30       	cpi	r20, 0x08	; 8
     396:	51 05       	cpc	r21, r1
     398:	61 f7       	brne	.-40     	; 0x372 <remove_note+0x12>
	current_note = note; //set current note
	
} 
void remove_note(uint8_t note){
	
	uint8_t free_slot = 0;
     39a:	40 e0       	ldi	r20, 0x00	; 0
		
	}
	
	
	//now shift elements left	
	memmove(note_pool + free_slot, note_pool + free_slot + 1, sizeof(note_pool) - (sizeof(*note_pool)*(free_slot + 1)));
     39c:	50 e0       	ldi	r21, 0x00	; 0
     39e:	ca 01       	movw	r24, r20
     3a0:	88 0f       	add	r24, r24
     3a2:	99 1f       	adc	r25, r25
     3a4:	bc 01       	movw	r22, r24
     3a6:	66 54       	subi	r22, 0x46	; 70
     3a8:	7e 4f       	sbci	r23, 0xFE	; 254
     3aa:	40 95       	com	r20
     3ac:	50 95       	com	r21
     3ae:	48 5f       	subi	r20, 0xF8	; 248
     3b0:	5f 4f       	sbci	r21, 0xFF	; 255
     3b2:	44 0f       	add	r20, r20
     3b4:	55 1f       	adc	r21, r21
     3b6:	88 54       	subi	r24, 0x48	; 72
     3b8:	9e 4f       	sbci	r25, 0xFE	; 254
     3ba:	0e 94 5f 1f 	call	0x3ebe	; 0x3ebe <memmove>
	note_pool[7].note = EMPTY;	
     3be:	8f ef       	ldi	r24, 0xFF	; 255
     3c0:	80 93 c6 01 	sts	0x01C6, r24
	
	//check to see if this is the last note released		
	//if it is, this might be a good place to ensure gate_buffer is empty
	if (note_pool[0].note == EMPTY) {
     3c4:	80 91 b8 01 	lds	r24, 0x01B8
     3c8:	8f 3f       	cpi	r24, 0xFF	; 255
     3ca:	19 f4       	brne	.+6      	; 0x3d2 <remove_note+0x72>
		
		current_note = temp_note; //store last note released for maintaining pitch during envelope release stage
     3cc:	c0 93 b5 02 	sts	0x02B5, r28
     3d0:	02 c0       	rjmp	.+4      	; 0x3d6 <remove_note+0x76>
		
	} else {		
		
		current_note = note_pool[0].note; //otherwise, the current note is the next one in the note stack
     3d2:	80 93 b5 02 	sts	0x02B5, r24

	}	
	
}
     3d6:	cf 91       	pop	r28
     3d8:	08 95       	ret

000003da <setup_system_clock>:
struct clock lfo_clock;

void setup_system_clock(void) {
	
	
	TCCR1B = (1<<CS10) | (1<<CS12) | (1<<WGM12);//TIMER1_DIVIDE_1024;
     3da:	8d e0       	ldi	r24, 0x0D	; 13
     3dc:	80 93 81 00 	sts	0x0081, r24
	TIMSK1 = (1<<OCIE1A);
     3e0:	82 e0       	ldi	r24, 0x02	; 2
     3e2:	80 93 6f 00 	sts	0x006F, r24
	
	
	
}
     3e6:	08 95       	ret

000003e8 <update_clock_rate>:

void update_clock_rate(uint16_t rate) {
	
	OCR1A = rate;
     3e8:	90 93 89 00 	sts	0x0089, r25
     3ec:	80 93 88 00 	sts	0x0088, r24
	if (TCNT1 > rate) TCNT1 = rate - 1; //this prevents wrapping. setting TCNT1 = rate would cause immediate interrupt. Is that OK?
     3f0:	20 91 84 00 	lds	r18, 0x0084
     3f4:	30 91 85 00 	lds	r19, 0x0085
     3f8:	82 17       	cp	r24, r18
     3fa:	93 07       	cpc	r25, r19
     3fc:	28 f4       	brcc	.+10     	; 0x408 <update_clock_rate+0x20>
     3fe:	01 97       	sbiw	r24, 0x01	; 1
     400:	90 93 85 00 	sts	0x0085, r25
     404:	80 93 84 00 	sts	0x0084, r24
     408:	08 95       	ret

0000040a <set_control_voltage>:
struct control_voltage sustain_2_cv		={SUSTAIN_2,	DAC_MUX_EN3};
struct control_voltage sustain_1_cv		={SUSTAIN_1,	DAC_MUX_EN3};
struct control_voltage release_2_cv		={RELEASE_2,	DAC_MUX_EN3};
struct control_voltage release_1_cv		={RELEASE_1,	DAC_MUX_EN3};		

void set_control_voltage (struct control_voltage * cv, uint16_t value) {
     40a:	dc 01       	movw	r26, r24

	DAC_BUS_LOW = value & 0b00000011111111; //mask top 6 MSBs to set low byte
     40c:	6b b9       	out	0x0b, r22	; 11
	
	DAC_BUS_HIGH = value >> 8; //shift away bottom LSBs to set high byte
     40e:	78 b9       	out	0x08, r23	; 8
	
	DAC_CTRL &= ~(1<<DAC_WR); //write DATA
     410:	a0 98       	cbi	0x14, 0	; 20
	DAC_CTRL |= (1<<DAC_WR);	
     412:	a0 9a       	sbi	0x14, 0	; 20

	DATA_BUS = cv->channel; //set channel for DG408 multiplexer output
     414:	8c 91       	ld	r24, X
     416:	87 70       	andi	r24, 0x07	; 7
     418:	82 b9       	out	0x02, r24	; 2
     41a:	66 e0       	ldi	r22, 0x06	; 6
     41c:	6a 95       	dec	r22
     41e:	f1 f7       	brne	.-4      	; 0x41c <set_control_voltage+0x12>
     420:	00 c0       	rjmp	.+0      	; 0x422 <set_control_voltage+0x18>

	_delay_us(1); //AD5556 DAC has 0.5 us settling time. 1 us wasn't long enough for transitions from 10V to 0V
	DAC_MUX |= (1<<cv->mux_addr); //enable multiplexer
     422:	ea ed       	ldi	r30, 0xDA	; 218
     424:	f0 e0       	ldi	r31, 0x00	; 0
     426:	40 81       	ld	r20, Z
     428:	8c 91       	ld	r24, X
     42a:	86 95       	lsr	r24
     42c:	86 95       	lsr	r24
     42e:	86 95       	lsr	r24
     430:	87 70       	andi	r24, 0x07	; 7
     432:	21 e0       	ldi	r18, 0x01	; 1
     434:	30 e0       	ldi	r19, 0x00	; 0
     436:	b9 01       	movw	r22, r18
     438:	02 c0       	rjmp	.+4      	; 0x43e <set_control_voltage+0x34>
     43a:	66 0f       	add	r22, r22
     43c:	77 1f       	adc	r23, r23
     43e:	8a 95       	dec	r24
     440:	e2 f7       	brpl	.-8      	; 0x43a <set_control_voltage+0x30>
     442:	cb 01       	movw	r24, r22
     444:	84 2b       	or	r24, r20
     446:	80 83       	st	Z, r24
     448:	76 e0       	ldi	r23, 0x06	; 6
     44a:	7a 95       	dec	r23
     44c:	f1 f7       	brne	.-4      	; 0x44a <set_control_voltage+0x40>
     44e:	00 c0       	rjmp	.+0      	; 0x450 <set_control_voltage+0x46>
	_delay_us(1); //wait for S&H cap to charge - need to figure out how to do this more time efficiently
	DAC_MUX &= ~(1<<cv->mux_addr); //disable multiplexer
     450:	80 81       	ld	r24, Z
     452:	9c 91       	ld	r25, X
     454:	96 95       	lsr	r25
     456:	96 95       	lsr	r25
     458:	96 95       	lsr	r25
     45a:	97 70       	andi	r25, 0x07	; 7
     45c:	02 c0       	rjmp	.+4      	; 0x462 <set_control_voltage+0x58>
     45e:	22 0f       	add	r18, r18
     460:	33 1f       	adc	r19, r19
     462:	9a 95       	dec	r25
     464:	e2 f7       	brpl	.-8      	; 0x45e <set_control_voltage+0x54>
     466:	20 95       	com	r18
     468:	28 23       	and	r18, r24
     46a:	20 83       	st	Z, r18
	
}	
     46c:	08 95       	ret

0000046e <setup_dac>:

	
void setup_dac(void) //set up DAC
{
	DDRG |= (1<<DAC_WR) | (1<<DAC_RS); //set DAC control bits as outputs
     46e:	83 b3       	in	r24, 0x13	; 19
     470:	83 60       	ori	r24, 0x03	; 3
     472:	83 bb       	out	0x13, r24	; 19
	DDRD = 0xFF; //set DAC_BUS_LOW bits to outputs
     474:	8f ef       	ldi	r24, 0xFF	; 255
     476:	8a b9       	out	0x0a, r24	; 10
	DDRC |= 0xFF;//set DAC_BUS_HIGH bits to outputs
     478:	97 b1       	in	r25, 0x07	; 7
     47a:	87 b9       	out	0x07, r24	; 7
	DDRH |= (1<<DAC_MUX_EN0) | (1<<DAC_MUX_EN1) | (1<<DAC_MUX_EN2) | (1<<DAC_MUX_EN3); //set DAC_MUX_EN pins as outputs
     47c:	e9 ed       	ldi	r30, 0xD9	; 217
     47e:	f0 e0       	ldi	r31, 0x00	; 0
     480:	80 81       	ld	r24, Z
     482:	8f 60       	ori	r24, 0x0F	; 15
     484:	80 83       	st	Z, r24
	
	DAC_MUX &= ~((1<<DAC_MUX_EN0) | (1<<DAC_MUX_EN1) | (1<<DAC_MUX_EN2) | (1<<DAC_MUX_EN3)); //disable DG408 VDAC multiplexers
     486:	ea ed       	ldi	r30, 0xDA	; 218
     488:	f0 e0       	ldi	r31, 0x00	; 0
     48a:	80 81       	ld	r24, Z
     48c:	80 7f       	andi	r24, 0xF0	; 240
     48e:	80 83       	st	Z, r24
	
	DAC_CTRL |= (1<<DAC_RS) | (1<<DAC_WR); //disable DAC
     490:	84 b3       	in	r24, 0x14	; 20
     492:	83 60       	ori	r24, 0x03	; 3
     494:	84 bb       	out	0x14, r24	; 20
	
	DAC_CTRL &= ~(1<<DAC_RS); //reset DAC
     496:	a1 98       	cbi	0x14, 1	; 20
	DAC_CTRL |= (1<<DAC_RS);
     498:	a1 9a       	sbi	0x14, 1	; 20
	
	DAC_CTRL &= ~(1<<DAC_WR); //write DATA - falling edge then rising edge to toggle DAC bits to output register
     49a:	a0 98       	cbi	0x14, 0	; 20
	DAC_CTRL |= (1<<DAC_WR);
     49c:	a0 9a       	sbi	0x14, 0	; 20
}
     49e:	08 95       	ret

000004a0 <display_dec>:
#include "synth.h"



void display_dec(uint16_t number, uint8_t place)
{
     4a0:	0f 93       	push	r16
     4a2:	1f 93       	push	r17
     4a4:	cf 93       	push	r28
     4a6:	df 93       	push	r29
     4a8:	cd b7       	in	r28, 0x3d	; 61
     4aa:	de b7       	in	r29, 0x3e	; 62
     4ac:	2e 97       	sbiw	r28, 0x0e	; 14
     4ae:	0f b6       	in	r0, 0x3f	; 63
     4b0:	f8 94       	cli
     4b2:	de bf       	out	0x3e, r29	; 62
     4b4:	0f be       	out	0x3f, r0	; 63
     4b6:	cd bf       	out	0x3d, r28	; 61
	
	uint8_t digit[] = {
     4b8:	28 e0       	ldi	r18, 0x08	; 8
     4ba:	29 83       	std	Y+1, r18	; 0x01
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 83       	std	Y+2, r18	; 0x02
     4c0:	22 e0       	ldi	r18, 0x02	; 2
     4c2:	2b 83       	std	Y+3, r18	; 0x03
     4c4:	24 e0       	ldi	r18, 0x04	; 4
     4c6:	2c 83       	std	Y+4, r18	; 0x04
		TENS,
		HUNDS,
		THOUS,
	};
	
	uint8_t dec[] = {
     4c8:	de 01       	movw	r26, r28
     4ca:	15 96       	adiw	r26, 0x05	; 5
     4cc:	e7 ee       	ldi	r30, 0xE7	; 231
     4ce:	f1 e0       	ldi	r31, 0x01	; 1
     4d0:	2a e0       	ldi	r18, 0x0A	; 10
     4d2:	01 90       	ld	r0, Z+
     4d4:	0d 92       	st	X+, r0
     4d6:	21 50       	subi	r18, 0x01	; 1
     4d8:	e1 f7       	brne	.-8      	; 0x4d2 <display_dec+0x32>
		
		
	};
	
	//clear cathode bits
	DATA_BUS = 0xFF; //set bits for cathode (current sinks, active LOW)
     4da:	2f ef       	ldi	r18, 0xFF	; 255
     4dc:	22 b9       	out	0x02, r18	; 2
	//latch data to cathode lines
	DISPLAY_PORT |= (1<<DISP_CATHODE_LATCH);
     4de:	ea ed       	ldi	r30, 0xDA	; 218
     4e0:	f0 e0       	ldi	r31, 0x00	; 0
     4e2:	20 81       	ld	r18, Z
     4e4:	20 61       	ori	r18, 0x10	; 16
     4e6:	20 83       	st	Z, r18
	DISPLAY_PORT &= ~(1<<DISP_CATHODE_LATCH);
     4e8:	20 81       	ld	r18, Z
     4ea:	2f 7e       	andi	r18, 0xEF	; 239
     4ec:	20 83       	st	Z, r18
	
	//set anode bit
	DATA_BUS = digit[place];
     4ee:	06 2f       	mov	r16, r22
     4f0:	10 e0       	ldi	r17, 0x00	; 0
     4f2:	de 01       	movw	r26, r28
     4f4:	a0 0f       	add	r26, r16
     4f6:	b1 1f       	adc	r27, r17
     4f8:	11 96       	adiw	r26, 0x01	; 1
     4fa:	2c 91       	ld	r18, X
     4fc:	11 97       	sbiw	r26, 0x01	; 1
     4fe:	22 b9       	out	0x02, r18	; 2
	//latch data to anode lines
	DISPLAY_PORT |= (1<<DISP_ANODE_LATCH);
     500:	20 81       	ld	r18, Z
     502:	20 62       	ori	r18, 0x20	; 32
     504:	20 83       	st	Z, r18
	DISPLAY_PORT &= ~(1<<DISP_ANODE_LATCH);
     506:	20 81       	ld	r18, Z
     508:	2f 7d       	andi	r18, 0xDF	; 223
     50a:	20 83       	st	Z, r18
     50c:	48 2f       	mov	r20, r24
     50e:	59 2f       	mov	r21, r25
     510:	87 e2       	ldi	r24, 0x27	; 39
     512:	40 31       	cpi	r20, 0x10	; 16
     514:	58 07       	cpc	r21, r24
     516:	10 f0       	brcs	.+4      	; 0x51c <display_dec+0x7c>
     518:	4f e0       	ldi	r20, 0x0F	; 15
     51a:	57 e2       	ldi	r21, 0x27	; 39
	if (number > 9999) {
		number = 9999;
		}
	
	/* First division by 10 */
	q1 = (number >> 1) + (number >> 2);
     51c:	ca 01       	movw	r24, r20
     51e:	96 95       	lsr	r25
     520:	87 95       	ror	r24
     522:	96 95       	lsr	r25
     524:	87 95       	ror	r24
     526:	9a 01       	movw	r18, r20
     528:	36 95       	lsr	r19
     52a:	27 95       	ror	r18
     52c:	28 0f       	add	r18, r24
     52e:	39 1f       	adc	r19, r25
	q1 += q1 >> 4;
     530:	c9 01       	movw	r24, r18
     532:	92 95       	swap	r25
     534:	82 95       	swap	r24
     536:	8f 70       	andi	r24, 0x0F	; 15
     538:	89 27       	eor	r24, r25
     53a:	9f 70       	andi	r25, 0x0F	; 15
     53c:	89 27       	eor	r24, r25
     53e:	82 0f       	add	r24, r18
     540:	93 1f       	adc	r25, r19
	q1 += q1 >> 8;
     542:	29 2f       	mov	r18, r25
     544:	33 27       	eor	r19, r19
     546:	82 0f       	add	r24, r18
     548:	93 1f       	adc	r25, r19
	q2 = q1 >> 3;
     54a:	96 95       	lsr	r25
     54c:	87 95       	ror	r24
     54e:	96 95       	lsr	r25
     550:	87 95       	ror	r24
     552:	96 95       	lsr	r25
     554:	87 95       	ror	r24
	r = number - q2 * 10;
     556:	28 2f       	mov	r18, r24
     558:	22 0f       	add	r18, r18
     55a:	32 2f       	mov	r19, r18
     55c:	33 0f       	add	r19, r19
     55e:	33 0f       	add	r19, r19
     560:	23 0f       	add	r18, r19
     562:	e4 2f       	mov	r30, r20
     564:	e2 1b       	sub	r30, r18
	//r = number - (((q2 << 2) + q2) << 1);
	qa = q2 + (r > 9);
     566:	61 e0       	ldi	r22, 0x01	; 1
     568:	70 e0       	ldi	r23, 0x00	; 0
     56a:	ea 30       	cpi	r30, 0x0A	; 10
     56c:	10 f4       	brcc	.+4      	; 0x572 <display_dec+0xd2>
     56e:	60 e0       	ldi	r22, 0x00	; 0
     570:	70 e0       	ldi	r23, 0x00	; 0
     572:	68 0f       	add	r22, r24
     574:	79 1f       	adc	r23, r25
	ones_place = rem[r];

	/* second division by 10 */

	q2 = (qa >> 1) + (qa >> 2);
     576:	9b 01       	movw	r18, r22
     578:	36 95       	lsr	r19
     57a:	27 95       	ror	r18
     57c:	36 95       	lsr	r19
     57e:	27 95       	ror	r18
     580:	ab 01       	movw	r20, r22
     582:	56 95       	lsr	r21
     584:	47 95       	ror	r20
     586:	24 0f       	add	r18, r20
     588:	35 1f       	adc	r19, r21
	q2 += q2 >> 4;
     58a:	c9 01       	movw	r24, r18
     58c:	92 95       	swap	r25
     58e:	82 95       	swap	r24
     590:	8f 70       	andi	r24, 0x0F	; 15
     592:	89 27       	eor	r24, r25
     594:	9f 70       	andi	r25, 0x0F	; 15
     596:	89 27       	eor	r24, r25
     598:	82 0f       	add	r24, r18
     59a:	93 1f       	adc	r25, r19
	q2 += q2 >> 8;
     59c:	29 2f       	mov	r18, r25
     59e:	33 27       	eor	r19, r19
     5a0:	82 0f       	add	r24, r18
     5a2:	93 1f       	adc	r25, r19
	q3 = q2 >> 3;
     5a4:	96 95       	lsr	r25
     5a6:	87 95       	ror	r24
     5a8:	96 95       	lsr	r25
     5aa:	87 95       	ror	r24
     5ac:	96 95       	lsr	r25
     5ae:	87 95       	ror	r24
	r = qa - q3 * 10;
     5b0:	98 2f       	mov	r25, r24
     5b2:	99 0f       	add	r25, r25
     5b4:	29 2f       	mov	r18, r25
     5b6:	22 0f       	add	r18, r18
     5b8:	22 0f       	add	r18, r18
     5ba:	92 0f       	add	r25, r18
     5bc:	69 1b       	sub	r22, r25
	qb = q3 + (r > 9);
     5be:	91 e0       	ldi	r25, 0x01	; 1
     5c0:	6a 30       	cpi	r22, 0x0A	; 10
     5c2:	08 f4       	brcc	.+2      	; 0x5c6 <display_dec+0x126>
     5c4:	90 e0       	ldi	r25, 0x00	; 0
     5c6:	89 0f       	add	r24, r25
	tens_place = rem[r];
     5c8:	41 ef       	ldi	r20, 0xF1	; 241
     5ca:	51 e0       	ldi	r21, 0x01	; 1
     5cc:	da 01       	movw	r26, r20
     5ce:	a6 0f       	add	r26, r22
     5d0:	b1 1d       	adc	r27, r1
     5d2:	3c 91       	ld	r19, X

	/* third division by 10 */

	q4 = (qb >> 1) + (qb >> 2);
     5d4:	28 2f       	mov	r18, r24
     5d6:	26 95       	lsr	r18
     5d8:	26 95       	lsr	r18
     5da:	98 2f       	mov	r25, r24
     5dc:	96 95       	lsr	r25
     5de:	92 0f       	add	r25, r18
	q4 += q4 >> 4;
     5e0:	29 2f       	mov	r18, r25
     5e2:	22 95       	swap	r18
     5e4:	2f 70       	andi	r18, 0x0F	; 15
     5e6:	92 0f       	add	r25, r18
	q4 = q4 >> 3;
     5e8:	96 95       	lsr	r25
     5ea:	96 95       	lsr	r25
     5ec:	96 95       	lsr	r25
	r = qb - q4 * 10;
     5ee:	29 2f       	mov	r18, r25
     5f0:	22 0f       	add	r18, r18
     5f2:	62 2f       	mov	r22, r18
     5f4:	66 0f       	add	r22, r22
     5f6:	66 0f       	add	r22, r22
     5f8:	26 0f       	add	r18, r22
     5fa:	82 1b       	sub	r24, r18
	thous_place = q4 + (r > 9);
	hunds_place = rem[r];
     5fc:	da 01       	movw	r26, r20
     5fe:	a8 0f       	add	r26, r24
     600:	b1 1d       	adc	r27, r1
     602:	2c 91       	ld	r18, X
	q1 += q1 >> 8;
	q2 = q1 >> 3;
	r = number - q2 * 10;
	//r = number - (((q2 << 2) + q2) << 1);
	qa = q2 + (r > 9);
	ones_place = rem[r];
     604:	4e 0f       	add	r20, r30
     606:	51 1d       	adc	r21, r1
	q4 = q4 >> 3;
	r = qb - q4 * 10;
	thous_place = q4 + (r > 9);
	hunds_place = rem[r];

	digit_index[0] = ones_place;
     608:	fa 01       	movw	r30, r20
     60a:	40 81       	ld	r20, Z
     60c:	40 93 b8 02 	sts	0x02B8, r20
	digit_index[1] = tens_place;
     610:	30 93 b9 02 	sts	0x02B9, r19
	digit_index[2] = hunds_place;
     614:	20 93 ba 02 	sts	0x02BA, r18

	q4 = (qb >> 1) + (qb >> 2);
	q4 += q4 >> 4;
	q4 = q4 >> 3;
	r = qb - q4 * 10;
	thous_place = q4 + (r > 9);
     618:	21 e0       	ldi	r18, 0x01	; 1
     61a:	8a 30       	cpi	r24, 0x0A	; 10
     61c:	08 f4       	brcc	.+2      	; 0x620 <display_dec+0x180>
     61e:	20 e0       	ldi	r18, 0x00	; 0
     620:	92 0f       	add	r25, r18
	hunds_place = rem[r];

	digit_index[0] = ones_place;
	digit_index[1] = tens_place;
	digit_index[2] = hunds_place;
	digit_index[3] = thous_place;
     622:	90 93 bb 02 	sts	0x02BB, r25

	cathode_byte = dec[digit_index[place]];
     626:	f8 01       	movw	r30, r16
     628:	e8 54       	subi	r30, 0x48	; 72
     62a:	fd 4f       	sbci	r31, 0xFD	; 253
     62c:	80 81       	ld	r24, Z
     62e:	fe 01       	movw	r30, r28
     630:	e8 0f       	add	r30, r24
     632:	f1 1d       	adc	r31, r1
     634:	85 81       	ldd	r24, Z+5	; 0x05
	
	if (current_patch.mode == EDIT) cathode_byte |= dp;
     636:	90 91 0b 03 	lds	r25, 0x030B
     63a:	92 30       	cpi	r25, 0x02	; 2
     63c:	11 f4       	brne	.+4      	; 0x642 <display_dec+0x1a2>
     63e:	80 62       	ori	r24, 0x20	; 32
     640:	03 c0       	rjmp	.+6      	; 0x648 <display_dec+0x1a8>
	if (current_patch.mode == MANUAL) cathode_byte = g; //Roland style dash for MANUAL mode. Could move this to the top as manual mode precludes the need to parse digit
     642:	91 30       	cpi	r25, 0x01	; 1
     644:	09 f4       	brne	.+2      	; 0x648 <display_dec+0x1a8>
     646:	88 e0       	ldi	r24, 0x08	; 8
	
	
	//set cathode byte
	DATA_BUS = ~(cathode_byte); //set bits for cathode (current sinks, active LOW)
     648:	80 95       	com	r24
     64a:	82 b9       	out	0x02, r24	; 2
	//latch data to cathode lines
	DISPLAY_PORT |= (1<<DISP_CATHODE_LATCH);
     64c:	ea ed       	ldi	r30, 0xDA	; 218
     64e:	f0 e0       	ldi	r31, 0x00	; 0
     650:	80 81       	ld	r24, Z
     652:	80 61       	ori	r24, 0x10	; 16
     654:	80 83       	st	Z, r24
	DISPLAY_PORT &= ~(1<<DISP_CATHODE_LATCH);
     656:	80 81       	ld	r24, Z
     658:	8f 7e       	andi	r24, 0xEF	; 239
     65a:	80 83       	st	Z, r24
	
	//DATA_BUS = 0; //clear DATA_BUS before return
}
     65c:	2e 96       	adiw	r28, 0x0e	; 14
     65e:	0f b6       	in	r0, 0x3f	; 63
     660:	f8 94       	cli
     662:	de bf       	out	0x3e, r29	; 62
     664:	0f be       	out	0x3f, r0	; 63
     666:	cd bf       	out	0x3d, r28	; 61
     668:	df 91       	pop	r29
     66a:	cf 91       	pop	r28
     66c:	1f 91       	pop	r17
     66e:	0f 91       	pop	r16
     670:	08 95       	ret

00000672 <update_display>:

void update_display(uint16_t number, uint8_t type) {
     672:	cf 93       	push	r28
	
	static uint8_t place = 0;
	

	
	if (type == DEC) {
     674:	66 23       	and	r22, r22
     676:	69 f4       	brne	.+26     	; 0x692 <update_display+0x20>

		
			
		display_dec(number, place);
     678:	c0 91 bc 02 	lds	r28, 0x02BC
     67c:	6c 2f       	mov	r22, r28
     67e:	0e 94 50 02 	call	0x4a0	; 0x4a0 <display_dec>
		//increment digit display place
		if (place++ == 3) //post increment
     682:	8c 2f       	mov	r24, r28
     684:	8f 5f       	subi	r24, 0xFF	; 255
     686:	80 93 bc 02 	sts	0x02BC, r24
     68a:	c3 30       	cpi	r28, 0x03	; 3
     68c:	11 f4       	brne	.+4      	; 0x692 <update_display+0x20>
		{
			place = 0;
     68e:	10 92 bc 02 	sts	0x02BC, r1
		
		
	}
	
	
     692:	cf 91       	pop	r28
     694:	08 95       	ret

00000696 <__vector_10>:
#include "display.h"
#include "clock.h"
#include "assigner.h"
#include "arp.h"

ISR (TIMER0_COMP_vect) { //timer 0 output compare interrupt for tuning
     696:	1f 92       	push	r1
     698:	0f 92       	push	r0
     69a:	0f b6       	in	r0, 0x3f	; 63
     69c:	0f 92       	push	r0
     69e:	11 24       	eor	r1, r1
     6a0:	8f 93       	push	r24
     6a2:	9f 93       	push	r25
     6a4:	ef 93       	push	r30
     6a6:	ff 93       	push	r31
	
	OCR0A = period-1; //OCR0A counts n-1 periods - see comment in tune.c about setting OCR0A
     6a8:	80 91 80 03 	lds	r24, 0x0380
     6ac:	81 50       	subi	r24, 0x01	; 1
     6ae:	87 bd       	out	0x27, r24	; 39
	//PORTB ^= (1<<ARP_SYNC_LED); //toggle arp ARP_SYNC LED
	if (period_counter == 0) {
     6b0:	80 91 81 03 	lds	r24, 0x0381
     6b4:	88 23       	and	r24, r24
     6b6:	a1 f4       	brne	.+40     	; 0x6e0 <__vector_10+0x4a>
		count_finished = FALSE;
     6b8:	10 92 7e 03 	sts	0x037E, r1
		no_overflow = TRUE;
     6bc:	81 e0       	ldi	r24, 0x01	; 1
     6be:	80 93 af 02 	sts	0x02AF, r24
		period_counter = 1; //set period counter to 1
     6c2:	80 93 81 03 	sts	0x0381, r24
		//set up 16 bit timer/counter1		
		TCCR1B |= timer1_clock; //clock /64 to run at 312.5 KHz or /8 to run at 2.5 MHz, dependent on note frequency being measured
     6c6:	e1 e8       	ldi	r30, 0x81	; 129
     6c8:	f0 e0       	ldi	r31, 0x00	; 0
     6ca:	80 81       	ld	r24, Z
     6cc:	90 91 7f 03 	lds	r25, 0x037F
     6d0:	89 2b       	or	r24, r25
     6d2:	80 83       	st	Z, r24
		TIMSK1 |= (1<<TOIE1); //enable timer1 overflow interrupt
     6d4:	ef e6       	ldi	r30, 0x6F	; 111
     6d6:	f0 e0       	ldi	r31, 0x00	; 0
     6d8:	80 81       	ld	r24, Z
     6da:	81 60       	ori	r24, 0x01	; 1
     6dc:	80 83       	st	Z, r24
     6de:	11 c0       	rjmp	.+34     	; 0x702 <__vector_10+0x6c>
		
	} else {
		
		osc_count = TCNT1;		
     6e0:	e4 e8       	ldi	r30, 0x84	; 132
     6e2:	f0 e0       	ldi	r31, 0x00	; 0
     6e4:	80 81       	ld	r24, Z
     6e6:	91 81       	ldd	r25, Z+1	; 0x01
     6e8:	90 93 7d 03 	sts	0x037D, r25
     6ec:	80 93 7c 03 	sts	0x037C, r24
		TCCR1B = 0; //turn off 16 bit timer/counter1
     6f0:	10 92 81 00 	sts	0x0081, r1
		count_finished = TRUE;
     6f4:	81 e0       	ldi	r24, 0x01	; 1
     6f6:	80 93 7e 03 	sts	0x037E, r24
		period_counter = 0;
     6fa:	10 92 81 03 	sts	0x0381, r1
		TCNT1 = 0; //reset timer/counter 1
     6fe:	11 82       	std	Z+1, r1	; 0x01
     700:	10 82       	st	Z, r1
	}
	
	
	
	
}
     702:	ff 91       	pop	r31
     704:	ef 91       	pop	r30
     706:	9f 91       	pop	r25
     708:	8f 91       	pop	r24
     70a:	0f 90       	pop	r0
     70c:	0f be       	out	0x3f, r0	; 63
     70e:	0f 90       	pop	r0
     710:	1f 90       	pop	r1
     712:	18 95       	reti

00000714 <__vector_9>:



ISR (TIMER1_OVF_vect) {
     714:	1f 92       	push	r1
     716:	0f 92       	push	r0
     718:	0f b6       	in	r0, 0x3f	; 63
     71a:	0f 92       	push	r0
     71c:	11 24       	eor	r1, r1
	
	//during frequency counting, if timer1 overflow occurs set overflow flag
	no_overflow = FALSE;
     71e:	10 92 af 02 	sts	0x02AF, r1
	//PORTB ^= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED
	
}
     722:	0f 90       	pop	r0
     724:	0f be       	out	0x3f, r0	; 63
     726:	0f 90       	pop	r0
     728:	1f 90       	pop	r1
     72a:	18 95       	reti

0000072c <__vector_7>:

ISR (TIMER1_COMPA_vect) { //output compare match for master clock
     72c:	1f 92       	push	r1
     72e:	0f 92       	push	r0
     730:	0f b6       	in	r0, 0x3f	; 63
     732:	0f 92       	push	r0
     734:	11 24       	eor	r1, r1
     736:	2f 93       	push	r18
     738:	3f 93       	push	r19
     73a:	4f 93       	push	r20
     73c:	5f 93       	push	r21
     73e:	6f 93       	push	r22
     740:	7f 93       	push	r23
     742:	8f 93       	push	r24
     744:	9f 93       	push	r25
     746:	af 93       	push	r26
     748:	bf 93       	push	r27
     74a:	ef 93       	push	r30
     74c:	ff 93       	push	r31
	//PORTB ^= (1<<ARP_SYNC_LED);
	
	if (system_clock.ppqn_counter == system_clock.divider >> 1) { //50% gate width
     74e:	80 91 d8 03 	lds	r24, 0x03D8
     752:	86 95       	lsr	r24
     754:	90 91 d9 03 	lds	r25, 0x03D9
     758:	98 17       	cp	r25, r24
     75a:	51 f4       	brne	.+20     	; 0x770 <__vector_7+0x44>
				
		
		if ((arp.clock_source == INTERNAL_CLOCK) && (arp.mode)) {
     75c:	80 91 96 03 	lds	r24, 0x0396
     760:	81 30       	cpi	r24, 0x01	; 1
     762:	31 f4       	brne	.+12     	; 0x770 <__vector_7+0x44>
     764:	80 91 97 03 	lds	r24, 0x0397
     768:	88 23       	and	r24, r24
     76a:	11 f0       	breq	.+4      	; 0x770 <__vector_7+0x44>
			
			PORTF &= ~(1<<GATE); //if arp is running, turn gate off
     76c:	89 98       	cbi	0x11, 1	; 17
			PORTB &= ~ (1<<ARP_SYNC_LED); //turn off arp sync LED
     76e:	2f 98       	cbi	0x05, 7	; 5
			
		}
	}			
		
	if (++system_clock.ppqn_counter == system_clock.divider) {
     770:	80 91 d9 03 	lds	r24, 0x03D9
     774:	8f 5f       	subi	r24, 0xFF	; 255
     776:	80 93 d9 03 	sts	0x03D9, r24
     77a:	90 91 d8 03 	lds	r25, 0x03D8
     77e:	89 17       	cp	r24, r25
     780:	91 f4       	brne	.+36     	; 0x7a6 <__vector_7+0x7a>
		
		system_clock.ppqn_counter = 0;
     782:	10 92 d9 03 	sts	0x03D9, r1
		
		if ((arp.clock_source == INTERNAL_CLOCK) && (arp.mode)) {
     786:	80 91 96 03 	lds	r24, 0x0396
     78a:	81 30       	cpi	r24, 0x01	; 1
     78c:	61 f4       	brne	.+24     	; 0x7a6 <__vector_7+0x7a>
     78e:	80 91 97 03 	lds	r24, 0x0397
     792:	88 23       	and	r24, r24
     794:	41 f0       	breq	.+16     	; 0x7a6 <__vector_7+0x7a>
			
			//step arp note here based on range and note sequence from assigner	
			
			if (gate_buffer) { //if there are still notes in gate buffer
     796:	80 91 b4 02 	lds	r24, 0x02B4
     79a:	88 23       	and	r24, r24
     79c:	21 f0       	breq	.+8      	; 0x7a6 <__vector_7+0x7a>
				step_arp_note(); //will need to force inline this function. It will need to be used elsewhere for arp MIDI sync.
     79e:	0e 94 36 01 	call	0x26c	; 0x26c <step_arp_note>
				PORTF |= (1<<GATE);
     7a2:	89 9a       	sbi	0x11, 1	; 17
				PORTB |= (1<<ARP_SYNC_LED);
     7a4:	2f 9a       	sbi	0x05, 7	; 5
			} 
		}			
	}
	
     7a6:	ff 91       	pop	r31
     7a8:	ef 91       	pop	r30
     7aa:	bf 91       	pop	r27
     7ac:	af 91       	pop	r26
     7ae:	9f 91       	pop	r25
     7b0:	8f 91       	pop	r24
     7b2:	7f 91       	pop	r23
     7b4:	6f 91       	pop	r22
     7b6:	5f 91       	pop	r21
     7b8:	4f 91       	pop	r20
     7ba:	3f 91       	pop	r19
     7bc:	2f 91       	pop	r18
     7be:	0f 90       	pop	r0
     7c0:	0f be       	out	0x3f, r0	; 63
     7c2:	0f 90       	pop	r0
     7c4:	1f 90       	pop	r1
     7c6:	18 95       	reti

000007c8 <song_position_event>:
uint8_t switch_timer = 0;


void song_position_event(MidiDevice * device, uint8_t byte0, uint8_t byte1, uint8_t byte2) {
	
	arp.display = 42;
     7c8:	8a e2       	ldi	r24, 0x2A	; 42
     7ca:	80 93 95 03 	sts	0x0395, r24
	
}
     7ce:	08 95       	ret

000007d0 <real_time_event>:
}

void real_time_event(MidiDevice * device, uint8_t real_time_byte) {
	//PORTB ^= (1<<ARP_SYNC_LED);
	//if (~(current_patch.byte_2 & (1<<LFO_KEY_SYNC) >> 1)) return; //if not in a sync mode, then retrun
	switch (real_time_byte) {
     7d0:	6a 3f       	cpi	r22, 0xFA	; 250
     7d2:	09 f4       	brne	.+2      	; 0x7d6 <real_time_event+0x6>
     7d4:	5b c0       	rjmp	.+182    	; 0x88c <real_time_event+0xbc>
     7d6:	6c 3f       	cpi	r22, 0xFC	; 252
     7d8:	09 f4       	brne	.+2      	; 0x7dc <real_time_event+0xc>
     7da:	71 c0       	rjmp	.+226    	; 0x8be <real_time_event+0xee>
     7dc:	68 3f       	cpi	r22, 0xF8	; 248
     7de:	09 f0       	breq	.+2      	; 0x7e2 <real_time_event+0x12>
     7e0:	71 c0       	rjmp	.+226    	; 0x8c4 <real_time_event+0xf4>
		
		case MIDI_CLOCK:
		
			if (++midi_clock.ppqn_counter == midi_clock.divider) { //can be used for analog LFO reset and eventually for software LFO
     7e2:	80 91 e5 03 	lds	r24, 0x03E5
     7e6:	8f 5f       	subi	r24, 0xFF	; 255
     7e8:	80 93 e5 03 	sts	0x03E5, r24
     7ec:	90 91 e4 03 	lds	r25, 0x03E4
     7f0:	89 17       	cp	r24, r25
     7f2:	11 f4       	brne	.+4      	; 0x7f8 <real_time_event+0x28>
				
				//++arp.song_position;
				midi_clock.ppqn_counter = 0;
     7f4:	10 92 e5 03 	sts	0x03E5, r1
				//arp.display = arp.song_position;
			}						
			++arp.song_position;
     7f8:	80 91 91 03 	lds	r24, 0x0391
     7fc:	90 91 92 03 	lds	r25, 0x0392
     800:	a0 91 93 03 	lds	r26, 0x0393
     804:	b0 91 94 03 	lds	r27, 0x0394
     808:	01 96       	adiw	r24, 0x01	; 1
     80a:	a1 1d       	adc	r26, r1
     80c:	b1 1d       	adc	r27, r1
     80e:	80 93 91 03 	sts	0x0391, r24
     812:	90 93 92 03 	sts	0x0392, r25
     816:	a0 93 93 03 	sts	0x0393, r26
     81a:	b0 93 94 03 	sts	0x0394, r27
			if (++lfo_clock.ppqn_counter == lfo_clock.divider) {
     81e:	80 91 df 03 	lds	r24, 0x03DF
     822:	8f 5f       	subi	r24, 0xFF	; 255
     824:	80 93 df 03 	sts	0x03DF, r24
     828:	90 91 de 03 	lds	r25, 0x03DE
     82c:	89 17       	cp	r24, r25
     82e:	21 f4       	brne	.+8      	; 0x838 <real_time_event+0x68>
				PORTB |= (1<< LFO_RESET);
     830:	2c 9a       	sbi	0x05, 4	; 5
				//_delay_us(1); //what is minimum pulse width required for LFO reset? Will need to implement this with some other kind of delay OR OR OR - maybe a RC network to provide minimum pulse width for LFO reset????
				
				//PORTB ^= (1<<ARP_SYNC_LED);
				//register clock event - this will do something  - reset LFO or initiate LFO
				lfo_clock.ppqn_counter = 0; //reset MIDI ppqn clock	
     832:	10 92 df 03 	sts	0x03DF, r1
				PORTB &= ~(1<< LFO_RESET); //turn off LFO reset pin
     836:	2c 98       	cbi	0x05, 4	; 5
			}
			
			if (arp.mode) { //if arp is running
     838:	80 91 97 03 	lds	r24, 0x0397
     83c:	88 23       	and	r24, r24
     83e:	09 f4       	brne	.+2      	; 0x842 <real_time_event+0x72>
     840:	41 c0       	rjmp	.+130    	; 0x8c4 <real_time_event+0xf4>
				
				//arp.ppqn_counter++;
			
				if (arp.ppqn_counter == arp.divider) {
     842:	90 91 8e 03 	lds	r25, 0x038E
     846:	80 91 8f 03 	lds	r24, 0x038F
     84a:	98 17       	cp	r25, r24
     84c:	51 f4       	brne	.+20     	; 0x862 <real_time_event+0x92>
				
				
					arp.ppqn_counter = 0;
     84e:	10 92 8e 03 	sts	0x038E, r1
					if (gate_buffer) { //if there are still notes in gate buffer
     852:	80 91 b4 02 	lds	r24, 0x02B4
     856:	88 23       	and	r24, r24
     858:	21 f0       	breq	.+8      	; 0x862 <real_time_event+0x92>
						
						step_arp_note(); //should force inline this function.
     85a:	0e 94 36 01 	call	0x26c	; 0x26c <step_arp_note>
						PORTF |= (1<<GATE);  
     85e:	89 9a       	sbi	0x11, 1	; 17
						PORTB |= (1<<ARP_SYNC_LED);
     860:	2f 9a       	sbi	0x05, 7	; 5
					}	
				
				}
				
				if (arp.ppqn_counter == arp.divider - (arp.divider >> 1)) { //50% gate width
     862:	40 91 8f 03 	lds	r20, 0x038F
     866:	20 91 8e 03 	lds	r18, 0x038E
     86a:	30 e0       	ldi	r19, 0x00	; 0
     86c:	84 2f       	mov	r24, r20
     86e:	90 e0       	ldi	r25, 0x00	; 0
     870:	46 95       	lsr	r20
     872:	84 1b       	sub	r24, r20
     874:	91 09       	sbc	r25, r1
     876:	28 17       	cp	r18, r24
     878:	39 07       	cpc	r19, r25
     87a:	11 f4       	brne	.+4      	; 0x880 <real_time_event+0xb0>
								
					PORTF &= ~(1<<GATE);
     87c:	89 98       	cbi	0x11, 1	; 17
					PORTB &= ~ (1<<ARP_SYNC_LED); //turn off arp sync LED
     87e:	2f 98       	cbi	0x05, 7	; 5
								
				}
				arp.ppqn_counter++; //post increment means ppqn_counter is never 0, lowest is 1. Does this make sense for counting from 1 to arp.divide?
     880:	80 91 8e 03 	lds	r24, 0x038E
     884:	8f 5f       	subi	r24, 0xFF	; 255
     886:	80 93 8e 03 	sts	0x038E, r24
     88a:	08 95       	ret
			
			break;
			
		case MIDI_START:
			
			lfo_clock.ppqn_counter = 0;
     88c:	10 92 df 03 	sts	0x03DF, r1
			midi_clock.ppqn_counter = 0;
     890:	10 92 e5 03 	sts	0x03E5, r1
			arp.ppqn_counter = arp.divider - arp.ppqn_shift; //trigger arp step on next MIDI clock tick. This ppqn_shift of -1 here is key to getting note on events that occur simultaneously with divided clock events
     894:	80 91 8f 03 	lds	r24, 0x038F
     898:	90 91 90 03 	lds	r25, 0x0390
     89c:	89 1b       	sub	r24, r25
     89e:	80 93 8e 03 	sts	0x038E, r24
			arp.clock_source = MIDI_CLOCK;
     8a2:	88 ef       	ldi	r24, 0xF8	; 248
     8a4:	80 93 96 03 	sts	0x0396, r24
			arp.step_position = 0; 
     8a8:	10 92 8a 03 	sts	0x038A, r1
			arp.song_position = 0; //reset master song position counter
     8ac:	10 92 91 03 	sts	0x0391, r1
     8b0:	10 92 92 03 	sts	0x0392, r1
     8b4:	10 92 93 03 	sts	0x0393, r1
     8b8:	10 92 94 03 	sts	0x0394, r1
			break;
     8bc:	08 95       	ret
			
		case MIDI_STOP:
		
			arp.clock_source = INTERNAL_CLOCK; //revert to internal clock when MIDI STOP message received
     8be:	81 e0       	ldi	r24, 0x01	; 1
     8c0:	80 93 96 03 	sts	0x0396, r24
     8c4:	08 95       	ret

000008c6 <note_off_event>:
		}		
	}
	//PORTB &= ~(1<< LFO_RESET);
	
}
void note_off_event(MidiDevice * device, uint8_t status, uint8_t note, uint8_t velocity) {
     8c6:	84 2f       	mov	r24, r20
	
	remove_note(note);
     8c8:	0e 94 b0 01 	call	0x360	; 0x360 <remove_note>
	gate_buffer--;
     8cc:	80 91 b4 02 	lds	r24, 0x02B4
     8d0:	81 50       	subi	r24, 0x01	; 1
     8d2:	80 93 b4 02 	sts	0x02B4, r24
	//
	if (arp.mode) {	//if arp on, update arp sequence
     8d6:	90 91 97 03 	lds	r25, 0x0397
     8da:	99 23       	and	r25, r25
     8dc:	71 f0       	breq	.+28     	; 0x8fa <note_off_event+0x34>
		//gate_buffer--;
		if (gate_buffer == 0) {
     8de:	88 23       	and	r24, r24
     8e0:	49 f4       	brne	.+18     	; 0x8f4 <note_off_event+0x2e>
			arp.current_note = arp.previous_note; //handle last note prevservation for release phase
     8e2:	80 91 8c 03 	lds	r24, 0x038C
     8e6:	80 93 8d 03 	sts	0x038D, r24
			//if (arp.clock_source == INTERNAL_CLOCK) arp.step_position = 0; //if arp is synced to MIDI clock, then step position is reset when MIDI START message received
			arp.step_position = 0;
     8ea:	10 92 8a 03 	sts	0x038A, r1
			arp.direction = UP; //this is to initialize UP/DOWN mode
     8ee:	81 e0       	ldi	r24, 0x01	; 1
     8f0:	80 93 8b 03 	sts	0x038B, r24
		}			
		update_arp_sequence();
     8f4:	0e 94 a3 00 	call	0x146	; 0x146 <update_arp_sequence>
     8f8:	08 95       	ret
	} else {
		
		//update_arp_sequence();
		if (gate_buffer == 0) PORTF &= ~(1<<GATE);
     8fa:	88 23       	and	r24, r24
     8fc:	09 f4       	brne	.+2      	; 0x900 <note_off_event+0x3a>
     8fe:	89 98       	cbi	0x11, 1	; 17
     900:	08 95       	ret

00000902 <note_on_event>:
	
}



void note_on_event(MidiDevice * device, uint8_t status, uint8_t note, uint8_t velocity) {
     902:	84 2f       	mov	r24, r20
	
	if ((current_patch.byte_2 >> LFO_KEY_SYNC) & 1) {
     904:	90 91 03 03 	lds	r25, 0x0303
     908:	90 ff       	sbrs	r25, 0
     90a:	06 c0       	rjmp	.+12     	; 0x918 <note_on_event+0x16>
		
		PORTB |= (1<< LFO_RESET);
     90c:	2c 9a       	sbi	0x05, 4	; 5
     90e:	96 e0       	ldi	r25, 0x06	; 6
     910:	9a 95       	dec	r25
     912:	f1 f7       	brne	.-4      	; 0x910 <note_on_event+0xe>
     914:	00 c0       	rjmp	.+0      	; 0x916 <note_on_event+0x14>
		_delay_us(1); //what is minimum pulse width required for LFO reset?
		PORTB &= ~(1<< LFO_RESET);
     916:	2c 98       	cbi	0x05, 4	; 5
			
	}		
	
	midi_note_number = note;
     918:	80 93 be 02 	sts	0x02BE, r24
	if (velocity == 0) { //if velocity is 0 then it is a note off event - just call note off function rather than duplicate code here. arp will need to handle this too
     91c:	22 23       	and	r18, r18
     91e:	59 f4       	brne	.+22     	; 0x936 <note_on_event+0x34>
		remove_note(note);
     920:	0e 94 b0 01 	call	0x360	; 0x360 <remove_note>
		gate_buffer--;
     924:	80 91 b4 02 	lds	r24, 0x02B4
     928:	81 50       	subi	r24, 0x01	; 1
     92a:	80 93 b4 02 	sts	0x02B4, r24
		if (gate_buffer == 0) PORTF &= ~(1<<GATE);
     92e:	88 23       	and	r24, r24
     930:	91 f4       	brne	.+36     	; 0x956 <note_on_event+0x54>
     932:	89 98       	cbi	0x11, 1	; 17
     934:	08 95       	ret
				
	} else {
		
		new_note(note, velocity);  
     936:	62 2f       	mov	r22, r18
     938:	0e 94 98 01 	call	0x330	; 0x330 <new_note>
		
		gate_buffer++;
     93c:	80 91 b4 02 	lds	r24, 0x02B4
     940:	8f 5f       	subi	r24, 0xFF	; 255
     942:	80 93 b4 02 	sts	0x02B4, r24
		if (arp.mode) { //if arp is off, handle gate
     946:	80 91 97 03 	lds	r24, 0x0397
     94a:	88 23       	and	r24, r24
     94c:	19 f0       	breq	.+6      	; 0x954 <note_on_event+0x52>
			//new_note(note, velocity);
			//gate_buffer++; //increment gate_buffer
			//arp.display = arp.ppqn_counter;
			update_arp_sequence();
     94e:	0e 94 a3 00 	call	0x146	; 0x146 <update_arp_sequence>
     952:	08 95       	ret
				//arp.ppqn_counter = arp.divider; //reset ppqn counter to trigger arp step. This should implement KEY SYNC but messes up over all beat sync to master
				//ok, if note on comes on an arp divider beat, then it needs to be triggered, but if it isn't on a divider beat, then it shouldn't be triggered, right?	
				//arp.step_position = 0; //reset step position when new note arrives? Have a look here to get into nitty gritty details of arp sync behaviour: http://lauterzeit.com/arp_lfo_seq_sync/
			//}			
		} else {
			PORTF |= (1<<GATE); //if arp is OFF then turn on gate. Otherwise arpeggiator handles GATE
     954:	89 9a       	sbi	0x11, 1	; 17
     956:	08 95       	ret

00000958 <setup_midi_usart>:

void setup_midi_usart(void)
{
    uint16_t ubbr_value = 39; //20MHz/(16*31250 BAUD) - 1
    //write ubbr_value to H and L UBBR1 registers:
    UBRR0L = (unsigned char) ubbr_value;
     958:	87 e2       	ldi	r24, 0x27	; 39
     95a:	80 93 c4 00 	sts	0x00C4, r24
    UBRR0H = (unsigned char) (ubbr_value >> 8);
     95e:	10 92 c5 00 	sts	0x00C5, r1
	
	UCSR0B = (1<<RXEN0)|(1<<TXEN0) | (1<<RXCIE0);
     962:	88 e9       	ldi	r24, 0x98	; 152
     964:	80 93 c1 00 	sts	0x00C1, r24
	//UCSR0C |= (0<<UMSEL0)|(0<<UMSEL01)|(0<<UPM01)|(0<<UPM00)|(0<<USBS0)|(0<<UCSZ02)|(1<<UCSZ01)|(1<<UCSZ00);  	
}
     968:	08 95       	ret

0000096a <__vector_13>:



ISR (USART_RX_vect) { // USART receive interrupt
     96a:	1f 92       	push	r1
     96c:	0f 92       	push	r0
     96e:	0f b6       	in	r0, 0x3f	; 63
     970:	0f 92       	push	r0
     972:	11 24       	eor	r1, r1
     974:	2f 93       	push	r18
     976:	3f 93       	push	r19
     978:	4f 93       	push	r20
     97a:	5f 93       	push	r21
     97c:	6f 93       	push	r22
     97e:	7f 93       	push	r23
     980:	8f 93       	push	r24
     982:	9f 93       	push	r25
     984:	af 93       	push	r26
     986:	bf 93       	push	r27
     988:	ef 93       	push	r30
     98a:	ff 93       	push	r31
     98c:	cf 93       	push	r28
     98e:	df 93       	push	r29
     990:	0f 92       	push	r0
     992:	cd b7       	in	r28, 0x3d	; 61
     994:	de b7       	in	r29, 0x3e	; 62
	//PORTB ^= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED 
	uint8_t inByte = UDR0;
     996:	80 91 c6 00 	lds	r24, 0x00C6
     99a:	89 83       	std	Y+1, r24	; 0x01
	midi_device_input(&midi_device, 1, &inByte); 
     99c:	8a ee       	ldi	r24, 0xEA	; 234
     99e:	93 e0       	ldi	r25, 0x03	; 3
     9a0:	61 e0       	ldi	r22, 0x01	; 1
     9a2:	ae 01       	movw	r20, r28
     9a4:	4f 5f       	subi	r20, 0xFF	; 255
     9a6:	5f 4f       	sbci	r21, 0xFF	; 255
     9a8:	0e 94 8c 1a 	call	0x3518	; 0x3518 <midi_device_input>
	//calling a function in an interrupt is inefficient according to AVR C guidelines
	// so this function should maybe be inlined in main loop if inByte is made volatile	
	//***HOWEVER***, xnor-midi example code has this function being called from USART_RX_vect ISR  	
}
     9ac:	0f 90       	pop	r0
     9ae:	df 91       	pop	r29
     9b0:	cf 91       	pop	r28
     9b2:	ff 91       	pop	r31
     9b4:	ef 91       	pop	r30
     9b6:	bf 91       	pop	r27
     9b8:	af 91       	pop	r26
     9ba:	9f 91       	pop	r25
     9bc:	8f 91       	pop	r24
     9be:	7f 91       	pop	r23
     9c0:	6f 91       	pop	r22
     9c2:	5f 91       	pop	r21
     9c4:	4f 91       	pop	r20
     9c6:	3f 91       	pop	r19
     9c8:	2f 91       	pop	r18
     9ca:	0f 90       	pop	r0
     9cc:	0f be       	out	0x3f, r0	; 63
     9ce:	0f 90       	pop	r0
     9d0:	1f 90       	pop	r1
     9d2:	18 95       	reti

000009d4 <main>:


int main(void)
{
	//turn off JTAG so all outputs of PORTC can be used
	MCUCR = (1<<JTD);
     9d4:	c0 e8       	ldi	r28, 0x80	; 128
     9d6:	c5 bf       	out	0x35, r28	; 53
	MCUCR = (1<<JTD);
     9d8:	c5 bf       	out	0x35, r28	; 53
		
	//SET PORTB PIN 7 (PB7) as OUTPUT
	DDRB |= (1<<ARP_SYNC_LED);
     9da:	27 9a       	sbi	0x04, 7	; 4
	
	DDRB |= (1<< LFO_RESET); //set LFO reset as output. This affects LFO rate and TRI balance - needed to trim both rate and balance.
     9dc:	24 9a       	sbi	0x04, 4	; 4
	//PORTB |= (1<< LFO_RESET);
	
	
	DDRF |= (1<<GATE); //set gate as output
     9de:	81 9a       	sbi	0x10, 1	; 16
	//PORTF |= (1<<GATE); //turn gate on for testing
	
	DDRG |= (1<<TUNE_SELECT); //set tune select bit as output on PORTG
     9e0:	9a 9a       	sbi	0x13, 2	; 19
	PORTG &= ~(1<<TUNE_SELECT); //set tune select bit to 0 to select VCF/VCA output for oscillator tuning
     9e2:	a2 98       	cbi	0x14, 2	; 20
	//PORTG |= (1<<TUNE_SELECT);
	
	setup_spi(); 
     9e4:	0e 94 4e 08 	call	0x109c	; 0x109c <setup_spi>
	
	DDRH |= (1<<POTMUX_EN0) | (1<<POTMUX_EN1); //set POTMUX_EN pins as outputs
     9e8:	a9 ed       	ldi	r26, 0xD9	; 217
     9ea:	b0 e0       	ldi	r27, 0x00	; 0
     9ec:	8c 91       	ld	r24, X
     9ee:	80 6c       	ori	r24, 0xC0	; 192
     9f0:	8c 93       	st	X, r24
	POT_MUX |= (1<<POTMUX_EN0) | (1<<POTMUX_EN1); //set POTMUX_EN pins HIGH (active LOW)
     9f2:	ea ed       	ldi	r30, 0xDA	; 218
     9f4:	f0 e0       	ldi	r31, 0x00	; 0
     9f6:	80 81       	ld	r24, Z
     9f8:	80 6c       	ori	r24, 0xC0	; 192
     9fa:	80 83       	st	Z, r24
	//POT_MUX |= (1<<POTMUX_EN1);
	
	//set up LED display
	DDRA |= 0b11111111; //set all lines or DATA_BUS to outputs
     9fc:	81 b1       	in	r24, 0x01	; 1
     9fe:	8f ef       	ldi	r24, 0xFF	; 255
     a00:	81 b9       	out	0x01, r24	; 1
	DATA_BUS |= 0b11111111; //set all DATA_BUS lines to HIGH (cathodes OFF)
     a02:	92 b1       	in	r25, 0x02	; 2
     a04:	82 b9       	out	0x02, r24	; 2
	DDRH |= (1<<DISP_CATHODE_LATCH) | (1<<DISP_ANODE_LATCH); //set display latches to outputs
     a06:	8c 91       	ld	r24, X
     a08:	80 63       	ori	r24, 0x30	; 48
     a0a:	8c 93       	st	X, r24
	DISPLAY_PORT &= ~(1<<DISP_ANODE_LATCH | 1<< DISP_CATHODE_LATCH); //set DISP latches to LOW (inactive)
     a0c:	80 81       	ld	r24, Z
     a0e:	8f 7c       	andi	r24, 0xCF	; 207
     a10:	80 83       	st	Z, r24
	
	//set up switch port
	DDRF &= ~(1<<BMOD_SW); //set BMOD_SW pin as input
     a12:	82 98       	cbi	0x10, 2	; 16
	
	//set up LFO DEMUX LATCH
	DDRJ |= (1<<LFO_SW_LATCH); //set LFO_SW_LATCH pin as output
     a14:	ec ed       	ldi	r30, 0xDC	; 220
     a16:	f0 e0       	ldi	r31, 0x00	; 0
     a18:	80 81       	ld	r24, Z
     a1a:	80 62       	ori	r24, 0x20	; 32
     a1c:	80 83       	st	Z, r24
	DATA_BUS = LFO_TRI_ADDR;
     a1e:	12 b8       	out	0x02, r1	; 2
	LFO_LATCH_PORT |= (1<<LFO_SW_LATCH);
     a20:	ed ed       	ldi	r30, 0xDD	; 221
     a22:	f0 e0       	ldi	r31, 0x00	; 0
     a24:	80 81       	ld	r24, Z
     a26:	80 62       	ori	r24, 0x20	; 32
     a28:	80 83       	st	Z, r24
	LFO_LATCH_PORT &= ~(1<<LFO_SW_LATCH);
     a2a:	80 81       	ld	r24, Z
     a2c:	8f 7d       	andi	r24, 0xDF	; 223
     a2e:	80 83       	st	Z, r24
	DATA_BUS = 0;
     a30:	12 b8       	out	0x02, r1	; 2
	current_patch.byte_2 = (1<<LFO_TRI);
     a32:	c0 93 03 03 	sts	0x0303, r28
	
	//setup ADC
    setup_adc();		
     a36:	0e 94 51 00 	call	0xa2	; 0xa2 <setup_adc>
	//setup DAC
	setup_dac();
     a3a:	0e 94 37 02 	call	0x46e	; 0x46e <setup_dac>
	
	//setup MIDI
	//initialize MIDI device
	midi_device_init(&midi_device);
     a3e:	ca ee       	ldi	r28, 0xEA	; 234
     a40:	d3 e0       	ldi	r29, 0x03	; 3
     a42:	ce 01       	movw	r24, r28
     a44:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <midi_device_init>
	//register callbacks
	midi_register_noteon_callback(&midi_device, note_on_event);
     a48:	ce 01       	movw	r24, r28
     a4a:	61 e8       	ldi	r22, 0x81	; 129
     a4c:	74 e0       	ldi	r23, 0x04	; 4
     a4e:	0e 94 23 1a 	call	0x3446	; 0x3446 <midi_register_noteon_callback>
	midi_register_noteoff_callback(&midi_device, note_off_event);
     a52:	ce 01       	movw	r24, r28
     a54:	63 e6       	ldi	r22, 0x63	; 99
     a56:	74 e0       	ldi	r23, 0x04	; 4
     a58:	0e 94 27 1a 	call	0x344e	; 0x344e <midi_register_noteoff_callback>
	midi_register_realtime_callback(&midi_device, real_time_event);
     a5c:	ce 01       	movw	r24, r28
     a5e:	68 ee       	ldi	r22, 0xE8	; 232
     a60:	73 e0       	ldi	r23, 0x03	; 3
     a62:	0e 94 47 1a 	call	0x348e	; 0x348e <midi_register_realtime_callback>
	midi_register_songposition_callback(&midi_device, song_position_event);
     a66:	ce 01       	movw	r24, r28
     a68:	64 ee       	ldi	r22, 0xE4	; 228
     a6a:	73 e0       	ldi	r23, 0x03	; 3
     a6c:	0e 94 33 1a 	call	0x3466	; 0x3466 <midi_register_songposition_callback>
	//setup MIDI USART
	setup_midi_usart();
     a70:	0e 94 ac 04 	call	0x958	; 0x958 <setup_midi_usart>
	
	update_spi(); //initial update of SPI - will eventual be useful for picking up special power up switch holds
     a74:	0e 94 73 08 	call	0x10e6	; 0x10e6 <update_spi>
	
	
	current_patch.number = 1;
     a78:	c1 e0       	ldi	r28, 0x01	; 1
     a7a:	c0 93 07 03 	sts	0x0307, r28
		
	sei(); //enable global interrupts
     a7e:	78 94       	sei

	
	//eeprom_update_word((uint16_t*)109, test_word);
	//value_to_display = eeprom_read_word((uint16_t*)109);
	
	load_tuning_tables();
     a80:	0e 94 89 16 	call	0x2d12	; 0x2d12 <load_tuning_tables>
	//value_to_display = vco1_init_cv;
	//set_one_volt_per_octave(); //overwrite tuning tables with 1V/octave data for calibration purposes
	//set initial switch states
	//switch_states.byte0 = (1<<VCO1_PULSE_SW) | (1<<VCO2_PULSE_SW);
	//current_patch.byte_4 = (1<<VCO1_32F) | (1<<VCO2_32F);
	load_patch(1);
     a84:	81 e0       	ldi	r24, 0x01	; 1
     a86:	0e 94 ec 0a 	call	0x15d8	; 0x15d8 <load_patch>
	
	setup_system_clock();
     a8a:	0e 94 ed 01 	call	0x3da	; 0x3da <setup_system_clock>
	//update_clock_speed(244);
	system_clock.divider = 24;
     a8e:	88 e1       	ldi	r24, 0x18	; 24
     a90:	80 93 d8 03 	sts	0x03D8, r24
	midi_clock.divider = 6;//this is for MIDI beat clock which is /6 MIDI ppqn clock or 16th notes
     a94:	86 e0       	ldi	r24, 0x06	; 6
     a96:	80 93 e4 03 	sts	0x03E4, r24
	arp.step_position = 0; //initialize step position
     a9a:	10 92 8a 03 	sts	0x038A, r1
	arp.clock_source = INTERNAL_CLOCK;
     a9e:	c0 93 96 03 	sts	0x0396, r28
	arp.mode = OFF;
     aa2:	10 92 97 03 	sts	0x0397, r1
	arp.ppqn_counter = 1;
     aa6:	c0 93 8e 03 	sts	0x038E, r28
	arp.ppqn_shift = 1;
     aaa:	c0 93 90 03 	sts	0x0390, r28

	while(1)
	{	
		
		
		midi_device_process(&midi_device); //this needs to be called 'frequently' in order for MIDI to work
     aae:	0a ee       	ldi	r16, 0xEA	; 234
     ab0:	13 e0       	ldi	r17, 0x03	; 3
		if (switch_timer++ == 5)
		{
			switch_timer = 0;
			switch_press = 0; //reset global switch press flag
			//read switches directly connected to MCU	
			switch_states.byte2 ^= read_switch_port(); //toggle switch states
     ab2:	0f 2e       	mov	r0, r31
     ab4:	f4 e8       	ldi	r31, 0x84	; 132
     ab6:	ef 2e       	mov	r14, r31
     ab8:	f3 e0       	ldi	r31, 0x03	; 3
     aba:	ff 2e       	mov	r15, r31
     abc:	f0 2d       	mov	r31, r0
			switch_states.byte2 |= (current_patch.mode == MANUAL) << PROG_MANUAL_SW; //if MANUAL then don't toggle switch
     abe:	0f 2e       	mov	r0, r31
     ac0:	fb e0       	ldi	r31, 0x0B	; 11
     ac2:	cf 2e       	mov	r12, r31
     ac4:	f3 e0       	ldi	r31, 0x03	; 3
     ac6:	df 2e       	mov	r13, r31
     ac8:	f0 2d       	mov	r31, r0
			//switch_states.byte2 |= (current_patch.mode == WRITE) << PROG_WRITE_SW; //if WRITE then don't toggle switch
			update_spi();
			if (switch_press) { 
				update_patch();
				if (current_patch.mode == MEMORY) current_patch.mode = EDIT; //change mode to EDIT if non-program switch is detected
     aca:	bb 24       	eor	r11, r11
     acc:	68 94       	set
     ace:	b1 f8       	bld	r11, 1
		{
			switch_timer = 0;
			switch_press = 0; //reset global switch press flag
			//read switches directly connected to MCU	
			switch_states.byte2 ^= read_switch_port(); //toggle switch states
			switch_states.byte2 |= (current_patch.mode == MANUAL) << PROG_MANUAL_SW; //if MANUAL then don't toggle switch
     ad0:	d0 e8       	ldi	r29, 0x80	; 128

	while(1)
	{	
		
		
		midi_device_process(&midi_device); //this needs to be called 'frequently' in order for MIDI to work
     ad2:	c8 01       	movw	r24, r16
     ad4:	0e 94 b6 1c 	call	0x396c	; 0x396c <midi_device_process>
		//value_to_display = vco1_init_cv;
		//PORTB |= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED
		update_display(value_to_display, DEC); //maybe move this into switch_timer loop. Probably doesn't need to be updated this frequently
     ad8:	80 91 fd 01 	lds	r24, 0x01FD
     adc:	90 91 fe 01 	lds	r25, 0x01FE
     ae0:	60 e0       	ldi	r22, 0x00	; 0
     ae2:	0e 94 39 03 	call	0x672	; 0x672 <update_display>
		//PORTB &= ~(1<<ARP_SYNC_LED);
		 	
		//scan_pots_and_update_control_voltages();
		scan_pots();
     ae6:	0e 94 a2 05 	call	0xb44	; 0xb44 <scan_pots>
		update_control_voltages();
     aea:	0e 94 2f 06 	call	0xc5e	; 0xc5e <update_control_voltages>
			
		//do SPI read/write every 5 loops. This is quite clumsy. Not sure yet how to better implement it
		if (switch_timer++ == 5)
     aee:	80 91 bd 02 	lds	r24, 0x02BD
     af2:	98 2f       	mov	r25, r24
     af4:	9f 5f       	subi	r25, 0xFF	; 255
     af6:	90 93 bd 02 	sts	0x02BD, r25
     afa:	85 30       	cpi	r24, 0x05	; 5
     afc:	51 f7       	brne	.-44     	; 0xad2 <main+0xfe>
		{
			switch_timer = 0;
     afe:	10 92 bd 02 	sts	0x02BD, r1
			switch_press = 0; //reset global switch press flag
     b02:	10 92 c5 02 	sts	0x02C5, r1
			//read switches directly connected to MCU	
			switch_states.byte2 ^= read_switch_port(); //toggle switch states
     b06:	f7 01       	movw	r30, r14
     b08:	c0 81       	ld	r28, Z
     b0a:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <read_switch_port>
     b0e:	8c 27       	eor	r24, r28
			switch_states.byte2 |= (current_patch.mode == MANUAL) << PROG_MANUAL_SW; //if MANUAL then don't toggle switch
     b10:	f6 01       	movw	r30, r12
     b12:	90 81       	ld	r25, Z
     b14:	91 30       	cpi	r25, 0x01	; 1
     b16:	11 f4       	brne	.+4      	; 0xb1c <main+0x148>
     b18:	cd 2f       	mov	r28, r29
     b1a:	01 c0       	rjmp	.+2      	; 0xb1e <main+0x14a>
     b1c:	c0 e0       	ldi	r28, 0x00	; 0
     b1e:	c8 2b       	or	r28, r24
     b20:	f7 01       	movw	r30, r14
     b22:	c0 83       	st	Z, r28
			//switch_states.byte2 |= (current_patch.mode == WRITE) << PROG_WRITE_SW; //if WRITE then don't toggle switch
			update_spi();
     b24:	0e 94 73 08 	call	0x10e6	; 0x10e6 <update_spi>
			if (switch_press) { 
     b28:	80 91 c5 02 	lds	r24, 0x02C5
     b2c:	88 23       	and	r24, r24
     b2e:	39 f0       	breq	.+14     	; 0xb3e <main+0x16a>
				update_patch();
     b30:	0e 94 06 10 	call	0x200c	; 0x200c <update_patch>
				if (current_patch.mode == MEMORY) current_patch.mode = EDIT; //change mode to EDIT if non-program switch is detected
     b34:	f6 01       	movw	r30, r12
     b36:	80 81       	ld	r24, Z
     b38:	88 23       	and	r24, r24
     b3a:	09 f4       	brne	.+2      	; 0xb3e <main+0x16a>
     b3c:	b0 82       	st	Z, r11
			}				
			update_patch_programmer();	
     b3e:	0e 94 93 10 	call	0x2126	; 0x2126 <update_patch_programmer>
     b42:	c7 cf       	rjmp	.-114    	; 0xad2 <main+0xfe>

00000b44 <scan_pots>:

uint8_t midi_note_number = 0; //store incoming MIDI note here for pitch lookup table

volatile uint16_t value_to_display = 79; //global to hold display value
	
void scan_pots(void) { //should probably move this to adc.c
     b44:	bf 92       	push	r11
     b46:	cf 92       	push	r12
     b48:	df 92       	push	r13
     b4a:	ef 92       	push	r14
     b4c:	ff 92       	push	r15
     b4e:	0f 93       	push	r16
     b50:	1f 93       	push	r17
     b52:	cf 93       	push	r28
     b54:	df 93       	push	r29
     b56:	c0 e0       	ldi	r28, 0x00	; 0
     b58:	d1 e0       	ldi	r29, 0x01	; 1
     b5a:	06 ec       	ldi	r16, 0xC6	; 198
     b5c:	12 e0       	ldi	r17, 0x02	; 2
     b5e:	0f 2e       	mov	r0, r31
     b60:	fc e3       	ldi	r31, 0x3C	; 60
     b62:	cf 2e       	mov	r12, r31
     b64:	dd 24       	eor	r13, r13
     b66:	f0 2d       	mov	r31, r0
     b68:	cc 0e       	add	r12, r28
     b6a:	dd 1e       	adc	r13, r29
		//what happens next depends on mode. if pot is locked, then the value of the pot is not written to the current patch unless it is different from the pot's locked value
		
		uint8_t delta_pot = pot_id[i]->locked_value - ((pot_id[i]->value >> 2)); //quick and dirty subtraction, where unsigned delta pot will overflow if value > locked value. see below
		
		
		if ((current_patch.mode == MANUAL) || (pot_id[i]->locked == 0)) { //if in manual mode or pot is already unlocked
     b6c:	0f 2e       	mov	r0, r31
     b6e:	fb e0       	ldi	r31, 0x0B	; 11
     b70:	ef 2e       	mov	r14, r31
     b72:	f3 e0       	ldi	r31, 0x03	; 3
     b74:	ff 2e       	mov	r15, r31
     b76:	f0 2d       	mov	r31, r0
		//} else if ((((pot_id[i]->value >> 2) != pot_id[i]->locked_value)) && (pot_id[i]->locked == 1)) { //need to figure out delta threshold here. 10 bit to 8 bit resolution should be enough???
			
		} else if (((delta_pot > 2) && (delta_pot < 253)) && (pot_id[i]->locked == 1)) { //set a threshold of +/- 3 for pot change  		  		  	
			*(patch_value + i) = pot_id[i]->value;
			pot_id[i]->locked = 0; //unlock pot
			current_patch.mode = EDIT;
     b78:	bb 24       	eor	r11, r11
     b7a:	68 94       	set
     b7c:	b1 f8       	bld	r11, 1
	
	uint16_t *patch_value = &(current_patch.vco2_mix); //pointer to first element of current_patch struct
	//scan 30 parameter pots
	for (int i = 0; i <= NUM_POTS; i++) {
		
		adc_value = read_pot(pot_id[i]);
     b7e:	88 81       	ld	r24, Y
     b80:	99 81       	ldd	r25, Y+1	; 0x01
     b82:	0e 94 64 00 	call	0xc8	; 0xc8 <read_pot>
     b86:	90 93 c0 02 	sts	0x02C0, r25
     b8a:	80 93 bf 02 	sts	0x02BF, r24
		adc_change = adc_value - pot_id[i]->value;
     b8e:	e8 81       	ld	r30, Y
     b90:	f9 81       	ldd	r31, Y+1	; 0x01
     b92:	40 81       	ld	r20, Z
     b94:	21 81       	ldd	r18, Z+1	; 0x01
     b96:	52 2f       	mov	r21, r18
     b98:	53 70       	andi	r21, 0x03	; 3
     b9a:	84 1b       	sub	r24, r20
     b9c:	95 0b       	sbc	r25, r21
		pot_id[i]->value = pot_id[i]->value + (adc_change >> 2);
     b9e:	95 95       	asr	r25
     ba0:	87 95       	ror	r24
     ba2:	95 95       	asr	r25
     ba4:	87 95       	ror	r24
     ba6:	84 0f       	add	r24, r20
     ba8:	95 1f       	adc	r25, r21
     baa:	80 83       	st	Z, r24
     bac:	89 2f       	mov	r24, r25
     bae:	83 70       	andi	r24, 0x03	; 3
     bb0:	2c 7f       	andi	r18, 0xFC	; 252
     bb2:	28 2b       	or	r18, r24
     bb4:	21 83       	std	Z+1, r18	; 0x01
		//what happens next depends on mode. if pot is locked, then the value of the pot is not written to the current patch unless it is different from the pot's locked value
		
		uint8_t delta_pot = pot_id[i]->locked_value - ((pot_id[i]->value >> 2)); //quick and dirty subtraction, where unsigned delta pot will overflow if value > locked value. see below
     bb6:	e9 91       	ld	r30, Y+
     bb8:	f9 91       	ld	r31, Y+
     bba:	92 81       	ldd	r25, Z+2	; 0x02
     bbc:	20 81       	ld	r18, Z
     bbe:	81 81       	ldd	r24, Z+1	; 0x01
     bc0:	38 2f       	mov	r19, r24
     bc2:	33 70       	andi	r19, 0x03	; 3
		
		
		if ((current_patch.mode == MANUAL) || (pot_id[i]->locked == 0)) { //if in manual mode or pot is already unlocked
     bc4:	d7 01       	movw	r26, r14
     bc6:	8c 91       	ld	r24, X
     bc8:	81 30       	cpi	r24, 0x01	; 1
     bca:	19 f0       	breq	.+6      	; 0xbd2 <scan_pots+0x8e>
     bcc:	83 81       	ldd	r24, Z+3	; 0x03
     bce:	88 23       	and	r24, r24
     bd0:	24 f0       	brlt	.+8      	; 0xbda <scan_pots+0x96>
			
			*(patch_value + i) = pot_id[i]->value; //this is a hacked way of indexing the patch structure. Depends on order of pots in pot array being the same as order of parameters in patch struct
     bd2:	f8 01       	movw	r30, r16
     bd4:	31 83       	std	Z+1, r19	; 0x01
     bd6:	20 83       	st	Z, r18
     bd8:	14 c0       	rjmp	.+40     	; 0xc02 <scan_pots+0xbe>
		adc_value = read_pot(pot_id[i]);
		adc_change = adc_value - pot_id[i]->value;
		pot_id[i]->value = pot_id[i]->value + (adc_change >> 2);
		//what happens next depends on mode. if pot is locked, then the value of the pot is not written to the current patch unless it is different from the pot's locked value
		
		uint8_t delta_pot = pot_id[i]->locked_value - ((pot_id[i]->value >> 2)); //quick and dirty subtraction, where unsigned delta pot will overflow if value > locked value. see below
     bda:	49 2f       	mov	r20, r25
     bdc:	43 50       	subi	r20, 0x03	; 3
     bde:	c9 01       	movw	r24, r18
     be0:	95 95       	asr	r25
     be2:	87 95       	ror	r24
     be4:	95 95       	asr	r25
     be6:	87 95       	ror	r24
			
			*(patch_value + i) = pot_id[i]->value; //this is a hacked way of indexing the patch structure. Depends on order of pots in pot array being the same as order of parameters in patch struct
			
		//} else if ((((pot_id[i]->value >> 2) != pot_id[i]->locked_value)) && (pot_id[i]->locked == 1)) { //need to figure out delta threshold here. 10 bit to 8 bit resolution should be enough???
			
		} else if (((delta_pot > 2) && (delta_pot < 253)) && (pot_id[i]->locked == 1)) { //set a threshold of +/- 3 for pot change  		  		  	
     be8:	94 2f       	mov	r25, r20
     bea:	98 1b       	sub	r25, r24
     bec:	9a 3f       	cpi	r25, 0xFA	; 250
     bee:	48 f4       	brcc	.+18     	; 0xc02 <scan_pots+0xbe>
			*(patch_value + i) = pot_id[i]->value;
     bf0:	d8 01       	movw	r26, r16
     bf2:	11 96       	adiw	r26, 0x01	; 1
     bf4:	3c 93       	st	X, r19
     bf6:	2e 93       	st	-X, r18
			pot_id[i]->locked = 0; //unlock pot
     bf8:	83 81       	ldd	r24, Z+3	; 0x03
     bfa:	8f 77       	andi	r24, 0x7F	; 127
     bfc:	83 83       	std	Z+3, r24	; 0x03
			current_patch.mode = EDIT;
     bfe:	f7 01       	movw	r30, r14
     c00:	b0 82       	st	Z, r11
     c02:	0e 5f       	subi	r16, 0xFE	; 254
     c04:	1f 4f       	sbci	r17, 0xFF	; 255

	int adc_change = 0;
	
	uint16_t *patch_value = &(current_patch.vco2_mix); //pointer to first element of current_patch struct
	//scan 30 parameter pots
	for (int i = 0; i <= NUM_POTS; i++) {
     c06:	cc 15       	cp	r28, r12
     c08:	dd 05       	cpc	r29, r13
     c0a:	09 f0       	breq	.+2      	; 0xc0e <scan_pots+0xca>
     c0c:	b8 cf       	rjmp	.-144    	; 0xb7e <scan_pots+0x3a>
		
	}
	
	
	//scan volume pot
	adc_value = read_pot(&volume_pot);
     c0e:	8c e7       	ldi	r24, 0x7C	; 124
     c10:	91 e0       	ldi	r25, 0x01	; 1
     c12:	0e 94 64 00 	call	0xc8	; 0xc8 <read_pot>
     c16:	90 93 c0 02 	sts	0x02C0, r25
     c1a:	80 93 bf 02 	sts	0x02BF, r24
	adc_change = adc_value - volume_pot.value;
     c1e:	20 91 7c 01 	lds	r18, 0x017C
     c22:	40 91 7d 01 	lds	r20, 0x017D
     c26:	34 2f       	mov	r19, r20
     c28:	33 70       	andi	r19, 0x03	; 3
     c2a:	82 1b       	sub	r24, r18
     c2c:	93 0b       	sbc	r25, r19
	volume_pot.value = volume_pot.value + (adc_change >> 2);
     c2e:	95 95       	asr	r25
     c30:	87 95       	ror	r24
     c32:	95 95       	asr	r25
     c34:	87 95       	ror	r24
     c36:	28 0f       	add	r18, r24
     c38:	39 1f       	adc	r19, r25
     c3a:	20 93 7c 01 	sts	0x017C, r18
     c3e:	83 2f       	mov	r24, r19
     c40:	83 70       	andi	r24, 0x03	; 3
     c42:	4c 7f       	andi	r20, 0xFC	; 252
     c44:	48 2b       	or	r20, r24
     c46:	40 93 7d 01 	sts	0x017D, r20
	
}
     c4a:	df 91       	pop	r29
     c4c:	cf 91       	pop	r28
     c4e:	1f 91       	pop	r17
     c50:	0f 91       	pop	r16
     c52:	ff 90       	pop	r15
     c54:	ef 90       	pop	r14
     c56:	df 90       	pop	r13
     c58:	cf 90       	pop	r12
     c5a:	bf 90       	pop	r11
     c5c:	08 95       	ret

00000c5e <update_control_voltages>:

void update_control_voltages(void) { //keep everything updated in the current order of pots. Probably arbitrary, but try to minimize change from old CV update to new CV update
     c5e:	cf 93       	push	r28
     c60:	df 93       	push	r29
	
	set_control_voltage(&vco2_mix_cv, (current_patch.vco2_mix << 4));
     c62:	60 91 c6 02 	lds	r22, 0x02C6
     c66:	70 91 c7 02 	lds	r23, 0x02C7
     c6a:	62 95       	swap	r22
     c6c:	72 95       	swap	r23
     c6e:	70 7f       	andi	r23, 0xF0	; 240
     c70:	76 27       	eor	r23, r22
     c72:	60 7f       	andi	r22, 0xF0	; 240
     c74:	76 27       	eor	r23, r22
     c76:	84 ee       	ldi	r24, 0xE4	; 228
     c78:	91 e0       	ldi	r25, 0x01	; 1
     c7a:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&vco1_mix_cv, (current_patch.vco1_mix << 4));
     c7e:	60 91 c8 02 	lds	r22, 0x02C8
     c82:	70 91 c9 02 	lds	r23, 0x02C9
     c86:	62 95       	swap	r22
     c88:	72 95       	swap	r23
     c8a:	70 7f       	andi	r23, 0xF0	; 240
     c8c:	76 27       	eor	r23, r22
     c8e:	60 7f       	andi	r22, 0xF0	; 240
     c90:	76 27       	eor	r23, r22
     c92:	83 ee       	ldi	r24, 0xE3	; 227
     c94:	91 e0       	ldi	r25, 0x01	; 1
     c96:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&pitch_eg2_cv, (current_patch.pitch_eg2 << 3)); //1/4 scale
     c9a:	60 91 ca 02 	lds	r22, 0x02CA
     c9e:	70 91 cb 02 	lds	r23, 0x02CB
     ca2:	66 0f       	add	r22, r22
     ca4:	77 1f       	adc	r23, r23
     ca6:	66 0f       	add	r22, r22
     ca8:	77 1f       	adc	r23, r23
     caa:	66 0f       	add	r22, r22
     cac:	77 1f       	adc	r23, r23
     cae:	82 ee       	ldi	r24, 0xE2	; 226
     cb0:	91 e0       	ldi	r25, 0x01	; 1
     cb2:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&pitch_vco2_cv, (current_patch.pitch_vco2 << 4));
     cb6:	60 91 cc 02 	lds	r22, 0x02CC
     cba:	70 91 cd 02 	lds	r23, 0x02CD
     cbe:	62 95       	swap	r22
     cc0:	72 95       	swap	r23
     cc2:	70 7f       	andi	r23, 0xF0	; 240
     cc4:	76 27       	eor	r23, r22
     cc6:	60 7f       	andi	r22, 0xF0	; 240
     cc8:	76 27       	eor	r23, r22
     cca:	87 eb       	ldi	r24, 0xB7	; 183
     ccc:	92 e0       	ldi	r25, 0x02	; 2
     cce:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&pitch_lfo_cv, (current_patch.pitch_lfo << 3)); // 1/4 scale
     cd2:	60 91 ce 02 	lds	r22, 0x02CE
     cd6:	70 91 cf 02 	lds	r23, 0x02CF
     cda:	66 0f       	add	r22, r22
     cdc:	77 1f       	adc	r23, r23
     cde:	66 0f       	add	r22, r22
     ce0:	77 1f       	adc	r23, r23
     ce2:	66 0f       	add	r22, r22
     ce4:	77 1f       	adc	r23, r23
     ce6:	81 ee       	ldi	r24, 0xE1	; 225
     ce8:	91 e0       	ldi	r25, 0x01	; 1
     cea:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&pwm_lfo_cv, (current_patch.pwm_lfo) << 4);
     cee:	60 91 d0 02 	lds	r22, 0x02D0
     cf2:	70 91 d1 02 	lds	r23, 0x02D1
     cf6:	62 95       	swap	r22
     cf8:	72 95       	swap	r23
     cfa:	70 7f       	andi	r23, 0xF0	; 240
     cfc:	76 27       	eor	r23, r22
     cfe:	60 7f       	andi	r22, 0xF0	; 240
     d00:	76 27       	eor	r23, r22
     d02:	80 ee       	ldi	r24, 0xE0	; 224
     d04:	91 e0       	ldi	r25, 0x01	; 1
     d06:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&pwm_eg2_cv, (current_patch.pwm_eg2) << 4);
     d0a:	60 91 d2 02 	lds	r22, 0x02D2
     d0e:	70 91 d3 02 	lds	r23, 0x02D3
     d12:	62 95       	swap	r22
     d14:	72 95       	swap	r23
     d16:	70 7f       	andi	r23, 0xF0	; 240
     d18:	76 27       	eor	r23, r22
     d1a:	60 7f       	andi	r22, 0xF0	; 240
     d1c:	76 27       	eor	r23, r22
     d1e:	8f ed       	ldi	r24, 0xDF	; 223
     d20:	91 e0       	ldi	r25, 0x01	; 1
     d22:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&vco1_pw_cv, (current_patch.vco1_pw) << 4);
     d26:	60 91 d4 02 	lds	r22, 0x02D4
     d2a:	70 91 d5 02 	lds	r23, 0x02D5
     d2e:	62 95       	swap	r22
     d30:	72 95       	swap	r23
     d32:	70 7f       	andi	r23, 0xF0	; 240
     d34:	76 27       	eor	r23, r22
     d36:	60 7f       	andi	r22, 0xF0	; 240
     d38:	76 27       	eor	r23, r22
     d3a:	8e ed       	ldi	r24, 0xDE	; 222
     d3c:	91 e0       	ldi	r25, 0x01	; 1
     d3e:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	
	int tune_offset = 512 - current_patch.tune; //master tune offset
     d42:	80 91 d8 02 	lds	r24, 0x02D8
     d46:	90 91 d9 02 	lds	r25, 0x02D9
     d4a:	c0 e0       	ldi	r28, 0x00	; 0
     d4c:	d2 e0       	ldi	r29, 0x02	; 2
     d4e:	c8 1b       	sub	r28, r24
     d50:	d9 0b       	sbc	r29, r25
	
	int fine_offset = 512 - current_patch.fine; //fine tune offset
     d52:	60 91 77 03 	lds	r22, 0x0377
     d56:	70 91 78 03 	lds	r23, 0x0378
     d5a:	60 50       	subi	r22, 0x00	; 0
     d5c:	7e 4f       	sbci	r23, 0xFE	; 254
	
	set_control_voltage(&fine_cv, vco2_init_cv + tune_offset + fine_offset);
     d5e:	80 91 d6 02 	lds	r24, 0x02D6
     d62:	90 91 d7 02 	lds	r25, 0x02D7
     d66:	68 1b       	sub	r22, r24
     d68:	79 0b       	sbc	r23, r25
     d6a:	6c 0f       	add	r22, r28
     d6c:	7d 1f       	adc	r23, r29
     d6e:	8d ed       	ldi	r24, 0xDD	; 221
     d70:	91 e0       	ldi	r25, 0x01	; 1
     d72:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&tune_cv, vco1_init_cv + tune_offset);
     d76:	60 91 79 03 	lds	r22, 0x0379
     d7a:	70 91 7a 03 	lds	r23, 0x037A
     d7e:	6c 0f       	add	r22, r28
     d80:	7d 1f       	adc	r23, r29
     d82:	8c ed       	ldi	r24, 0xDC	; 220
     d84:	91 e0       	ldi	r25, 0x01	; 1
     d86:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	
	set_control_voltage(&lfo_rate_cv, (current_patch.lfo_rate) << 4);
     d8a:	60 91 da 02 	lds	r22, 0x02DA
     d8e:	70 91 db 02 	lds	r23, 0x02DB
     d92:	62 95       	swap	r22
     d94:	72 95       	swap	r23
     d96:	70 7f       	andi	r23, 0xF0	; 240
     d98:	76 27       	eor	r23, r22
     d9a:	60 7f       	andi	r22, 0xF0	; 240
     d9c:	76 27       	eor	r23, r22
     d9e:	8b ed       	ldi	r24, 0xDB	; 219
     da0:	91 e0       	ldi	r25, 0x01	; 1
     da2:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&glide_cv, (current_patch.glide) << 4);
     da6:	60 91 de 02 	lds	r22, 0x02DE
     daa:	70 91 df 02 	lds	r23, 0x02DF
     dae:	62 95       	swap	r22
     db0:	72 95       	swap	r23
     db2:	70 7f       	andi	r23, 0xF0	; 240
     db4:	76 27       	eor	r23, r22
     db6:	60 7f       	andi	r22, 0xF0	; 240
     db8:	76 27       	eor	r23, r22
     dba:	8a ed       	ldi	r24, 0xDA	; 218
     dbc:	91 e0       	ldi	r25, 0x01	; 1
     dbe:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&amp_lfo_cv, (current_patch.amp_lfo) << 4);
     dc2:	60 91 e0 02 	lds	r22, 0x02E0
     dc6:	70 91 e1 02 	lds	r23, 0x02E1
     dca:	62 95       	swap	r22
     dcc:	72 95       	swap	r23
     dce:	70 7f       	andi	r23, 0xF0	; 240
     dd0:	76 27       	eor	r23, r22
     dd2:	60 7f       	andi	r22, 0xF0	; 240
     dd4:	76 27       	eor	r23, r22
     dd6:	89 ed       	ldi	r24, 0xD9	; 217
     dd8:	91 e0       	ldi	r25, 0x01	; 1
     dda:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&volume_cv, (volume_pot.value << 4)); //volume level not a patch parameter
     dde:	60 91 7c 01 	lds	r22, 0x017C
     de2:	80 91 7d 01 	lds	r24, 0x017D
     de6:	78 2f       	mov	r23, r24
     de8:	73 70       	andi	r23, 0x03	; 3
     dea:	62 95       	swap	r22
     dec:	72 95       	swap	r23
     dee:	70 7f       	andi	r23, 0xF0	; 240
     df0:	76 27       	eor	r23, r22
     df2:	60 7f       	andi	r22, 0xF0	; 240
     df4:	76 27       	eor	r23, r22
     df6:	88 ed       	ldi	r24, 0xD8	; 216
     df8:	91 e0       	ldi	r25, 0x01	; 1
     dfa:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&vco2_pw_cv, (current_patch.vco2_pw) << 4);	
     dfe:	60 91 e2 02 	lds	r22, 0x02E2
     e02:	70 91 e3 02 	lds	r23, 0x02E3
     e06:	62 95       	swap	r22
     e08:	72 95       	swap	r23
     e0a:	70 7f       	andi	r23, 0xF0	; 240
     e0c:	76 27       	eor	r23, r22
     e0e:	60 7f       	andi	r22, 0xF0	; 240
     e10:	76 27       	eor	r23, r22
     e12:	87 ed       	ldi	r24, 0xD7	; 215
     e14:	91 e0       	ldi	r25, 0x01	; 1
     e16:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	
	set_control_voltage(&fil_eg2_cv, (current_patch.fil_eg2) << 4);
     e1a:	60 91 e4 02 	lds	r22, 0x02E4
     e1e:	70 91 e5 02 	lds	r23, 0x02E5
     e22:	62 95       	swap	r22
     e24:	72 95       	swap	r23
     e26:	70 7f       	andi	r23, 0xF0	; 240
     e28:	76 27       	eor	r23, r22
     e2a:	60 7f       	andi	r22, 0xF0	; 240
     e2c:	76 27       	eor	r23, r22
     e2e:	86 ed       	ldi	r24, 0xD6	; 214
     e30:	91 e0       	ldi	r25, 0x01	; 1
     e32:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&res_cv, (current_patch.res) << 4);
     e36:	60 91 e6 02 	lds	r22, 0x02E6
     e3a:	70 91 e7 02 	lds	r23, 0x02E7
     e3e:	62 95       	swap	r22
     e40:	72 95       	swap	r23
     e42:	70 7f       	andi	r23, 0xF0	; 240
     e44:	76 27       	eor	r23, r22
     e46:	60 7f       	andi	r22, 0xF0	; 240
     e48:	76 27       	eor	r23, r22
     e4a:	85 ed       	ldi	r24, 0xD5	; 213
     e4c:	91 e0       	ldi	r25, 0x01	; 1
     e4e:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	
	//this next bit should be separated out, but leave it here for now while testing decoupled adc/dac read/write
	uint8_t note = get_current_note(); //get current note from assigner
     e52:	0e 94 8e 01 	call	0x31c	; 0x31c <get_current_note>
     e56:	c8 2f       	mov	r28, r24
	if (note < 8) note = 8; //init_cv gives VCO range from MIDI note 8 to MIDI note 127+. If you don't set notes <8 to 8 then you get array out of bounds problems. Should find a better way to handle this.
     e58:	88 30       	cpi	r24, 0x08	; 8
     e5a:	08 f4       	brcc	.+2      	; 0xe5e <update_control_voltages+0x200>
     e5c:	c8 e0       	ldi	r28, 0x08	; 8
	//value_to_display = current_patch.number + 100*(arp.sequence[arp.step_position].note); //100*note;
	//value_to_display = arp.sequence[arp.step_position].note;
	//uint8_t arp_note = arp.sequence[arp.step_position].note;
	//if (arp_note == EMPTY) arp_note = 0;
	value_to_display = current_patch.number + 100*arp.display;
     e5e:	60 91 07 03 	lds	r22, 0x0307
     e62:	40 91 95 03 	lds	r20, 0x0395
     e66:	50 e0       	ldi	r21, 0x00	; 0
     e68:	24 e6       	ldi	r18, 0x64	; 100
     e6a:	30 e0       	ldi	r19, 0x00	; 0
     e6c:	42 9f       	mul	r20, r18
     e6e:	c0 01       	movw	r24, r0
     e70:	43 9f       	mul	r20, r19
     e72:	90 0d       	add	r25, r0
     e74:	52 9f       	mul	r21, r18
     e76:	90 0d       	add	r25, r0
     e78:	11 24       	eor	r1, r1
     e7a:	86 0f       	add	r24, r22
     e7c:	91 1d       	adc	r25, r1
     e7e:	90 93 fe 01 	sts	0x01FE, r25
     e82:	80 93 fd 01 	sts	0x01FD, r24
		
	uint16_t interpolated_pitch_cv = 0; //holder for interpolated pitch values
	
	interpolated_pitch_cv = interpolate_pitch_cv(note-8, filter_pitch_table); //subtract 8 from note because filter pitch is calibrated so that 0V is E, 20.6 Hz
     e86:	8c 2f       	mov	r24, r28
     e88:	88 50       	subi	r24, 0x08	; 8
     e8a:	63 e1       	ldi	r22, 0x13	; 19
     e8c:	73 e0       	ldi	r23, 0x03	; 3
     e8e:	0e 94 b2 16 	call	0x2d64	; 0x2d64 <interpolate_pitch_cv>
	//note that product of key_track and interpolated_pitch_cv needs to be cast as uint32t - otherwise product is evaluated incorrectly
	uint16_t divided_pitch_cv = ((uint32_t)current_patch.key_track*interpolated_pitch_cv) >> 10;
     e92:	bc 01       	movw	r22, r24
     e94:	80 e0       	ldi	r24, 0x00	; 0
     e96:	90 e0       	ldi	r25, 0x00	; 0
     e98:	20 91 ea 02 	lds	r18, 0x02EA
     e9c:	30 91 eb 02 	lds	r19, 0x02EB
     ea0:	40 e0       	ldi	r20, 0x00	; 0
     ea2:	50 e0       	ldi	r21, 0x00	; 0
     ea4:	0e 94 90 1e 	call	0x3d20	; 0x3d20 <__mulsi3>
     ea8:	dc 01       	movw	r26, r24
     eaa:	cb 01       	movw	r24, r22
     eac:	07 2e       	mov	r0, r23
     eae:	7a e0       	ldi	r23, 0x0A	; 10
     eb0:	b6 95       	lsr	r27
     eb2:	a7 95       	ror	r26
     eb4:	97 95       	ror	r25
     eb6:	87 95       	ror	r24
     eb8:	7a 95       	dec	r23
     eba:	d1 f7       	brne	.-12     	; 0xeb0 <update_control_voltages+0x252>
     ebc:	70 2d       	mov	r23, r0
	uint16_t filter_cutoff_cv = divided_pitch_cv + (current_patch.cutoff << 4); //filter cutoff CV is the sum of filter cutoff pot and key track amount.
     ebe:	60 91 e8 02 	lds	r22, 0x02E8
     ec2:	70 91 e9 02 	lds	r23, 0x02E9
     ec6:	62 95       	swap	r22
     ec8:	72 95       	swap	r23
     eca:	70 7f       	andi	r23, 0xF0	; 240
     ecc:	76 27       	eor	r23, r22
     ece:	60 7f       	andi	r22, 0xF0	; 240
     ed0:	76 27       	eor	r23, r22
     ed2:	86 0f       	add	r24, r22
     ed4:	97 1f       	adc	r25, r23
	if (filter_cutoff_cv > MAX) filter_cutoff_cv = MAX; //make sure there is no overflow/wrap by capping max
	set_control_voltage(&cutoff_cv, filter_cutoff_cv);	
     ed6:	bc 01       	movw	r22, r24
     ed8:	80 e4       	ldi	r24, 0x40	; 64
     eda:	60 30       	cpi	r22, 0x00	; 0
     edc:	78 07       	cpc	r23, r24
     ede:	10 f0       	brcs	.+4      	; 0xee4 <update_control_voltages+0x286>
     ee0:	6f ef       	ldi	r22, 0xFF	; 255
     ee2:	7f e3       	ldi	r23, 0x3F	; 63
     ee4:	84 ed       	ldi	r24, 0xD4	; 212
     ee6:	91 e0       	ldi	r25, 0x01	; 1
     ee8:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	
	set_control_voltage(&fil_vco2_cv, (current_patch.fil_vco2) << 4);
     eec:	60 91 ec 02 	lds	r22, 0x02EC
     ef0:	70 91 ed 02 	lds	r23, 0x02ED
     ef4:	62 95       	swap	r22
     ef6:	72 95       	swap	r23
     ef8:	70 7f       	andi	r23, 0xF0	; 240
     efa:	76 27       	eor	r23, r22
     efc:	60 7f       	andi	r22, 0xF0	; 240
     efe:	76 27       	eor	r23, r22
     f00:	82 ed       	ldi	r24, 0xD2	; 210
     f02:	91 e0       	ldi	r25, 0x01	; 1
     f04:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&fil_lfo_cv, (current_patch.fil_lfo) << 4);
     f08:	60 91 ee 02 	lds	r22, 0x02EE
     f0c:	70 91 ef 02 	lds	r23, 0x02EF
     f10:	62 95       	swap	r22
     f12:	72 95       	swap	r23
     f14:	70 7f       	andi	r23, 0xF0	; 240
     f16:	76 27       	eor	r23, r22
     f18:	60 7f       	andi	r22, 0xF0	; 240
     f1a:	76 27       	eor	r23, r22
     f1c:	81 ed       	ldi	r24, 0xD1	; 209
     f1e:	91 e0       	ldi	r25, 0x01	; 1
     f20:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&noise_mix_cv, (current_patch.noise_mix) << 4);
     f24:	60 91 f0 02 	lds	r22, 0x02F0
     f28:	70 91 f1 02 	lds	r23, 0x02F1
     f2c:	62 95       	swap	r22
     f2e:	72 95       	swap	r23
     f30:	70 7f       	andi	r23, 0xF0	; 240
     f32:	76 27       	eor	r23, r22
     f34:	60 7f       	andi	r22, 0xF0	; 240
     f36:	76 27       	eor	r23, r22
     f38:	80 ed       	ldi	r24, 0xD0	; 208
     f3a:	91 e0       	ldi	r25, 0x01	; 1
     f3c:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&attack_2_cv, (current_patch.attack_2) << 4);
     f40:	60 91 f2 02 	lds	r22, 0x02F2
     f44:	70 91 f3 02 	lds	r23, 0x02F3
     f48:	62 95       	swap	r22
     f4a:	72 95       	swap	r23
     f4c:	70 7f       	andi	r23, 0xF0	; 240
     f4e:	76 27       	eor	r23, r22
     f50:	60 7f       	andi	r22, 0xF0	; 240
     f52:	76 27       	eor	r23, r22
     f54:	8f ec       	ldi	r24, 0xCF	; 207
     f56:	91 e0       	ldi	r25, 0x01	; 1
     f58:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&attack_1_cv, (current_patch.attack_1) << 4);
     f5c:	60 91 f4 02 	lds	r22, 0x02F4
     f60:	70 91 f5 02 	lds	r23, 0x02F5
     f64:	62 95       	swap	r22
     f66:	72 95       	swap	r23
     f68:	70 7f       	andi	r23, 0xF0	; 240
     f6a:	76 27       	eor	r23, r22
     f6c:	60 7f       	andi	r22, 0xF0	; 240
     f6e:	76 27       	eor	r23, r22
     f70:	8e ec       	ldi	r24, 0xCE	; 206
     f72:	91 e0       	ldi	r25, 0x01	; 1
     f74:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&decay_2_cv, (current_patch.decay_2) << 4);
     f78:	60 91 f6 02 	lds	r22, 0x02F6
     f7c:	70 91 f7 02 	lds	r23, 0x02F7
     f80:	62 95       	swap	r22
     f82:	72 95       	swap	r23
     f84:	70 7f       	andi	r23, 0xF0	; 240
     f86:	76 27       	eor	r23, r22
     f88:	60 7f       	andi	r22, 0xF0	; 240
     f8a:	76 27       	eor	r23, r22
     f8c:	8d ec       	ldi	r24, 0xCD	; 205
     f8e:	91 e0       	ldi	r25, 0x01	; 1
     f90:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&decay_1_cv, (current_patch.decay_1) << 4);
     f94:	60 91 f8 02 	lds	r22, 0x02F8
     f98:	70 91 f9 02 	lds	r23, 0x02F9
     f9c:	62 95       	swap	r22
     f9e:	72 95       	swap	r23
     fa0:	70 7f       	andi	r23, 0xF0	; 240
     fa2:	76 27       	eor	r23, r22
     fa4:	60 7f       	andi	r22, 0xF0	; 240
     fa6:	76 27       	eor	r23, r22
     fa8:	8c ec       	ldi	r24, 0xCC	; 204
     faa:	91 e0       	ldi	r25, 0x01	; 1
     fac:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&sustain_1_cv, (current_patch.sustain_1) << 4);
     fb0:	60 91 fc 02 	lds	r22, 0x02FC
     fb4:	70 91 fd 02 	lds	r23, 0x02FD
     fb8:	62 95       	swap	r22
     fba:	72 95       	swap	r23
     fbc:	70 7f       	andi	r23, 0xF0	; 240
     fbe:	76 27       	eor	r23, r22
     fc0:	60 7f       	andi	r22, 0xF0	; 240
     fc2:	76 27       	eor	r23, r22
     fc4:	8a ec       	ldi	r24, 0xCA	; 202
     fc6:	91 e0       	ldi	r25, 0x01	; 1
     fc8:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&sustain_2_cv, (current_patch.sustain_2) << 4);
     fcc:	60 91 fa 02 	lds	r22, 0x02FA
     fd0:	70 91 fb 02 	lds	r23, 0x02FB
     fd4:	62 95       	swap	r22
     fd6:	72 95       	swap	r23
     fd8:	70 7f       	andi	r23, 0xF0	; 240
     fda:	76 27       	eor	r23, r22
     fdc:	60 7f       	andi	r22, 0xF0	; 240
     fde:	76 27       	eor	r23, r22
     fe0:	8b ec       	ldi	r24, 0xCB	; 203
     fe2:	91 e0       	ldi	r25, 0x01	; 1
     fe4:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&release_1_cv, (current_patch.release_1) << 4);
     fe8:	60 91 00 03 	lds	r22, 0x0300
     fec:	70 91 01 03 	lds	r23, 0x0301
     ff0:	62 95       	swap	r22
     ff2:	72 95       	swap	r23
     ff4:	70 7f       	andi	r23, 0xF0	; 240
     ff6:	76 27       	eor	r23, r22
     ff8:	60 7f       	andi	r22, 0xF0	; 240
     ffa:	76 27       	eor	r23, r22
     ffc:	88 ec       	ldi	r24, 0xC8	; 200
     ffe:	91 e0       	ldi	r25, 0x01	; 1
    1000:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&release_2_cv, (current_patch.release_2) << 4);
    1004:	60 91 fe 02 	lds	r22, 0x02FE
    1008:	70 91 ff 02 	lds	r23, 0x02FF
    100c:	62 95       	swap	r22
    100e:	72 95       	swap	r23
    1010:	70 7f       	andi	r23, 0xF0	; 240
    1012:	76 27       	eor	r23, r22
    1014:	60 7f       	andi	r22, 0xF0	; 240
    1016:	76 27       	eor	r23, r22
    1018:	89 ec       	ldi	r24, 0xC9	; 201
    101a:	91 e0       	ldi	r25, 0x01	; 1
    101c:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>

	//set VCO1 and VCO2 pitch control voltages. Remember, set_control_voltage() is expecting a pointer to a control_voltage struct
	//that contains the control_voltage multiplexer channel and the multiplexer address
	

	uint8_t vco1_note = transpose_note(note, VCO1); //transpose
    1020:	8c 2f       	mov	r24, r28
    1022:	6f e0       	ldi	r22, 0x0F	; 15
    1024:	0e 94 cc 0d 	call	0x1b98	; 0x1b98 <transpose_note>

	interpolated_pitch_cv = interpolate_pitch_cv(vco1_note, vco1_pitch_table);
    1028:	65 e5       	ldi	r22, 0x55	; 85
    102a:	73 e0       	ldi	r23, 0x03	; 3
    102c:	0e 94 b2 16 	call	0x2d64	; 0x2d64 <interpolate_pitch_cv>
    1030:	bc 01       	movw	r22, r24
	
	//value_to_display = interpolated_pitch_cv;
	
	set_control_voltage(&vco1_pitch_cv, interpolated_pitch_cv);
    1032:	86 ee       	ldi	r24, 0xE6	; 230
    1034:	91 e0       	ldi	r25, 0x01	; 1
    1036:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	
	uint8_t vco2_note = transpose_note(note, VCO2);
    103a:	8c 2f       	mov	r24, r28
    103c:	60 ef       	ldi	r22, 0xF0	; 240
    103e:	0e 94 cc 0d 	call	0x1b98	; 0x1b98 <transpose_note>
	
	interpolated_pitch_cv = interpolate_pitch_cv(vco2_note, vco2_pitch_table);
    1042:	63 e3       	ldi	r22, 0x33	; 51
    1044:	73 e0       	ldi	r23, 0x03	; 3
    1046:	0e 94 b2 16 	call	0x2d64	; 0x2d64 <interpolate_pitch_cv>
    104a:	bc 01       	movw	r22, r24
	
	set_control_voltage(&vco2_pitch_cv, interpolated_pitch_cv);
    104c:	85 ee       	ldi	r24, 0xE5	; 229
    104e:	91 e0       	ldi	r25, 0x01	; 1
    1050:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
		
	DAC_CTRL &= ~(1<<DAC_RS); //reset DAC
    1054:	a1 98       	cbi	0x14, 1	; 20
	DAC_CTRL |= (1<<DAC_RS);
    1056:	a1 9a       	sbi	0x14, 1	; 20
	
	system_clock.rate = (1023 - arp_rate_pot.value) + 244;    
    1058:	20 91 88 01 	lds	r18, 0x0188
    105c:	80 91 89 01 	lds	r24, 0x0189
    1060:	38 2f       	mov	r19, r24
    1062:	33 70       	andi	r19, 0x03	; 3
    1064:	83 ef       	ldi	r24, 0xF3	; 243
    1066:	94 e0       	ldi	r25, 0x04	; 4
    1068:	82 1b       	sub	r24, r18
    106a:	93 0b       	sbc	r25, r19
    106c:	90 93 db 03 	sts	0x03DB, r25
    1070:	80 93 da 03 	sts	0x03DA, r24
	
	if (system_clock.rate != system_clock.previous_rate) {
    1074:	20 91 dc 03 	lds	r18, 0x03DC
    1078:	30 91 dd 03 	lds	r19, 0x03DD
    107c:	82 17       	cp	r24, r18
    107e:	93 07       	cpc	r25, r19
    1080:	11 f0       	breq	.+4      	; 0x1086 <update_control_voltages+0x428>
		
		update_clock_rate(system_clock.rate);
    1082:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <update_clock_rate>
	
	}
	
	system_clock.previous_rate = system_clock.rate;
    1086:	80 91 da 03 	lds	r24, 0x03DA
    108a:	90 91 db 03 	lds	r25, 0x03DB
    108e:	90 93 dd 03 	sts	0x03DD, r25
    1092:	80 93 dc 03 	sts	0x03DC, r24
	
}			
    1096:	df 91       	pop	r29
    1098:	cf 91       	pop	r28
    109a:	08 95       	ret

0000109c <setup_spi>:
void setup_spi(void) {
	
		//SET SPI_DATA_OUT and SPI_CLK and SPI_SW_LATCH pins as outputs
		//also set Slave Select (PB0) as output just to ensure it doesn't interfere with SPI communication (currently floating)
		//ACTUALLY, Slave Select ***MUST*** be set as output. Leaving it floating without setting its data direction bit breaks SPI!
		DDRB |= (SPI_DATA_OUT | SPI_CLK | SPI_SW_LATCH |(1<<PB0));
    109c:	84 b1       	in	r24, 0x04	; 4
    109e:	87 62       	ori	r24, 0x27	; 39
    10a0:	84 b9       	out	0x04, r24	; 4
		
		//SET SPI_EN and LED_LATCH and VCO_SW_LATCH and EG2_POL pins as outputs
		DDRJ |= (SPI_EN | LED_LATCH | (1<<VCO_SW_LATCH) | (1<<EG2_POL));
    10a2:	ec ed       	ldi	r30, 0xDC	; 220
    10a4:	f0 e0       	ldi	r31, 0x00	; 0
    10a6:	80 81       	ld	r24, Z
    10a8:	8c 65       	ori	r24, 0x5C	; 92
    10aa:	80 83       	st	Z, r24
		
		//SET SPI_DATA_OUT and SPI_CLK and SPI_SW_LATCH outputs LOW
		SPI_PORT &= ~(SPI_DATA_OUT | SPI_CLK | SPI_SW_LATCH);
    10ac:	85 b1       	in	r24, 0x05	; 5
    10ae:	89 7d       	andi	r24, 0xD9	; 217
    10b0:	85 b9       	out	0x05, r24	; 5
		
		//SET SPI_EN LOW (active) and LED_LATCH LOW (active)
		SPI_LATCH_PORT &= ~(SPI_EN | LED_LATCH);
    10b2:	ed ed       	ldi	r30, 0xDD	; 221
    10b4:	f0 e0       	ldi	r31, 0x00	; 0
    10b6:	80 81       	ld	r24, Z
    10b8:	83 7f       	andi	r24, 0xF3	; 243
    10ba:	80 83       	st	Z, r24
		
		//SET UP SPI
		SPCR = (1<<SPE) | (1<<MSTR); //Start SPI as MASTER
    10bc:	80 e5       	ldi	r24, 0x50	; 80
    10be:	8c bd       	out	0x2c, r24	; 44
		
		//Pull LED_LATCH LOW
		SPI_LATCH_PORT &= ~LED_LATCH;
    10c0:	80 81       	ld	r24, Z
    10c2:	87 7f       	andi	r24, 0xF7	; 247
    10c4:	80 83       	st	Z, r24
		
		
		//Toggle LED_LATCH to shift data to 74HC595 shift register outputs
		
		SPI_LATCH_PORT &= ~LED_LATCH;
    10c6:	80 81       	ld	r24, Z
    10c8:	87 7f       	andi	r24, 0xF7	; 247
    10ca:	80 83       	st	Z, r24
		SPI_LATCH_PORT |= LED_LATCH;
    10cc:	80 81       	ld	r24, Z
    10ce:	88 60       	ori	r24, 0x08	; 8
    10d0:	80 83       	st	Z, r24
		
		//set EG2 POL
		EG2_POL_PORT &= ~(1 << EG2_POL); //0 for normal, 1 for inverted
    10d2:	80 81       	ld	r24, Z
    10d4:	8f 7e       	andi	r24, 0xEF	; 239
    10d6:	80 83       	st	Z, r24
	
}
    10d8:	08 95       	ret

000010da <spi_shift_byte>:

uint8_t spi_shift_byte(uint8_t byte) { //shifts out byte for LED data and simultaneously reads switch data
	
	SPDR = byte;
    10da:	8e bd       	out	0x2e, r24	; 46
	while (!(SPSR & (1<<SPIF)));
    10dc:	0d b4       	in	r0, 0x2d	; 45
    10de:	07 fe       	sbrs	r0, 7
    10e0:	fd cf       	rjmp	.-6      	; 0x10dc <spi_shift_byte+0x2>
	return SPDR;
    10e2:	8e b5       	in	r24, 0x2e	; 46
	
}
    10e4:	08 95       	ret

000010e6 <update_spi>:

void update_spi(void) {
	
			SPI_PORT |= SPI_SW_LATCH;
    10e6:	2d 9a       	sbi	0x05, 5	; 5
			
			//SHIFT 5th BYTE				
			//Read SPDR for switch data shifted in from 74XX165 U14 and write LED data to LED latch 5
			spi_sw_byte0_current_state = spi_shift_byte(current_patch.byte_5);
    10e8:	80 91 06 03 	lds	r24, 0x0306
    10ec:	0e 94 6d 08 	call	0x10da	; 0x10da <spi_shift_byte>
			switch_press |= spi_sw_byte0_current_state; //set switch press global flag
    10f0:	90 91 c5 02 	lds	r25, 0x02C5
    10f4:	98 2b       	or	r25, r24
    10f6:	90 93 c5 02 	sts	0x02C5, r25
			spi_sw_byte0_current_state ^= spi_sw_byte0_previous_state;
    10fa:	20 91 c3 02 	lds	r18, 0x02C3
    10fe:	98 2f       	mov	r25, r24
    1100:	92 27       	eor	r25, r18
			spi_sw_byte0_previous_state ^= spi_sw_byte0_current_state;
    1102:	89 2f       	mov	r24, r25
    1104:	82 27       	eor	r24, r18
    1106:	80 93 c3 02 	sts	0x02C3, r24
			spi_sw_byte0_current_state &= spi_sw_byte0_previous_state;
    110a:	89 23       	and	r24, r25
    110c:	80 93 c4 02 	sts	0x02C4, r24
			
			//toggle switch state		
			switch_states.byte0 ^= spi_sw_byte0_current_state; //Omar's solution.
    1110:	90 91 82 03 	lds	r25, 0x0382
    1114:	89 27       	eor	r24, r25
    1116:	80 93 82 03 	sts	0x0382, r24
			//Now read SPDR for switch data shifted in from 74XX165 (U9)
			//uint8_t spi_data = (1<<VCO2_32F | 1<<VCO1_32F); //turn on 32' octave LEDs as default 
			
			uint8_t spi_data = current_patch.byte_4;
					
			spi_sw_byte1_current_state = spi_shift_byte(spi_data);
    111a:	80 91 05 03 	lds	r24, 0x0305
    111e:	0e 94 6d 08 	call	0x10da	; 0x10da <spi_shift_byte>
			switch_press |= spi_sw_byte1_current_state;
    1122:	90 91 c5 02 	lds	r25, 0x02C5
    1126:	98 2b       	or	r25, r24
    1128:	90 93 c5 02 	sts	0x02C5, r25
			spi_sw_byte1_current_state ^= spi_sw_byte1_previous_state;
    112c:	20 91 c1 02 	lds	r18, 0x02C1
    1130:	98 2f       	mov	r25, r24
    1132:	92 27       	eor	r25, r18
			spi_sw_byte1_previous_state ^= spi_sw_byte1_current_state;
    1134:	89 2f       	mov	r24, r25
    1136:	82 27       	eor	r24, r18
    1138:	80 93 c1 02 	sts	0x02C1, r24
			spi_sw_byte1_current_state &= spi_sw_byte1_previous_state;
    113c:	89 23       	and	r24, r25
    113e:	80 93 c2 02 	sts	0x02C2, r24
			
			//toggle switch state
			switch_states.byte1 ^= spi_sw_byte1_current_state; //Omar's solution.			
    1142:	90 91 83 03 	lds	r25, 0x0383
    1146:	89 27       	eor	r24, r25
    1148:	80 93 83 03 	sts	0x0383, r24
							
			//SHIFT 3th BYTE
			spi_shift_byte(current_patch.byte_3);
    114c:	80 91 04 03 	lds	r24, 0x0304
    1150:	0e 94 6d 08 	call	0x10da	; 0x10da <spi_shift_byte>

			//SHIFT 2th BYTE
			spi_shift_byte(current_patch.byte_2);
    1154:	80 91 03 03 	lds	r24, 0x0303
    1158:	0e 94 6d 08 	call	0x10da	; 0x10da <spi_shift_byte>
			
			//SHIFT 1st BYTE	//eventually need to parse this elsewhere		
			spi_data =	//((switch_states.byte1 >> ARP_MODE_SW) & 1) << ARP_MODE | 
    115c:	80 91 0b 03 	lds	r24, 0x030B
    1160:	83 30       	cpi	r24, 0x03	; 3
    1162:	11 f4       	brne	.+4      	; 0x1168 <__stack+0x69>
    1164:	20 e8       	ldi	r18, 0x80	; 128
    1166:	01 c0       	rjmp	.+2      	; 0x116a <__stack+0x6b>
    1168:	20 e0       	ldi	r18, 0x00	; 0
						//((switch_states.byte2 >> PROG_WRITE_SW) & 1) << PROG_WRITE | 
						((current_patch.mode == WRITE) << PROG_WRITE) | //hack to light PROG WRITE LED only when in WRITE mode
						//((switch_states.byte2 >> EG2_INV_SW) &1 ) << EG2_INV |
						((switch_states.byte2 >> PROG_MANUAL_SW &1) << PROG_MANUAL) |
    116a:	80 91 84 03 	lds	r24, 0x0384
    116e:	88 1f       	adc	r24, r24
    1170:	88 27       	eor	r24, r24
    1172:	88 1f       	adc	r24, r24
    1174:	82 95       	swap	r24
    1176:	88 0f       	add	r24, r24
    1178:	88 0f       	add	r24, r24
    117a:	80 7c       	andi	r24, 0xC0	; 192

			//SHIFT 2th BYTE
			spi_shift_byte(current_patch.byte_2);
			
			//SHIFT 1st BYTE	//eventually need to parse this elsewhere		
			spi_data =	//((switch_states.byte1 >> ARP_MODE_SW) & 1) << ARP_MODE | 
    117c:	90 91 02 03 	lds	r25, 0x0302
    1180:	89 2b       	or	r24, r25
						((current_patch.mode == WRITE) << PROG_WRITE) | //hack to light PROG WRITE LED only when in WRITE mode
						//((switch_states.byte2 >> EG2_INV_SW) &1 ) << EG2_INV |
						((switch_states.byte2 >> PROG_MANUAL_SW &1) << PROG_MANUAL) |
						((current_patch.byte_1)); 			
			//Wait for SPI shift to complete
			spi_shift_byte(spi_data);
    1182:	82 2b       	or	r24, r18
    1184:	0e 94 6d 08 	call	0x10da	; 0x10da <spi_shift_byte>
			
			//Toggle LED_LATCH to shift data to 74HC595 shift register outputs
			
			SPI_LATCH_PORT &= ~LED_LATCH;
    1188:	ed ed       	ldi	r30, 0xDD	; 221
    118a:	f0 e0       	ldi	r31, 0x00	; 0
    118c:	80 81       	ld	r24, Z
    118e:	87 7f       	andi	r24, 0xF7	; 247
    1190:	80 83       	st	Z, r24
			SPI_LATCH_PORT |= LED_LATCH;
    1192:	80 81       	ld	r24, Z
    1194:	88 60       	ori	r24, 0x08	; 8
    1196:	80 83       	st	Z, r24
			
			//clear SPI_SW_LATCH
			SPI_PORT &= ~SPI_SW_LATCH;
    1198:	2d 98       	cbi	0x05, 5	; 5
			
			

	
    119a:	08 95       	ret

0000119c <lock_pots>:
		LFO_PULSE_ADDR,
		LFO_RNDM_ADDR
	};
	

void lock_pots(void) { //run this every time new patch is loaded to lock pots and store locked values
    119c:	a0 e0       	ldi	r26, 0x00	; 0
    119e:	b1 e0       	ldi	r27, 0x01	; 1
    11a0:	9d 01       	movw	r18, r26
    11a2:	24 5c       	subi	r18, 0xC4	; 196
    11a4:	3f 4f       	sbci	r19, 0xFF	; 255

for (int i = 0; i <= NUM_POTS; i++) {
	
	pot_id[i]->locked_value = (pot_id[i]->value) >> 2;
    11a6:	ed 91       	ld	r30, X+
    11a8:	fc 91       	ld	r31, X
    11aa:	11 97       	sbiw	r26, 0x01	; 1
    11ac:	80 81       	ld	r24, Z
    11ae:	41 81       	ldd	r20, Z+1	; 0x01
    11b0:	94 2f       	mov	r25, r20
    11b2:	93 70       	andi	r25, 0x03	; 3
    11b4:	95 95       	asr	r25
    11b6:	87 95       	ror	r24
    11b8:	95 95       	asr	r25
    11ba:	87 95       	ror	r24
    11bc:	82 83       	std	Z+2, r24	; 0x02
	pot_id[i]->locked = 1;
    11be:	ed 91       	ld	r30, X+
    11c0:	fd 91       	ld	r31, X+
    11c2:	83 81       	ldd	r24, Z+3	; 0x03
    11c4:	80 68       	ori	r24, 0x80	; 128
    11c6:	83 83       	std	Z+3, r24	; 0x03
	};
	

void lock_pots(void) { //run this every time new patch is loaded to lock pots and store locked values

for (int i = 0; i <= NUM_POTS; i++) {
    11c8:	a2 17       	cp	r26, r18
    11ca:	b3 07       	cpc	r27, r19
    11cc:	61 f7       	brne	.-40     	; 0x11a6 <lock_pots+0xa>
	pot_id[i]->locked_value = (pot_id[i]->value) >> 2;
	pot_id[i]->locked = 1;
	
}

}
    11ce:	08 95       	ret

000011d0 <unlock_pots>:

void unlock_pots(void) {
    11d0:	e0 e0       	ldi	r30, 0x00	; 0
    11d2:	f1 e0       	ldi	r31, 0x01	; 1
    11d4:	cf 01       	movw	r24, r30
    11d6:	cc 96       	adiw	r24, 0x3c	; 60
	
	for (int i = 0; i <= NUM_POTS; i++) {
		
		pot_id[i]->locked = 0;
    11d8:	a1 91       	ld	r26, Z+
    11da:	b1 91       	ld	r27, Z+
    11dc:	13 96       	adiw	r26, 0x03	; 3
    11de:	2c 91       	ld	r18, X
    11e0:	13 97       	sbiw	r26, 0x03	; 3
    11e2:	2f 77       	andi	r18, 0x7F	; 127
    11e4:	13 96       	adiw	r26, 0x03	; 3
    11e6:	2c 93       	st	X, r18
    11e8:	13 97       	sbiw	r26, 0x03	; 3

}

void unlock_pots(void) {
	
	for (int i = 0; i <= NUM_POTS; i++) {
    11ea:	e8 17       	cp	r30, r24
    11ec:	f9 07       	cpc	r31, r25
    11ee:	a1 f7       	brne	.-24     	; 0x11d8 <unlock_pots+0x8>
		
		pot_id[i]->locked = 0;
		
	}
	
}			
    11f0:	08 95       	ret

000011f2 <save_patch>:
	
	
void save_patch(uint8_t patch_number) {
    11f2:	1f 93       	push	r17
    11f4:	cf 93       	push	r28
    11f6:	df 93       	push	r29
    11f8:	cd b7       	in	r28, 0x3d	; 61
    11fa:	de b7       	in	r29, 0x3e	; 62
    11fc:	ab 97       	sbiw	r28, 0x2b	; 43
    11fe:	0f b6       	in	r0, 0x3f	; 63
    1200:	f8 94       	cli
    1202:	de bf       	out	0x3e, r29	; 62
    1204:	0f be       	out	0x3f, r0	; 63
    1206:	cd bf       	out	0x3d, r28	; 61
    1208:	18 2f       	mov	r17, r24
	
	struct eeprom_patch patch_to_save;
	//because of bit fields in eeprom patch struct, a temporary eeprom patch needs to be filled with current_patch values and then saved to memory.
	
	patch_to_save.vco2_pw = current_patch.vco2_pw;
    120a:	e2 ee       	ldi	r30, 0xE2	; 226
    120c:	f2 e0       	ldi	r31, 0x02	; 2
    120e:	20 91 e2 02 	lds	r18, 0x02E2
    1212:	82 2f       	mov	r24, r18
    1214:	82 95       	swap	r24
    1216:	80 7f       	andi	r24, 0xF0	; 240
    1218:	22 95       	swap	r18
    121a:	2f 70       	andi	r18, 0x0F	; 15
    121c:	90 91 e3 02 	lds	r25, 0x02E3
    1220:	93 70       	andi	r25, 0x03	; 3
    1222:	92 95       	swap	r25
    1224:	90 7f       	andi	r25, 0xF0	; 240
	patch_to_save.vco1_mix = current_patch.vco1_mix; //YOU'RE MISSING VCO2_MIX HERE YOU NITWIT
    1226:	df 01       	movw	r26, r30
    1228:	5a 97       	sbiw	r26, 0x1a	; 26
    122a:	3c 91       	ld	r19, X
    122c:	53 2f       	mov	r21, r19
    122e:	55 0f       	add	r21, r21
    1230:	55 0f       	add	r21, r21
    1232:	4a 81       	ldd	r20, Y+2	; 0x02
    1234:	43 70       	andi	r20, 0x03	; 3
    1236:	45 2b       	or	r20, r21
    1238:	4a 83       	std	Y+2, r20	; 0x02
    123a:	63 2f       	mov	r22, r19
    123c:	62 95       	swap	r22
    123e:	66 95       	lsr	r22
    1240:	66 95       	lsr	r22
    1242:	63 70       	andi	r22, 0x03	; 3
    1244:	11 96       	adiw	r26, 0x01	; 1
    1246:	4c 91       	ld	r20, X
    1248:	43 70       	andi	r20, 0x03	; 3
    124a:	44 0f       	add	r20, r20
    124c:	44 0f       	add	r20, r20
	patch_to_save.pitch_eg2 = current_patch.pitch_eg2;
    124e:	df 01       	movw	r26, r30
    1250:	58 97       	sbiw	r26, 0x18	; 24
    1252:	3c 91       	ld	r19, X
    1254:	53 2f       	mov	r21, r19
    1256:	52 95       	swap	r21
    1258:	50 7f       	andi	r21, 0xF0	; 240
    125a:	46 2b       	or	r20, r22
    125c:	45 2b       	or	r20, r21
    125e:	4b 83       	std	Y+3, r20	; 0x03
    1260:	63 2f       	mov	r22, r19
    1262:	62 95       	swap	r22
    1264:	6f 70       	andi	r22, 0x0F	; 15
    1266:	11 96       	adiw	r26, 0x01	; 1
    1268:	4c 91       	ld	r20, X
    126a:	43 70       	andi	r20, 0x03	; 3
    126c:	42 95       	swap	r20
    126e:	40 7f       	andi	r20, 0xF0	; 240
	patch_to_save.pitch_vco2 = current_patch.pitch_vco2;
    1270:	df 01       	movw	r26, r30
    1272:	56 97       	sbiw	r26, 0x16	; 22
    1274:	3c 91       	ld	r19, X
    1276:	53 2f       	mov	r21, r19
    1278:	52 95       	swap	r21
    127a:	55 0f       	add	r21, r21
    127c:	55 0f       	add	r21, r21
    127e:	50 7c       	andi	r21, 0xC0	; 192
    1280:	46 2b       	or	r20, r22
    1282:	45 2b       	or	r20, r21
    1284:	4c 83       	std	Y+4, r20	; 0x04
    1286:	11 96       	adiw	r26, 0x01	; 1
    1288:	4c 91       	ld	r20, X
    128a:	42 95       	swap	r20
    128c:	44 0f       	add	r20, r20
    128e:	44 0f       	add	r20, r20
    1290:	40 7c       	andi	r20, 0xC0	; 192
    1292:	36 95       	lsr	r19
    1294:	36 95       	lsr	r19
    1296:	34 2b       	or	r19, r20
    1298:	3d 83       	std	Y+5, r19	; 0x05
	patch_to_save.pitch_lfo = current_patch.pitch_lfo;
    129a:	df 01       	movw	r26, r30
    129c:	54 97       	sbiw	r26, 0x14	; 20
    129e:	3c 91       	ld	r19, X
    12a0:	3e 83       	std	Y+6, r19	; 0x06
    12a2:	11 96       	adiw	r26, 0x01	; 1
    12a4:	4c 91       	ld	r20, X
	patch_to_save.pwm_lfo = current_patch.pwm_lfo;
    12a6:	df 01       	movw	r26, r30
    12a8:	52 97       	sbiw	r26, 0x12	; 18
    12aa:	3c 91       	ld	r19, X
    12ac:	53 2f       	mov	r21, r19
    12ae:	55 0f       	add	r21, r21
    12b0:	55 0f       	add	r21, r21
    12b2:	43 70       	andi	r20, 0x03	; 3
    12b4:	45 2b       	or	r20, r21
    12b6:	4f 83       	std	Y+7, r20	; 0x07
    12b8:	63 2f       	mov	r22, r19
    12ba:	62 95       	swap	r22
    12bc:	66 95       	lsr	r22
    12be:	66 95       	lsr	r22
    12c0:	63 70       	andi	r22, 0x03	; 3
    12c2:	11 96       	adiw	r26, 0x01	; 1
    12c4:	4c 91       	ld	r20, X
    12c6:	43 70       	andi	r20, 0x03	; 3
    12c8:	44 0f       	add	r20, r20
    12ca:	44 0f       	add	r20, r20
	patch_to_save.pwm_eg2 = current_patch.pwm_eg2;
    12cc:	df 01       	movw	r26, r30
    12ce:	50 97       	sbiw	r26, 0x10	; 16
    12d0:	3c 91       	ld	r19, X
    12d2:	53 2f       	mov	r21, r19
    12d4:	52 95       	swap	r21
    12d6:	50 7f       	andi	r21, 0xF0	; 240
    12d8:	46 2b       	or	r20, r22
    12da:	45 2b       	or	r20, r21
    12dc:	48 87       	std	Y+8, r20	; 0x08
    12de:	63 2f       	mov	r22, r19
    12e0:	62 95       	swap	r22
    12e2:	6f 70       	andi	r22, 0x0F	; 15
    12e4:	11 96       	adiw	r26, 0x01	; 1
    12e6:	4c 91       	ld	r20, X
    12e8:	43 70       	andi	r20, 0x03	; 3
    12ea:	42 95       	swap	r20
    12ec:	40 7f       	andi	r20, 0xF0	; 240
	patch_to_save.vco1_pw = current_patch.vco1_pw;
    12ee:	df 01       	movw	r26, r30
    12f0:	1e 97       	sbiw	r26, 0x0e	; 14
    12f2:	3c 91       	ld	r19, X
    12f4:	53 2f       	mov	r21, r19
    12f6:	52 95       	swap	r21
    12f8:	55 0f       	add	r21, r21
    12fa:	55 0f       	add	r21, r21
    12fc:	50 7c       	andi	r21, 0xC0	; 192
    12fe:	46 2b       	or	r20, r22
    1300:	45 2b       	or	r20, r21
    1302:	49 87       	std	Y+9, r20	; 0x09
    1304:	11 96       	adiw	r26, 0x01	; 1
    1306:	4c 91       	ld	r20, X
    1308:	42 95       	swap	r20
    130a:	44 0f       	add	r20, r20
    130c:	44 0f       	add	r20, r20
    130e:	40 7c       	andi	r20, 0xC0	; 192
    1310:	36 95       	lsr	r19
    1312:	36 95       	lsr	r19
    1314:	34 2b       	or	r19, r20
    1316:	3a 87       	std	Y+10, r19	; 0x0a
	patch_to_save.fine = current_patch.fine;
    1318:	df 01       	movw	r26, r30
    131a:	1c 97       	sbiw	r26, 0x0c	; 12
    131c:	3c 91       	ld	r19, X
    131e:	3b 87       	std	Y+11, r19	; 0x0b
    1320:	11 96       	adiw	r26, 0x01	; 1
    1322:	4c 91       	ld	r20, X
	patch_to_save.tune = current_patch.tune; //probably shouldn't save master tune value. Like volume, it is a parameter that doesn't apply to a patch.
    1324:	df 01       	movw	r26, r30
    1326:	1a 97       	sbiw	r26, 0x0a	; 10
    1328:	3c 91       	ld	r19, X
    132a:	53 2f       	mov	r21, r19
    132c:	55 0f       	add	r21, r21
    132e:	55 0f       	add	r21, r21
    1330:	43 70       	andi	r20, 0x03	; 3
    1332:	45 2b       	or	r20, r21
    1334:	4c 87       	std	Y+12, r20	; 0x0c
    1336:	63 2f       	mov	r22, r19
    1338:	62 95       	swap	r22
    133a:	66 95       	lsr	r22
    133c:	66 95       	lsr	r22
    133e:	63 70       	andi	r22, 0x03	; 3
    1340:	11 96       	adiw	r26, 0x01	; 1
    1342:	4c 91       	ld	r20, X
    1344:	43 70       	andi	r20, 0x03	; 3
    1346:	44 0f       	add	r20, r20
    1348:	44 0f       	add	r20, r20
	patch_to_save.lfo_rate = current_patch.lfo_rate;
    134a:	df 01       	movw	r26, r30
    134c:	18 97       	sbiw	r26, 0x08	; 8
    134e:	3c 91       	ld	r19, X
    1350:	53 2f       	mov	r21, r19
    1352:	52 95       	swap	r21
    1354:	50 7f       	andi	r21, 0xF0	; 240
    1356:	46 2b       	or	r20, r22
    1358:	45 2b       	or	r20, r21
    135a:	4d 87       	std	Y+13, r20	; 0x0d
    135c:	63 2f       	mov	r22, r19
    135e:	62 95       	swap	r22
    1360:	6f 70       	andi	r22, 0x0F	; 15
    1362:	11 96       	adiw	r26, 0x01	; 1
    1364:	4c 91       	ld	r20, X
    1366:	43 70       	andi	r20, 0x03	; 3
    1368:	42 95       	swap	r20
    136a:	40 7f       	andi	r20, 0xF0	; 240
	patch_to_save.arp_rate = current_patch.arp_rate;
    136c:	df 01       	movw	r26, r30
    136e:	16 97       	sbiw	r26, 0x06	; 6
    1370:	3c 91       	ld	r19, X
    1372:	53 2f       	mov	r21, r19
    1374:	52 95       	swap	r21
    1376:	55 0f       	add	r21, r21
    1378:	55 0f       	add	r21, r21
    137a:	50 7c       	andi	r21, 0xC0	; 192
    137c:	46 2b       	or	r20, r22
    137e:	45 2b       	or	r20, r21
    1380:	4e 87       	std	Y+14, r20	; 0x0e
    1382:	11 96       	adiw	r26, 0x01	; 1
    1384:	4c 91       	ld	r20, X
    1386:	42 95       	swap	r20
    1388:	44 0f       	add	r20, r20
    138a:	44 0f       	add	r20, r20
    138c:	40 7c       	andi	r20, 0xC0	; 192
    138e:	36 95       	lsr	r19
    1390:	36 95       	lsr	r19
    1392:	34 2b       	or	r19, r20
    1394:	3f 87       	std	Y+15, r19	; 0x0f
	patch_to_save.glide	= current_patch.glide;
    1396:	df 01       	movw	r26, r30
    1398:	14 97       	sbiw	r26, 0x04	; 4
    139a:	3c 91       	ld	r19, X
    139c:	38 8b       	std	Y+16, r19	; 0x10
    139e:	11 96       	adiw	r26, 0x01	; 1
    13a0:	4c 91       	ld	r20, X
	patch_to_save.amp_lfo = current_patch.amp_lfo;
    13a2:	df 01       	movw	r26, r30
    13a4:	12 97       	sbiw	r26, 0x02	; 2
    13a6:	3c 91       	ld	r19, X
    13a8:	53 2f       	mov	r21, r19
    13aa:	55 0f       	add	r21, r21
    13ac:	55 0f       	add	r21, r21
    13ae:	43 70       	andi	r20, 0x03	; 3
    13b0:	45 2b       	or	r20, r21
    13b2:	49 8b       	std	Y+17, r20	; 0x11
    13b4:	32 95       	swap	r19
    13b6:	36 95       	lsr	r19
    13b8:	36 95       	lsr	r19
    13ba:	33 70       	andi	r19, 0x03	; 3
    13bc:	11 96       	adiw	r26, 0x01	; 1
    13be:	4c 91       	ld	r20, X
    13c0:	43 70       	andi	r20, 0x03	; 3
    13c2:	44 0f       	add	r20, r20
    13c4:	44 0f       	add	r20, r20
    13c6:	83 2b       	or	r24, r19
    13c8:	84 2b       	or	r24, r20
    13ca:	8a 8b       	std	Y+18, r24	; 0x12
	patch_to_save.vco2_pw = current_patch.vco2_pw;
	
	patch_to_save.fil_eg2 = current_patch.fil_eg2;
    13cc:	80 91 e4 02 	lds	r24, 0x02E4
    13d0:	38 2f       	mov	r19, r24
    13d2:	32 95       	swap	r19
    13d4:	33 0f       	add	r19, r19
    13d6:	33 0f       	add	r19, r19
    13d8:	30 7c       	andi	r19, 0xC0	; 192
    13da:	92 2b       	or	r25, r18
    13dc:	93 2b       	or	r25, r19
    13de:	9b 8b       	std	Y+19, r25	; 0x13
    13e0:	93 81       	ldd	r25, Z+3	; 0x03
    13e2:	92 95       	swap	r25
    13e4:	99 0f       	add	r25, r25
    13e6:	99 0f       	add	r25, r25
    13e8:	90 7c       	andi	r25, 0xC0	; 192
    13ea:	86 95       	lsr	r24
    13ec:	86 95       	lsr	r24
    13ee:	89 2b       	or	r24, r25
    13f0:	8c 8b       	std	Y+20, r24	; 0x14
	patch_to_save.res = current_patch.res;
    13f2:	80 91 e6 02 	lds	r24, 0x02E6
    13f6:	8d 8b       	std	Y+21, r24	; 0x15
    13f8:	95 81       	ldd	r25, Z+5	; 0x05
	patch_to_save.cutoff = current_patch.cutoff;
    13fa:	80 91 e8 02 	lds	r24, 0x02E8
    13fe:	28 2f       	mov	r18, r24
    1400:	22 0f       	add	r18, r18
    1402:	22 0f       	add	r18, r18
    1404:	93 70       	andi	r25, 0x03	; 3
    1406:	92 2b       	or	r25, r18
    1408:	9e 8b       	std	Y+22, r25	; 0x16
    140a:	38 2f       	mov	r19, r24
    140c:	32 95       	swap	r19
    140e:	36 95       	lsr	r19
    1410:	36 95       	lsr	r19
    1412:	33 70       	andi	r19, 0x03	; 3
    1414:	97 81       	ldd	r25, Z+7	; 0x07
    1416:	93 70       	andi	r25, 0x03	; 3
    1418:	99 0f       	add	r25, r25
    141a:	99 0f       	add	r25, r25
	patch_to_save.key_track = current_patch.key_track;
    141c:	80 91 ea 02 	lds	r24, 0x02EA
    1420:	28 2f       	mov	r18, r24
    1422:	22 95       	swap	r18
    1424:	20 7f       	andi	r18, 0xF0	; 240
    1426:	93 2b       	or	r25, r19
    1428:	92 2b       	or	r25, r18
    142a:	9f 8b       	std	Y+23, r25	; 0x17
    142c:	38 2f       	mov	r19, r24
    142e:	32 95       	swap	r19
    1430:	3f 70       	andi	r19, 0x0F	; 15
    1432:	91 85       	ldd	r25, Z+9	; 0x09
    1434:	93 70       	andi	r25, 0x03	; 3
    1436:	92 95       	swap	r25
    1438:	90 7f       	andi	r25, 0xF0	; 240
	patch_to_save.fil_vco2 = current_patch.fil_vco2;
    143a:	80 91 ec 02 	lds	r24, 0x02EC
    143e:	28 2f       	mov	r18, r24
    1440:	22 95       	swap	r18
    1442:	22 0f       	add	r18, r18
    1444:	22 0f       	add	r18, r18
    1446:	20 7c       	andi	r18, 0xC0	; 192
    1448:	93 2b       	or	r25, r19
    144a:	92 2b       	or	r25, r18
    144c:	98 8f       	std	Y+24, r25	; 0x18
    144e:	93 85       	ldd	r25, Z+11	; 0x0b
    1450:	92 95       	swap	r25
    1452:	99 0f       	add	r25, r25
    1454:	99 0f       	add	r25, r25
    1456:	90 7c       	andi	r25, 0xC0	; 192
    1458:	86 95       	lsr	r24
    145a:	86 95       	lsr	r24
    145c:	89 2b       	or	r24, r25
    145e:	89 8f       	std	Y+25, r24	; 0x19
	patch_to_save.fil_lfo = current_patch.fil_lfo;
    1460:	80 91 ee 02 	lds	r24, 0x02EE
    1464:	8a 8f       	std	Y+26, r24	; 0x1a
    1466:	95 85       	ldd	r25, Z+13	; 0x0d
	patch_to_save.noise_mix = current_patch.noise_mix;
    1468:	80 91 f0 02 	lds	r24, 0x02F0
    146c:	28 2f       	mov	r18, r24
    146e:	22 0f       	add	r18, r18
    1470:	22 0f       	add	r18, r18
    1472:	93 70       	andi	r25, 0x03	; 3
    1474:	92 2b       	or	r25, r18
    1476:	9b 8f       	std	Y+27, r25	; 0x1b
    1478:	38 2f       	mov	r19, r24
    147a:	32 95       	swap	r19
    147c:	36 95       	lsr	r19
    147e:	36 95       	lsr	r19
    1480:	33 70       	andi	r19, 0x03	; 3
    1482:	97 85       	ldd	r25, Z+15	; 0x0f
    1484:	93 70       	andi	r25, 0x03	; 3
    1486:	99 0f       	add	r25, r25
    1488:	99 0f       	add	r25, r25
	patch_to_save.attack_2 = current_patch.attack_2;
    148a:	80 91 f2 02 	lds	r24, 0x02F2
    148e:	28 2f       	mov	r18, r24
    1490:	22 95       	swap	r18
    1492:	20 7f       	andi	r18, 0xF0	; 240
    1494:	93 2b       	or	r25, r19
    1496:	92 2b       	or	r25, r18
    1498:	9c 8f       	std	Y+28, r25	; 0x1c
    149a:	38 2f       	mov	r19, r24
    149c:	32 95       	swap	r19
    149e:	3f 70       	andi	r19, 0x0F	; 15
    14a0:	91 89       	ldd	r25, Z+17	; 0x11
    14a2:	93 70       	andi	r25, 0x03	; 3
    14a4:	92 95       	swap	r25
    14a6:	90 7f       	andi	r25, 0xF0	; 240
	patch_to_save.attack_1 = current_patch.attack_1;
    14a8:	80 91 f4 02 	lds	r24, 0x02F4
    14ac:	28 2f       	mov	r18, r24
    14ae:	22 95       	swap	r18
    14b0:	22 0f       	add	r18, r18
    14b2:	22 0f       	add	r18, r18
    14b4:	20 7c       	andi	r18, 0xC0	; 192
    14b6:	93 2b       	or	r25, r19
    14b8:	92 2b       	or	r25, r18
    14ba:	9d 8f       	std	Y+29, r25	; 0x1d
    14bc:	93 89       	ldd	r25, Z+19	; 0x13
    14be:	92 95       	swap	r25
    14c0:	99 0f       	add	r25, r25
    14c2:	99 0f       	add	r25, r25
    14c4:	90 7c       	andi	r25, 0xC0	; 192
    14c6:	86 95       	lsr	r24
    14c8:	86 95       	lsr	r24
    14ca:	89 2b       	or	r24, r25
    14cc:	8e 8f       	std	Y+30, r24	; 0x1e
	patch_to_save.decay_2 = current_patch.decay_2;
    14ce:	80 91 f6 02 	lds	r24, 0x02F6
    14d2:	8f 8f       	std	Y+31, r24	; 0x1f
    14d4:	95 89       	ldd	r25, Z+21	; 0x15
	patch_to_save.decay_1 = current_patch.decay_1;
    14d6:	80 91 f8 02 	lds	r24, 0x02F8
    14da:	28 2f       	mov	r18, r24
    14dc:	22 0f       	add	r18, r18
    14de:	22 0f       	add	r18, r18
    14e0:	93 70       	andi	r25, 0x03	; 3
    14e2:	92 2b       	or	r25, r18
    14e4:	98 a3       	lds	r25, 0x58
    14e6:	38 2f       	mov	r19, r24
    14e8:	32 95       	swap	r19
    14ea:	36 95       	lsr	r19
    14ec:	36 95       	lsr	r19
    14ee:	33 70       	andi	r19, 0x03	; 3
    14f0:	97 89       	ldd	r25, Z+23	; 0x17
    14f2:	93 70       	andi	r25, 0x03	; 3
    14f4:	99 0f       	add	r25, r25
    14f6:	99 0f       	add	r25, r25
	patch_to_save.sustain_2 = current_patch.sustain_2;
    14f8:	80 91 fa 02 	lds	r24, 0x02FA
    14fc:	28 2f       	mov	r18, r24
    14fe:	22 95       	swap	r18
    1500:	20 7f       	andi	r18, 0xF0	; 240
    1502:	93 2b       	or	r25, r19
    1504:	92 2b       	or	r25, r18
    1506:	99 a3       	lds	r25, 0x59
    1508:	38 2f       	mov	r19, r24
    150a:	32 95       	swap	r19
    150c:	3f 70       	andi	r19, 0x0F	; 15
    150e:	91 8d       	ldd	r25, Z+25	; 0x19
    1510:	93 70       	andi	r25, 0x03	; 3
    1512:	92 95       	swap	r25
    1514:	90 7f       	andi	r25, 0xF0	; 240
	patch_to_save.sustain_1 = current_patch.sustain_1;
    1516:	80 91 fc 02 	lds	r24, 0x02FC
    151a:	28 2f       	mov	r18, r24
    151c:	22 95       	swap	r18
    151e:	22 0f       	add	r18, r18
    1520:	22 0f       	add	r18, r18
    1522:	20 7c       	andi	r18, 0xC0	; 192
    1524:	93 2b       	or	r25, r19
    1526:	92 2b       	or	r25, r18
    1528:	9a a3       	lds	r25, 0x5a
    152a:	93 8d       	ldd	r25, Z+27	; 0x1b
    152c:	92 95       	swap	r25
    152e:	99 0f       	add	r25, r25
    1530:	99 0f       	add	r25, r25
    1532:	90 7c       	andi	r25, 0xC0	; 192
    1534:	86 95       	lsr	r24
    1536:	86 95       	lsr	r24
    1538:	89 2b       	or	r24, r25
    153a:	8b a3       	lds	r24, 0x5b
	patch_to_save.release_2 = current_patch.release_2;
    153c:	80 91 fe 02 	lds	r24, 0x02FE
    1540:	8c a3       	lds	r24, 0x5c
    1542:	95 8d       	ldd	r25, Z+29	; 0x1d
	patch_to_save.release_1 = current_patch.release_1;
    1544:	80 91 00 03 	lds	r24, 0x0300
    1548:	28 2f       	mov	r18, r24
    154a:	22 0f       	add	r18, r18
    154c:	22 0f       	add	r18, r18
    154e:	93 70       	andi	r25, 0x03	; 3
    1550:	92 2b       	or	r25, r18
    1552:	9d a3       	lds	r25, 0x5d
    1554:	82 95       	swap	r24
    1556:	86 95       	lsr	r24
    1558:	86 95       	lsr	r24
    155a:	83 70       	andi	r24, 0x03	; 3
    155c:	2e a1       	lds	r18, 0x4e
    155e:	20 7f       	andi	r18, 0xF0	; 240
    1560:	97 8d       	ldd	r25, Z+31	; 0x1f
    1562:	93 70       	andi	r25, 0x03	; 3
    1564:	99 0f       	add	r25, r25
    1566:	99 0f       	add	r25, r25
    1568:	82 2b       	or	r24, r18
    156a:	89 2b       	or	r24, r25
    156c:	8e a3       	lds	r24, 0x5e
	
		
	patch_to_save.byte_1 = current_patch.byte_1;
    156e:	80 91 02 03 	lds	r24, 0x0302
    1572:	8f a3       	lds	r24, 0x5f
	patch_to_save.byte_2 = current_patch.byte_2;
    1574:	80 91 03 03 	lds	r24, 0x0303
    1578:	88 a7       	lds	r24, 0x78
	patch_to_save.byte_3 = current_patch.byte_3;
    157a:	80 91 04 03 	lds	r24, 0x0304
    157e:	89 a7       	lds	r24, 0x79
	patch_to_save.byte_4 = current_patch.byte_4;
    1580:	80 91 05 03 	lds	r24, 0x0305
    1584:	8a a7       	lds	r24, 0x7a
	patch_to_save.byte_5 = current_patch.byte_5;
    1586:	80 91 06 03 	lds	r24, 0x0306
    158a:	8b a7       	lds	r24, 0x7b
	
	
	lock_pots();
    158c:	0e 94 ce 08 	call	0x119c	; 0x119c <lock_pots>
	//if (current_patch.mode == MANUAL) switch_states.byte2 &= ~(1<< PROG_MANUAL_SW); //if in MANUAL mode, turn off MANUAL LED
	switch_states.byte2 &= ~(1<< PROG_MANUAL_SW);
    1590:	80 91 84 03 	lds	r24, 0x0384
    1594:	8f 77       	andi	r24, 0x7F	; 127
    1596:	80 93 84 03 	sts	0x0384, r24
	current_patch.mode = MEMORY;
    159a:	10 92 0b 03 	sts	0x030B, r1
	
	eeprom_update_block((const void*)&patch_to_save, (void*)&patch_memory[patch_number], sizeof(patch_to_save));
    159e:	21 2f       	mov	r18, r17
    15a0:	30 e0       	ldi	r19, 0x00	; 0
    15a2:	8b e2       	ldi	r24, 0x2B	; 43
    15a4:	90 e0       	ldi	r25, 0x00	; 0
    15a6:	28 9f       	mul	r18, r24
    15a8:	b0 01       	movw	r22, r0
    15aa:	29 9f       	mul	r18, r25
    15ac:	70 0d       	add	r23, r0
    15ae:	38 9f       	mul	r19, r24
    15b0:	70 0d       	add	r23, r0
    15b2:	11 24       	eor	r1, r1
    15b4:	60 50       	subi	r22, 0x00	; 0
    15b6:	70 40       	sbci	r23, 0x00	; 0
    15b8:	ce 01       	movw	r24, r28
    15ba:	01 96       	adiw	r24, 0x01	; 1
    15bc:	4b e2       	ldi	r20, 0x2B	; 43
    15be:	50 e0       	ldi	r21, 0x00	; 0
    15c0:	0e 94 87 1f 	call	0x3f0e	; 0x3f0e <__eeupd_block_m6450a>
}	
    15c4:	ab 96       	adiw	r28, 0x2b	; 43
    15c6:	0f b6       	in	r0, 0x3f	; 63
    15c8:	f8 94       	cli
    15ca:	de bf       	out	0x3e, r29	; 62
    15cc:	0f be       	out	0x3f, r0	; 63
    15ce:	cd bf       	out	0x3d, r28	; 61
    15d0:	df 91       	pop	r29
    15d2:	cf 91       	pop	r28
    15d4:	1f 91       	pop	r17
    15d6:	08 95       	ret

000015d8 <load_patch>:
	
void load_patch(uint8_t patch_number) {
    15d8:	1f 93       	push	r17
    15da:	cf 93       	push	r28
    15dc:	df 93       	push	r29
    15de:	cd b7       	in	r28, 0x3d	; 61
    15e0:	de b7       	in	r29, 0x3e	; 62
    15e2:	c3 54       	subi	r28, 0x43	; 67
    15e4:	d0 40       	sbci	r29, 0x00	; 0
    15e6:	0f b6       	in	r0, 0x3f	; 63
    15e8:	f8 94       	cli
    15ea:	de bf       	out	0x3e, r29	; 62
    15ec:	0f be       	out	0x3f, r0	; 63
    15ee:	cd bf       	out	0x3d, r28	; 61
	
	struct eeprom_patch loaded_patch;
	//because of bit fields in eeprom patch struct, a temporary eeprom patch needs to be filled with current_patch values and then saved to memory.
	eeprom_read_block((void*)&loaded_patch, (const void*)&patch_memory[patch_number], sizeof(loaded_patch));
    15f0:	90 e0       	ldi	r25, 0x00	; 0
    15f2:	2b e2       	ldi	r18, 0x2B	; 43
    15f4:	30 e0       	ldi	r19, 0x00	; 0
    15f6:	82 9f       	mul	r24, r18
    15f8:	b0 01       	movw	r22, r0
    15fa:	83 9f       	mul	r24, r19
    15fc:	70 0d       	add	r23, r0
    15fe:	92 9f       	mul	r25, r18
    1600:	70 0d       	add	r23, r0
    1602:	11 24       	eor	r1, r1
    1604:	60 50       	subi	r22, 0x00	; 0
    1606:	70 40       	sbci	r23, 0x00	; 0
    1608:	ce 01       	movw	r24, r28
    160a:	01 96       	adiw	r24, 0x01	; 1
    160c:	4b e2       	ldi	r20, 0x2B	; 43
    160e:	50 e0       	ldi	r21, 0x00	; 0
    1610:	0e 94 71 1f 	call	0x3ee2	; 0x3ee2 <__eerd_block_m6450a>
	
	
	
	current_patch.vco2_pw = loaded_patch.vco2_pw;
    1614:	e2 ee       	ldi	r30, 0xE2	; 226
    1616:	f2 e0       	ldi	r31, 0x02	; 2
    1618:	8a 89       	ldd	r24, Y+18	; 0x12
    161a:	28 2f       	mov	r18, r24
    161c:	22 95       	swap	r18
    161e:	2f 70       	andi	r18, 0x0F	; 15
    1620:	9b 89       	ldd	r25, Y+19	; 0x13
    1622:	39 2f       	mov	r19, r25
    1624:	32 95       	swap	r19
    1626:	30 7f       	andi	r19, 0xF0	; 240
    1628:	32 2b       	or	r19, r18
    162a:	29 2f       	mov	r18, r25
    162c:	22 95       	swap	r18
    162e:	2f 70       	andi	r18, 0x0F	; 15
    1630:	23 70       	andi	r18, 0x03	; 3
    1632:	30 93 e2 02 	sts	0x02E2, r19
    1636:	20 93 e3 02 	sts	0x02E3, r18
	current_patch.vco1_mix = loaded_patch.vco1_mix; //YOU'RE MISSING VCO2_MIX HERE YOU NITWIT
    163a:	df 01       	movw	r26, r30
    163c:	5a 97       	sbiw	r26, 0x1a	; 26
    163e:	4a 81       	ldd	r20, Y+2	; 0x02
    1640:	46 95       	lsr	r20
    1642:	46 95       	lsr	r20
    1644:	2b 81       	ldd	r18, Y+3	; 0x03
    1646:	32 2f       	mov	r19, r18
    1648:	32 95       	swap	r19
    164a:	33 0f       	add	r19, r19
    164c:	33 0f       	add	r19, r19
    164e:	30 7c       	andi	r19, 0xC0	; 192
    1650:	43 2b       	or	r20, r19
    1652:	32 2f       	mov	r19, r18
    1654:	36 95       	lsr	r19
    1656:	36 95       	lsr	r19
    1658:	33 70       	andi	r19, 0x03	; 3
    165a:	4c 93       	st	X, r20
    165c:	11 96       	adiw	r26, 0x01	; 1
    165e:	3c 93       	st	X, r19
	current_patch.pitch_eg2 = loaded_patch.pitch_eg2;
    1660:	df 01       	movw	r26, r30
    1662:	58 97       	sbiw	r26, 0x18	; 24
    1664:	32 2f       	mov	r19, r18
    1666:	32 95       	swap	r19
    1668:	3f 70       	andi	r19, 0x0F	; 15
    166a:	2c 81       	ldd	r18, Y+4	; 0x04
    166c:	42 2f       	mov	r20, r18
    166e:	42 95       	swap	r20
    1670:	40 7f       	andi	r20, 0xF0	; 240
    1672:	43 2b       	or	r20, r19
    1674:	32 2f       	mov	r19, r18
    1676:	32 95       	swap	r19
    1678:	3f 70       	andi	r19, 0x0F	; 15
    167a:	33 70       	andi	r19, 0x03	; 3
    167c:	4c 93       	st	X, r20
    167e:	11 96       	adiw	r26, 0x01	; 1
    1680:	3c 93       	st	X, r19
	current_patch.pitch_vco2 = loaded_patch.pitch_vco2;
    1682:	df 01       	movw	r26, r30
    1684:	56 97       	sbiw	r26, 0x16	; 22
    1686:	22 95       	swap	r18
    1688:	26 95       	lsr	r18
    168a:	26 95       	lsr	r18
    168c:	23 70       	andi	r18, 0x03	; 3
    168e:	3d 81       	ldd	r19, Y+5	; 0x05
    1690:	43 2f       	mov	r20, r19
    1692:	44 0f       	add	r20, r20
    1694:	44 0f       	add	r20, r20
    1696:	24 2b       	or	r18, r20
    1698:	32 95       	swap	r19
    169a:	36 95       	lsr	r19
    169c:	36 95       	lsr	r19
    169e:	33 70       	andi	r19, 0x03	; 3
    16a0:	2c 93       	st	X, r18
    16a2:	11 96       	adiw	r26, 0x01	; 1
    16a4:	3c 93       	st	X, r19
	current_patch.pitch_lfo = loaded_patch.pitch_lfo;
    16a6:	df 01       	movw	r26, r30
    16a8:	54 97       	sbiw	r26, 0x14	; 20
    16aa:	4e 81       	ldd	r20, Y+6	; 0x06
    16ac:	2f 81       	ldd	r18, Y+7	; 0x07
    16ae:	32 2f       	mov	r19, r18
    16b0:	33 70       	andi	r19, 0x03	; 3
    16b2:	4c 93       	st	X, r20
    16b4:	11 96       	adiw	r26, 0x01	; 1
    16b6:	3c 93       	st	X, r19
	current_patch.pwm_lfo = loaded_patch.pwm_lfo;
    16b8:	df 01       	movw	r26, r30
    16ba:	52 97       	sbiw	r26, 0x12	; 18
    16bc:	32 2f       	mov	r19, r18
    16be:	36 95       	lsr	r19
    16c0:	36 95       	lsr	r19
    16c2:	28 85       	ldd	r18, Y+8	; 0x08
    16c4:	42 2f       	mov	r20, r18
    16c6:	42 95       	swap	r20
    16c8:	44 0f       	add	r20, r20
    16ca:	44 0f       	add	r20, r20
    16cc:	40 7c       	andi	r20, 0xC0	; 192
    16ce:	43 2b       	or	r20, r19
    16d0:	32 2f       	mov	r19, r18
    16d2:	36 95       	lsr	r19
    16d4:	36 95       	lsr	r19
    16d6:	33 70       	andi	r19, 0x03	; 3
    16d8:	4c 93       	st	X, r20
    16da:	11 96       	adiw	r26, 0x01	; 1
    16dc:	3c 93       	st	X, r19
	current_patch.pwm_eg2 = loaded_patch.pwm_eg2;
    16de:	df 01       	movw	r26, r30
    16e0:	50 97       	sbiw	r26, 0x10	; 16
    16e2:	32 2f       	mov	r19, r18
    16e4:	32 95       	swap	r19
    16e6:	3f 70       	andi	r19, 0x0F	; 15
    16e8:	29 85       	ldd	r18, Y+9	; 0x09
    16ea:	42 2f       	mov	r20, r18
    16ec:	42 95       	swap	r20
    16ee:	40 7f       	andi	r20, 0xF0	; 240
    16f0:	43 2b       	or	r20, r19
    16f2:	32 2f       	mov	r19, r18
    16f4:	32 95       	swap	r19
    16f6:	3f 70       	andi	r19, 0x0F	; 15
    16f8:	33 70       	andi	r19, 0x03	; 3
    16fa:	4c 93       	st	X, r20
    16fc:	11 96       	adiw	r26, 0x01	; 1
    16fe:	3c 93       	st	X, r19
	current_patch.vco1_pw = loaded_patch.vco1_pw;
    1700:	df 01       	movw	r26, r30
    1702:	1e 97       	sbiw	r26, 0x0e	; 14
    1704:	22 95       	swap	r18
    1706:	26 95       	lsr	r18
    1708:	26 95       	lsr	r18
    170a:	23 70       	andi	r18, 0x03	; 3
    170c:	3a 85       	ldd	r19, Y+10	; 0x0a
    170e:	43 2f       	mov	r20, r19
    1710:	44 0f       	add	r20, r20
    1712:	44 0f       	add	r20, r20
    1714:	24 2b       	or	r18, r20
    1716:	32 95       	swap	r19
    1718:	36 95       	lsr	r19
    171a:	36 95       	lsr	r19
    171c:	33 70       	andi	r19, 0x03	; 3
    171e:	2c 93       	st	X, r18
    1720:	11 96       	adiw	r26, 0x01	; 1
    1722:	3c 93       	st	X, r19
	current_patch.fine = loaded_patch.fine;
    1724:	df 01       	movw	r26, r30
    1726:	1c 97       	sbiw	r26, 0x0c	; 12
    1728:	4b 85       	ldd	r20, Y+11	; 0x0b
    172a:	2c 85       	ldd	r18, Y+12	; 0x0c
    172c:	32 2f       	mov	r19, r18
    172e:	33 70       	andi	r19, 0x03	; 3
    1730:	4c 93       	st	X, r20
    1732:	11 96       	adiw	r26, 0x01	; 1
    1734:	3c 93       	st	X, r19
	current_patch.tune = loaded_patch.tune; //probably shouldn't save master tune value. Like volume, it is a parameter that doesn't apply to a patch.
    1736:	df 01       	movw	r26, r30
    1738:	1a 97       	sbiw	r26, 0x0a	; 10
    173a:	32 2f       	mov	r19, r18
    173c:	36 95       	lsr	r19
    173e:	36 95       	lsr	r19
    1740:	2d 85       	ldd	r18, Y+13	; 0x0d
    1742:	42 2f       	mov	r20, r18
    1744:	42 95       	swap	r20
    1746:	44 0f       	add	r20, r20
    1748:	44 0f       	add	r20, r20
    174a:	40 7c       	andi	r20, 0xC0	; 192
    174c:	43 2b       	or	r20, r19
    174e:	32 2f       	mov	r19, r18
    1750:	36 95       	lsr	r19
    1752:	36 95       	lsr	r19
    1754:	33 70       	andi	r19, 0x03	; 3
    1756:	4c 93       	st	X, r20
    1758:	11 96       	adiw	r26, 0x01	; 1
    175a:	3c 93       	st	X, r19
	current_patch.lfo_rate = loaded_patch.lfo_rate;
    175c:	df 01       	movw	r26, r30
    175e:	18 97       	sbiw	r26, 0x08	; 8
    1760:	32 2f       	mov	r19, r18
    1762:	32 95       	swap	r19
    1764:	3f 70       	andi	r19, 0x0F	; 15
    1766:	2e 85       	ldd	r18, Y+14	; 0x0e
    1768:	42 2f       	mov	r20, r18
    176a:	42 95       	swap	r20
    176c:	40 7f       	andi	r20, 0xF0	; 240
    176e:	43 2b       	or	r20, r19
    1770:	32 2f       	mov	r19, r18
    1772:	32 95       	swap	r19
    1774:	3f 70       	andi	r19, 0x0F	; 15
    1776:	33 70       	andi	r19, 0x03	; 3
    1778:	4c 93       	st	X, r20
    177a:	11 96       	adiw	r26, 0x01	; 1
    177c:	3c 93       	st	X, r19
	current_patch.arp_rate = loaded_patch.arp_rate;
    177e:	df 01       	movw	r26, r30
    1780:	16 97       	sbiw	r26, 0x06	; 6
    1782:	22 95       	swap	r18
    1784:	26 95       	lsr	r18
    1786:	26 95       	lsr	r18
    1788:	23 70       	andi	r18, 0x03	; 3
    178a:	3f 85       	ldd	r19, Y+15	; 0x0f
    178c:	43 2f       	mov	r20, r19
    178e:	44 0f       	add	r20, r20
    1790:	44 0f       	add	r20, r20
    1792:	24 2b       	or	r18, r20
    1794:	32 95       	swap	r19
    1796:	36 95       	lsr	r19
    1798:	36 95       	lsr	r19
    179a:	33 70       	andi	r19, 0x03	; 3
    179c:	2c 93       	st	X, r18
    179e:	11 96       	adiw	r26, 0x01	; 1
    17a0:	3c 93       	st	X, r19
	current_patch.glide	= loaded_patch.glide;
    17a2:	df 01       	movw	r26, r30
    17a4:	14 97       	sbiw	r26, 0x04	; 4
    17a6:	48 89       	ldd	r20, Y+16	; 0x10
    17a8:	29 89       	ldd	r18, Y+17	; 0x11
    17aa:	32 2f       	mov	r19, r18
    17ac:	33 70       	andi	r19, 0x03	; 3
    17ae:	4c 93       	st	X, r20
    17b0:	11 96       	adiw	r26, 0x01	; 1
    17b2:	3c 93       	st	X, r19
	current_patch.amp_lfo = loaded_patch.amp_lfo;
    17b4:	df 01       	movw	r26, r30
    17b6:	12 97       	sbiw	r26, 0x02	; 2
    17b8:	26 95       	lsr	r18
    17ba:	26 95       	lsr	r18
    17bc:	38 2f       	mov	r19, r24
    17be:	32 95       	swap	r19
    17c0:	33 0f       	add	r19, r19
    17c2:	33 0f       	add	r19, r19
    17c4:	30 7c       	andi	r19, 0xC0	; 192
    17c6:	23 2b       	or	r18, r19
    17c8:	86 95       	lsr	r24
    17ca:	86 95       	lsr	r24
    17cc:	83 70       	andi	r24, 0x03	; 3
    17ce:	2c 93       	st	X, r18
    17d0:	11 96       	adiw	r26, 0x01	; 1
    17d2:	8c 93       	st	X, r24
	current_patch.vco2_pw = loaded_patch.vco2_pw;
	
	current_patch.fil_eg2 = loaded_patch.fil_eg2;
    17d4:	92 95       	swap	r25
    17d6:	96 95       	lsr	r25
    17d8:	96 95       	lsr	r25
    17da:	93 70       	andi	r25, 0x03	; 3
    17dc:	8c 89       	ldd	r24, Y+20	; 0x14
    17de:	28 2f       	mov	r18, r24
    17e0:	22 0f       	add	r18, r18
    17e2:	22 0f       	add	r18, r18
    17e4:	92 2b       	or	r25, r18
    17e6:	82 95       	swap	r24
    17e8:	86 95       	lsr	r24
    17ea:	86 95       	lsr	r24
    17ec:	83 70       	andi	r24, 0x03	; 3
    17ee:	90 93 e4 02 	sts	0x02E4, r25
    17f2:	83 83       	std	Z+3, r24	; 0x03
	current_patch.res = loaded_patch.res;
    17f4:	2d 89       	ldd	r18, Y+21	; 0x15
    17f6:	8e 89       	ldd	r24, Y+22	; 0x16
    17f8:	98 2f       	mov	r25, r24
    17fa:	93 70       	andi	r25, 0x03	; 3
    17fc:	20 93 e6 02 	sts	0x02E6, r18
    1800:	95 83       	std	Z+5, r25	; 0x05
	current_patch.cutoff = loaded_patch.cutoff;
    1802:	98 2f       	mov	r25, r24
    1804:	96 95       	lsr	r25
    1806:	96 95       	lsr	r25
    1808:	8f 89       	ldd	r24, Y+23	; 0x17
    180a:	28 2f       	mov	r18, r24
    180c:	22 95       	swap	r18
    180e:	22 0f       	add	r18, r18
    1810:	22 0f       	add	r18, r18
    1812:	20 7c       	andi	r18, 0xC0	; 192
    1814:	29 2b       	or	r18, r25
    1816:	98 2f       	mov	r25, r24
    1818:	96 95       	lsr	r25
    181a:	96 95       	lsr	r25
    181c:	93 70       	andi	r25, 0x03	; 3
    181e:	20 93 e8 02 	sts	0x02E8, r18
    1822:	97 83       	std	Z+7, r25	; 0x07
	current_patch.key_track = loaded_patch.key_track;
    1824:	98 2f       	mov	r25, r24
    1826:	92 95       	swap	r25
    1828:	9f 70       	andi	r25, 0x0F	; 15
    182a:	88 8d       	ldd	r24, Y+24	; 0x18
    182c:	28 2f       	mov	r18, r24
    182e:	22 95       	swap	r18
    1830:	20 7f       	andi	r18, 0xF0	; 240
    1832:	29 2b       	or	r18, r25
    1834:	98 2f       	mov	r25, r24
    1836:	92 95       	swap	r25
    1838:	9f 70       	andi	r25, 0x0F	; 15
    183a:	93 70       	andi	r25, 0x03	; 3
    183c:	20 93 ea 02 	sts	0x02EA, r18
    1840:	91 87       	std	Z+9, r25	; 0x09
	current_patch.fil_vco2 = loaded_patch.fil_vco2;
    1842:	82 95       	swap	r24
    1844:	86 95       	lsr	r24
    1846:	86 95       	lsr	r24
    1848:	83 70       	andi	r24, 0x03	; 3
    184a:	99 8d       	ldd	r25, Y+25	; 0x19
    184c:	29 2f       	mov	r18, r25
    184e:	22 0f       	add	r18, r18
    1850:	22 0f       	add	r18, r18
    1852:	82 2b       	or	r24, r18
    1854:	92 95       	swap	r25
    1856:	96 95       	lsr	r25
    1858:	96 95       	lsr	r25
    185a:	93 70       	andi	r25, 0x03	; 3
    185c:	80 93 ec 02 	sts	0x02EC, r24
    1860:	93 87       	std	Z+11, r25	; 0x0b
	current_patch.fil_lfo = loaded_patch.fil_lfo;
    1862:	2a 8d       	ldd	r18, Y+26	; 0x1a
    1864:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1866:	98 2f       	mov	r25, r24
    1868:	93 70       	andi	r25, 0x03	; 3
    186a:	20 93 ee 02 	sts	0x02EE, r18
    186e:	95 87       	std	Z+13, r25	; 0x0d
	current_patch.noise_mix = loaded_patch.noise_mix;
    1870:	98 2f       	mov	r25, r24
    1872:	96 95       	lsr	r25
    1874:	96 95       	lsr	r25
    1876:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1878:	28 2f       	mov	r18, r24
    187a:	22 95       	swap	r18
    187c:	22 0f       	add	r18, r18
    187e:	22 0f       	add	r18, r18
    1880:	20 7c       	andi	r18, 0xC0	; 192
    1882:	29 2b       	or	r18, r25
    1884:	98 2f       	mov	r25, r24
    1886:	96 95       	lsr	r25
    1888:	96 95       	lsr	r25
    188a:	93 70       	andi	r25, 0x03	; 3
    188c:	20 93 f0 02 	sts	0x02F0, r18
    1890:	97 87       	std	Z+15, r25	; 0x0f
	current_patch.attack_2 = loaded_patch.attack_2;
    1892:	98 2f       	mov	r25, r24
    1894:	92 95       	swap	r25
    1896:	9f 70       	andi	r25, 0x0F	; 15
    1898:	8d 8d       	ldd	r24, Y+29	; 0x1d
    189a:	28 2f       	mov	r18, r24
    189c:	22 95       	swap	r18
    189e:	20 7f       	andi	r18, 0xF0	; 240
    18a0:	29 2b       	or	r18, r25
    18a2:	98 2f       	mov	r25, r24
    18a4:	92 95       	swap	r25
    18a6:	9f 70       	andi	r25, 0x0F	; 15
    18a8:	93 70       	andi	r25, 0x03	; 3
    18aa:	20 93 f2 02 	sts	0x02F2, r18
    18ae:	91 8b       	std	Z+17, r25	; 0x11
	current_patch.attack_1 = loaded_patch.attack_1;
    18b0:	82 95       	swap	r24
    18b2:	86 95       	lsr	r24
    18b4:	86 95       	lsr	r24
    18b6:	83 70       	andi	r24, 0x03	; 3
    18b8:	9e 8d       	ldd	r25, Y+30	; 0x1e
    18ba:	29 2f       	mov	r18, r25
    18bc:	22 0f       	add	r18, r18
    18be:	22 0f       	add	r18, r18
    18c0:	82 2b       	or	r24, r18
    18c2:	92 95       	swap	r25
    18c4:	96 95       	lsr	r25
    18c6:	96 95       	lsr	r25
    18c8:	93 70       	andi	r25, 0x03	; 3
    18ca:	80 93 f4 02 	sts	0x02F4, r24
    18ce:	93 8b       	std	Z+19, r25	; 0x13
	current_patch.decay_2 = loaded_patch.decay_2;
    18d0:	2f 8d       	ldd	r18, Y+31	; 0x1f
    18d2:	88 a1       	lds	r24, 0x48
    18d4:	98 2f       	mov	r25, r24
    18d6:	93 70       	andi	r25, 0x03	; 3
    18d8:	20 93 f6 02 	sts	0x02F6, r18
    18dc:	95 8b       	std	Z+21, r25	; 0x15
	current_patch.decay_1 = loaded_patch.decay_1;
    18de:	98 2f       	mov	r25, r24
    18e0:	96 95       	lsr	r25
    18e2:	96 95       	lsr	r25
    18e4:	89 a1       	lds	r24, 0x49
    18e6:	28 2f       	mov	r18, r24
    18e8:	22 95       	swap	r18
    18ea:	22 0f       	add	r18, r18
    18ec:	22 0f       	add	r18, r18
    18ee:	20 7c       	andi	r18, 0xC0	; 192
    18f0:	29 2b       	or	r18, r25
    18f2:	98 2f       	mov	r25, r24
    18f4:	96 95       	lsr	r25
    18f6:	96 95       	lsr	r25
    18f8:	93 70       	andi	r25, 0x03	; 3
    18fa:	20 93 f8 02 	sts	0x02F8, r18
    18fe:	97 8b       	std	Z+23, r25	; 0x17
	current_patch.sustain_2 = loaded_patch.sustain_2;
    1900:	98 2f       	mov	r25, r24
    1902:	92 95       	swap	r25
    1904:	9f 70       	andi	r25, 0x0F	; 15
    1906:	8a a1       	lds	r24, 0x4a
    1908:	28 2f       	mov	r18, r24
    190a:	22 95       	swap	r18
    190c:	20 7f       	andi	r18, 0xF0	; 240
    190e:	29 2b       	or	r18, r25
    1910:	98 2f       	mov	r25, r24
    1912:	92 95       	swap	r25
    1914:	9f 70       	andi	r25, 0x0F	; 15
    1916:	93 70       	andi	r25, 0x03	; 3
    1918:	20 93 fa 02 	sts	0x02FA, r18
    191c:	91 8f       	std	Z+25, r25	; 0x19
	current_patch.sustain_1 = loaded_patch.sustain_1;
    191e:	82 95       	swap	r24
    1920:	86 95       	lsr	r24
    1922:	86 95       	lsr	r24
    1924:	83 70       	andi	r24, 0x03	; 3
    1926:	9b a1       	lds	r25, 0x4b
    1928:	29 2f       	mov	r18, r25
    192a:	22 0f       	add	r18, r18
    192c:	22 0f       	add	r18, r18
    192e:	82 2b       	or	r24, r18
    1930:	92 95       	swap	r25
    1932:	96 95       	lsr	r25
    1934:	96 95       	lsr	r25
    1936:	93 70       	andi	r25, 0x03	; 3
    1938:	80 93 fc 02 	sts	0x02FC, r24
    193c:	93 8f       	std	Z+27, r25	; 0x1b
	current_patch.release_2 = loaded_patch.release_2;
    193e:	2c a1       	lds	r18, 0x4c
    1940:	8d a1       	lds	r24, 0x4d
    1942:	98 2f       	mov	r25, r24
    1944:	93 70       	andi	r25, 0x03	; 3
    1946:	20 93 fe 02 	sts	0x02FE, r18
    194a:	95 8f       	std	Z+29, r25	; 0x1d
	current_patch.release_1 = loaded_patch.release_1;
    194c:	98 2f       	mov	r25, r24
    194e:	96 95       	lsr	r25
    1950:	96 95       	lsr	r25
    1952:	8e a1       	lds	r24, 0x4e
    1954:	28 2f       	mov	r18, r24
    1956:	22 95       	swap	r18
    1958:	22 0f       	add	r18, r18
    195a:	22 0f       	add	r18, r18
    195c:	20 7c       	andi	r18, 0xC0	; 192
    195e:	29 2b       	or	r18, r25
    1960:	86 95       	lsr	r24
    1962:	86 95       	lsr	r24
    1964:	98 2f       	mov	r25, r24
    1966:	93 70       	andi	r25, 0x03	; 3
    1968:	20 93 00 03 	sts	0x0300, r18
    196c:	97 8f       	std	Z+31, r25	; 0x1f
	
	
	current_patch.byte_1 = loaded_patch.byte_1;
    196e:	7f a1       	lds	r23, 0x4f
    1970:	70 93 02 03 	sts	0x0302, r23
	current_patch.byte_2 = loaded_patch.byte_2;
    1974:	68 a5       	lds	r22, 0x68
    1976:	60 93 03 03 	sts	0x0303, r22
	current_patch.byte_3 = loaded_patch.byte_3;
    197a:	89 a5       	lds	r24, 0x69
    197c:	80 93 04 03 	sts	0x0304, r24
	current_patch.byte_4 = loaded_patch.byte_4;
    1980:	9a a5       	lds	r25, 0x6a
    1982:	90 93 05 03 	sts	0x0305, r25
	current_patch.byte_5 = loaded_patch.byte_5;
    1986:	1b a5       	lds	r17, 0x6b
    1988:	10 93 06 03 	sts	0x0306, r17
	
	//using De Bruijn sequence to determine which bit is set. For alphabet size k = 2 (binary - 0 and 1) and n = 3. 2^3 = 8. The minimum number of bits required to represent the 5 octave positions
	uint8_t vco1_lookup[] = {7, 2, 5, 0, 6, 4, 3, 1}; // *modified* De Bruijn lookup table for octave number, see: http://stackoverflow.com/questions/14429661/determine-which-single-bit-in-the-byte-is-set
    198c:	de 01       	movw	r26, r28
    198e:	9c 96       	adiw	r26, 0x2c	; 44
    1990:	ef ef       	ldi	r30, 0xFF	; 255
    1992:	f1 e0       	ldi	r31, 0x01	; 1
    1994:	28 e0       	ldi	r18, 0x08	; 8
    1996:	01 90       	ld	r0, Z+
    1998:	0d 92       	st	X+, r0
    199a:	21 50       	subi	r18, 0x01	; 1
    199c:	e1 f7       	brne	.-8      	; 0x1996 <load_patch+0x3be>
	//lookup table modified from standard 8 bit De Bruijn sequence to handle non sequential order of octave LEDs in byte_4
	uint8_t vco1_bitfield = current_patch.byte_4 & 0b00011111; //clear top 3 bits, which are used for VCO2 octave lookup - probably don't need to clear these bits
    199e:	e9 2f       	mov	r30, r25
    19a0:	ef 71       	andi	r30, 0x1F	; 31
	uint8_t bit_index = ((vco1_bitfield*0x1D) >> 4) & 0x7;	//0x1D 0b11101 is the De Bruijn sequence for 8 bits 
    19a2:	f0 e0       	ldi	r31, 0x00	; 0
    19a4:	9f 01       	movw	r18, r30
    19a6:	22 0f       	add	r18, r18
    19a8:	33 1f       	adc	r19, r19
    19aa:	22 0f       	add	r18, r18
    19ac:	33 1f       	adc	r19, r19
    19ae:	a9 01       	movw	r20, r18
    19b0:	44 0f       	add	r20, r20
    19b2:	55 1f       	adc	r21, r21
    19b4:	44 0f       	add	r20, r20
    19b6:	55 1f       	adc	r21, r21
    19b8:	44 0f       	add	r20, r20
    19ba:	55 1f       	adc	r21, r21
    19bc:	42 1b       	sub	r20, r18
    19be:	53 0b       	sbc	r21, r19
    19c0:	4e 0f       	add	r20, r30
    19c2:	5f 1f       	adc	r21, r31
    19c4:	55 95       	asr	r21
    19c6:	47 95       	ror	r20
    19c8:	55 95       	asr	r21
    19ca:	47 95       	ror	r20
    19cc:	55 95       	asr	r21
    19ce:	47 95       	ror	r20
    19d0:	55 95       	asr	r21
    19d2:	47 95       	ror	r20
    19d4:	47 70       	andi	r20, 0x07	; 7
	octave_index.vco1 = vco1_lookup[bit_index];	
    19d6:	fe 01       	movw	r30, r28
    19d8:	e4 0f       	add	r30, r20
    19da:	f1 1d       	adc	r31, r1
    19dc:	24 a5       	lds	r18, 0x64
    19de:	20 93 0c 03 	sts	0x030C, r18
	
	uint8_t vco2_lookup[] = {7, 4, 5, 3, 6, 2, 1, 0}; 
    19e2:	de 01       	movw	r26, r28
    19e4:	d4 96       	adiw	r26, 0x34	; 52
    19e6:	e7 e0       	ldi	r30, 0x07	; 7
    19e8:	f2 e0       	ldi	r31, 0x02	; 2
    19ea:	28 e0       	ldi	r18, 0x08	; 8
    19ec:	01 90       	ld	r0, Z+
    19ee:	0d 92       	st	X+, r0
    19f0:	21 50       	subi	r18, 0x01	; 1
    19f2:	e1 f7       	brne	.-8      	; 0x19ec <load_patch+0x414>
																																				 //bit order 4   3    2    1   0
	uint8_t vco2_bitfield = ((current_patch.byte_4 & 0b11100000) >> 3) | (current_patch.byte_3 & 0b00000011); //combine  all VCO2 octave bits into one byte: 8', 16', 32', 4', 2'
    19f4:	29 2f       	mov	r18, r25
    19f6:	30 e0       	ldi	r19, 0x00	; 0
    19f8:	20 7e       	andi	r18, 0xE0	; 224
    19fa:	30 70       	andi	r19, 0x00	; 0
    19fc:	35 95       	asr	r19
    19fe:	27 95       	ror	r18
    1a00:	35 95       	asr	r19
    1a02:	27 95       	ror	r18
    1a04:	35 95       	asr	r19
    1a06:	27 95       	ror	r18
    1a08:	83 70       	andi	r24, 0x03	; 3
    1a0a:	28 2b       	or	r18, r24
	bit_index = ((vco2_bitfield*0x1D) >> 4) & 0x7;																								     //index 2   1    0    3   4
    1a0c:	42 2f       	mov	r20, r18
    1a0e:	50 e0       	ldi	r21, 0x00	; 0
    1a10:	ca 01       	movw	r24, r20
    1a12:	88 0f       	add	r24, r24
    1a14:	99 1f       	adc	r25, r25
    1a16:	88 0f       	add	r24, r24
    1a18:	99 1f       	adc	r25, r25
    1a1a:	9c 01       	movw	r18, r24
    1a1c:	22 0f       	add	r18, r18
    1a1e:	33 1f       	adc	r19, r19
    1a20:	22 0f       	add	r18, r18
    1a22:	33 1f       	adc	r19, r19
    1a24:	22 0f       	add	r18, r18
    1a26:	33 1f       	adc	r19, r19
    1a28:	28 1b       	sub	r18, r24
    1a2a:	39 0b       	sbc	r19, r25
    1a2c:	42 0f       	add	r20, r18
    1a2e:	53 1f       	adc	r21, r19
    1a30:	ca 01       	movw	r24, r20
    1a32:	95 95       	asr	r25
    1a34:	87 95       	ror	r24
    1a36:	95 95       	asr	r25
    1a38:	87 95       	ror	r24
    1a3a:	95 95       	asr	r25
    1a3c:	87 95       	ror	r24
    1a3e:	95 95       	asr	r25
    1a40:	87 95       	ror	r24
    1a42:	87 70       	andi	r24, 0x07	; 7
	octave_index.vco2 = vco2_lookup[bit_index];
    1a44:	fe 01       	movw	r30, r28
    1a46:	e8 0f       	add	r30, r24
    1a48:	f1 1d       	adc	r31, r1
    1a4a:	84 a9       	sts	0x44, r24
    1a4c:	80 93 0d 03 	sts	0x030D, r24
	
	uint8_t lfo_lookup[] = {0, 0, 2, 2, 1, 3, 3, 1}; //bits 7, 5, 4, 6 are irrelevant here. Complier seems to be reformatting this table???
    1a50:	de 01       	movw	r26, r28
    1a52:	dc 96       	adiw	r26, 0x3c	; 60
    1a54:	ef e0       	ldi	r30, 0x0F	; 15
    1a56:	f2 e0       	ldi	r31, 0x02	; 2
    1a58:	88 e0       	ldi	r24, 0x08	; 8
    1a5a:	01 90       	ld	r0, Z+
    1a5c:	0d 92       	st	X+, r0
    1a5e:	81 50       	subi	r24, 0x01	; 1
    1a60:	e1 f7       	brne	.-8      	; 0x1a5a <load_patch+0x482>
	uint8_t lfo_bitfield = current_patch.byte_2 & 0b11110000; //shave off 4 LSBs. Really could use 4 bit De Bruijn sequence here
    1a62:	60 7f       	andi	r22, 0xF0	; 240
	bit_index = ((lfo_bitfield*0x1D) >> 4) & 0x7;
    1a64:	46 2f       	mov	r20, r22
    1a66:	50 e0       	ldi	r21, 0x00	; 0
    1a68:	ca 01       	movw	r24, r20
    1a6a:	88 0f       	add	r24, r24
    1a6c:	99 1f       	adc	r25, r25
    1a6e:	88 0f       	add	r24, r24
    1a70:	99 1f       	adc	r25, r25
    1a72:	9c 01       	movw	r18, r24
    1a74:	22 0f       	add	r18, r18
    1a76:	33 1f       	adc	r19, r19
    1a78:	22 0f       	add	r18, r18
    1a7a:	33 1f       	adc	r19, r19
    1a7c:	22 0f       	add	r18, r18
    1a7e:	33 1f       	adc	r19, r19
    1a80:	28 1b       	sub	r18, r24
    1a82:	39 0b       	sbc	r19, r25
    1a84:	42 0f       	add	r20, r18
    1a86:	53 1f       	adc	r21, r19
    1a88:	ca 01       	movw	r24, r20
    1a8a:	95 95       	asr	r25
    1a8c:	87 95       	ror	r24
    1a8e:	95 95       	asr	r25
    1a90:	87 95       	ror	r24
    1a92:	95 95       	asr	r25
    1a94:	87 95       	ror	r24
    1a96:	95 95       	asr	r25
    1a98:	87 95       	ror	r24
    1a9a:	87 70       	andi	r24, 0x07	; 7
	lfo_shape_index = lfo_lookup[bit_index];
    1a9c:	fe 01       	movw	r30, r28
    1a9e:	e8 0f       	add	r30, r24
    1aa0:	f1 1d       	adc	r31, r1
    1aa2:	84 ad       	sts	0x64, r24
    1aa4:	80 93 0e 03 	sts	0x030E, r24
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1aa8:	21 2f       	mov	r18, r17
    1aaa:	26 95       	lsr	r18
    1aac:	27 95       	ror	r18
    1aae:	22 27       	eor	r18, r18
    1ab0:	27 95       	ror	r18
    1ab2:	81 2f       	mov	r24, r17
    1ab4:	81 70       	andi	r24, 0x01	; 1
    1ab6:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
    1ab8:	81 2f       	mov	r24, r17
    1aba:	86 95       	lsr	r24
    1abc:	86 95       	lsr	r24
    1abe:	90 e0       	ldi	r25, 0x00	; 0
    1ac0:	81 70       	andi	r24, 0x01	; 1
    1ac2:	90 70       	andi	r25, 0x00	; 0
    1ac4:	88 0f       	add	r24, r24
    1ac6:	99 1f       	adc	r25, r25
    1ac8:	88 0f       	add	r24, r24
    1aca:	99 1f       	adc	r25, r25
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1acc:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
							((current_patch.byte_5 >> VCO1_TRI) & 1) << VCO1_TRI_SW |
    1ace:	81 2f       	mov	r24, r17
    1ad0:	86 95       	lsr	r24
    1ad2:	86 95       	lsr	r24
    1ad4:	86 95       	lsr	r24
    1ad6:	90 e0       	ldi	r25, 0x00	; 0
    1ad8:	81 70       	andi	r24, 0x01	; 1
    1ada:	90 70       	andi	r25, 0x00	; 0
    1adc:	88 0f       	add	r24, r24
    1ade:	99 1f       	adc	r25, r25
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1ae0:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
							((current_patch.byte_5 >> VCO1_TRI) & 1) << VCO1_TRI_SW |
							((current_patch.byte_5 >> VCO1_PULSE) & 1) << VCO1_PULSE_SW |
							((current_patch.byte_5 >> VCO2_SAW) & 1) << VCO2_SAW_SW |
    1ae2:	81 2f       	mov	r24, r17
    1ae4:	82 95       	swap	r24
    1ae6:	8f 70       	andi	r24, 0x0F	; 15
    1ae8:	90 e0       	ldi	r25, 0x00	; 0
    1aea:	81 70       	andi	r24, 0x01	; 1
    1aec:	90 70       	andi	r25, 0x00	; 0
    1aee:	82 95       	swap	r24
    1af0:	92 95       	swap	r25
    1af2:	90 7f       	andi	r25, 0xF0	; 240
    1af4:	98 27       	eor	r25, r24
    1af6:	80 7f       	andi	r24, 0xF0	; 240
    1af8:	98 27       	eor	r25, r24
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1afa:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
							((current_patch.byte_5 >> VCO1_TRI) & 1) << VCO1_TRI_SW |
							((current_patch.byte_5 >> VCO1_PULSE) & 1) << VCO1_PULSE_SW |
							((current_patch.byte_5 >> VCO2_SAW) & 1) << VCO2_SAW_SW |
							((current_patch.byte_5 >> VCO2_TRI) & 1) << VCO2_TRI_SW |
    1afc:	81 2f       	mov	r24, r17
    1afe:	82 95       	swap	r24
    1b00:	86 95       	lsr	r24
    1b02:	87 70       	andi	r24, 0x07	; 7
    1b04:	90 e0       	ldi	r25, 0x00	; 0
    1b06:	81 70       	andi	r24, 0x01	; 1
    1b08:	90 70       	andi	r25, 0x00	; 0
    1b0a:	88 0f       	add	r24, r24
    1b0c:	99 1f       	adc	r25, r25
    1b0e:	82 95       	swap	r24
    1b10:	92 95       	swap	r25
    1b12:	90 7f       	andi	r25, 0xF0	; 240
    1b14:	98 27       	eor	r25, r24
    1b16:	80 7f       	andi	r24, 0xF0	; 240
    1b18:	98 27       	eor	r25, r24
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1b1a:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
							((current_patch.byte_5 >> VCO1_TRI) & 1) << VCO1_TRI_SW |
							((current_patch.byte_5 >> VCO1_PULSE) & 1) << VCO1_PULSE_SW |
							((current_patch.byte_5 >> VCO2_SAW) & 1) << VCO2_SAW_SW |
							((current_patch.byte_5 >> VCO2_TRI) & 1) << VCO2_TRI_SW |
							((current_patch.byte_5 >> VCO2_PULSE) & 1) << VCO2_PULSE_SW;
    1b1c:	81 2f       	mov	r24, r17
    1b1e:	82 95       	swap	r24
    1b20:	86 95       	lsr	r24
    1b22:	86 95       	lsr	r24
    1b24:	83 70       	andi	r24, 0x03	; 3
    1b26:	90 e0       	ldi	r25, 0x00	; 0
    1b28:	81 70       	andi	r24, 0x01	; 1
    1b2a:	90 70       	andi	r25, 0x00	; 0
    1b2c:	00 24       	eor	r0, r0
    1b2e:	96 95       	lsr	r25
    1b30:	87 95       	ror	r24
    1b32:	07 94       	ror	r0
    1b34:	96 95       	lsr	r25
    1b36:	87 95       	ror	r24
    1b38:	07 94       	ror	r0
    1b3a:	98 2f       	mov	r25, r24
    1b3c:	80 2d       	mov	r24, r0
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1b3e:	82 2b       	or	r24, r18
    1b40:	80 93 82 03 	sts	0x0382, r24
							((current_patch.byte_5 >> VCO2_PULSE) & 1) << VCO2_PULSE_SW;
							
	switch_states.byte2 &= 0b11110011; //preserve PROG switches states, clear BMOD and EG2 states
	
	switch_states.byte2 |=	((current_patch.byte_5 >> BMOD) & 1) << BMOD_SW |
							((current_patch.byte_1 >> EG2_INV) & 1) << EG2_INV_SW;	
    1b44:	87 2f       	mov	r24, r23
    1b46:	90 e0       	ldi	r25, 0x00	; 0
    1b48:	81 70       	andi	r24, 0x01	; 1
    1b4a:	90 70       	andi	r25, 0x00	; 0
    1b4c:	88 0f       	add	r24, r24
    1b4e:	99 1f       	adc	r25, r25
    1b50:	88 0f       	add	r24, r24
    1b52:	99 1f       	adc	r25, r25
    1b54:	88 0f       	add	r24, r24
    1b56:	99 1f       	adc	r25, r25
							((current_patch.byte_5 >> VCO1_PULSE) & 1) << VCO1_PULSE_SW |
							((current_patch.byte_5 >> VCO2_SAW) & 1) << VCO2_SAW_SW |
							((current_patch.byte_5 >> VCO2_TRI) & 1) << VCO2_TRI_SW |
							((current_patch.byte_5 >> VCO2_PULSE) & 1) << VCO2_PULSE_SW;
							
	switch_states.byte2 &= 0b11110011; //preserve PROG switches states, clear BMOD and EG2 states
    1b58:	90 91 84 03 	lds	r25, 0x0384
    1b5c:	93 7f       	andi	r25, 0xF3	; 243
	
	switch_states.byte2 |=	((current_patch.byte_5 >> BMOD) & 1) << BMOD_SW |
    1b5e:	89 2b       	or	r24, r25
    1b60:	11 1f       	adc	r17, r17
    1b62:	11 27       	eor	r17, r17
    1b64:	11 1f       	adc	r17, r17
    1b66:	11 0f       	add	r17, r17
    1b68:	11 0f       	add	r17, r17
    1b6a:	81 2b       	or	r24, r17
    1b6c:	80 93 84 03 	sts	0x0384, r24
													
	//spi_sw_byte0_current_state = spi_sw_byte0_previous_state = switch_states.byte0;
	//
	//spi_sw_byte1_current_state = spi_sw_byte1_previous_state = switch_states.byte1;						
			
	lock_pots();
    1b70:	0e 94 ce 08 	call	0x119c	; 0x119c <lock_pots>
	
	//if (current_patch.mode == MANUAL) switch_states.byte2 &= ~(1<< PROG_MANUAL_SW); //if in MANUAL mode, turn off MANUAL LED
	switch_states.byte2 &= ~(1<<PROG_MANUAL_SW);
    1b74:	80 91 84 03 	lds	r24, 0x0384
    1b78:	8f 77       	andi	r24, 0x7F	; 127
    1b7a:	80 93 84 03 	sts	0x0384, r24
	
	current_patch.mode = MEMORY;
    1b7e:	10 92 0b 03 	sts	0x030B, r1
	
}
    1b82:	cd 5b       	subi	r28, 0xBD	; 189
    1b84:	df 4f       	sbci	r29, 0xFF	; 255
    1b86:	0f b6       	in	r0, 0x3f	; 63
    1b88:	f8 94       	cli
    1b8a:	de bf       	out	0x3e, r29	; 62
    1b8c:	0f be       	out	0x3f, r0	; 63
    1b8e:	cd bf       	out	0x3d, r28	; 61
    1b90:	df 91       	pop	r29
    1b92:	cf 91       	pop	r28
    1b94:	1f 91       	pop	r17
    1b96:	08 95       	ret

00001b98 <transpose_note>:

uint8_t transpose_note (uint8_t note, uint8_t vco) {
	
	uint8_t n = 0;
	
	n = octave_index.vco1;
    1b98:	90 91 0c 03 	lds	r25, 0x030C
	if (vco == VCO2) n = octave_index.vco2;
    1b9c:	60 3f       	cpi	r22, 0xF0	; 240
    1b9e:	11 f4       	brne	.+4      	; 0x1ba4 <transpose_note+0xc>
    1ba0:	90 91 0d 03 	lds	r25, 0x030D

	note = (n*12) + note; //calculate MIDI note after octave addition
    1ba4:	29 2f       	mov	r18, r25
    1ba6:	22 0f       	add	r18, r18
    1ba8:	92 0f       	add	r25, r18
    1baa:	99 0f       	add	r25, r25
    1bac:	99 0f       	add	r25, r25
    1bae:	89 0f       	add	r24, r25
			
		note = 136;
			
	}
		
	return note;	
    1bb0:	89 38       	cpi	r24, 0x89	; 137
    1bb2:	08 f0       	brcs	.+2      	; 0x1bb6 <transpose_note+0x1e>
    1bb4:	88 e8       	ldi	r24, 0x88	; 136
	
}
    1bb6:	08 95       	ret

00001bb8 <update_octave_range>:

void update_octave_range(void) {
	
	if ((switch_states.byte0 >> VCO1_OCTAVE_UP_SW) & 1) {
    1bb8:	80 91 82 03 	lds	r24, 0x0382
    1bbc:	98 2f       	mov	r25, r24
    1bbe:	96 95       	lsr	r25
    1bc0:	96 95       	lsr	r25
    1bc2:	96 95       	lsr	r25
    1bc4:	90 ff       	sbrs	r25, 0
    1bc6:	0e c0       	rjmp	.+28     	; 0x1be4 <update_octave_range+0x2c>
		
		if (++octave_index.vco1 == 5) octave_index.vco1 = 4;
    1bc8:	90 91 0c 03 	lds	r25, 0x030C
    1bcc:	9f 5f       	subi	r25, 0xFF	; 255
    1bce:	90 93 0c 03 	sts	0x030C, r25
    1bd2:	95 30       	cpi	r25, 0x05	; 5
    1bd4:	19 f4       	brne	.+6      	; 0x1bdc <update_octave_range+0x24>
    1bd6:	94 e0       	ldi	r25, 0x04	; 4
    1bd8:	90 93 0c 03 	sts	0x030C, r25
		switch_states.byte0 ^= (1<<VCO1_OCTAVE_UP_SW); //toggle switch state bit
    1bdc:	98 e0       	ldi	r25, 0x08	; 8
    1bde:	89 27       	eor	r24, r25
    1be0:	80 93 82 03 	sts	0x0382, r24
		
	}
	
	if ((switch_states.byte1 >> VCO1_OCTAVE_DOWN_SW) & 1) { //this didn't work initially because VCO1_OCTAVE_DOWN_SW pull down resistor wasn't installed on PCB!!!
    1be4:	80 91 83 03 	lds	r24, 0x0383
    1be8:	98 2f       	mov	r25, r24
    1bea:	96 95       	lsr	r25
    1bec:	96 95       	lsr	r25
    1bee:	96 95       	lsr	r25
    1bf0:	90 ff       	sbrs	r25, 0
    1bf2:	0b c0       	rjmp	.+22     	; 0x1c0a <update_octave_range+0x52>
	
		if (octave_index.vco1 == 0) {} else {octave_index.vco1--;}
    1bf4:	90 91 0c 03 	lds	r25, 0x030C
    1bf8:	99 23       	and	r25, r25
    1bfa:	19 f0       	breq	.+6      	; 0x1c02 <update_octave_range+0x4a>
    1bfc:	91 50       	subi	r25, 0x01	; 1
    1bfe:	90 93 0c 03 	sts	0x030C, r25
		switch_states.byte1 ^= (1<<VCO1_OCTAVE_DOWN_SW);
    1c02:	98 e0       	ldi	r25, 0x08	; 8
    1c04:	89 27       	eor	r24, r25
    1c06:	80 93 83 03 	sts	0x0383, r24

	}
	
	current_patch.byte_4 = 0; //clear the whole damn byte as all bits are set below
	current_patch.byte_4 |= (1<<vco1_octave[octave_index.vco1]); //set octave	
    1c0a:	80 91 0c 03 	lds	r24, 0x030C
    1c0e:	e1 e2       	ldi	r30, 0x21	; 33
    1c10:	f2 e0       	ldi	r31, 0x02	; 2
    1c12:	e8 0f       	add	r30, r24
    1c14:	f1 1d       	adc	r31, r1
    1c16:	81 e0       	ldi	r24, 0x01	; 1
    1c18:	90 e0       	ldi	r25, 0x00	; 0
    1c1a:	00 80       	ld	r0, Z
    1c1c:	02 c0       	rjmp	.+4      	; 0x1c22 <update_octave_range+0x6a>
    1c1e:	88 0f       	add	r24, r24
    1c20:	99 1f       	adc	r25, r25
    1c22:	0a 94       	dec	r0
    1c24:	e2 f7       	brpl	.-8      	; 0x1c1e <update_octave_range+0x66>
    1c26:	58 2f       	mov	r21, r24
    1c28:	80 93 05 03 	sts	0x0305, r24
	
	if ((switch_states.byte1 >> VCO2_OCTAVE_UP_SW) & 1) {
    1c2c:	90 91 83 03 	lds	r25, 0x0383
    1c30:	29 2f       	mov	r18, r25
    1c32:	26 95       	lsr	r18
    1c34:	26 95       	lsr	r18
    1c36:	20 ff       	sbrs	r18, 0
    1c38:	0e c0       	rjmp	.+28     	; 0x1c56 <update_octave_range+0x9e>
		
		if (++octave_index.vco2 == 5) octave_index.vco2 = 4;
    1c3a:	80 91 0d 03 	lds	r24, 0x030D
    1c3e:	8f 5f       	subi	r24, 0xFF	; 255
    1c40:	80 93 0d 03 	sts	0x030D, r24
    1c44:	85 30       	cpi	r24, 0x05	; 5
    1c46:	19 f4       	brne	.+6      	; 0x1c4e <update_octave_range+0x96>
    1c48:	84 e0       	ldi	r24, 0x04	; 4
    1c4a:	80 93 0d 03 	sts	0x030D, r24
		switch_states.byte1 ^= (1<<VCO2_OCTAVE_UP_SW); //toggle switch state bit		
    1c4e:	84 e0       	ldi	r24, 0x04	; 4
    1c50:	98 27       	eor	r25, r24
    1c52:	90 93 83 03 	sts	0x0383, r25
	}	
	
	if ((switch_states.byte1 >> VCO2_OCTAVE_DOWN_SW) & 1) {
    1c56:	90 91 83 03 	lds	r25, 0x0383
    1c5a:	29 2f       	mov	r18, r25
    1c5c:	26 95       	lsr	r18
    1c5e:	20 ff       	sbrs	r18, 0
    1c60:	0b c0       	rjmp	.+22     	; 0x1c78 <update_octave_range+0xc0>
		
		if (octave_index.vco2 == 0) {} else {octave_index.vco2--;}
    1c62:	80 91 0d 03 	lds	r24, 0x030D
    1c66:	88 23       	and	r24, r24
    1c68:	19 f0       	breq	.+6      	; 0x1c70 <update_octave_range+0xb8>
    1c6a:	81 50       	subi	r24, 0x01	; 1
    1c6c:	80 93 0d 03 	sts	0x030D, r24
		switch_states.byte1 ^= (1<<VCO2_OCTAVE_DOWN_SW);
    1c70:	82 e0       	ldi	r24, 0x02	; 2
    1c72:	98 27       	eor	r25, r24
    1c74:	90 93 83 03 	sts	0x0383, r25
		
	}
			
	current_patch.byte_3 &= 0b11111100; //clear bottom 2 bits for patch byte_3, which are for VCO2 2' and 4'
    1c78:	40 91 04 03 	lds	r20, 0x0304
    1c7c:	4c 7f       	andi	r20, 0xFC	; 252
    1c7e:	40 93 04 03 	sts	0x0304, r20
	
	if (octave_index.vco2 > 2) { //VCO2 2' and 4' LEDs are on LED latch 3
    1c82:	90 91 0d 03 	lds	r25, 0x030D
    1c86:	93 30       	cpi	r25, 0x03	; 3
    1c88:	88 f0       	brcs	.+34     	; 0x1cac <update_octave_range+0xf4>

						
		current_patch.byte_3 |= (1<<vco2_octave[octave_index.vco2]);	
    1c8a:	ec e1       	ldi	r30, 0x1C	; 28
    1c8c:	f2 e0       	ldi	r31, 0x02	; 2
    1c8e:	e9 0f       	add	r30, r25
    1c90:	f1 1d       	adc	r31, r1
    1c92:	21 e0       	ldi	r18, 0x01	; 1
    1c94:	30 e0       	ldi	r19, 0x00	; 0
    1c96:	c9 01       	movw	r24, r18
    1c98:	00 80       	ld	r0, Z
    1c9a:	02 c0       	rjmp	.+4      	; 0x1ca0 <update_octave_range+0xe8>
    1c9c:	88 0f       	add	r24, r24
    1c9e:	99 1f       	adc	r25, r25
    1ca0:	0a 94       	dec	r0
    1ca2:	e2 f7       	brpl	.-8      	; 0x1c9c <update_octave_range+0xe4>
    1ca4:	84 2b       	or	r24, r20
    1ca6:	80 93 04 03 	sts	0x0304, r24
    1caa:	08 95       	ret
				
	} else { //VCO2 8', 16' and 32' are on LED latch 4
		
		current_patch.byte_4 |= (1<<vco2_octave[octave_index.vco2]); //set octave
    1cac:	ec e1       	ldi	r30, 0x1C	; 28
    1cae:	f2 e0       	ldi	r31, 0x02	; 2
    1cb0:	e9 0f       	add	r30, r25
    1cb2:	f1 1d       	adc	r31, r1
    1cb4:	21 e0       	ldi	r18, 0x01	; 1
    1cb6:	30 e0       	ldi	r19, 0x00	; 0
    1cb8:	c9 01       	movw	r24, r18
    1cba:	00 80       	ld	r0, Z
    1cbc:	02 c0       	rjmp	.+4      	; 0x1cc2 <update_octave_range+0x10a>
    1cbe:	88 0f       	add	r24, r24
    1cc0:	99 1f       	adc	r25, r25
    1cc2:	0a 94       	dec	r0
    1cc4:	e2 f7       	brpl	.-8      	; 0x1cbe <update_octave_range+0x106>
    1cc6:	85 2b       	or	r24, r21
    1cc8:	80 93 05 03 	sts	0x0305, r24
    1ccc:	08 95       	ret

00001cce <update_lfo_shape>:
	
}	
	
void update_lfo_shape(void) {

	if ((switch_states.byte1 >> LFO_SHAPE_SW) & 1) {
    1cce:	80 91 83 03 	lds	r24, 0x0383
    1cd2:	88 23       	and	r24, r24
    1cd4:	64 f4       	brge	.+24     	; 0x1cee <update_lfo_shape+0x20>
	
		switch_states.byte1 ^= (1<<LFO_SHAPE_SW); //toggle switch state
    1cd6:	80 58       	subi	r24, 0x80	; 128
    1cd8:	80 93 83 03 	sts	0x0383, r24
		if (++lfo_shape_index == 5) lfo_shape_index = 0;
    1cdc:	80 91 0e 03 	lds	r24, 0x030E
    1ce0:	8f 5f       	subi	r24, 0xFF	; 255
    1ce2:	80 93 0e 03 	sts	0x030E, r24
    1ce6:	85 30       	cpi	r24, 0x05	; 5
    1ce8:	11 f4       	brne	.+4      	; 0x1cee <update_lfo_shape+0x20>
    1cea:	10 92 0e 03 	sts	0x030E, r1
	}
	
	current_patch.byte_2 &= 0b00001111; //clear top 4 bits
	current_patch.byte_2 |= 1 << lfo[lfo_shape_index].led_addr;
    1cee:	e0 91 0e 03 	lds	r30, 0x030E
    1cf2:	f0 e0       	ldi	r31, 0x00	; 0
    1cf4:	ee 0f       	add	r30, r30
    1cf6:	ff 1f       	adc	r31, r31
    1cf8:	ea 5d       	subi	r30, 0xDA	; 218
    1cfa:	fd 4f       	sbci	r31, 0xFD	; 253
    1cfc:	81 e0       	ldi	r24, 0x01	; 1
    1cfe:	90 e0       	ldi	r25, 0x00	; 0
    1d00:	01 80       	ldd	r0, Z+1	; 0x01
    1d02:	02 c0       	rjmp	.+4      	; 0x1d08 <update_lfo_shape+0x3a>
    1d04:	88 0f       	add	r24, r24
    1d06:	99 1f       	adc	r25, r25
    1d08:	0a 94       	dec	r0
    1d0a:	e2 f7       	brpl	.-8      	; 0x1d04 <update_lfo_shape+0x36>
	
		switch_states.byte1 ^= (1<<LFO_SHAPE_SW); //toggle switch state
		if (++lfo_shape_index == 5) lfo_shape_index = 0;
	}
	
	current_patch.byte_2 &= 0b00001111; //clear top 4 bits
    1d0c:	90 91 03 03 	lds	r25, 0x0303
    1d10:	9f 70       	andi	r25, 0x0F	; 15
	current_patch.byte_2 |= 1 << lfo[lfo_shape_index].led_addr;
    1d12:	89 2b       	or	r24, r25
    1d14:	80 93 03 03 	sts	0x0303, r24
	DATA_BUS = lfo[lfo_shape_index].waveform_addr;
    1d18:	80 81       	ld	r24, Z
    1d1a:	82 b9       	out	0x02, r24	; 2
	LFO_LATCH_PORT |= (1<<LFO_SW_LATCH);
    1d1c:	ed ed       	ldi	r30, 0xDD	; 221
    1d1e:	f0 e0       	ldi	r31, 0x00	; 0
    1d20:	80 81       	ld	r24, Z
    1d22:	80 62       	ori	r24, 0x20	; 32
    1d24:	80 83       	st	Z, r24
	LFO_LATCH_PORT &= ~(1<<LFO_SW_LATCH);
    1d26:	80 81       	ld	r24, Z
    1d28:	8f 7d       	andi	r24, 0xDF	; 223
    1d2a:	80 83       	st	Z, r24
	
}		
    1d2c:	08 95       	ret

00001d2e <update_lfo_sync>:
	
void update_lfo_sync(void) {
	
	static uint8_t lfo_sync_mode = 0;
	
	if ((switch_states.byte1 >> LFO_SYNC_SW) & 1) {
    1d2e:	80 91 83 03 	lds	r24, 0x0383
    1d32:	80 ff       	sbrs	r24, 0
    1d34:	0f c0       	rjmp	.+30     	; 0x1d54 <update_lfo_sync+0x26>
			
		switch_states.byte1 ^= (1<<LFO_SYNC_SW); //toggle switch state
    1d36:	91 e0       	ldi	r25, 0x01	; 1
    1d38:	89 27       	eor	r24, r25
    1d3a:	80 93 83 03 	sts	0x0383, r24
		if (++lfo_sync_mode == 5) lfo_sync_mode = 0;
    1d3e:	80 91 0f 03 	lds	r24, 0x030F
    1d42:	8f 5f       	subi	r24, 0xFF	; 255
    1d44:	80 93 0f 03 	sts	0x030F, r24
    1d48:	85 30       	cpi	r24, 0x05	; 5
    1d4a:	11 f4       	brne	.+4      	; 0x1d50 <update_lfo_sync+0x22>
    1d4c:	10 92 0f 03 	sts	0x030F, r1
		lfo_clock.ppqn_counter = 0; //reset counter
    1d50:	10 92 df 03 	sts	0x03DF, r1
	}
	
	current_patch.byte_2 &= 0b11110000; //clear bottom 4 bits
    1d54:	60 91 03 03 	lds	r22, 0x0303
    1d58:	60 7f       	andi	r22, 0xF0	; 240
    1d5a:	60 93 03 03 	sts	0x0303, r22
	if (lfo_sync_mode) current_patch.byte_2 |= (1<<(lfo_sync_mode -1)); //this allows an off state when lfo_sync_mode = 0;
    1d5e:	20 91 0f 03 	lds	r18, 0x030F
    1d62:	22 23       	and	r18, r18
    1d64:	71 f0       	breq	.+28     	; 0x1d82 <update_lfo_sync+0x54>
    1d66:	30 e0       	ldi	r19, 0x00	; 0
    1d68:	21 50       	subi	r18, 0x01	; 1
    1d6a:	30 40       	sbci	r19, 0x00	; 0
    1d6c:	41 e0       	ldi	r20, 0x01	; 1
    1d6e:	50 e0       	ldi	r21, 0x00	; 0
    1d70:	ca 01       	movw	r24, r20
    1d72:	02 c0       	rjmp	.+4      	; 0x1d78 <update_lfo_sync+0x4a>
    1d74:	88 0f       	add	r24, r24
    1d76:	99 1f       	adc	r25, r25
    1d78:	2a 95       	dec	r18
    1d7a:	e2 f7       	brpl	.-8      	; 0x1d74 <update_lfo_sync+0x46>
    1d7c:	86 2b       	or	r24, r22
    1d7e:	80 93 03 03 	sts	0x0303, r24
	
	//now parse out clock divide from patch byte_2
	switch (current_patch.byte_2 & 0b00001111) {
    1d82:	80 91 03 03 	lds	r24, 0x0303
    1d86:	90 e0       	ldi	r25, 0x00	; 0
    1d88:	8f 70       	andi	r24, 0x0F	; 15
    1d8a:	90 70       	andi	r25, 0x00	; 0
    1d8c:	82 30       	cpi	r24, 0x02	; 2
    1d8e:	91 05       	cpc	r25, r1
    1d90:	89 f0       	breq	.+34     	; 0x1db4 <update_lfo_sync+0x86>
    1d92:	83 30       	cpi	r24, 0x03	; 3
    1d94:	91 05       	cpc	r25, r1
    1d96:	24 f4       	brge	.+8      	; 0x1da0 <update_lfo_sync+0x72>
    1d98:	81 30       	cpi	r24, 0x01	; 1
    1d9a:	91 05       	cpc	r25, r1
    1d9c:	b9 f4       	brne	.+46     	; 0x1dcc <update_lfo_sync+0x9e>
    1d9e:	07 c0       	rjmp	.+14     	; 0x1dae <update_lfo_sync+0x80>
    1da0:	84 30       	cpi	r24, 0x04	; 4
    1da2:	91 05       	cpc	r25, r1
    1da4:	59 f0       	breq	.+22     	; 0x1dbc <update_lfo_sync+0x8e>
    1da6:	88 30       	cpi	r24, 0x08	; 8
    1da8:	91 05       	cpc	r25, r1
    1daa:	81 f4       	brne	.+32     	; 0x1dcc <update_lfo_sync+0x9e>
    1dac:	0b c0       	rjmp	.+22     	; 0x1dc4 <update_lfo_sync+0x96>
		
		case 0b0001:
			lfo_clock.divider = 0; //key sync mode - need to turn midi sync off here. How?
    1dae:	10 92 de 03 	sts	0x03DE, r1
			
			break;
    1db2:	08 95       	ret
			
		case 0b0010: //turn these case conditions into constants. #define 0b0010 DIV_24
			lfo_clock.divider = 24; //1:4
    1db4:	88 e1       	ldi	r24, 0x18	; 24
    1db6:	80 93 de 03 	sts	0x03DE, r24
			break;
    1dba:	08 95       	ret
			
		case 0b0100:
			lfo_clock.divider = 12; //1:8
    1dbc:	8c e0       	ldi	r24, 0x0C	; 12
    1dbe:	80 93 de 03 	sts	0x03DE, r24
			break;
    1dc2:	08 95       	ret
			
		case 0b1000:
			lfo_clock.divider = 6; //1:16	 		
    1dc4:	86 e0       	ldi	r24, 0x06	; 6
    1dc6:	80 93 de 03 	sts	0x03DE, r24
			break;
    1dca:	08 95       	ret
		
		default:
			lfo_clock.divider = 0; //need to turn midi sync off here. How?
    1dcc:	10 92 de 03 	sts	0x03DE, r1
    1dd0:	08 95       	ret

00001dd2 <update_arp_sync>:

void update_arp_sync(void) {
	
	static uint8_t arp_sync_mode = 0;
	
	if ((switch_states.byte1 >> ARP_SYNC_SW) & 1) {
    1dd2:	80 91 83 03 	lds	r24, 0x0383
    1dd6:	98 2f       	mov	r25, r24
    1dd8:	92 95       	swap	r25
    1dda:	96 95       	lsr	r25
    1ddc:	96 95       	lsr	r25
    1dde:	93 70       	andi	r25, 0x03	; 3
    1de0:	90 ff       	sbrs	r25, 0
    1de2:	6f c0       	rjmp	.+222    	; 0x1ec2 <update_arp_sync+0xf0>
		
		switch_states.byte1 ^= (1<<ARP_SYNC_SW); //toggle switch state
    1de4:	90 e4       	ldi	r25, 0x40	; 64
    1de6:	89 27       	eor	r24, r25
    1de8:	80 93 83 03 	sts	0x0383, r24
		if (++arp_sync_mode == 5) arp_sync_mode = 0;
    1dec:	80 91 10 03 	lds	r24, 0x0310
    1df0:	8f 5f       	subi	r24, 0xFF	; 255
    1df2:	80 93 10 03 	sts	0x0310, r24
    1df6:	85 30       	cpi	r24, 0x05	; 5
    1df8:	11 f4       	brne	.+4      	; 0x1dfe <update_arp_sync+0x2c>
    1dfa:	10 92 10 03 	sts	0x0310, r1
		//if (arp.clock_source == MIDI_CLOCK) arp.ppqn_counter = 0;//arp.ppqn_counter >> 1; //need to take into account current ppqn count and and new divider value.
		//arp.ppqn_counter = arp.ppqn_counter >> 1;//0; //try this at least to get rid of weird ppqn counter overflow that occurs when changing sync modes.
		current_patch.byte_3 &= 0b11000011; //clear middle 4 bits
    1dfe:	60 91 04 03 	lds	r22, 0x0304
    1e02:	63 7c       	andi	r22, 0xC3	; 195
    1e04:	60 93 04 03 	sts	0x0304, r22
		if (arp_sync_mode) current_patch.byte_3 |= 1<<(arp_sync_mode + 1); //this allows an off state when arp_sync_mode = 0. Is that what's really needed?
    1e08:	20 91 10 03 	lds	r18, 0x0310
    1e0c:	22 23       	and	r18, r18
    1e0e:	71 f0       	breq	.+28     	; 0x1e2c <update_arp_sync+0x5a>
    1e10:	30 e0       	ldi	r19, 0x00	; 0
    1e12:	2f 5f       	subi	r18, 0xFF	; 255
    1e14:	3f 4f       	sbci	r19, 0xFF	; 255
    1e16:	41 e0       	ldi	r20, 0x01	; 1
    1e18:	50 e0       	ldi	r21, 0x00	; 0
    1e1a:	ca 01       	movw	r24, r20
    1e1c:	02 c0       	rjmp	.+4      	; 0x1e22 <update_arp_sync+0x50>
    1e1e:	88 0f       	add	r24, r24
    1e20:	99 1f       	adc	r25, r25
    1e22:	2a 95       	dec	r18
    1e24:	e2 f7       	brpl	.-8      	; 0x1e1e <update_arp_sync+0x4c>
    1e26:	86 2b       	or	r24, r22
    1e28:	80 93 04 03 	sts	0x0304, r24
			
		switch (current_patch.byte_3 & 0b00111100) {
    1e2c:	80 91 04 03 	lds	r24, 0x0304
    1e30:	90 e0       	ldi	r25, 0x00	; 0
    1e32:	8c 73       	andi	r24, 0x3C	; 60
    1e34:	90 70       	andi	r25, 0x00	; 0
    1e36:	88 30       	cpi	r24, 0x08	; 8
    1e38:	91 05       	cpc	r25, r1
    1e3a:	a1 f0       	breq	.+40     	; 0x1e64 <update_arp_sync+0x92>
    1e3c:	89 30       	cpi	r24, 0x09	; 9
    1e3e:	91 05       	cpc	r25, r1
    1e40:	24 f4       	brge	.+8      	; 0x1e4a <update_arp_sync+0x78>
    1e42:	84 30       	cpi	r24, 0x04	; 4
    1e44:	91 05       	cpc	r25, r1
    1e46:	01 f5       	brne	.+64     	; 0x1e88 <update_arp_sync+0xb6>
    1e48:	07 c0       	rjmp	.+14     	; 0x1e58 <update_arp_sync+0x86>
    1e4a:	80 31       	cpi	r24, 0x10	; 16
    1e4c:	91 05       	cpc	r25, r1
    1e4e:	81 f0       	breq	.+32     	; 0x1e70 <update_arp_sync+0x9e>
    1e50:	80 32       	cpi	r24, 0x20	; 32
    1e52:	91 05       	cpc	r25, r1
    1e54:	c9 f4       	brne	.+50     	; 0x1e88 <update_arp_sync+0xb6>
    1e56:	12 c0       	rjmp	.+36     	; 0x1e7c <update_arp_sync+0xaa>
				
			case 0b00000100:
			system_clock.divider = arp.divider = 48; //1:2
    1e58:	80 e3       	ldi	r24, 0x30	; 48
    1e5a:	80 93 8f 03 	sts	0x038F, r24
    1e5e:	80 93 d8 03 	sts	0x03D8, r24
			break;
    1e62:	17 c0       	rjmp	.+46     	; 0x1e92 <update_arp_sync+0xc0>
				
			case 0b00001000:
			system_clock.divider = arp.divider = 24; //1:4
    1e64:	88 e1       	ldi	r24, 0x18	; 24
    1e66:	80 93 8f 03 	sts	0x038F, r24
    1e6a:	80 93 d8 03 	sts	0x03D8, r24
				
			break;
    1e6e:	11 c0       	rjmp	.+34     	; 0x1e92 <update_arp_sync+0xc0>
				
			case 0b00010000:
			system_clock.divider = arp.divider = 12; //1:8
    1e70:	8c e0       	ldi	r24, 0x0C	; 12
    1e72:	80 93 8f 03 	sts	0x038F, r24
    1e76:	80 93 d8 03 	sts	0x03D8, r24
			break;
    1e7a:	0b c0       	rjmp	.+22     	; 0x1e92 <update_arp_sync+0xc0>
				
			case 0b00100000:
			system_clock.divider = arp.divider = 6; //1:16
    1e7c:	86 e0       	ldi	r24, 0x06	; 6
    1e7e:	80 93 8f 03 	sts	0x038F, r24
    1e82:	80 93 d8 03 	sts	0x03D8, r24
			break;
    1e86:	05 c0       	rjmp	.+10     	; 0x1e92 <update_arp_sync+0xc0>
				
			default:
			system_clock.divider = arp.divider = 3; //1:32 - this is a hack - no LEDs lighted
    1e88:	83 e0       	ldi	r24, 0x03	; 3
    1e8a:	80 93 8f 03 	sts	0x038F, r24
    1e8e:	80 93 d8 03 	sts	0x03D8, r24
				
		}
		
		//uint32_t total_ppqn = (uint32_t)arp.song_position*6;
		arp.ppqn_counter = (arp.song_position % arp.divider) - arp.ppqn_shift;// + 1;
    1e92:	20 91 8f 03 	lds	r18, 0x038F
    1e96:	30 e0       	ldi	r19, 0x00	; 0
    1e98:	40 e0       	ldi	r20, 0x00	; 0
    1e9a:	50 e0       	ldi	r21, 0x00	; 0
    1e9c:	60 91 91 03 	lds	r22, 0x0391
    1ea0:	70 91 92 03 	lds	r23, 0x0392
    1ea4:	80 91 93 03 	lds	r24, 0x0393
    1ea8:	90 91 94 03 	lds	r25, 0x0394
    1eac:	0e 94 d6 1e 	call	0x3dac	; 0x3dac <__udivmodsi4>
    1eb0:	80 91 90 03 	lds	r24, 0x0390
    1eb4:	68 1b       	sub	r22, r24
    1eb6:	60 93 8e 03 	sts	0x038E, r22
		arp.display = arp.ppqn_counter;
    1eba:	60 93 95 03 	sts	0x0395, r22
			
		//OK, now need to modify this to maintain phase with beat clock
		system_clock.ppqn_counter = 0;	//same applies to system clock ppqn counter
    1ebe:	10 92 d9 03 	sts	0x03D9, r1
    1ec2:	08 95       	ret

00001ec4 <update_arp_range>:

void update_arp_range(void) {
	
	static uint8_t arp_range = 0;
	
	if ((switch_states.byte1 == (1<<ARP_RANGE_SW)) & 1) {
    1ec4:	80 91 83 03 	lds	r24, 0x0383
    1ec8:	80 31       	cpi	r24, 0x10	; 16
    1eca:	69 f4       	brne	.+26     	; 0x1ee6 <update_arp_range+0x22>
		
		switch_states.byte1 ^= (1<<ARP_RANGE_SW); //toggle switch bit
    1ecc:	10 92 83 03 	sts	0x0383, r1
		
		if (++arp_range == 4) arp_range = 0;
    1ed0:	80 91 11 03 	lds	r24, 0x0311
    1ed4:	8f 5f       	subi	r24, 0xFF	; 255
    1ed6:	80 93 11 03 	sts	0x0311, r24
    1eda:	84 30       	cpi	r24, 0x04	; 4
    1edc:	11 f4       	brne	.+4      	; 0x1ee2 <update_arp_range+0x1e>
    1ede:	10 92 11 03 	sts	0x0311, r1
		arp.step_position = 0; //reset step position if range changes
    1ee2:	10 92 8a 03 	sts	0x038A, r1
						
	}
	
	//arp range LEDs 3 and 2 are in byte_3, bits 7 and 6, respectively. arp range LED 1 is bit 1 of byte_1
	
	current_patch.byte_1 &= ~(1<<ARP_RANGE_1); //clear arp range 1 LED
    1ee6:	80 91 02 03 	lds	r24, 0x0302
    1eea:	8d 7f       	andi	r24, 0xFD	; 253
    1eec:	80 93 02 03 	sts	0x0302, r24
	current_patch.byte_3 &= 0b00111111; //clear bits 6 and7, arp range 3 and 2
    1ef0:	80 91 04 03 	lds	r24, 0x0304
    1ef4:	8f 73       	andi	r24, 0x3F	; 63
    1ef6:	80 93 04 03 	sts	0x0304, r24
	
	arp.range = arp_range;
    1efa:	80 91 11 03 	lds	r24, 0x0311
    1efe:	80 93 88 03 	sts	0x0388, r24
	
	update_arp_sequence(); //update sequence with new settings
    1f02:	0e 94 a3 00 	call	0x146	; 0x146 <update_arp_sequence>
	
	switch (arp_range) { //this just updates LEDs. no struct to handle arp range yet
    1f06:	80 91 11 03 	lds	r24, 0x0311
    1f0a:	82 30       	cpi	r24, 0x02	; 2
    1f0c:	51 f0       	breq	.+20     	; 0x1f22 <update_arp_range+0x5e>
    1f0e:	83 30       	cpi	r24, 0x03	; 3
    1f10:	71 f0       	breq	.+28     	; 0x1f2e <update_arp_range+0x6a>
    1f12:	81 30       	cpi	r24, 0x01	; 1
    1f14:	89 f4       	brne	.+34     	; 0x1f38 <update_arp_range+0x74>
			
			break;
			
		case 1:
		
			current_patch.byte_1 |= (1<<ARP_RANGE_1); //set range 1 LED. LED was in the wrong way!
    1f16:	80 91 02 03 	lds	r24, 0x0302
    1f1a:	82 60       	ori	r24, 0x02	; 2
    1f1c:	80 93 02 03 	sts	0x0302, r24
			break;
    1f20:	08 95       	ret
			
		case 2:
		
			current_patch.byte_3 |= (1<<ARP_RANGE_2);		
    1f22:	80 91 04 03 	lds	r24, 0x0304
    1f26:	80 64       	ori	r24, 0x40	; 64
    1f28:	80 93 04 03 	sts	0x0304, r24
			break;
    1f2c:	08 95       	ret
			
			
		case 3: 
			
			current_patch.byte_3 |= (1<<ARP_RANGE_3);
    1f2e:	80 91 04 03 	lds	r24, 0x0304
    1f32:	80 68       	ori	r24, 0x80	; 128
    1f34:	80 93 04 03 	sts	0x0304, r24
    1f38:	08 95       	ret

00001f3a <update_arp_mode>:

void update_arp_mode(void) {

	static uint8_t arp_mode = 0;
	
	if ((switch_states.byte1 >> ARP_MODE_SW) & 1) {
    1f3a:	80 91 83 03 	lds	r24, 0x0383
    1f3e:	98 2f       	mov	r25, r24
    1f40:	92 95       	swap	r25
    1f42:	96 95       	lsr	r25
    1f44:	97 70       	andi	r25, 0x07	; 7
    1f46:	90 ff       	sbrs	r25, 0
    1f48:	2b c0       	rjmp	.+86     	; 0x1fa0 <update_arp_mode+0x66>
		
		switch_states.byte1 ^= (1<<ARP_MODE_SW); //toggle switch state
    1f4a:	90 e2       	ldi	r25, 0x20	; 32
    1f4c:	89 27       	eor	r24, r25
    1f4e:	80 93 83 03 	sts	0x0383, r24
		if (arp_mode == 0) {
    1f52:	80 91 12 03 	lds	r24, 0x0312
    1f56:	88 23       	and	r24, r24
    1f58:	d1 f4       	brne	.+52     	; 0x1f8e <update_arp_mode+0x54>
			
			update_arp_sequence(); //if arp mode is OFF it's about to be turned on, so update arp_sequence
    1f5a:	0e 94 a3 00 	call	0x146	; 0x146 <update_arp_sequence>
			//arp.ppqn_counter = ((arp.song_position*6) % arp.divider);// +1; //not sure about the +1 here - may
			arp.ppqn_counter = (arp.song_position % arp.divider) - arp.ppqn_shift;// + 1;
    1f5e:	20 91 8f 03 	lds	r18, 0x038F
    1f62:	30 e0       	ldi	r19, 0x00	; 0
    1f64:	40 e0       	ldi	r20, 0x00	; 0
    1f66:	50 e0       	ldi	r21, 0x00	; 0
    1f68:	60 91 91 03 	lds	r22, 0x0391
    1f6c:	70 91 92 03 	lds	r23, 0x0392
    1f70:	80 91 93 03 	lds	r24, 0x0393
    1f74:	90 91 94 03 	lds	r25, 0x0394
    1f78:	0e 94 d6 1e 	call	0x3dac	; 0x3dac <__udivmodsi4>
    1f7c:	80 91 90 03 	lds	r24, 0x0390
    1f80:	68 1b       	sub	r22, r24
    1f82:	60 93 8e 03 	sts	0x038E, r22
			arp.display = arp.ppqn_counter;
    1f86:	60 93 95 03 	sts	0x0395, r22
			arp.step_position = 0;
    1f8a:	10 92 8a 03 	sts	0x038A, r1
			//now need to set arp.ppqn_counter and arp.step_position based on arp.song_position
			//arp.step_position = //do something to calculate arp step position based on calculated ppqn_counter. Is there enough information to calculate this???
		
		}			
		if (++arp_mode == 5) arp_mode = 0;
    1f8e:	80 91 12 03 	lds	r24, 0x0312
    1f92:	8f 5f       	subi	r24, 0xFF	; 255
    1f94:	80 93 12 03 	sts	0x0312, r24
    1f98:	85 30       	cpi	r24, 0x05	; 5
    1f9a:	11 f4       	brne	.+4      	; 0x1fa0 <update_arp_mode+0x66>
    1f9c:	10 92 12 03 	sts	0x0312, r1
		
	}

	//if (arp.clock_source != MIDI_CLOCK) arp.clock_source = INTERNAL_CLOCK;	

	current_patch.byte_1 &= 0b11000011; //clear middle 4 bits UP, DOWN, RANDOM, MODE correspond to bits 6>>2
    1fa0:	90 91 02 03 	lds	r25, 0x0302
    1fa4:	93 7c       	andi	r25, 0xC3	; 195
    1fa6:	90 93 02 03 	sts	0x0302, r25
	
	switch(arp_mode) {
    1faa:	80 91 12 03 	lds	r24, 0x0312
    1fae:	81 30       	cpi	r24, 0x01	; 1
    1fb0:	79 f0       	breq	.+30     	; 0x1fd0 <update_arp_mode+0x96>
    1fb2:	81 30       	cpi	r24, 0x01	; 1
    1fb4:	28 f0       	brcs	.+10     	; 0x1fc0 <update_arp_mode+0x86>
    1fb6:	82 30       	cpi	r24, 0x02	; 2
    1fb8:	91 f0       	breq	.+36     	; 0x1fde <update_arp_mode+0xa4>
    1fba:	83 30       	cpi	r24, 0x03	; 3
    1fbc:	f1 f4       	brne	.+60     	; 0x1ffa <update_arp_mode+0xc0>
    1fbe:	16 c0       	rjmp	.+44     	; 0x1fec <update_arp_mode+0xb2>
		
		case 0:
		
			//turn arp off
			arp.mode = OFF;
    1fc0:	10 92 97 03 	sts	0x0397, r1
			if (gate_buffer == 0) PORTF &= ~(1<<GATE); //turn gate off.
    1fc4:	80 91 b4 02 	lds	r24, 0x02B4
    1fc8:	88 23       	and	r24, r24
    1fca:	e9 f4       	brne	.+58     	; 0x2006 <update_arp_mode+0xcc>
    1fcc:	89 98       	cbi	0x11, 1	; 17
    1fce:	1b c0       	rjmp	.+54     	; 0x2006 <update_arp_mode+0xcc>
			break;
			
		case 1:
		
			current_patch.byte_1 |= (1<<ARP_MODE_UP) | (1<<ARP_ON);
    1fd0:	94 62       	ori	r25, 0x24	; 36
    1fd2:	90 93 02 03 	sts	0x0302, r25
			arp.mode = UP;
    1fd6:	81 e0       	ldi	r24, 0x01	; 1
    1fd8:	80 93 97 03 	sts	0x0397, r24
			break;	
    1fdc:	14 c0       	rjmp	.+40     	; 0x2006 <update_arp_mode+0xcc>
		
		case 2:
			current_patch.byte_1 |= (1<<ARP_MODE_DN) | (1<<ARP_ON);
    1fde:	94 61       	ori	r25, 0x14	; 20
    1fe0:	90 93 02 03 	sts	0x0302, r25
			arp.mode = DOWN;
    1fe4:	82 e0       	ldi	r24, 0x02	; 2
    1fe6:	80 93 97 03 	sts	0x0397, r24
			break;
    1fea:	0d c0       	rjmp	.+26     	; 0x2006 <update_arp_mode+0xcc>
			
		case 3:
			current_patch.byte_1 |= (1<<ARP_MODE_UP) | (1<<ARP_MODE_DN) | (1<<ARP_ON);
    1fec:	94 63       	ori	r25, 0x34	; 52
    1fee:	90 93 02 03 	sts	0x0302, r25
			arp.mode = UP_DOWN;
    1ff2:	83 e0       	ldi	r24, 0x03	; 3
    1ff4:	80 93 97 03 	sts	0x0397, r24
			break;
    1ff8:	06 c0       	rjmp	.+12     	; 0x2006 <update_arp_mode+0xcc>
			
		default:
			current_patch.byte_1 |= (1<<ARP_MODE_RD) | (1<<ARP_ON);
    1ffa:	9c 60       	ori	r25, 0x0C	; 12
    1ffc:	90 93 02 03 	sts	0x0302, r25
			arp.mode = RANDOM;
    2000:	84 e0       	ldi	r24, 0x04	; 4
    2002:	80 93 97 03 	sts	0x0397, r24
			
					
		
	}
	
	update_arp_sequence(); //update arp sequence with new mode
    2006:	0e 94 a3 00 	call	0x146	; 0x146 <update_arp_sequence>
	



}
    200a:	08 95       	ret

0000200c <update_patch>:
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    200c:	90 91 82 03 	lds	r25, 0x0382
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
							((switch_states.byte0 >> VCO1_PULSE_SW) & 1) << VCO1_PULSE |
							((switch_states.byte0 >> VCO2_SAW_SW) & 1) << VCO2_SAW |
							((switch_states.byte0 >> VCO2_TRI_SW) & 1) << VCO2_TRI |
							((switch_states.byte0 >> VCO2_PULSE_SW) & 1) << VCO2_PULSE |
							((switch_states.byte2 >> BMOD_SW) & 1) << BMOD;
    2010:	80 91 84 03 	lds	r24, 0x0384
    2014:	86 95       	lsr	r24
    2016:	86 95       	lsr	r24
    2018:	68 2f       	mov	r22, r24
    201a:	67 95       	ror	r22
    201c:	66 27       	eor	r22, r22
    201e:	67 95       	ror	r22
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    2020:	29 2f       	mov	r18, r25
    2022:	21 70       	andi	r18, 0x01	; 1
    2024:	26 2b       	or	r18, r22
    2026:	69 2f       	mov	r22, r25
    2028:	66 1f       	adc	r22, r22
    202a:	66 27       	eor	r22, r22
    202c:	66 1f       	adc	r22, r22
    202e:	66 0f       	add	r22, r22
    2030:	62 2b       	or	r22, r18
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
    2032:	29 2f       	mov	r18, r25
    2034:	26 95       	lsr	r18
    2036:	26 95       	lsr	r18
    2038:	30 e0       	ldi	r19, 0x00	; 0
    203a:	21 70       	andi	r18, 0x01	; 1
    203c:	30 70       	andi	r19, 0x00	; 0
    203e:	d9 01       	movw	r26, r18
    2040:	aa 0f       	add	r26, r26
    2042:	bb 1f       	adc	r27, r27
    2044:	aa 0f       	add	r26, r26
    2046:	bb 1f       	adc	r27, r27
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    2048:	6a 2b       	or	r22, r26
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
    204a:	a9 2f       	mov	r26, r25
    204c:	a6 95       	lsr	r26
    204e:	b0 e0       	ldi	r27, 0x00	; 0
    2050:	a1 70       	andi	r26, 0x01	; 1
    2052:	b0 70       	andi	r27, 0x00	; 0
    2054:	fd 01       	movw	r30, r26
    2056:	ee 0f       	add	r30, r30
    2058:	ff 1f       	adc	r31, r31
    205a:	ee 0f       	add	r30, r30
    205c:	ff 1f       	adc	r31, r31
    205e:	ee 0f       	add	r30, r30
    2060:	ff 1f       	adc	r31, r31
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    2062:	a6 2f       	mov	r26, r22
    2064:	ae 2b       	or	r26, r30
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
							((switch_states.byte0 >> VCO1_PULSE_SW) & 1) << VCO1_PULSE |
							((switch_states.byte0 >> VCO2_SAW_SW) & 1) << VCO2_SAW |
    2066:	e9 2f       	mov	r30, r25
    2068:	e2 95       	swap	r30
    206a:	ef 70       	andi	r30, 0x0F	; 15
    206c:	f0 e0       	ldi	r31, 0x00	; 0
    206e:	e1 70       	andi	r30, 0x01	; 1
    2070:	f0 70       	andi	r31, 0x00	; 0
    2072:	bf 01       	movw	r22, r30
    2074:	62 95       	swap	r22
    2076:	72 95       	swap	r23
    2078:	70 7f       	andi	r23, 0xF0	; 240
    207a:	76 27       	eor	r23, r22
    207c:	60 7f       	andi	r22, 0xF0	; 240
    207e:	76 27       	eor	r23, r22
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    2080:	ea 2f       	mov	r30, r26
    2082:	e6 2b       	or	r30, r22
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
							((switch_states.byte0 >> VCO1_PULSE_SW) & 1) << VCO1_PULSE |
							((switch_states.byte0 >> VCO2_SAW_SW) & 1) << VCO2_SAW |
							((switch_states.byte0 >> VCO2_TRI_SW) & 1) << VCO2_TRI |
    2084:	69 2f       	mov	r22, r25
    2086:	62 95       	swap	r22
    2088:	66 95       	lsr	r22
    208a:	67 70       	andi	r22, 0x07	; 7
    208c:	70 e0       	ldi	r23, 0x00	; 0
    208e:	61 70       	andi	r22, 0x01	; 1
    2090:	70 70       	andi	r23, 0x00	; 0
    2092:	ab 01       	movw	r20, r22
    2094:	44 0f       	add	r20, r20
    2096:	55 1f       	adc	r21, r21
    2098:	42 95       	swap	r20
    209a:	52 95       	swap	r21
    209c:	50 7f       	andi	r21, 0xF0	; 240
    209e:	54 27       	eor	r21, r20
    20a0:	40 7f       	andi	r20, 0xF0	; 240
    20a2:	54 27       	eor	r21, r20
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    20a4:	6e 2f       	mov	r22, r30
    20a6:	64 2b       	or	r22, r20
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
							((switch_states.byte0 >> VCO1_PULSE_SW) & 1) << VCO1_PULSE |
							((switch_states.byte0 >> VCO2_SAW_SW) & 1) << VCO2_SAW |
							((switch_states.byte0 >> VCO2_TRI_SW) & 1) << VCO2_TRI |
							((switch_states.byte0 >> VCO2_PULSE_SW) & 1) << VCO2_PULSE |
    20a8:	49 2f       	mov	r20, r25
    20aa:	42 95       	swap	r20
    20ac:	46 95       	lsr	r20
    20ae:	46 95       	lsr	r20
    20b0:	43 70       	andi	r20, 0x03	; 3
    20b2:	50 e0       	ldi	r21, 0x00	; 0
    20b4:	41 70       	andi	r20, 0x01	; 1
    20b6:	50 70       	andi	r21, 0x00	; 0
    20b8:	9a 01       	movw	r18, r20
    20ba:	00 24       	eor	r0, r0
    20bc:	36 95       	lsr	r19
    20be:	27 95       	ror	r18
    20c0:	07 94       	ror	r0
    20c2:	36 95       	lsr	r19
    20c4:	27 95       	ror	r18
    20c6:	07 94       	ror	r0
    20c8:	32 2f       	mov	r19, r18
    20ca:	20 2d       	mov	r18, r0
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    20cc:	26 2b       	or	r18, r22
    20ce:	20 93 06 03 	sts	0x0306, r18
			
	//update analog switch latch:
	//need to incorporate BMOD_LATCH_BIT switch state into data byte sent to analog switch latch
	//3rd switch bit is VCO1_OCTAVE_UP_SW state, which isn't used by analog switch latch
	uint8_t analog_sw_byte = switch_states.byte0;
	uint8_t BMOD_SW_ON = (switch_states.byte2 >> BMOD_SW) & 1;
    20d2:	81 70       	andi	r24, 0x01	; 1
	analog_sw_byte ^= (-BMOD_SW_ON ^ analog_sw_byte) & (1<<3);//set third bit dependent on BMOD switch state
    20d4:	81 95       	neg	r24
    20d6:	89 27       	eor	r24, r25
    20d8:	88 70       	andi	r24, 0x08	; 8
	update_analog_switch_latch(analog_sw_byte);
    20da:	89 27       	eor	r24, r25
    20dc:	0e 94 6d 17 	call	0x2eda	; 0x2eda <update_analog_switch_latch>
					
	//set EG2 INV bit. This changes the nth bit to x from: http://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit-in-c-c
	//need to make sure this doesn't interfere with anything else on this port
	uint8_t EG2_INV_ON = (switch_states.byte2 >> EG2_INV_SW) & 1;	
	EG2_POL_PORT ^= (-EG2_INV_ON ^ EG2_POL_PORT) & (1<<EG2_POL);
    20e0:	ed ed       	ldi	r30, 0xDD	; 221
    20e2:	f0 e0       	ldi	r31, 0x00	; 0
    20e4:	20 81       	ld	r18, Z
	analog_sw_byte ^= (-BMOD_SW_ON ^ analog_sw_byte) & (1<<3);//set third bit dependent on BMOD switch state
	update_analog_switch_latch(analog_sw_byte);
					
	//set EG2 INV bit. This changes the nth bit to x from: http://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit-in-c-c
	//need to make sure this doesn't interfere with anything else on this port
	uint8_t EG2_INV_ON = (switch_states.byte2 >> EG2_INV_SW) & 1;	
    20e6:	90 91 84 03 	lds	r25, 0x0384
    20ea:	96 95       	lsr	r25
    20ec:	96 95       	lsr	r25
    20ee:	96 95       	lsr	r25
    20f0:	91 70       	andi	r25, 0x01	; 1
	EG2_POL_PORT ^= (-EG2_INV_ON ^ EG2_POL_PORT) & (1<<EG2_POL);
    20f2:	91 95       	neg	r25
    20f4:	80 81       	ld	r24, Z
    20f6:	89 27       	eor	r24, r25
    20f8:	80 71       	andi	r24, 0x10	; 16
    20fa:	82 27       	eor	r24, r18
    20fc:	80 83       	st	Z, r24
	current_patch.byte_1 ^= (-EG2_INV_ON ^ current_patch.byte_1) & (1 << EG2_INV); //don't forget to set it in patch or it won't be saved!
    20fe:	e2 e0       	ldi	r30, 0x02	; 2
    2100:	f3 e0       	ldi	r31, 0x03	; 3
    2102:	80 81       	ld	r24, Z
    2104:	98 27       	eor	r25, r24
    2106:	91 70       	andi	r25, 0x01	; 1
    2108:	89 27       	eor	r24, r25
    210a:	80 83       	st	Z, r24
	
	//parse octave switch data
	update_octave_range();
    210c:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <update_octave_range>
	
	//parse LFO data
	update_lfo_shape();
    2110:	0e 94 67 0e 	call	0x1cce	; 0x1cce <update_lfo_shape>
	
	//parse LFO sync data
	update_lfo_sync();
    2114:	0e 94 97 0e 	call	0x1d2e	; 0x1d2e <update_lfo_sync>

	//update arp settings
	update_arp_sync();
    2118:	0e 94 e9 0e 	call	0x1dd2	; 0x1dd2 <update_arp_sync>
	update_arp_range();
    211c:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <update_arp_range>
	update_arp_mode();
    2120:	0e 94 9d 0f 	call	0x1f3a	; 0x1f3a <update_arp_mode>
	//update_patch_programmer();		
				

		
	
}
    2124:	08 95       	ret

00002126 <update_patch_programmer>:





void update_patch_programmer(void) { //maybe best to use a switch/case statement here instead of a series of if/elses?
    2126:	cf 93       	push	r28
    2128:	df 93       	push	r29
	
	if (current_patch.mode == CAL) //temporary tune button hack by pressing and holding PROG DOWN switch
    212a:	90 91 0b 03 	lds	r25, 0x030B
    212e:	95 30       	cpi	r25, 0x05	; 5
    2130:	01 f5       	brne	.+64     	; 0x2172 <update_patch_programmer+0x4c>
	{
		
		
		//TURN OFF LFO OUTPUT
		DATA_BUS = 0b00000111; //turn off LFO waveform
    2132:	87 e0       	ldi	r24, 0x07	; 7
    2134:	82 b9       	out	0x02, r24	; 2
		LFO_LATCH_PORT |= (1<<LFO_SW_LATCH);
    2136:	cd ed       	ldi	r28, 0xDD	; 221
    2138:	d0 e0       	ldi	r29, 0x00	; 0
    213a:	88 81       	ld	r24, Y
    213c:	80 62       	ori	r24, 0x20	; 32
    213e:	88 83       	st	Y, r24
		LFO_LATCH_PORT &= ~(1<<LFO_SW_LATCH);
    2140:	88 81       	ld	r24, Y
    2142:	8f 7d       	andi	r24, 0xDF	; 223
    2144:	88 83       	st	Y, r24
		DATA_BUS = 0;
    2146:	12 b8       	out	0x02, r1	; 2
		
		tune();
    2148:	0e 94 10 17 	call	0x2e20	; 0x2e20 <tune>
		
		DATA_BUS = LFO_TRI_ADDR;
    214c:	12 b8       	out	0x02, r1	; 2
		LFO_LATCH_PORT |= (1<<LFO_SW_LATCH);
    214e:	88 81       	ld	r24, Y
    2150:	80 62       	ori	r24, 0x20	; 32
    2152:	88 83       	st	Y, r24
		LFO_LATCH_PORT &= ~(1<<LFO_SW_LATCH);
    2154:	88 81       	ld	r24, Y
    2156:	8f 7d       	andi	r24, 0xDF	; 223
    2158:	88 83       	st	Y, r24
		DATA_BUS = 0;
    215a:	12 b8       	out	0x02, r1	; 2
		current_patch.byte_2 &= 0b00001111; //clear top 4 bits
    215c:	80 91 03 03 	lds	r24, 0x0303
    2160:	8f 70       	andi	r24, 0x0F	; 15
		current_patch.byte_2 |= (1<<LFO_TRI);
    2162:	80 68       	ori	r24, 0x80	; 128
    2164:	80 93 03 03 	sts	0x0303, r24
		
		setup_system_clock(); //restore system clock settings
    2168:	0e 94 ed 01 	call	0x3da	; 0x3da <setup_system_clock>

		current_patch.mode = MEMORY;
    216c:	10 92 0b 03 	sts	0x030B, r1
		
		return;
    2170:	63 c0       	rjmp	.+198    	; 0x2238 <update_patch_programmer+0x112>
		
	}
	

	
	if ((switch_states.byte2>> PROG_UP_SW) & 1) {
    2172:	80 91 84 03 	lds	r24, 0x0384
    2176:	28 2f       	mov	r18, r24
    2178:	22 95       	swap	r18
    217a:	26 95       	lsr	r18
    217c:	26 95       	lsr	r18
    217e:	23 70       	andi	r18, 0x03	; 3
    2180:	20 ff       	sbrs	r18, 0
    2182:	15 c0       	rjmp	.+42     	; 0x21ae <update_patch_programmer+0x88>
		
		switch_states.byte2 ^= (1<<PROG_UP_SW); //toggle switch state bit
    2184:	20 e4       	ldi	r18, 0x40	; 64
    2186:	82 27       	eor	r24, r18
    2188:	80 93 84 03 	sts	0x0384, r24
		
		if (++current_patch.number == NUM_PATCHES + 1) {			
    218c:	80 91 07 03 	lds	r24, 0x0307
    2190:	8f 5f       	subi	r24, 0xFF	; 255
    2192:	80 93 07 03 	sts	0x0307, r24
    2196:	85 32       	cpi	r24, 0x25	; 37
    2198:	21 f4       	brne	.+8      	; 0x21a2 <update_patch_programmer+0x7c>
			
			current_patch.number = NUM_PATCHES; //max patch number
    219a:	84 e2       	ldi	r24, 0x24	; 36
    219c:	80 93 07 03 	sts	0x0307, r24
    21a0:	06 c0       	rjmp	.+12     	; 0x21ae <update_patch_programmer+0x88>
		
					
		} else if (current_patch.mode != WRITE) { //load next patch if not in WRITE mode
    21a2:	93 30       	cpi	r25, 0x03	; 3
    21a4:	21 f0       	breq	.+8      	; 0x21ae <update_patch_programmer+0x88>
			
			load_patch(current_patch.number);
    21a6:	0e 94 ec 0a 	call	0x15d8	; 0x15d8 <load_patch>
			update_patch();
    21aa:	0e 94 06 10 	call	0x200c	; 0x200c <update_patch>
			
		}		
		
	}
	
	if ((switch_states.byte2 >> PROG_DOWN_SW) & 1) {
    21ae:	80 91 84 03 	lds	r24, 0x0384
    21b2:	98 2f       	mov	r25, r24
    21b4:	92 95       	swap	r25
    21b6:	96 95       	lsr	r25
    21b8:	97 70       	andi	r25, 0x07	; 7
    21ba:	90 ff       	sbrs	r25, 0
    21bc:	15 c0       	rjmp	.+42     	; 0x21e8 <update_patch_programmer+0xc2>
	
		switch_states.byte2 ^= (1<<PROG_DOWN_SW); //toggle switch state bit
    21be:	90 e2       	ldi	r25, 0x20	; 32
    21c0:	89 27       	eor	r24, r25
    21c2:	80 93 84 03 	sts	0x0384, r24

		if (current_patch.number == 1) {} else {current_patch.number--;}
    21c6:	80 91 07 03 	lds	r24, 0x0307
    21ca:	81 30       	cpi	r24, 0x01	; 1
    21cc:	19 f0       	breq	.+6      	; 0x21d4 <update_patch_programmer+0xae>
    21ce:	81 50       	subi	r24, 0x01	; 1
    21d0:	80 93 07 03 	sts	0x0307, r24
		
		if (current_patch.mode != WRITE) {
    21d4:	80 91 0b 03 	lds	r24, 0x030B
    21d8:	83 30       	cpi	r24, 0x03	; 3
    21da:	31 f0       	breq	.+12     	; 0x21e8 <update_patch_programmer+0xc2>
			
			load_patch(current_patch.number); 
    21dc:	80 91 07 03 	lds	r24, 0x0307
    21e0:	0e 94 ec 0a 	call	0x15d8	; 0x15d8 <load_patch>
			update_patch();
    21e4:	0e 94 06 10 	call	0x200c	; 0x200c <update_patch>
		}			
	}
	
	
	if ((switch_states.byte2 >> PROG_WRITE_SW) & 1) {
    21e8:	80 91 84 03 	lds	r24, 0x0384
    21ec:	98 2f       	mov	r25, r24
    21ee:	92 95       	swap	r25
    21f0:	9f 70       	andi	r25, 0x0F	; 15
    21f2:	90 ff       	sbrs	r25, 0
    21f4:	15 c0       	rjmp	.+42     	; 0x2220 <update_patch_programmer+0xfa>
		
		switch_states.byte2 ^= (1<<PROG_WRITE_SW);
    21f6:	90 e1       	ldi	r25, 0x10	; 16
    21f8:	89 27       	eor	r24, r25
    21fa:	80 93 84 03 	sts	0x0384, r24
		if (current_patch.mode != WRITE) {
    21fe:	90 91 0b 03 	lds	r25, 0x030B
    2202:	93 30       	cpi	r25, 0x03	; 3
    2204:	49 f0       	breq	.+18     	; 0x2218 <update_patch_programmer+0xf2>
			switch_states.byte2 &= ~(1<< PROG_MANUAL_SW); //turn off manual mode
    2206:	8f 77       	andi	r24, 0x7F	; 127
    2208:	80 93 84 03 	sts	0x0384, r24
			current_patch.mode = WRITE;
    220c:	83 e0       	ldi	r24, 0x03	; 3
    220e:	80 93 0b 03 	sts	0x030B, r24
			lock_pots();
    2212:	0e 94 ce 08 	call	0x119c	; 0x119c <lock_pots>
    2216:	04 c0       	rjmp	.+8      	; 0x2220 <update_patch_programmer+0xfa>
			
			
		} else {
			
			save_patch(current_patch.number); //write the patch
    2218:	80 91 07 03 	lds	r24, 0x0307
    221c:	0e 94 f9 08 	call	0x11f2	; 0x11f2 <save_patch>
		//save_patch(current_patch.number);
		
		
	}
	
	if (((switch_states.byte2 >> PROG_MANUAL_SW) & 1)) {
    2220:	80 91 84 03 	lds	r24, 0x0384
    2224:	88 23       	and	r24, r24
    2226:	44 f4       	brge	.+16     	; 0x2238 <update_patch_programmer+0x112>
			
		switch_states.byte2 |= (1<< PROG_MANUAL_SW);
    2228:	80 68       	ori	r24, 0x80	; 128
    222a:	80 93 84 03 	sts	0x0384, r24
		current_patch.mode = MANUAL;
    222e:	81 e0       	ldi	r24, 0x01	; 1
    2230:	80 93 0b 03 	sts	0x030B, r24
		unlock_pots();
    2234:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <unlock_pots>
	}
	//value_to_display = current_patch.number;	
	//value_to_display = vco1_init_cv>>1;
	
	
}	
    2238:	df 91       	pop	r29
    223a:	cf 91       	pop	r28
    223c:	08 95       	ret

0000223e <initialize_voice_for_tuning>:
	

void initialize_voice_for_tuning(void) { //this function sets all CVs required for oscillator tuning
	

	set_control_voltage(&volume_cv, MIN); //turn volume all the way down
    223e:	88 ed       	ldi	r24, 0xD8	; 216
    2240:	91 e0       	ldi	r25, 0x01	; 1
    2242:	60 e0       	ldi	r22, 0x00	; 0
    2244:	70 e0       	ldi	r23, 0x00	; 0
    2246:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	//turn off all pitch modulation
	set_control_voltage(&pitch_lfo_cv, MIN);
    224a:	81 ee       	ldi	r24, 0xE1	; 225
    224c:	91 e0       	ldi	r25, 0x01	; 1
    224e:	60 e0       	ldi	r22, 0x00	; 0
    2250:	70 e0       	ldi	r23, 0x00	; 0
    2252:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&pitch_eg2_cv, MIN);
    2256:	82 ee       	ldi	r24, 0xE2	; 226
    2258:	91 e0       	ldi	r25, 0x01	; 1
    225a:	60 e0       	ldi	r22, 0x00	; 0
    225c:	70 e0       	ldi	r23, 0x00	; 0
    225e:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&pitch_vco2_cv, MIN);
    2262:	87 eb       	ldi	r24, 0xB7	; 183
    2264:	92 e0       	ldi	r25, 0x02	; 2
    2266:	60 e0       	ldi	r22, 0x00	; 0
    2268:	70 e0       	ldi	r23, 0x00	; 0
    226a:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	//turn off glide
	set_control_voltage(&glide_cv, MIN);
    226e:	8a ed       	ldi	r24, 0xDA	; 218
    2270:	91 e0       	ldi	r25, 0x01	; 1
    2272:	60 e0       	ldi	r22, 0x00	; 0
    2274:	70 e0       	ldi	r23, 0x00	; 0
    2276:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	//turn off all pulse width modulation
	set_control_voltage(&pwm_eg2_cv, MIN);
    227a:	8f ed       	ldi	r24, 0xDF	; 223
    227c:	91 e0       	ldi	r25, 0x01	; 1
    227e:	60 e0       	ldi	r22, 0x00	; 0
    2280:	70 e0       	ldi	r23, 0x00	; 0
    2282:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&pwm_lfo_cv, MIN);
    2286:	80 ee       	ldi	r24, 0xE0	; 224
    2288:	91 e0       	ldi	r25, 0x01	; 1
    228a:	60 e0       	ldi	r22, 0x00	; 0
    228c:	70 e0       	ldi	r23, 0x00	; 0
    228e:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	//turn off all filter modulation
	set_control_voltage(&fil_lfo_cv, MIN);
    2292:	81 ed       	ldi	r24, 0xD1	; 209
    2294:	91 e0       	ldi	r25, 0x01	; 1
    2296:	60 e0       	ldi	r22, 0x00	; 0
    2298:	70 e0       	ldi	r23, 0x00	; 0
    229a:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&fil_eg2_cv, MIN);
    229e:	86 ed       	ldi	r24, 0xD6	; 214
    22a0:	91 e0       	ldi	r25, 0x01	; 1
    22a2:	60 e0       	ldi	r22, 0x00	; 0
    22a4:	70 e0       	ldi	r23, 0x00	; 0
    22a6:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&fil_vco2_cv, MIN);
    22aa:	82 ed       	ldi	r24, 0xD2	; 210
    22ac:	91 e0       	ldi	r25, 0x01	; 1
    22ae:	60 e0       	ldi	r22, 0x00	; 0
    22b0:	70 e0       	ldi	r23, 0x00	; 0
    22b2:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&key_track_cv, MIN);
    22b6:	83 ed       	ldi	r24, 0xD3	; 211
    22b8:	91 e0       	ldi	r25, 0x01	; 1
    22ba:	60 e0       	ldi	r22, 0x00	; 0
    22bc:	70 e0       	ldi	r23, 0x00	; 0
    22be:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	//open filter with no resonance
	set_control_voltage(&cutoff_cv, MAX);
    22c2:	84 ed       	ldi	r24, 0xD4	; 212
    22c4:	91 e0       	ldi	r25, 0x01	; 1
    22c6:	6f ef       	ldi	r22, 0xFF	; 255
    22c8:	7f e3       	ldi	r23, 0x3F	; 63
    22ca:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&res_cv, MIN);
    22ce:	85 ed       	ldi	r24, 0xD5	; 213
    22d0:	91 e0       	ldi	r25, 0x01	; 1
    22d2:	60 e0       	ldi	r22, 0x00	; 0
    22d4:	70 e0       	ldi	r23, 0x00	; 0
    22d6:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	//turn off VCA LFO modulation
	set_control_voltage(&amp_lfo_cv, MIN);
    22da:	89 ed       	ldi	r24, 0xD9	; 217
    22dc:	91 e0       	ldi	r25, 0x01	; 1
    22de:	60 e0       	ldi	r22, 0x00	; 0
    22e0:	70 e0       	ldi	r23, 0x00	; 0
    22e2:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	//initialize VCA envelope
	set_control_voltage(&attack_1_cv, MIN);
    22e6:	8e ec       	ldi	r24, 0xCE	; 206
    22e8:	91 e0       	ldi	r25, 0x01	; 1
    22ea:	60 e0       	ldi	r22, 0x00	; 0
    22ec:	70 e0       	ldi	r23, 0x00	; 0
    22ee:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&decay_1_cv, MIN);
    22f2:	8c ec       	ldi	r24, 0xCC	; 204
    22f4:	91 e0       	ldi	r25, 0x01	; 1
    22f6:	60 e0       	ldi	r22, 0x00	; 0
    22f8:	70 e0       	ldi	r23, 0x00	; 0
    22fa:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&sustain_1_cv, MAX);
    22fe:	8a ec       	ldi	r24, 0xCA	; 202
    2300:	91 e0       	ldi	r25, 0x01	; 1
    2302:	6f ef       	ldi	r22, 0xFF	; 255
    2304:	7f e3       	ldi	r23, 0x3F	; 63
    2306:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&release_1_cv, MIN);
    230a:	88 ec       	ldi	r24, 0xC8	; 200
    230c:	91 e0       	ldi	r25, 0x01	; 1
    230e:	60 e0       	ldi	r22, 0x00	; 0
    2310:	70 e0       	ldi	r23, 0x00	; 0
    2312:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	//turn off noise
	set_control_voltage(&noise_mix_cv, MIN);
    2316:	80 ed       	ldi	r24, 0xD0	; 208
    2318:	91 e0       	ldi	r25, 0x01	; 1
    231a:	60 e0       	ldi	r22, 0x00	; 0
    231c:	70 e0       	ldi	r23, 0x00	; 0
    231e:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&vco1_mix_cv, MIN);
    2322:	83 ee       	ldi	r24, 0xE3	; 227
    2324:	91 e0       	ldi	r25, 0x01	; 1
    2326:	60 e0       	ldi	r22, 0x00	; 0
    2328:	70 e0       	ldi	r23, 0x00	; 0
    232a:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&vco2_mix_cv, MIN);
    232e:	84 ee       	ldi	r24, 0xE4	; 228
    2330:	91 e0       	ldi	r25, 0x01	; 1
    2332:	60 e0       	ldi	r22, 0x00	; 0
    2334:	70 e0       	ldi	r23, 0x00	; 0
    2336:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
}	
    233a:	08 95       	ret

0000233c <set_vco_init_cv>:
	
uint16_t set_vco_init_cv(uint8_t vco, uint16_t base_reference) { 
    233c:	2f 92       	push	r2
    233e:	3f 92       	push	r3
    2340:	4f 92       	push	r4
    2342:	5f 92       	push	r5
    2344:	6f 92       	push	r6
    2346:	7f 92       	push	r7
    2348:	8f 92       	push	r8
    234a:	9f 92       	push	r9
    234c:	af 92       	push	r10
    234e:	bf 92       	push	r11
    2350:	cf 92       	push	r12
    2352:	df 92       	push	r13
    2354:	ef 92       	push	r14
    2356:	ff 92       	push	r15
    2358:	0f 93       	push	r16
    235a:	1f 93       	push	r17
    235c:	cf 93       	push	r28
    235e:	df 93       	push	r29
    2360:	cd b7       	in	r28, 0x3d	; 61
    2362:	de b7       	in	r29, 0x3e	; 62
    2364:	2c 97       	sbiw	r28, 0x0c	; 12
    2366:	0f b6       	in	r0, 0x3f	; 63
    2368:	f8 94       	cli
    236a:	de bf       	out	0x3e, r29	; 62
    236c:	0f be       	out	0x3f, r0	; 63
    236e:	cd bf       	out	0x3d, r28	; 61
    2370:	18 2f       	mov	r17, r24
    2372:	78 87       	std	Y+8, r23	; 0x08
    2374:	6f 83       	std	Y+7, r22	; 0x07

	uint16_t init_cv = 0;
	timer1_clock |= (1<<CS11) | (1<<CS10);
    2376:	80 91 7f 03 	lds	r24, 0x037F
    237a:	83 60       	ori	r24, 0x03	; 3
    237c:	80 93 7f 03 	sts	0x037F, r24
	 
	//TO DO: disable UART so MIDI data doesn't interrupt tuning
	
	//setup control voltages	
	initialize_voice_for_tuning();
    2380:	0e 94 1f 11 	call	0x223e	; 0x223e <initialize_voice_for_tuning>
	struct control_voltage *vco_init_cv;
	struct control_voltage *vco_mix_cv;
	struct control_voltage *vco_pw_cv;
	struct control_voltage *vco_pitch_cv;

	count_finished = FALSE;
    2384:	10 92 7e 03 	sts	0x037E, r1
	
	if (vco == VCO1) { //turn on VCO1 pulse
    2388:	1f 30       	cpi	r17, 0x0F	; 15
    238a:	e9 f4       	brne	.+58     	; 0x23c6 <set_vco_init_cv+0x8a>
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
		vco_mix_cv = &vco1_mix_cv;
		vco_pw_cv = &vco1_pw_cv;
		vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
    238c:	0f 2e       	mov	r0, r31
    238e:	f6 ee       	ldi	r31, 0xE6	; 230
    2390:	4f 2e       	mov	r4, r31
    2392:	f1 e0       	ldi	r31, 0x01	; 1
    2394:	5f 2e       	mov	r5, r31
    2396:	f0 2d       	mov	r31, r0
	if (vco == VCO1) { //turn on VCO1 pulse
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
		vco_mix_cv = &vco1_mix_cv;
		vco_pw_cv = &vco1_pw_cv;
    2398:	0f 2e       	mov	r0, r31
    239a:	fe ed       	ldi	r31, 0xDE	; 222
    239c:	2f 2e       	mov	r2, r31
    239e:	f1 e0       	ldi	r31, 0x01	; 1
    23a0:	3f 2e       	mov	r3, r31
    23a2:	f0 2d       	mov	r31, r0
	
	if (vco == VCO1) { //turn on VCO1 pulse
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
		vco_mix_cv = &vco1_mix_cv;
    23a4:	23 ee       	ldi	r18, 0xE3	; 227
    23a6:	31 e0       	ldi	r19, 0x01	; 1
    23a8:	3a 83       	std	Y+2, r19	; 0x02
    23aa:	29 83       	std	Y+1, r18	; 0x01
	count_finished = FALSE;
	
	if (vco == VCO1) { //turn on VCO1 pulse
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
    23ac:	0f 2e       	mov	r0, r31
    23ae:	fc ed       	ldi	r31, 0xDC	; 220
    23b0:	ef 2e       	mov	r14, r31
    23b2:	f1 e0       	ldi	r31, 0x01	; 1
    23b4:	ff 2e       	mov	r15, r31
    23b6:	f0 2d       	mov	r31, r0
		vco_mix_cv = &vco1_mix_cv;
		vco_pw_cv = &vco1_pw_cv;
		vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
		reference_count = base_reference;//38222; //make this an argument passed to function
		vco_display_num = 1;
		eeprom_addr = &vco1_init_cv_eeprom;
    23b8:	82 e7       	ldi	r24, 0x72	; 114
    23ba:	96 e0       	ldi	r25, 0x06	; 6
    23bc:	9a 87       	std	Y+10, r25	; 0x0a
    23be:	89 87       	std	Y+9, r24	; 0x09

	count_finished = FALSE;
	
	if (vco == VCO1) { //turn on VCO1 pulse
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
    23c0:	81 e0       	ldi	r24, 0x01	; 1
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
		vco_mix_cv = &vco1_mix_cv;
		vco_pw_cv = &vco1_pw_cv;
		vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
		reference_count = base_reference;//38222; //make this an argument passed to function
		vco_display_num = 1;
    23c2:	11 e0       	ldi	r17, 0x01	; 1
    23c4:	1c c0       	rjmp	.+56     	; 0x23fe <set_vco_init_cv+0xc2>
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
		vco_mix_cv = &vco2_mix_cv;
		vco_pw_cv = &vco2_pw_cv;
		vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
    23c6:	0f 2e       	mov	r0, r31
    23c8:	f5 ee       	ldi	r31, 0xE5	; 229
    23ca:	4f 2e       	mov	r4, r31
    23cc:	f1 e0       	ldi	r31, 0x01	; 1
    23ce:	5f 2e       	mov	r5, r31
    23d0:	f0 2d       	mov	r31, r0
	} else { //turn on VCO2 pulse	
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
		vco_mix_cv = &vco2_mix_cv;
		vco_pw_cv = &vco2_pw_cv;
    23d2:	0f 2e       	mov	r0, r31
    23d4:	f7 ed       	ldi	r31, 0xD7	; 215
    23d6:	2f 2e       	mov	r2, r31
    23d8:	f1 e0       	ldi	r31, 0x01	; 1
    23da:	3f 2e       	mov	r3, r31
    23dc:	f0 2d       	mov	r31, r0
		
	} else { //turn on VCO2 pulse	
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
		vco_mix_cv = &vco2_mix_cv;
    23de:	e4 ee       	ldi	r30, 0xE4	; 228
    23e0:	f1 e0       	ldi	r31, 0x01	; 1
    23e2:	fa 83       	std	Y+2, r31	; 0x02
    23e4:	e9 83       	std	Y+1, r30	; 0x01
		eeprom_addr = &vco1_init_cv_eeprom;
		
	} else { //turn on VCO2 pulse	
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
    23e6:	0f 2e       	mov	r0, r31
    23e8:	fd ed       	ldi	r31, 0xDD	; 221
    23ea:	ef 2e       	mov	r14, r31
    23ec:	f1 e0       	ldi	r31, 0x01	; 1
    23ee:	ff 2e       	mov	r15, r31
    23f0:	f0 2d       	mov	r31, r0
		vco_mix_cv = &vco2_mix_cv;
		vco_pw_cv = &vco2_pw_cv;
		vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
		reference_count = base_reference;
		vco_display_num = 2;
		eeprom_addr = &vco2_init_cv_eeprom;
    23f2:	20 e7       	ldi	r18, 0x70	; 112
    23f4:	36 e0       	ldi	r19, 0x06	; 6
    23f6:	3a 87       	std	Y+10, r19	; 0x0a
    23f8:	29 87       	std	Y+9, r18	; 0x09
		vco_display_num = 1;
		eeprom_addr = &vco1_init_cv_eeprom;
		
	} else { //turn on VCO2 pulse	
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
    23fa:	80 e4       	ldi	r24, 0x40	; 64
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
		vco_mix_cv = &vco2_mix_cv;
		vco_pw_cv = &vco2_pw_cv;
		vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
		reference_count = base_reference;
		vco_display_num = 2;
    23fc:	12 e0       	ldi	r17, 0x02	; 2
		eeprom_addr = &vco2_init_cv_eeprom;
	}
	
	//latch switch data
	DATA_BUS = switch_byte;
    23fe:	82 b9       	out	0x02, r24	; 2
	VCO_SW_LATCH_PORT |= (1<<VCO_SW_LATCH);
    2400:	ed ed       	ldi	r30, 0xDD	; 221
    2402:	f0 e0       	ldi	r31, 0x00	; 0
    2404:	80 81       	ld	r24, Z
    2406:	80 64       	ori	r24, 0x40	; 64
    2408:	80 83       	st	Z, r24
	//_delay_us(1); //why is this delay here????
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    240a:	80 81       	ld	r24, Z
    240c:	8f 7b       	andi	r24, 0xBF	; 191
    240e:	80 83       	st	Z, r24
	DATA_BUS = 0;
    2410:	12 b8       	out	0x02, r1	; 2

	PORTF |= (1<<GATE); //turn gate on
    2412:	89 9a       	sbi	0x11, 1	; 17
	
	//set up timer/counter0 to be clocked by T0 input
	
	TCCR0A |= (1<<CS02) | (1<<CS01) | (1<<CS00) | (1<<WGM01); //clocked by external T0 pin, rising edge + clear timer on compare match
    2414:	84 b5       	in	r24, 0x24	; 36
    2416:	8f 60       	ori	r24, 0x0F	; 15
    2418:	84 bd       	out	0x24, r24	; 36
	OCR0A = 1; //output compare register - set to number of periods to be counted. OCR0A needs to be set to (periods_to_be_counted - 1)
    241a:	81 e0       	ldi	r24, 0x01	; 1
    241c:	87 bd       	out	0x27, r24	; 39
	//set OCR0A to 1 here means first ISR interrupt will occur after 2 periods, it is then set to 0 to count only single periods
	//for reasons I don't understand yet, starting with OCR0A set to 0 results in a multi-second delay before first compare match ISR is called ***ACTUALLY, THIS MAY BE RELATED TO LEAVING Timer0 RUNNING. COULD TRY TO SET OCR0A TO 0 NOW and SEE IF IT WORKS
	TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt	
    241e:	ee e6       	ldi	r30, 0x6E	; 110
    2420:	f0 e0       	ldi	r31, 0x00	; 0
    2422:	90 81       	ld	r25, Z
    2424:	92 60       	ori	r25, 0x02	; 2
    2426:	90 83       	st	Z, r25
	period = 1; //only counting 1 period 
    2428:	80 93 80 03 	sts	0x0380, r24
	for (int dac_bit = 13; dac_bit >= 0; dac_bit--) {
    242c:	8d e0       	ldi	r24, 0x0D	; 13
    242e:	90 e0       	ldi	r25, 0x00	; 0
    2430:	9c 83       	std	Y+4, r25	; 0x04
    2432:	8b 83       	std	Y+3, r24	; 0x03
		count_finished = FALSE;
		period_counter = 0;
		//TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
		//enable watchdog timer
		//WDTCR |= (1<<WDP2) | (1<<WDP1) | (1<<WDP0) | (1<<WDE)| (1<<WDCE);
		wdt_enable(WDTO_2S);
    2434:	0f e0       	ldi	r16, 0x0F	; 15
			
			update_display(vco_display_num, DEC);
		
			set_control_voltage(vco_init_cv, init_cv);
			set_control_voltage(vco_pw_cv, MAX);
			set_control_voltage(&volume_cv, MIN);
    2436:	0f 2e       	mov	r0, r31
    2438:	f8 ed       	ldi	r31, 0xD8	; 216
    243a:	cf 2e       	mov	r12, r31
    243c:	f1 e0       	ldi	r31, 0x01	; 1
    243e:	df 2e       	mov	r13, r31
    2440:	f0 2d       	mov	r31, r0
			set_control_voltage(&cutoff_cv, MAX);
    2442:	0f 2e       	mov	r0, r31
    2444:	f4 ed       	ldi	r31, 0xD4	; 212
    2446:	af 2e       	mov	r10, r31
    2448:	f1 e0       	ldi	r31, 0x01	; 1
    244a:	bf 2e       	mov	r11, r31
    244c:	f0 2d       	mov	r31, r0
			set_control_voltage(&sustain_1_cv, MAX);
    244e:	0f 2e       	mov	r0, r31
    2450:	fa ec       	ldi	r31, 0xCA	; 202
    2452:	8f 2e       	mov	r8, r31
    2454:	f1 e0       	ldi	r31, 0x01	; 1
    2456:	9f 2e       	mov	r9, r31
    2458:	f0 2d       	mov	r31, r0
			set_control_voltage(&sustain_2_cv, MAX); //can't remember is EG1 for VCA or EG2????
    245a:	0f 2e       	mov	r0, r31
    245c:	fb ec       	ldi	r31, 0xCB	; 203
    245e:	6f 2e       	mov	r6, r31
    2460:	f1 e0       	ldi	r31, 0x01	; 1
    2462:	7f 2e       	mov	r7, r31
    2464:	f0 2d       	mov	r31, r0
		//WDTCR = 0x00;
		wdt_disable();
		//remember that as INIT_CV goes up, pitch goes down, so looking for osc_count >= reference_count instead of <= as is the case for normal oscillator tuning
		//similarily, OR no_overflow == FALSE *not* AND no_overflow == FALSE to clear bits that make initial pitch too low
		if ((osc_count > reference_count)  || (no_overflow == FALSE)) init_cv &= ~(1 << dac_bit);
		no_overflow = TRUE;
    2466:	e0 e0       	ldi	r30, 0x00	; 0
    2468:	f0 e0       	ldi	r31, 0x00	; 0
    246a:	fc 87       	std	Y+12, r31	; 0x0c
    246c:	eb 87       	std	Y+11, r30	; 0x0b
	//for reasons I don't understand yet, starting with OCR0A set to 0 results in a multi-second delay before first compare match ISR is called ***ACTUALLY, THIS MAY BE RELATED TO LEAVING Timer0 RUNNING. COULD TRY TO SET OCR0A TO 0 NOW and SEE IF IT WORKS
	TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt	
	period = 1; //only counting 1 period 
	for (int dac_bit = 13; dac_bit >= 0; dac_bit--) {
	
		init_cv |= (1<<dac_bit);
    246e:	21 e0       	ldi	r18, 0x01	; 1
    2470:	30 e0       	ldi	r19, 0x00	; 0
    2472:	0b 80       	ldd	r0, Y+3	; 0x03
    2474:	02 c0       	rjmp	.+4      	; 0x247a <set_vco_init_cv+0x13e>
    2476:	22 0f       	add	r18, r18
    2478:	33 1f       	adc	r19, r19
    247a:	0a 94       	dec	r0
    247c:	e2 f7       	brpl	.-8      	; 0x2476 <set_vco_init_cv+0x13a>
    247e:	3e 83       	std	Y+6, r19	; 0x06
    2480:	2d 83       	std	Y+5, r18	; 0x05
    2482:	8b 85       	ldd	r24, Y+11	; 0x0b
    2484:	9c 85       	ldd	r25, Y+12	; 0x0c
    2486:	82 2b       	or	r24, r18
    2488:	93 2b       	or	r25, r19
    248a:	9c 87       	std	Y+12, r25	; 0x0c
    248c:	8b 87       	std	Y+11, r24	; 0x0b
		
		set_control_voltage(vco_init_cv, init_cv);
    248e:	c7 01       	movw	r24, r14
    2490:	6b 85       	ldd	r22, Y+11	; 0x0b
    2492:	7c 85       	ldd	r23, Y+12	; 0x0c
    2494:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
		
		
		count_finished = FALSE;
    2498:	10 92 7e 03 	sts	0x037E, r1
		period_counter = 0;
    249c:	10 92 81 03 	sts	0x0381, r1
		//TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
		//enable watchdog timer
		//WDTCR |= (1<<WDP2) | (1<<WDP1) | (1<<WDP0) | (1<<WDE)| (1<<WDCE);
		wdt_enable(WDTO_2S);
    24a0:	e8 e1       	ldi	r30, 0x18	; 24
    24a2:	f0 e0       	ldi	r31, 0x00	; 0
    24a4:	0f b6       	in	r0, 0x3f	; 63
    24a6:	f8 94       	cli
    24a8:	a8 95       	wdr
    24aa:	e0 93 60 00 	sts	0x0060, r30
    24ae:	0f be       	out	0x3f, r0	; 63
    24b0:	00 93 60 00 	sts	0x0060, r16
		while (count_finished == FALSE) { //need to have a watchdog timer here to escape while loop if it takes too long
    24b4:	80 91 7e 03 	lds	r24, 0x037E
    24b8:	88 23       	and	r24, r24
    24ba:	91 f5       	brne	.+100    	; 0x2520 <set_vco_init_cv+0x1e4>
			
			update_display(vco_display_num, DEC);
    24bc:	81 2f       	mov	r24, r17
    24be:	90 e0       	ldi	r25, 0x00	; 0
    24c0:	60 e0       	ldi	r22, 0x00	; 0
    24c2:	0e 94 39 03 	call	0x672	; 0x672 <update_display>
		
			set_control_voltage(vco_init_cv, init_cv);
    24c6:	c7 01       	movw	r24, r14
    24c8:	6b 85       	ldd	r22, Y+11	; 0x0b
    24ca:	7c 85       	ldd	r23, Y+12	; 0x0c
    24cc:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
			set_control_voltage(vco_pw_cv, MAX);
    24d0:	c1 01       	movw	r24, r2
    24d2:	6f ef       	ldi	r22, 0xFF	; 255
    24d4:	7f e3       	ldi	r23, 0x3F	; 63
    24d6:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
			set_control_voltage(&volume_cv, MIN);
    24da:	c6 01       	movw	r24, r12
    24dc:	60 e0       	ldi	r22, 0x00	; 0
    24de:	70 e0       	ldi	r23, 0x00	; 0
    24e0:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
			set_control_voltage(&cutoff_cv, MAX);
    24e4:	c5 01       	movw	r24, r10
    24e6:	6f ef       	ldi	r22, 0xFF	; 255
    24e8:	7f e3       	ldi	r23, 0x3F	; 63
    24ea:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
			set_control_voltage(&sustain_1_cv, MAX);
    24ee:	c4 01       	movw	r24, r8
    24f0:	6f ef       	ldi	r22, 0xFF	; 255
    24f2:	7f e3       	ldi	r23, 0x3F	; 63
    24f4:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
			set_control_voltage(&sustain_2_cv, MAX); //can't remember is EG1 for VCA or EG2????
    24f8:	c3 01       	movw	r24, r6
    24fa:	6f ef       	ldi	r22, 0xFF	; 255
    24fc:	7f e3       	ldi	r23, 0x3F	; 63
    24fe:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
			set_control_voltage(vco_mix_cv, MAX);
    2502:	89 81       	ldd	r24, Y+1	; 0x01
    2504:	9a 81       	ldd	r25, Y+2	; 0x02
    2506:	6f ef       	ldi	r22, 0xFF	; 255
    2508:	7f e3       	ldi	r23, 0x3F	; 63
    250a:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
			set_control_voltage(vco_pitch_cv, 0);	
    250e:	c2 01       	movw	r24, r4
    2510:	60 e0       	ldi	r22, 0x00	; 0
    2512:	70 e0       	ldi	r23, 0x00	; 0
    2514:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
		period_counter = 0;
		//TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
		//enable watchdog timer
		//WDTCR |= (1<<WDP2) | (1<<WDP1) | (1<<WDP0) | (1<<WDE)| (1<<WDCE);
		wdt_enable(WDTO_2S);
		while (count_finished == FALSE) { //need to have a watchdog timer here to escape while loop if it takes too long
    2518:	80 91 7e 03 	lds	r24, 0x037E
    251c:	88 23       	and	r24, r24
    251e:	71 f2       	breq	.-100    	; 0x24bc <set_vco_init_cv+0x180>
			
		}
		//turn off watchdog timer
		//WDTCR |= (1<<WDCE) | (1<<WDE);
		//WDTCR = 0x00;
		wdt_disable();
    2520:	98 e1       	ldi	r25, 0x18	; 24
    2522:	0f b6       	in	r0, 0x3f	; 63
    2524:	f8 94       	cli
    2526:	90 93 60 00 	sts	0x0060, r25
    252a:	10 92 60 00 	sts	0x0060, r1
    252e:	0f be       	out	0x3f, r0	; 63
		//remember that as INIT_CV goes up, pitch goes down, so looking for osc_count >= reference_count instead of <= as is the case for normal oscillator tuning
		//similarily, OR no_overflow == FALSE *not* AND no_overflow == FALSE to clear bits that make initial pitch too low
		if ((osc_count > reference_count)  || (no_overflow == FALSE)) init_cv &= ~(1 << dac_bit);
    2530:	80 91 7c 03 	lds	r24, 0x037C
    2534:	90 91 7d 03 	lds	r25, 0x037D
    2538:	ef 81       	ldd	r30, Y+7	; 0x07
    253a:	f8 85       	ldd	r31, Y+8	; 0x08
    253c:	e8 17       	cp	r30, r24
    253e:	f9 07       	cpc	r31, r25
    2540:	20 f0       	brcs	.+8      	; 0x254a <set_vco_init_cv+0x20e>
    2542:	80 91 af 02 	lds	r24, 0x02AF
    2546:	88 23       	and	r24, r24
    2548:	51 f4       	brne	.+20     	; 0x255e <set_vco_init_cv+0x222>
    254a:	8d 81       	ldd	r24, Y+5	; 0x05
    254c:	9e 81       	ldd	r25, Y+6	; 0x06
    254e:	80 95       	com	r24
    2550:	90 95       	com	r25
    2552:	2b 85       	ldd	r18, Y+11	; 0x0b
    2554:	3c 85       	ldd	r19, Y+12	; 0x0c
    2556:	28 23       	and	r18, r24
    2558:	39 23       	and	r19, r25
    255a:	3c 87       	std	Y+12, r19	; 0x0c
    255c:	2b 87       	std	Y+11, r18	; 0x0b
		no_overflow = TRUE;
    255e:	31 e0       	ldi	r19, 0x01	; 1
    2560:	30 93 af 02 	sts	0x02AF, r19
	OCR0A = 1; //output compare register - set to number of periods to be counted. OCR0A needs to be set to (periods_to_be_counted - 1)
	//set OCR0A to 1 here means first ISR interrupt will occur after 2 periods, it is then set to 0 to count only single periods
	//for reasons I don't understand yet, starting with OCR0A set to 0 results in a multi-second delay before first compare match ISR is called ***ACTUALLY, THIS MAY BE RELATED TO LEAVING Timer0 RUNNING. COULD TRY TO SET OCR0A TO 0 NOW and SEE IF IT WORKS
	TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt	
	period = 1; //only counting 1 period 
	for (int dac_bit = 13; dac_bit >= 0; dac_bit--) {
    2564:	8b 81       	ldd	r24, Y+3	; 0x03
    2566:	9c 81       	ldd	r25, Y+4	; 0x04
    2568:	01 97       	sbiw	r24, 0x01	; 1
    256a:	9c 83       	std	Y+4, r25	; 0x04
    256c:	8b 83       	std	Y+3, r24	; 0x03
    256e:	ef ef       	ldi	r30, 0xFF	; 255
    2570:	8f 3f       	cpi	r24, 0xFF	; 255
    2572:	9e 07       	cpc	r25, r30
    2574:	09 f0       	breq	.+2      	; 0x2578 <set_vco_init_cv+0x23c>
    2576:	7b cf       	rjmp	.-266    	; 0x246e <set_vco_init_cv+0x132>
    2578:	2b 85       	ldd	r18, Y+11	; 0x0b
    257a:	3c 85       	ldd	r19, Y+12	; 0x0c
    257c:	3e 83       	std	Y+6, r19	; 0x06
    257e:	2d 83       	std	Y+5, r18	; 0x05
		no_overflow = TRUE;
		
	}		
	
	//none of these help with clicking when returning from this function and starting to read pots	
	set_control_voltage(&release_1_cv, MIN); //this will hopefully reduce popping after returning from initializing pitch CV
    2580:	88 ec       	ldi	r24, 0xC8	; 200
    2582:	91 e0       	ldi	r25, 0x01	; 1
    2584:	60 e0       	ldi	r22, 0x00	; 0
    2586:	70 e0       	ldi	r23, 0x00	; 0
    2588:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&release_2_cv, MIN);
    258c:	89 ec       	ldi	r24, 0xC9	; 201
    258e:	91 e0       	ldi	r25, 0x01	; 1
    2590:	60 e0       	ldi	r22, 0x00	; 0
    2592:	70 e0       	ldi	r23, 0x00	; 0
    2594:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&cutoff_cv, MIN);
    2598:	84 ed       	ldi	r24, 0xD4	; 212
    259a:	91 e0       	ldi	r25, 0x01	; 1
    259c:	60 e0       	ldi	r22, 0x00	; 0
    259e:	70 e0       	ldi	r23, 0x00	; 0
    25a0:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&volume_cv, MIN);
    25a4:	88 ed       	ldi	r24, 0xD8	; 216
    25a6:	91 e0       	ldi	r25, 0x01	; 1
    25a8:	60 e0       	ldi	r22, 0x00	; 0
    25aa:	70 e0       	ldi	r23, 0x00	; 0
    25ac:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
		
	PORTF &= ~(1<<GATE); //turn gate off
    25b0:	89 98       	cbi	0x11, 1	; 17
	
	TIMSK0 &= ~(1<<OCIE0A); //turn off compare match A interrupt
    25b2:	ee e6       	ldi	r30, 0x6E	; 110
    25b4:	f0 e0       	ldi	r31, 0x00	; 0
    25b6:	80 81       	ld	r24, Z
    25b8:	8d 7f       	andi	r24, 0xFD	; 253
    25ba:	80 83       	st	Z, r24
	TCCR0A = 0; //turn off timer0 period timer
    25bc:	14 bc       	out	0x24, r1	; 36
	//} else {
		//
		//eeprom_update_word(&vco2_init_cv_eeprom, init_cv);
	//}				
		
	eeprom_update_word(eeprom_addr, init_cv);
    25be:	89 85       	ldd	r24, Y+9	; 0x09
    25c0:	9a 85       	ldd	r25, Y+10	; 0x0a
    25c2:	6d 81       	ldd	r22, Y+5	; 0x05
    25c4:	7e 81       	ldd	r23, Y+6	; 0x06
    25c6:	0e 94 a8 1f 	call	0x3f50	; 0x3f50 <__eeupd_word_m6450a>
	//value_to_display = eeprom_read_word(&vco1_init_cv_eeprom);	

	
	return init_cv;
	
}
    25ca:	8d 81       	ldd	r24, Y+5	; 0x05
    25cc:	9e 81       	ldd	r25, Y+6	; 0x06
    25ce:	2c 96       	adiw	r28, 0x0c	; 12
    25d0:	0f b6       	in	r0, 0x3f	; 63
    25d2:	f8 94       	cli
    25d4:	de bf       	out	0x3e, r29	; 62
    25d6:	0f be       	out	0x3f, r0	; 63
    25d8:	cd bf       	out	0x3d, r28	; 61
    25da:	df 91       	pop	r29
    25dc:	cf 91       	pop	r28
    25de:	1f 91       	pop	r17
    25e0:	0f 91       	pop	r16
    25e2:	ff 90       	pop	r15
    25e4:	ef 90       	pop	r14
    25e6:	df 90       	pop	r13
    25e8:	cf 90       	pop	r12
    25ea:	bf 90       	pop	r11
    25ec:	af 90       	pop	r10
    25ee:	9f 90       	pop	r9
    25f0:	8f 90       	pop	r8
    25f2:	7f 90       	pop	r7
    25f4:	6f 90       	pop	r6
    25f6:	5f 90       	pop	r5
    25f8:	4f 90       	pop	r4
    25fa:	3f 90       	pop	r3
    25fc:	2f 90       	pop	r2
    25fe:	08 95       	ret

00002600 <tune_8ths>:



void tune_8ths(uint8_t vco) {
    2600:	2f 92       	push	r2
    2602:	3f 92       	push	r3
    2604:	4f 92       	push	r4
    2606:	5f 92       	push	r5
    2608:	6f 92       	push	r6
    260a:	7f 92       	push	r7
    260c:	8f 92       	push	r8
    260e:	9f 92       	push	r9
    2610:	af 92       	push	r10
    2612:	bf 92       	push	r11
    2614:	cf 92       	push	r12
    2616:	df 92       	push	r13
    2618:	ef 92       	push	r14
    261a:	ff 92       	push	r15
    261c:	0f 93       	push	r16
    261e:	1f 93       	push	r17
    2620:	cf 93       	push	r28
    2622:	df 93       	push	r29
    2624:	cd b7       	in	r28, 0x3d	; 61
    2626:	de b7       	in	r29, 0x3e	; 62
    2628:	c0 54       	subi	r28, 0x40	; 64
    262a:	d0 40       	sbci	r29, 0x00	; 0
    262c:	0f b6       	in	r0, 0x3f	; 63
    262e:	f8 94       	cli
    2630:	de bf       	out	0x3e, r29	; 62
    2632:	0f be       	out	0x3f, r0	; 63
    2634:	cd bf       	out	0x3d, r28	; 61
    2636:	08 2f       	mov	r16, r24
		uint8_t period;
		uint16_t count;
	
		};

	struct pitch_reference reference[16] = 
    2638:	de 01       	movw	r26, r28
    263a:	11 96       	adiw	r26, 0x01	; 1
    263c:	e0 e3       	ldi	r30, 0x30	; 48
    263e:	f2 e0       	ldi	r31, 0x02	; 2
    2640:	80 e3       	ldi	r24, 0x30	; 48
    2642:	01 90       	ld	r0, Z+
    2644:	0d 92       	st	X+, r0
    2646:	81 50       	subi	r24, 0x01	; 1
    2648:	e1 f7       	brne	.-8      	; 0x2642 <tune_8ths+0x42>
	
		//to do:
		//disable UART so MIDI data doesn't interrupt tuning
	
		//setup control voltages	
		initialize_voice_for_tuning();
    264a:	0e 94 1f 11 	call	0x223e	; 0x223e <initialize_voice_for_tuning>
		struct control_voltage *vco_init_cv;
		struct control_voltage *vco_mix_cv;
		struct control_voltage *vco_pw_cv;
		struct control_voltage *vco_pitch_cv;	

		if (vco == VCO1) { //set up parameters for VCO1 tuning
    264e:	0f 30       	cpi	r16, 0x0F	; 15
    2650:	11 f5       	brne	.+68     	; 0x2696 <tune_8ths+0x96>
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
			vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 1; //allows second digit to display VCO being tuned
			init_cv = vco1_init_cv;
    2652:	40 90 79 03 	lds	r4, 0x0379
    2656:	50 90 7a 03 	lds	r5, 0x037A
			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
			vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
    265a:	0f 2e       	mov	r0, r31
    265c:	f6 ee       	ldi	r31, 0xE6	; 230
    265e:	8f 2e       	mov	r8, r31
    2660:	f1 e0       	ldi	r31, 0x01	; 1
    2662:	9f 2e       	mov	r9, r31
    2664:	f0 2d       	mov	r31, r0

			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
    2666:	0f 2e       	mov	r0, r31
    2668:	fe ed       	ldi	r31, 0xDE	; 222
    266a:	2f 2e       	mov	r2, r31
    266c:	f1 e0       	ldi	r31, 0x01	; 1
    266e:	3f 2e       	mov	r3, r31
    2670:	f0 2d       	mov	r31, r0
		if (vco == VCO1) { //set up parameters for VCO1 tuning

			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
    2672:	23 ee       	ldi	r18, 0xE3	; 227
    2674:	31 e0       	ldi	r19, 0x01	; 1
    2676:	3a ab       	sts	0x5a, r19
    2678:	29 ab       	sts	0x59, r18

		if (vco == VCO1) { //set up parameters for VCO1 tuning

			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
    267a:	0f 2e       	mov	r0, r31
    267c:	fc ed       	ldi	r31, 0xDC	; 220
    267e:	6f 2e       	mov	r6, r31
    2680:	f1 e0       	ldi	r31, 0x01	; 1
    2682:	7f 2e       	mov	r7, r31
    2684:	f0 2d       	mov	r31, r0
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
			vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 1; //allows second digit to display VCO being tuned
			init_cv = vco1_init_cv;
			vco_pitch_table = vco1_pitch_table;
    2686:	05 e5       	ldi	r16, 0x55	; 85
    2688:	13 e0       	ldi	r17, 0x03	; 3
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
			vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 1; //allows second digit to display VCO being tuned
    268a:	cc 24       	eor	r12, r12
    268c:	c3 94       	inc	r12
		struct control_voltage *vco_pitch_cv;	

		if (vco == VCO1) { //set up parameters for VCO1 tuning

			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
    268e:	ee 24       	eor	r14, r14
    2690:	68 94       	set
    2692:	e1 f8       	bld	r14, 1
    2694:	22 c0       	rjmp	.+68     	; 0x26da <tune_8ths+0xda>
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
			vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 2; //allows second digit to display VCO being tuned
			init_cv = vco2_init_cv;
    2696:	40 90 77 03 	lds	r4, 0x0377
    269a:	50 90 78 03 	lds	r5, 0x0378
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
			vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
    269e:	0f 2e       	mov	r0, r31
    26a0:	f5 ee       	ldi	r31, 0xE5	; 229
    26a2:	8f 2e       	mov	r8, r31
    26a4:	f1 e0       	ldi	r31, 0x01	; 1
    26a6:	9f 2e       	mov	r9, r31
    26a8:	f0 2d       	mov	r31, r0
		
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
    26aa:	0f 2e       	mov	r0, r31
    26ac:	f7 ed       	ldi	r31, 0xD7	; 215
    26ae:	2f 2e       	mov	r2, r31
    26b0:	f1 e0       	ldi	r31, 0x01	; 1
    26b2:	3f 2e       	mov	r3, r31
    26b4:	f0 2d       	mov	r31, r0
		} else { //set up parameters for VCO2 tuning
		
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
    26b6:	44 ee       	ldi	r20, 0xE4	; 228
    26b8:	51 e0       	ldi	r21, 0x01	; 1
    26ba:	5a ab       	sts	0x5a, r21
    26bc:	49 ab       	sts	0x59, r20
		
		} else { //set up parameters for VCO2 tuning
		
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
    26be:	0f 2e       	mov	r0, r31
    26c0:	fd ed       	ldi	r31, 0xDD	; 221
    26c2:	6f 2e       	mov	r6, r31
    26c4:	f1 e0       	ldi	r31, 0x01	; 1
    26c6:	7f 2e       	mov	r7, r31
    26c8:	f0 2d       	mov	r31, r0
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
			vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 2; //allows second digit to display VCO being tuned
			init_cv = vco2_init_cv;
			vco_pitch_table = vco2_pitch_table;
    26ca:	03 e3       	ldi	r16, 0x33	; 51
    26cc:	13 e0       	ldi	r17, 0x03	; 3
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
			vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 2; //allows second digit to display VCO being tuned
    26ce:	cc 24       	eor	r12, r12
    26d0:	68 94       	set
    26d2:	c1 f8       	bld	r12, 1
		
		
		} else { //set up parameters for VCO2 tuning
		
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
    26d4:	ee 24       	eor	r14, r14
    26d6:	68 94       	set
    26d8:	e5 f8       	bld	r14, 5
		}
	


		//set VCO init offset CV
		set_control_voltage(vco_init_cv, init_cv);
    26da:	c3 01       	movw	r24, r6
    26dc:	b2 01       	movw	r22, r4
    26de:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
		
	
		//latch switch data
		DATA_BUS = switch_byte;
    26e2:	e2 b8       	out	0x02, r14	; 2
		VCO_SW_LATCH_PORT |= (1<<VCO_SW_LATCH);
    26e4:	ed ed       	ldi	r30, 0xDD	; 221
    26e6:	f0 e0       	ldi	r31, 0x00	; 0
    26e8:	80 81       	ld	r24, Z
    26ea:	80 64       	ori	r24, 0x40	; 64
    26ec:	80 83       	st	Z, r24
		//_delay_us(1); //why is this delay here????
		VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    26ee:	80 81       	ld	r24, Z
    26f0:	8f 7b       	andi	r24, 0xBF	; 191
    26f2:	80 83       	st	Z, r24
		DATA_BUS = 0;
    26f4:	12 b8       	out	0x02, r1	; 2

		PORTF |= (1<<GATE); //turn gate on
    26f6:	89 9a       	sbi	0x11, 1	; 17
			
		period = 1; //need to initialize to minimum period number here
    26f8:	81 e0       	ldi	r24, 0x01	; 1
    26fa:	80 93 80 03 	sts	0x0380, r24
		
		compare_match_counter = 0;	
    26fe:	10 92 7b 03 	sts	0x037B, r1
			
				//enable watchdog timer
				wdt_enable(WDTO_2S);
				while (count_finished == FALSE) {
					//update_display(vco_number + period + (compare_match_counter>>4)*100, DEC);
					update_display(vco_number*100 + period, DEC);//
    2702:	8c 2d       	mov	r24, r12
    2704:	90 e0       	ldi	r25, 0x00	; 0
    2706:	24 e6       	ldi	r18, 0x64	; 100
    2708:	30 e0       	ldi	r19, 0x00	; 0
    270a:	82 9f       	mul	r24, r18
    270c:	d0 01       	movw	r26, r0
    270e:	83 9f       	mul	r24, r19
    2710:	b0 0d       	add	r27, r0
    2712:	92 9f       	mul	r25, r18
    2714:	b0 0d       	add	r27, r0
    2716:	11 24       	eor	r1, r1
    2718:	bc ab       	sts	0x5c, r27
    271a:	ab ab       	sts	0x5b, r26
    271c:	fe 01       	movw	r30, r28
    271e:	31 96       	adiw	r30, 0x01	; 1
    2720:	fc af       	sts	0x7c, r31
    2722:	eb af       	sts	0x7b, r30
	
}



void tune_8ths(uint8_t vco) {
    2724:	98 01       	movw	r18, r16
    2726:	2e 5f       	subi	r18, 0xFE	; 254
    2728:	3f 4f       	sbci	r19, 0xFF	; 255
    272a:	21 96       	adiw	r28, 0x01	; 1
    272c:	3f af       	sts	0x7f, r19
    272e:	2e af       	sts	0x7e, r18
    2730:	21 97       	sbiw	r28, 0x01	; 1
		PORTF |= (1<<GATE); //turn gate on
			
		period = 1; //need to initialize to minimum period number here
		
		compare_match_counter = 0;	
		for (int note_number = 0; note_number <= 15; note_number++) 
    2732:	1e ae       	sts	0xbe, r17
    2734:	1d ae       	sts	0xbd, r17
					//not sure what's really necessary here - definitely pitch and init_cv, but what else?
					set_control_voltage(vco_init_cv, init_cv);
					set_control_voltage(vco_pitch_cv, osc_pitch_cv);
					//set_control_voltage(&pitch_lfo_cv, MIN);
					//set_control_voltage(vco_pw_cv, MAX); //not necessary as SAW is being used to clock comparator
					set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
    2736:	0f 2e       	mov	r0, r31
    2738:	f8 ed       	ldi	r31, 0xD8	; 216
    273a:	ef 2e       	mov	r14, r31
    273c:	f1 e0       	ldi	r31, 0x01	; 1
    273e:	ff 2e       	mov	r15, r31
    2740:	f0 2d       	mov	r31, r0
					set_control_voltage(&cutoff_cv, MAX);
    2742:	0f 2e       	mov	r0, r31
    2744:	f4 ed       	ldi	r31, 0xD4	; 212
    2746:	cf 2e       	mov	r12, r31
    2748:	f1 e0       	ldi	r31, 0x01	; 1
    274a:	df 2e       	mov	r13, r31
    274c:	f0 2d       	mov	r31, r0
					//set_control_voltage(&res_cv, MIN);
					set_control_voltage(&sustain_1_cv, MAX);
    274e:	0f 2e       	mov	r0, r31
    2750:	fa ec       	ldi	r31, 0xCA	; 202
    2752:	af 2e       	mov	r10, r31
    2754:	f1 e0       	ldi	r31, 0x01	; 1
    2756:	bf 2e       	mov	r11, r31
    2758:	f0 2d       	mov	r31, r0
	
}



void tune_8ths(uint8_t vco) {
    275a:	eb ad       	sts	0x6b, r30
    275c:	fc ad       	sts	0x6c, r31
		period = 1; //need to initialize to minimum period number here
		
		compare_match_counter = 0;	
		for (int note_number = 0; note_number <= 15; note_number++) 
			{
			period = reference[note_number].period;
    275e:	80 81       	ld	r24, Z
    2760:	80 93 80 03 	sts	0x0380, r24
			//period timer needs to be initialized here and turned off after each note's SAR to prevent glitching caused by leaving timer0 running
			TCCR0A |= (1<<CS02) | (1<<CS01) | (1<<CS00) | (1<<WGM01); //clocked by external T0 pin, rising edge + clear timer on compare match
    2764:	84 b5       	in	r24, 0x24	; 36
    2766:	8f 60       	ori	r24, 0x0F	; 15
    2768:	84 bd       	out	0x24, r24	; 36
			OCR0A = 1; //output compare register - set to number of periods to be counted. OCR0A needs to be set to (periods_to_be_counted - 1) ***COULD PROBABLY CHANGE THIS TO 0 NOW*** - NOPE. NEEDS TO BE 1!!!
    276a:	81 e0       	ldi	r24, 0x01	; 1
    276c:	87 bd       	out	0x27, r24	; 39
			//TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
			TCNT0 = 0; //make sure timer/counter0 is actually 0. 
    276e:	16 bc       	out	0x26, r1	; 38
			
			if (note_number <= 2) {
    2770:	4d ad       	sts	0x6d, r20
    2772:	5e ad       	sts	0x6e, r21
    2774:	43 30       	cpi	r20, 0x03	; 3
    2776:	51 05       	cpc	r21, r1
    2778:	24 f4       	brge	.+8      	; 0x2782 <tune_8ths+0x182>
	
				//set timer/counter1 to /64 0.3125 MHz
				timer1_clock = (1<<CS11) | (1<<CS10);
    277a:	83 e0       	ldi	r24, 0x03	; 3
    277c:	80 93 7f 03 	sts	0x037F, r24
    2780:	03 c0       	rjmp	.+6      	; 0x2788 <tune_8ths+0x188>
	
			} else {
	
				//set timer/counter1 to /8 2.5 MHz
				timer1_clock = (1<<CS11);
    2782:	82 e0       	ldi	r24, 0x02	; 2
    2784:	80 93 7f 03 	sts	0x037F, r24
	
			}
			//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
			uint16_t reference_count = reference[note_number].count;
    2788:	81 81       	ldd	r24, Z+1	; 0x01
    278a:	92 81       	ldd	r25, Z+2	; 0x02
    278c:	9a af       	sts	0x7a, r25
    278e:	89 af       	sts	0x79, r24
			uint16_t osc_pitch_cv = 0;
			for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
    2790:	ad e0       	ldi	r26, 0x0D	; 13
    2792:	b0 e0       	ldi	r27, 0x00	; 0
    2794:	be ab       	sts	0x5e, r27
    2796:	ad ab       	sts	0x5d, r26
				timer1_clock = (1<<CS11);
	
			}
			//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
			uint16_t reference_count = reference[note_number].count;
			uint16_t osc_pitch_cv = 0;
    2798:	00 e0       	ldi	r16, 0x00	; 0
    279a:	10 e0       	ldi	r17, 0x00	; 0
			for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
				
				osc_pitch_cv |= (1<<dac_bit);
    279c:	e1 e0       	ldi	r30, 0x01	; 1
    279e:	f0 e0       	ldi	r31, 0x00	; 0
    27a0:	0d a8       	sts	0x8d, r16
    27a2:	02 c0       	rjmp	.+4      	; 0x27a8 <tune_8ths+0x1a8>
    27a4:	ee 0f       	add	r30, r30
    27a6:	ff 1f       	adc	r31, r31
    27a8:	0a 94       	dec	r0
    27aa:	e2 f7       	brpl	.-8      	; 0x27a4 <tune_8ths+0x1a4>
    27ac:	f8 af       	sts	0x78, r31
    27ae:	ef ab       	sts	0x5f, r30
    27b0:	0e 2b       	or	r16, r30
    27b2:	1f 2b       	or	r17, r31
				TIMSK0 &= ~(1<<OCIE0A); //turn off output compare match A interrupt
    27b4:	ae e6       	ldi	r26, 0x6E	; 110
    27b6:	b0 e0       	ldi	r27, 0x00	; 0
    27b8:	8c 91       	ld	r24, X
    27ba:	8d 7f       	andi	r24, 0xFD	; 253
    27bc:	8c 93       	st	X, r24
				set_control_voltage(vco_pitch_cv, osc_pitch_cv);
    27be:	c4 01       	movw	r24, r8
    27c0:	b8 01       	movw	r22, r16
    27c2:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    27c6:	e3 ef       	ldi	r30, 0xF3	; 243
    27c8:	f1 e0       	ldi	r31, 0x01	; 1
    27ca:	31 97       	sbiw	r30, 0x01	; 1
    27cc:	f1 f7       	brne	.-4      	; 0x27ca <tune_8ths+0x1ca>
    27ce:	00 c0       	rjmp	.+0      	; 0x27d0 <tune_8ths+0x1d0>
    27d0:	00 00       	nop
				_delay_ms(2); //add delay here to allow pitch to slew to its final value
				TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
    27d2:	ae e6       	ldi	r26, 0x6E	; 110
    27d4:	b0 e0       	ldi	r27, 0x00	; 0
    27d6:	8c 91       	ld	r24, X
    27d8:	82 60       	ori	r24, 0x02	; 2
    27da:	8c 93       	st	X, r24
				//TCNT0 = 0;
				
				count_finished = FALSE;
    27dc:	10 92 7e 03 	sts	0x037E, r1
				period_counter = 0;
    27e0:	10 92 81 03 	sts	0x0381, r1
			
				//enable watchdog timer
				wdt_enable(WDTO_2S);
    27e4:	e8 e1       	ldi	r30, 0x18	; 24
    27e6:	f0 e0       	ldi	r31, 0x00	; 0
    27e8:	2f e0       	ldi	r18, 0x0F	; 15
    27ea:	0f b6       	in	r0, 0x3f	; 63
    27ec:	f8 94       	cli
    27ee:	a8 95       	wdr
    27f0:	e0 93 60 00 	sts	0x0060, r30
    27f4:	0f be       	out	0x3f, r0	; 63
    27f6:	20 93 60 00 	sts	0x0060, r18
				while (count_finished == FALSE) {
    27fa:	80 91 7e 03 	lds	r24, 0x037E
    27fe:	88 23       	and	r24, r24
    2800:	81 f5       	brne	.+96     	; 0x2862 <tune_8ths+0x262>
					//update_display(vco_number + period + (compare_match_counter>>4)*100, DEC);
					update_display(vco_number*100 + period, DEC);//
    2802:	80 91 80 03 	lds	r24, 0x0380
    2806:	4b a9       	sts	0x4b, r20
    2808:	5c a9       	sts	0x4c, r21
    280a:	48 0f       	add	r20, r24
    280c:	51 1d       	adc	r21, r1
    280e:	ca 01       	movw	r24, r20
    2810:	60 e0       	ldi	r22, 0x00	; 0
    2812:	0e 94 39 03 	call	0x672	; 0x672 <update_display>
					//update_display(value_to_display, DEC);	
					//need to have a watchdog timer here to escape while loop if it takes too long
				
					//not sure what's really necessary here - definitely pitch and init_cv, but what else?
					set_control_voltage(vco_init_cv, init_cv);
    2816:	c3 01       	movw	r24, r6
    2818:	b2 01       	movw	r22, r4
    281a:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
					set_control_voltage(vco_pitch_cv, osc_pitch_cv);
    281e:	c4 01       	movw	r24, r8
    2820:	b8 01       	movw	r22, r16
    2822:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
					//set_control_voltage(&pitch_lfo_cv, MIN);
					//set_control_voltage(vco_pw_cv, MAX); //not necessary as SAW is being used to clock comparator
					set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
    2826:	c7 01       	movw	r24, r14
    2828:	60 e0       	ldi	r22, 0x00	; 0
    282a:	70 e0       	ldi	r23, 0x00	; 0
    282c:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
					set_control_voltage(&cutoff_cv, MAX);
    2830:	c6 01       	movw	r24, r12
    2832:	6f ef       	ldi	r22, 0xFF	; 255
    2834:	7f e3       	ldi	r23, 0x3F	; 63
    2836:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
					//set_control_voltage(&res_cv, MIN);
					set_control_voltage(&sustain_1_cv, MAX);
    283a:	c5 01       	movw	r24, r10
    283c:	6f ef       	ldi	r22, 0xFF	; 255
    283e:	7f e3       	ldi	r23, 0x3F	; 63
    2840:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
					//set_control_voltage(&attack_1_cv, MIN); //keep attack at minimum
					set_control_voltage(vco_pw_cv, 8192);
    2844:	c1 01       	movw	r24, r2
    2846:	60 e0       	ldi	r22, 0x00	; 0
    2848:	70 e2       	ldi	r23, 0x20	; 32
    284a:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
					set_control_voltage(vco_mix_cv, MAX);
    284e:	89 a9       	sts	0x49, r24
    2850:	9a a9       	sts	0x4a, r25
    2852:	6f ef       	ldi	r22, 0xFF	; 255
    2854:	7f e3       	ldi	r23, 0x3F	; 63
    2856:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
				count_finished = FALSE;
				period_counter = 0;
			
				//enable watchdog timer
				wdt_enable(WDTO_2S);
				while (count_finished == FALSE) {
    285a:	80 91 7e 03 	lds	r24, 0x037E
    285e:	88 23       	and	r24, r24
    2860:	81 f2       	breq	.-96     	; 0x2802 <tune_8ths+0x202>

			
			
				}							
				//turn off watchdog timer
				wdt_disable();
    2862:	58 e1       	ldi	r21, 0x18	; 24
    2864:	0f b6       	in	r0, 0x3f	; 63
    2866:	f8 94       	cli
    2868:	50 93 60 00 	sts	0x0060, r21
    286c:	10 92 60 00 	sts	0x0060, r1
    2870:	0f be       	out	0x3f, r0	; 63
				//Omar changed this from <= to < which makes sense. <= was an error because if it's equal you don't want to clear the bit
				if ((osc_count <= reference_count) && (no_overflow == TRUE)) osc_pitch_cv &= ~(1<<dac_bit);
    2872:	80 91 7c 03 	lds	r24, 0x037C
    2876:	90 91 7d 03 	lds	r25, 0x037D
    287a:	a9 ad       	sts	0x69, r26
    287c:	ba ad       	sts	0x6a, r27
    287e:	a8 17       	cp	r26, r24
    2880:	b9 07       	cpc	r27, r25
    2882:	50 f0       	brcs	.+20     	; 0x2898 <tune_8ths+0x298>
    2884:	80 91 af 02 	lds	r24, 0x02AF
    2888:	81 30       	cpi	r24, 0x01	; 1
    288a:	31 f4       	brne	.+12     	; 0x2898 <tune_8ths+0x298>
    288c:	8f a9       	sts	0x4f, r24
    288e:	98 ad       	sts	0x68, r25
    2890:	80 95       	com	r24
    2892:	90 95       	com	r25
    2894:	08 23       	and	r16, r24
    2896:	19 23       	and	r17, r25
				
				if (osc_count == reference_count && no_overflow == TRUE) {
    2898:	80 91 7c 03 	lds	r24, 0x037C
    289c:	90 91 7d 03 	lds	r25, 0x037D
    28a0:	e9 ad       	sts	0x69, r30
    28a2:	fa ad       	sts	0x6a, r31
    28a4:	8e 17       	cp	r24, r30
    28a6:	9f 07       	cpc	r25, r31
    28a8:	21 f4       	brne	.+8      	; 0x28b2 <tune_8ths+0x2b2>
    28aa:	80 91 af 02 	lds	r24, 0x02AF
    28ae:	81 30       	cpi	r24, 0x01	; 1
    28b0:	71 f0       	breq	.+28     	; 0x28ce <tune_8ths+0x2ce>
					break;	//if you hit the reference count then get out of here		
				}				
				no_overflow = TRUE;
    28b2:	f1 e0       	ldi	r31, 0x01	; 1
    28b4:	f0 93 af 02 	sts	0x02AF, r31
	
			}
			//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
			uint16_t reference_count = reference[note_number].count;
			uint16_t osc_pitch_cv = 0;
			for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
    28b8:	2d a9       	sts	0x4d, r18
    28ba:	3e a9       	sts	0x4e, r19
    28bc:	21 50       	subi	r18, 0x01	; 1
    28be:	30 40       	sbci	r19, 0x00	; 0
    28c0:	3e ab       	sts	0x5e, r19
    28c2:	2d ab       	sts	0x5d, r18
    28c4:	4f ef       	ldi	r20, 0xFF	; 255
    28c6:	2f 3f       	cpi	r18, 0xFF	; 255
    28c8:	34 07       	cpc	r19, r20
    28ca:	09 f0       	breq	.+2      	; 0x28ce <tune_8ths+0x2ce>
    28cc:	67 cf       	rjmp	.-306    	; 0x279c <tune_8ths+0x19c>
			
			
			}
		
			//vco_pitch_table[octave*12 + note_number] = osc_pitch_cv; //store the note control voltage in the pitch table
			*(vco_pitch_table + (note_number+1)) = osc_pitch_cv;		
    28ce:	21 96       	adiw	r28, 0x01	; 1
    28d0:	ae ad       	sts	0x6e, r26
    28d2:	bf ad       	sts	0x6f, r27
    28d4:	21 97       	sbiw	r28, 0x01	; 1
    28d6:	0d 93       	st	X+, r16
    28d8:	1d 93       	st	X+, r17
    28da:	21 96       	adiw	r28, 0x01	; 1
    28dc:	bf af       	sts	0x7f, r27
    28de:	ae af       	sts	0x7e, r26
    28e0:	21 97       	sbiw	r28, 0x01	; 1
			
			//need to turn timer off here. This seems to have stopped periodic glitching of first note of first VCO tuned.
			TIMSK0 &= ~(1<<OCIE0A); //turn off timer0 compare match A interrupt
    28e2:	ee e6       	ldi	r30, 0x6E	; 110
    28e4:	f0 e0       	ldi	r31, 0x00	; 0
    28e6:	80 81       	ld	r24, Z
    28e8:	8d 7f       	andi	r24, 0xFD	; 253
    28ea:	80 83       	st	Z, r24
			TCCR0A = 0; //turn off timer0
    28ec:	14 bc       	out	0x24, r1	; 36
		PORTF |= (1<<GATE); //turn gate on
			
		period = 1; //need to initialize to minimum period number here
		
		compare_match_counter = 0;	
		for (int note_number = 0; note_number <= 15; note_number++) 
    28ee:	2d ad       	sts	0x6d, r18
    28f0:	3e ad       	sts	0x6e, r19
    28f2:	2f 5f       	subi	r18, 0xFF	; 255
    28f4:	3f 4f       	sbci	r19, 0xFF	; 255
    28f6:	3e af       	sts	0x7e, r19
    28f8:	2d af       	sts	0x7d, r18
    28fa:	4b ad       	sts	0x6b, r20
    28fc:	5c ad       	sts	0x6c, r21
    28fe:	4d 5f       	subi	r20, 0xFD	; 253
    2900:	5f 4f       	sbci	r21, 0xFF	; 255
    2902:	5c af       	sts	0x7c, r21
    2904:	4b af       	sts	0x7b, r20
    2906:	20 31       	cpi	r18, 0x10	; 16
    2908:	31 05       	cpc	r19, r1
    290a:	09 f0       	breq	.+2      	; 0x290e <tune_8ths+0x30e>
    290c:	26 cf       	rjmp	.-436    	; 0x275a <tune_8ths+0x15a>
		}
	
		
		//eeprom_update_block((const void*)vco_pitch_table, (void*)vco_pitch_table_eeprom, sizeof(vco_pitch_table));
		//vco_pitch_table[0] = 0;
		PORTF &= ~(1<<GATE); //turn gate off
    290e:	89 98       	cbi	0x11, 1	; 17
		
		
	
	
	}
    2910:	c0 5c       	subi	r28, 0xC0	; 192
    2912:	df 4f       	sbci	r29, 0xFF	; 255
    2914:	0f b6       	in	r0, 0x3f	; 63
    2916:	f8 94       	cli
    2918:	de bf       	out	0x3e, r29	; 62
    291a:	0f be       	out	0x3f, r0	; 63
    291c:	cd bf       	out	0x3d, r28	; 61
    291e:	df 91       	pop	r29
    2920:	cf 91       	pop	r28
    2922:	1f 91       	pop	r17
    2924:	0f 91       	pop	r16
    2926:	ff 90       	pop	r15
    2928:	ef 90       	pop	r14
    292a:	df 90       	pop	r13
    292c:	cf 90       	pop	r12
    292e:	bf 90       	pop	r11
    2930:	af 90       	pop	r10
    2932:	9f 90       	pop	r9
    2934:	8f 90       	pop	r8
    2936:	7f 90       	pop	r7
    2938:	6f 90       	pop	r6
    293a:	5f 90       	pop	r5
    293c:	4f 90       	pop	r4
    293e:	3f 90       	pop	r3
    2940:	2f 90       	pop	r2
    2942:	08 95       	ret

00002944 <tune_filter>:
	
void tune_filter(void) {
    2944:	2f 92       	push	r2
    2946:	3f 92       	push	r3
    2948:	4f 92       	push	r4
    294a:	5f 92       	push	r5
    294c:	6f 92       	push	r6
    294e:	7f 92       	push	r7
    2950:	8f 92       	push	r8
    2952:	9f 92       	push	r9
    2954:	af 92       	push	r10
    2956:	bf 92       	push	r11
    2958:	cf 92       	push	r12
    295a:	df 92       	push	r13
    295c:	ef 92       	push	r14
    295e:	ff 92       	push	r15
    2960:	0f 93       	push	r16
    2962:	1f 93       	push	r17
    2964:	cf 93       	push	r28
    2966:	df 93       	push	r29
    2968:	cd b7       	in	r28, 0x3d	; 61
    296a:	de b7       	in	r29, 0x3e	; 62
    296c:	e9 97       	sbiw	r28, 0x39	; 57
    296e:	0f b6       	in	r0, 0x3f	; 63
    2970:	f8 94       	cli
    2972:	de bf       	out	0x3e, r29	; 62
    2974:	0f be       	out	0x3f, r0	; 63
    2976:	cd bf       	out	0x3d, r28	; 61
		uint8_t period;
		uint16_t count;
		
	};

	struct pitch_reference reference[15] =
    2978:	de 01       	movw	r26, r28
    297a:	11 96       	adiw	r26, 0x01	; 1
    297c:	e0 e6       	ldi	r30, 0x60	; 96
    297e:	f2 e0       	ldi	r31, 0x02	; 2
    2980:	8d e2       	ldi	r24, 0x2D	; 45
    2982:	01 90       	ld	r0, Z+
    2984:	0d 92       	st	X+, r0
    2986:	81 50       	subi	r24, 0x01	; 1
    2988:	e1 f7       	brne	.-8      	; 0x2982 <tune_filter+0x3e>
		
	};

	
	//initialize CVs for filter tuning
	set_control_voltage(&volume_cv, MIN); //turn volume all the way down
    298a:	88 ed       	ldi	r24, 0xD8	; 216
    298c:	91 e0       	ldi	r25, 0x01	; 1
    298e:	60 e0       	ldi	r22, 0x00	; 0
    2990:	70 e0       	ldi	r23, 0x00	; 0
    2992:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	//turn off all pitch modulation
	set_control_voltage(&pitch_lfo_cv, MIN);
    2996:	81 ee       	ldi	r24, 0xE1	; 225
    2998:	91 e0       	ldi	r25, 0x01	; 1
    299a:	60 e0       	ldi	r22, 0x00	; 0
    299c:	70 e0       	ldi	r23, 0x00	; 0
    299e:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&pitch_eg2_cv, MIN);
    29a2:	82 ee       	ldi	r24, 0xE2	; 226
    29a4:	91 e0       	ldi	r25, 0x01	; 1
    29a6:	60 e0       	ldi	r22, 0x00	; 0
    29a8:	70 e0       	ldi	r23, 0x00	; 0
    29aa:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&pitch_vco2_cv, MIN);
    29ae:	87 eb       	ldi	r24, 0xB7	; 183
    29b0:	92 e0       	ldi	r25, 0x02	; 2
    29b2:	60 e0       	ldi	r22, 0x00	; 0
    29b4:	70 e0       	ldi	r23, 0x00	; 0
    29b6:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	//turn off glide
	set_control_voltage(&glide_cv, MIN);
    29ba:	8a ed       	ldi	r24, 0xDA	; 218
    29bc:	91 e0       	ldi	r25, 0x01	; 1
    29be:	60 e0       	ldi	r22, 0x00	; 0
    29c0:	70 e0       	ldi	r23, 0x00	; 0
    29c2:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	//turn off all pulse width modulation
	set_control_voltage(&pwm_eg2_cv, MIN);
    29c6:	8f ed       	ldi	r24, 0xDF	; 223
    29c8:	91 e0       	ldi	r25, 0x01	; 1
    29ca:	60 e0       	ldi	r22, 0x00	; 0
    29cc:	70 e0       	ldi	r23, 0x00	; 0
    29ce:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&pwm_lfo_cv, MIN);
    29d2:	80 ee       	ldi	r24, 0xE0	; 224
    29d4:	91 e0       	ldi	r25, 0x01	; 1
    29d6:	60 e0       	ldi	r22, 0x00	; 0
    29d8:	70 e0       	ldi	r23, 0x00	; 0
    29da:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	//turn off all filter modulation
	set_control_voltage(&fil_lfo_cv, MIN);
    29de:	81 ed       	ldi	r24, 0xD1	; 209
    29e0:	91 e0       	ldi	r25, 0x01	; 1
    29e2:	60 e0       	ldi	r22, 0x00	; 0
    29e4:	70 e0       	ldi	r23, 0x00	; 0
    29e6:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&fil_eg2_cv, MIN);
    29ea:	86 ed       	ldi	r24, 0xD6	; 214
    29ec:	91 e0       	ldi	r25, 0x01	; 1
    29ee:	60 e0       	ldi	r22, 0x00	; 0
    29f0:	70 e0       	ldi	r23, 0x00	; 0
    29f2:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&fil_vco2_cv, MIN);
    29f6:	82 ed       	ldi	r24, 0xD2	; 210
    29f8:	91 e0       	ldi	r25, 0x01	; 1
    29fa:	60 e0       	ldi	r22, 0x00	; 0
    29fc:	70 e0       	ldi	r23, 0x00	; 0
    29fe:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&key_track_cv, MIN);
    2a02:	83 ed       	ldi	r24, 0xD3	; 211
    2a04:	91 e0       	ldi	r25, 0x01	; 1
    2a06:	60 e0       	ldi	r22, 0x00	; 0
    2a08:	70 e0       	ldi	r23, 0x00	; 0
    2a0a:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	//open filter with max resonance
	set_control_voltage(&cutoff_cv, MAX); //need to start with MAX to get filter oscillating
    2a0e:	84 ed       	ldi	r24, 0xD4	; 212
    2a10:	91 e0       	ldi	r25, 0x01	; 1
    2a12:	6f ef       	ldi	r22, 0xFF	; 255
    2a14:	7f e3       	ldi	r23, 0x3F	; 63
    2a16:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&res_cv, MAX);
    2a1a:	85 ed       	ldi	r24, 0xD5	; 213
    2a1c:	91 e0       	ldi	r25, 0x01	; 1
    2a1e:	6f ef       	ldi	r22, 0xFF	; 255
    2a20:	7f e3       	ldi	r23, 0x3F	; 63
    2a22:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	//turn off VCA LFO modulation
	set_control_voltage(&amp_lfo_cv, MIN);
    2a26:	89 ed       	ldi	r24, 0xD9	; 217
    2a28:	91 e0       	ldi	r25, 0x01	; 1
    2a2a:	60 e0       	ldi	r22, 0x00	; 0
    2a2c:	70 e0       	ldi	r23, 0x00	; 0
    2a2e:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	//initialize VCA envelope
	set_control_voltage(&attack_1_cv, MIN);
    2a32:	8e ec       	ldi	r24, 0xCE	; 206
    2a34:	91 e0       	ldi	r25, 0x01	; 1
    2a36:	60 e0       	ldi	r22, 0x00	; 0
    2a38:	70 e0       	ldi	r23, 0x00	; 0
    2a3a:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&decay_1_cv, MIN);
    2a3e:	8c ec       	ldi	r24, 0xCC	; 204
    2a40:	91 e0       	ldi	r25, 0x01	; 1
    2a42:	60 e0       	ldi	r22, 0x00	; 0
    2a44:	70 e0       	ldi	r23, 0x00	; 0
    2a46:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&sustain_1_cv, MAX);
    2a4a:	8a ec       	ldi	r24, 0xCA	; 202
    2a4c:	91 e0       	ldi	r25, 0x01	; 1
    2a4e:	6f ef       	ldi	r22, 0xFF	; 255
    2a50:	7f e3       	ldi	r23, 0x3F	; 63
    2a52:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&release_1_cv, MIN);
    2a56:	88 ec       	ldi	r24, 0xC8	; 200
    2a58:	91 e0       	ldi	r25, 0x01	; 1
    2a5a:	60 e0       	ldi	r22, 0x00	; 0
    2a5c:	70 e0       	ldi	r23, 0x00	; 0
    2a5e:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	//turn off noise, VCO1 and VCO2
	set_control_voltage(&noise_mix_cv, MIN);
    2a62:	80 ed       	ldi	r24, 0xD0	; 208
    2a64:	91 e0       	ldi	r25, 0x01	; 1
    2a66:	60 e0       	ldi	r22, 0x00	; 0
    2a68:	70 e0       	ldi	r23, 0x00	; 0
    2a6a:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&vco1_mix_cv, MIN);
    2a6e:	83 ee       	ldi	r24, 0xE3	; 227
    2a70:	91 e0       	ldi	r25, 0x01	; 1
    2a72:	60 e0       	ldi	r22, 0x00	; 0
    2a74:	70 e0       	ldi	r23, 0x00	; 0
    2a76:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
	set_control_voltage(&vco2_mix_cv, MIN);
    2a7a:	84 ee       	ldi	r24, 0xE4	; 228
    2a7c:	91 e0       	ldi	r25, 0x01	; 1
    2a7e:	60 e0       	ldi	r22, 0x00	; 0
    2a80:	70 e0       	ldi	r23, 0x00	; 0
    2a82:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>


	//latch switch data
	DATA_BUS = 0; //turn off all VCO waveforms
    2a86:	12 b8       	out	0x02, r1	; 2
	VCO_SW_LATCH_PORT |= (1<<VCO_SW_LATCH);
    2a88:	ed ed       	ldi	r30, 0xDD	; 221
    2a8a:	f0 e0       	ldi	r31, 0x00	; 0
    2a8c:	80 81       	ld	r24, Z
    2a8e:	80 64       	ori	r24, 0x40	; 64
    2a90:	80 83       	st	Z, r24
	//_delay_us(1); //why is this delay here????
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    2a92:	80 81       	ld	r24, Z
    2a94:	8f 7b       	andi	r24, 0xBF	; 191
    2a96:	80 83       	st	Z, r24
	//DATA_BUS = 0;


	period = 1; //need to initialize to minimum period number here
    2a98:	81 e0       	ldi	r24, 0x01	; 1
    2a9a:	80 93 80 03 	sts	0x0380, r24
	PORTF |= (1<<GATE); //turn gate on
    2a9e:	89 9a       	sbi	0x11, 1	; 17
    2aa0:	9e 01       	movw	r18, r28
    2aa2:	2f 5f       	subi	r18, 0xFF	; 255
    2aa4:	3f 4f       	sbci	r19, 0xFF	; 255
    2aa6:	3d ab       	sts	0x5d, r19
    2aa8:	2c ab       	sts	0x5c, r18
    2aaa:	85 e1       	ldi	r24, 0x15	; 21
    2aac:	93 e0       	ldi	r25, 0x03	; 3
    2aae:	99 af       	sts	0x79, r25
    2ab0:	88 af       	sts	0x78, r24
	
	
	
	for (int note_number = 0; note_number <= 14; note_number++)
    2ab2:	1f aa       	sts	0x9f, r17
    2ab4:	1e aa       	sts	0x9e, r17
		uint16_t pitch_cv = 0;
		for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
		
			pitch_cv |= (1<<dac_bit);

			set_control_voltage(&cutoff_cv, pitch_cv);
    2ab6:	0f 2e       	mov	r0, r31
    2ab8:	f4 ed       	ldi	r31, 0xD4	; 212
    2aba:	af 2e       	mov	r10, r31
    2abc:	f1 e0       	ldi	r31, 0x01	; 1
    2abe:	bf 2e       	mov	r11, r31
    2ac0:	f0 2d       	mov	r31, r0
				//value_to_display = TCNT0;
				//update_display(value_to_display, DEC);
				
		
				set_control_voltage(&cutoff_cv, pitch_cv);
				set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
    2ac2:	0f 2e       	mov	r0, r31
    2ac4:	f8 ed       	ldi	r31, 0xD8	; 216
    2ac6:	6f 2e       	mov	r6, r31
    2ac8:	f1 e0       	ldi	r31, 0x01	; 1
    2aca:	7f 2e       	mov	r7, r31
    2acc:	f0 2d       	mov	r31, r0
				set_control_voltage(&res_cv, MAX);
    2ace:	0f 2e       	mov	r0, r31
    2ad0:	f5 ed       	ldi	r31, 0xD5	; 213
    2ad2:	4f 2e       	mov	r4, r31
    2ad4:	f1 e0       	ldi	r31, 0x01	; 1
    2ad6:	5f 2e       	mov	r5, r31
    2ad8:	f0 2d       	mov	r31, r0
				set_control_voltage(&sustain_1_cv, MAX);
    2ada:	0f 2e       	mov	r0, r31
    2adc:	fa ec       	ldi	r31, 0xCA	; 202
    2ade:	2f 2e       	mov	r2, r31
    2ae0:	f1 e0       	ldi	r31, 0x01	; 1
    2ae2:	3f 2e       	mov	r3, r31
    2ae4:	f0 2d       	mov	r31, r0
		
	
	
	}
	
void tune_filter(void) {
    2ae6:	ac a9       	sts	0x4c, r26
    2ae8:	bd a9       	sts	0x4d, r27
	
	
	
	for (int note_number = 0; note_number <= 14; note_number++)
	{
		period = reference[note_number].period;
    2aea:	8c 91       	ld	r24, X
    2aec:	80 93 80 03 	sts	0x0380, r24
		//period timer needs to be initialized here and turned off after each note's SAR to prevent glitching caused by leaving timer0 running
		TCCR0A |= (1<<CS02) | (1<<CS01) | (1<<CS00) | (1<<WGM01); //clocked by external T0 pin, rising edge + clear timer on compare match
    2af0:	84 b5       	in	r24, 0x24	; 36
    2af2:	8f 60       	ori	r24, 0x0F	; 15
    2af4:	84 bd       	out	0x24, r24	; 36
		OCR0A = 1; //output compare register - set to number of periods to be counted. OCR0A needs to be set to (periods_to_be_counted - 1) ***COULD PROBABLY CHANGE THIS TO 0 NOW*** - NOPE. NEEDS TO BE 1!!!
    2af6:	81 e0       	ldi	r24, 0x01	; 1
    2af8:	87 bd       	out	0x27, r24	; 39
		TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
    2afa:	ee e6       	ldi	r30, 0x6E	; 110
    2afc:	f0 e0       	ldi	r31, 0x00	; 0
    2afe:	80 81       	ld	r24, Z
    2b00:	82 60       	ori	r24, 0x02	; 2
    2b02:	80 83       	st	Z, r24
		TCNT0 = 0; //make sure timer/counter0 is actually 0.
    2b04:	16 bc       	out	0x26, r1	; 38
		
		if (note_number <= 1) {
    2b06:	ee a9       	sts	0x4e, r30
    2b08:	ff a9       	sts	0x4f, r31
    2b0a:	e2 30       	cpi	r30, 0x02	; 2
    2b0c:	f1 05       	cpc	r31, r1
    2b0e:	24 f4       	brge	.+8      	; 0x2b18 <tune_filter+0x1d4>
			
			//set timer/counter1 to /64 0.3125 MHz
			timer1_clock = (1<<CS11) | (1<<CS10);
    2b10:	83 e0       	ldi	r24, 0x03	; 3
    2b12:	80 93 7f 03 	sts	0x037F, r24
    2b16:	03 c0       	rjmp	.+6      	; 0x2b1e <tune_filter+0x1da>
			
		} else {
			
			//set timer/counter1 to /8 2.5 MHz
			timer1_clock = (1<<CS11);
    2b18:	82 e0       	ldi	r24, 0x02	; 2
    2b1a:	80 93 7f 03 	sts	0x037F, r24
			
		}
		//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
		uint16_t reference_count = reference[note_number].count;
    2b1e:	11 96       	adiw	r26, 0x01	; 1
    2b20:	2d 91       	ld	r18, X+
    2b22:	3c 91       	ld	r19, X
    2b24:	12 97       	sbiw	r26, 0x02	; 2
    2b26:	3b ab       	sts	0x5b, r19
    2b28:	2a ab       	sts	0x5a, r18
		uint16_t pitch_cv = 0;
		for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
    2b2a:	8d e0       	ldi	r24, 0x0D	; 13
    2b2c:	90 e0       	ldi	r25, 0x00	; 0
    2b2e:	9f a7       	lds	r25, 0x7f
    2b30:	8e a7       	lds	r24, 0x7e
			timer1_clock = (1<<CS11);
			
		}
		//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
		uint16_t reference_count = reference[note_number].count;
		uint16_t pitch_cv = 0;
    2b32:	ee 24       	eor	r14, r14
    2b34:	ff 24       	eor	r15, r15
				set_control_voltage(&cutoff_cv, pitch_cv);
				set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
				set_control_voltage(&res_cv, MAX);
				set_control_voltage(&sustain_1_cv, MAX);
				set_control_voltage(&attack_1_cv, MIN); //keep attack at minimum
				set_control_voltage(&fil_lfo_cv, MIN);	//keep all filter modulation at a minimum
    2b36:	0f 2e       	mov	r0, r31
    2b38:	f1 ed       	ldi	r31, 0xD1	; 209
    2b3a:	cf 2e       	mov	r12, r31
    2b3c:	f1 e0       	ldi	r31, 0x01	; 1
    2b3e:	df 2e       	mov	r13, r31
    2b40:	f0 2d       	mov	r31, r0
				set_control_voltage(&fil_eg2_cv, MIN);
    2b42:	0f 2e       	mov	r0, r31
    2b44:	f6 ed       	ldi	r31, 0xD6	; 214
    2b46:	8f 2e       	mov	r8, r31
    2b48:	f1 e0       	ldi	r31, 0x01	; 1
    2b4a:	9f 2e       	mov	r9, r31
    2b4c:	f0 2d       	mov	r31, r0
		//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
		uint16_t reference_count = reference[note_number].count;
		uint16_t pitch_cv = 0;
		for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
		
			pitch_cv |= (1<<dac_bit);
    2b4e:	81 e0       	ldi	r24, 0x01	; 1
    2b50:	90 e0       	ldi	r25, 0x00	; 0
    2b52:	fc 01       	movw	r30, r24
    2b54:	0e a4       	lds	r16, 0xae
    2b56:	02 c0       	rjmp	.+4      	; 0x2b5c <tune_filter+0x218>
    2b58:	ee 0f       	add	r30, r30
    2b5a:	ff 1f       	adc	r31, r31
    2b5c:	0a 94       	dec	r0
    2b5e:	e2 f7       	brpl	.-8      	; 0x2b58 <tune_filter+0x214>
    2b60:	f9 ab       	sts	0x59, r31
    2b62:	e8 ab       	sts	0x58, r30
    2b64:	ee 2a       	or	r14, r30
    2b66:	ff 2a       	or	r15, r31

			set_control_voltage(&cutoff_cv, pitch_cv);
    2b68:	c5 01       	movw	r24, r10
    2b6a:	b7 01       	movw	r22, r14
    2b6c:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
			count_finished = FALSE;
    2b70:	10 92 7e 03 	sts	0x037E, r1
			period_counter = 0;
    2b74:	10 92 81 03 	sts	0x0381, r1
		
			//enable watchdog timer
			wdt_enable(WDTO_2S);
    2b78:	8f e0       	ldi	r24, 0x0F	; 15
    2b7a:	28 e1       	ldi	r18, 0x18	; 24
    2b7c:	30 e0       	ldi	r19, 0x00	; 0
    2b7e:	0f b6       	in	r0, 0x3f	; 63
    2b80:	f8 94       	cli
    2b82:	a8 95       	wdr
    2b84:	20 93 60 00 	sts	0x0060, r18
    2b88:	0f be       	out	0x3f, r0	; 63
    2b8a:	80 93 60 00 	sts	0x0060, r24
			while (count_finished == FALSE) {
    2b8e:	80 91 7e 03 	lds	r24, 0x037E
    2b92:	88 23       	and	r24, r24
    2b94:	b1 f5       	brne	.+108    	; 0x2c02 <tune_filter+0x2be>
				set_control_voltage(&res_cv, MAX);
				set_control_voltage(&sustain_1_cv, MAX);
				set_control_voltage(&attack_1_cv, MIN); //keep attack at minimum
				set_control_voltage(&fil_lfo_cv, MIN);	//keep all filter modulation at a minimum
				set_control_voltage(&fil_eg2_cv, MIN);
				set_control_voltage(&fil_vco2_cv, MIN);
    2b96:	02 ed       	ldi	r16, 0xD2	; 210
    2b98:	11 e0       	ldi	r17, 0x01	; 1
		
			//enable watchdog timer
			wdt_enable(WDTO_2S);
			while (count_finished == FALSE) {
				//update_display(vco_number + period + (compare_match_counter>>4)*100, DEC);
				update_display(300 + period, DEC);//
    2b9a:	80 91 80 03 	lds	r24, 0x0380
    2b9e:	90 e0       	ldi	r25, 0x00	; 0
    2ba0:	84 5d       	subi	r24, 0xD4	; 212
    2ba2:	9e 4f       	sbci	r25, 0xFE	; 254
    2ba4:	60 e0       	ldi	r22, 0x00	; 0
    2ba6:	0e 94 39 03 	call	0x672	; 0x672 <update_display>
				//value_to_display = TCNT0;
				//update_display(value_to_display, DEC);
				
		
				set_control_voltage(&cutoff_cv, pitch_cv);
    2baa:	c5 01       	movw	r24, r10
    2bac:	b7 01       	movw	r22, r14
    2bae:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
				set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
    2bb2:	c3 01       	movw	r24, r6
    2bb4:	60 e0       	ldi	r22, 0x00	; 0
    2bb6:	70 e0       	ldi	r23, 0x00	; 0
    2bb8:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
				set_control_voltage(&res_cv, MAX);
    2bbc:	c2 01       	movw	r24, r4
    2bbe:	6f ef       	ldi	r22, 0xFF	; 255
    2bc0:	7f e3       	ldi	r23, 0x3F	; 63
    2bc2:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
				set_control_voltage(&sustain_1_cv, MAX);
    2bc6:	c1 01       	movw	r24, r2
    2bc8:	6f ef       	ldi	r22, 0xFF	; 255
    2bca:	7f e3       	ldi	r23, 0x3F	; 63
    2bcc:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
				set_control_voltage(&attack_1_cv, MIN); //keep attack at minimum
    2bd0:	8e ec       	ldi	r24, 0xCE	; 206
    2bd2:	91 e0       	ldi	r25, 0x01	; 1
    2bd4:	60 e0       	ldi	r22, 0x00	; 0
    2bd6:	70 e0       	ldi	r23, 0x00	; 0
    2bd8:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
				set_control_voltage(&fil_lfo_cv, MIN);	//keep all filter modulation at a minimum
    2bdc:	c6 01       	movw	r24, r12
    2bde:	60 e0       	ldi	r22, 0x00	; 0
    2be0:	70 e0       	ldi	r23, 0x00	; 0
    2be2:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
				set_control_voltage(&fil_eg2_cv, MIN);
    2be6:	c4 01       	movw	r24, r8
    2be8:	60 e0       	ldi	r22, 0x00	; 0
    2bea:	70 e0       	ldi	r23, 0x00	; 0
    2bec:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
				set_control_voltage(&fil_vco2_cv, MIN);
    2bf0:	c8 01       	movw	r24, r16
    2bf2:	60 e0       	ldi	r22, 0x00	; 0
    2bf4:	70 e0       	ldi	r23, 0x00	; 0
    2bf6:	0e 94 05 02 	call	0x40a	; 0x40a <set_control_voltage>
			count_finished = FALSE;
			period_counter = 0;
		
			//enable watchdog timer
			wdt_enable(WDTO_2S);
			while (count_finished == FALSE) {
    2bfa:	80 91 7e 03 	lds	r24, 0x037E
    2bfe:	88 23       	and	r24, r24
    2c00:	61 f2       	breq	.-104    	; 0x2b9a <tune_filter+0x256>
				set_control_voltage(&fil_eg2_cv, MIN);
				set_control_voltage(&fil_vco2_cv, MIN);
						
			}
			//turn off watchdog timer
			wdt_disable();
    2c02:	88 e1       	ldi	r24, 0x18	; 24
    2c04:	0f b6       	in	r0, 0x3f	; 63
    2c06:	f8 94       	cli
    2c08:	80 93 60 00 	sts	0x0060, r24
    2c0c:	10 92 60 00 	sts	0x0060, r1
    2c10:	0f be       	out	0x3f, r0	; 63
			//Omar changed this from <= to < which makes sense. <= was an error because if it's equal you don't want to clear the bit
			if ((osc_count <= reference_count) && (no_overflow == TRUE))pitch_cv &= ~(1<<dac_bit);
    2c12:	80 91 7c 03 	lds	r24, 0x037C
    2c16:	90 91 7d 03 	lds	r25, 0x037D
    2c1a:	2a a9       	sts	0x4a, r18
    2c1c:	3b a9       	sts	0x4b, r19
    2c1e:	28 17       	cp	r18, r24
    2c20:	39 07       	cpc	r19, r25
    2c22:	50 f0       	brcs	.+20     	; 0x2c38 <tune_filter+0x2f4>
    2c24:	80 91 af 02 	lds	r24, 0x02AF
    2c28:	81 30       	cpi	r24, 0x01	; 1
    2c2a:	31 f4       	brne	.+12     	; 0x2c38 <tune_filter+0x2f4>
    2c2c:	88 a9       	sts	0x48, r24
    2c2e:	99 a9       	sts	0x49, r25
    2c30:	80 95       	com	r24
    2c32:	90 95       	com	r25
    2c34:	e8 22       	and	r14, r24
    2c36:	f9 22       	and	r15, r25
		
			if (osc_count == reference_count && no_overflow == TRUE) {
    2c38:	80 91 7c 03 	lds	r24, 0x037C
    2c3c:	90 91 7d 03 	lds	r25, 0x037D
    2c40:	ea a9       	sts	0x4a, r30
    2c42:	fb a9       	sts	0x4b, r31
    2c44:	8e 17       	cp	r24, r30
    2c46:	9f 07       	cpc	r25, r31
    2c48:	21 f4       	brne	.+8      	; 0x2c52 <tune_filter+0x30e>
    2c4a:	80 91 af 02 	lds	r24, 0x02AF
    2c4e:	81 30       	cpi	r24, 0x01	; 1
    2c50:	71 f0       	breq	.+28     	; 0x2c6e <tune_filter+0x32a>
				break;	//if you hit the reference count then get out of here
			}
			no_overflow = TRUE;
    2c52:	81 e0       	ldi	r24, 0x01	; 1
    2c54:	80 93 af 02 	sts	0x02AF, r24
			
		}
		//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
		uint16_t reference_count = reference[note_number].count;
		uint16_t pitch_cv = 0;
		for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
    2c58:	2e a5       	lds	r18, 0x6e
    2c5a:	3f a5       	lds	r19, 0x6f
    2c5c:	21 50       	subi	r18, 0x01	; 1
    2c5e:	30 40       	sbci	r19, 0x00	; 0
    2c60:	3f a7       	lds	r19, 0x7f
    2c62:	2e a7       	lds	r18, 0x7e
    2c64:	8f ef       	ldi	r24, 0xFF	; 255
    2c66:	2f 3f       	cpi	r18, 0xFF	; 255
    2c68:	38 07       	cpc	r19, r24
    2c6a:	09 f0       	breq	.+2      	; 0x2c6e <tune_filter+0x32a>
    2c6c:	70 cf       	rjmp	.-288    	; 0x2b4e <tune_filter+0x20a>
		
		
	}
	
	
	filter_pitch_table[note_number+1] = pitch_cv + 32; //32 is an offset that is trying to fix a bug somewhere else. This fix seems to work, but why 2^5 shift is required doesn't make sense to me yet. Need to look into this further
    2c6e:	ee a9       	sts	0x4e, r30
    2c70:	ff a9       	sts	0x4f, r31
    2c72:	31 96       	adiw	r30, 0x01	; 1
    2c74:	ff ab       	sts	0x5f, r31
    2c76:	ee ab       	sts	0x5e, r30
    2c78:	c7 01       	movw	r24, r14
    2c7a:	80 96       	adiw	r24, 0x20	; 32
    2c7c:	e8 ad       	sts	0x68, r30
    2c7e:	f9 ad       	sts	0x69, r31
    2c80:	81 93       	st	Z+, r24
    2c82:	91 93       	st	Z+, r25
    2c84:	f9 af       	sts	0x79, r31
    2c86:	e8 af       	sts	0x78, r30
	
	//need to turn timer off here. This seems to have stopped periodic glitching of first note of first VCO tuned.
	TIMSK0 &= ~(1<<OCIE0A); //turn off timer0 compare match A interrupt
    2c88:	ee e6       	ldi	r30, 0x6E	; 110
    2c8a:	f0 e0       	ldi	r31, 0x00	; 0
    2c8c:	80 81       	ld	r24, Z
    2c8e:	8d 7f       	andi	r24, 0xFD	; 253
    2c90:	80 83       	st	Z, r24
	TCCR0A = 0; //turn off timer0
    2c92:	14 bc       	out	0x24, r1	; 36
    2c94:	2c a9       	sts	0x4c, r18
    2c96:	3d a9       	sts	0x4d, r19
    2c98:	2d 5f       	subi	r18, 0xFD	; 253
    2c9a:	3f 4f       	sbci	r19, 0xFF	; 255
    2c9c:	3d ab       	sts	0x5d, r19
    2c9e:	2c ab       	sts	0x5c, r18
	period = 1; //need to initialize to minimum period number here
	PORTF |= (1<<GATE); //turn gate on
	
	
	
	for (int note_number = 0; note_number <= 14; note_number++)
    2ca0:	8e a9       	sts	0x4e, r24
    2ca2:	9f a9       	sts	0x4f, r25
    2ca4:	8f 30       	cpi	r24, 0x0F	; 15
    2ca6:	91 05       	cpc	r25, r1
    2ca8:	09 f0       	breq	.+2      	; 0x2cac <tune_filter+0x368>
    2caa:	1d cf       	rjmp	.-454    	; 0x2ae6 <tune_filter+0x1a2>
}


//eeprom_update_block((const void*)filter_pitch_table, (void*)filter_pitch_table_eeprom, sizeof(filter_pitch_table));

PORTF &= ~(1<<GATE); //turn gate off
    2cac:	89 98       	cbi	0x11, 1	; 17
	
	
}	
    2cae:	e9 96       	adiw	r28, 0x39	; 57
    2cb0:	0f b6       	in	r0, 0x3f	; 63
    2cb2:	f8 94       	cli
    2cb4:	de bf       	out	0x3e, r29	; 62
    2cb6:	0f be       	out	0x3f, r0	; 63
    2cb8:	cd bf       	out	0x3d, r28	; 61
    2cba:	df 91       	pop	r29
    2cbc:	cf 91       	pop	r28
    2cbe:	1f 91       	pop	r17
    2cc0:	0f 91       	pop	r16
    2cc2:	ff 90       	pop	r15
    2cc4:	ef 90       	pop	r14
    2cc6:	df 90       	pop	r13
    2cc8:	cf 90       	pop	r12
    2cca:	bf 90       	pop	r11
    2ccc:	af 90       	pop	r10
    2cce:	9f 90       	pop	r9
    2cd0:	8f 90       	pop	r8
    2cd2:	7f 90       	pop	r7
    2cd4:	6f 90       	pop	r6
    2cd6:	5f 90       	pop	r5
    2cd8:	4f 90       	pop	r4
    2cda:	3f 90       	pop	r3
    2cdc:	2f 90       	pop	r2
    2cde:	08 95       	ret

00002ce0 <save_tuning_tables>:


void save_tuning_tables(void) { //write tuning tables to memory
	
	eeprom_update_block((const void*)filter_pitch_table, (void*)filter_pitch_table_eeprom, sizeof(filter_pitch_table));
    2ce0:	83 e1       	ldi	r24, 0x13	; 19
    2ce2:	93 e0       	ldi	r25, 0x03	; 3
    2ce4:	6c e0       	ldi	r22, 0x0C	; 12
    2ce6:	76 e0       	ldi	r23, 0x06	; 6
    2ce8:	40 e2       	ldi	r20, 0x20	; 32
    2cea:	50 e0       	ldi	r21, 0x00	; 0
    2cec:	0e 94 87 1f 	call	0x3f0e	; 0x3f0e <__eeupd_block_m6450a>
	eeprom_update_block((const void*)vco1_pitch_table, (void*)vco1_pitch_table_eeprom, sizeof(vco1_pitch_table));
    2cf0:	85 e5       	ldi	r24, 0x55	; 85
    2cf2:	93 e0       	ldi	r25, 0x03	; 3
    2cf4:	6e e4       	ldi	r22, 0x4E	; 78
    2cf6:	76 e0       	ldi	r23, 0x06	; 6
    2cf8:	42 e2       	ldi	r20, 0x22	; 34
    2cfa:	50 e0       	ldi	r21, 0x00	; 0
    2cfc:	0e 94 87 1f 	call	0x3f0e	; 0x3f0e <__eeupd_block_m6450a>
	eeprom_update_block((const void*)vco2_pitch_table, (void*)vco2_pitch_table_eeprom, sizeof(vco2_pitch_table));
    2d00:	83 e3       	ldi	r24, 0x33	; 51
    2d02:	93 e0       	ldi	r25, 0x03	; 3
    2d04:	6c e2       	ldi	r22, 0x2C	; 44
    2d06:	76 e0       	ldi	r23, 0x06	; 6
    2d08:	42 e2       	ldi	r20, 0x22	; 34
    2d0a:	50 e0       	ldi	r21, 0x00	; 0
    2d0c:	0e 94 87 1f 	call	0x3f0e	; 0x3f0e <__eeupd_block_m6450a>
	
	
}
    2d10:	08 95       	ret

00002d12 <load_tuning_tables>:

void load_tuning_tables(void) { //retrieve tuning tables from memory
	
	
	vco1_init_cv = eeprom_read_word(&vco1_init_cv_eeprom);
    2d12:	82 e7       	ldi	r24, 0x72	; 114
    2d14:	96 e0       	ldi	r25, 0x06	; 6
    2d16:	0e 94 81 1f 	call	0x3f02	; 0x3f02 <__eerd_word_m6450a>
    2d1a:	90 93 7a 03 	sts	0x037A, r25
    2d1e:	80 93 79 03 	sts	0x0379, r24
	vco2_init_cv = eeprom_read_word(&vco2_init_cv_eeprom);
    2d22:	80 e7       	ldi	r24, 0x70	; 112
    2d24:	96 e0       	ldi	r25, 0x06	; 6
    2d26:	0e 94 81 1f 	call	0x3f02	; 0x3f02 <__eerd_word_m6450a>
    2d2a:	90 93 78 03 	sts	0x0378, r25
    2d2e:	80 93 77 03 	sts	0x0377, r24
	//uint16_t eeprom_addr = 0;
	//vco1_init_cv = eeprom_read_word((uint16_t*)eeprom_addr);
	//eeprom_addr += sizeof(vco2_init_cv);
	//vco2_init_cv = eeprom_read_word((uint16_t*)eeprom_addr);
	eeprom_read_block((void*)vco1_pitch_table, (const void*)vco1_pitch_table_eeprom, sizeof(vco1_pitch_table));
    2d32:	85 e5       	ldi	r24, 0x55	; 85
    2d34:	93 e0       	ldi	r25, 0x03	; 3
    2d36:	6e e4       	ldi	r22, 0x4E	; 78
    2d38:	76 e0       	ldi	r23, 0x06	; 6
    2d3a:	42 e2       	ldi	r20, 0x22	; 34
    2d3c:	50 e0       	ldi	r21, 0x00	; 0
    2d3e:	0e 94 71 1f 	call	0x3ee2	; 0x3ee2 <__eerd_block_m6450a>
	eeprom_read_block((void*)vco2_pitch_table, (const void*)vco2_pitch_table_eeprom, sizeof(vco2_pitch_table));
    2d42:	83 e3       	ldi	r24, 0x33	; 51
    2d44:	93 e0       	ldi	r25, 0x03	; 3
    2d46:	6c e2       	ldi	r22, 0x2C	; 44
    2d48:	76 e0       	ldi	r23, 0x06	; 6
    2d4a:	42 e2       	ldi	r20, 0x22	; 34
    2d4c:	50 e0       	ldi	r21, 0x00	; 0
    2d4e:	0e 94 71 1f 	call	0x3ee2	; 0x3ee2 <__eerd_block_m6450a>
	eeprom_read_block((void*)filter_pitch_table, (const void*)filter_pitch_table_eeprom, sizeof(filter_pitch_table));
    2d52:	83 e1       	ldi	r24, 0x13	; 19
    2d54:	93 e0       	ldi	r25, 0x03	; 3
    2d56:	6c e0       	ldi	r22, 0x0C	; 12
    2d58:	76 e0       	ldi	r23, 0x06	; 6
    2d5a:	40 e2       	ldi	r20, 0x20	; 32
    2d5c:	50 e0       	ldi	r21, 0x00	; 0
    2d5e:	0e 94 71 1f 	call	0x3ee2	; 0x3ee2 <__eerd_block_m6450a>
	
	//value_to_display = vco1_init_cv_eeprom;
	
}			
    2d62:	08 95       	ret

00002d64 <interpolate_pitch_cv>:
	
uint16_t interpolate_pitch_cv(uint8_t note, uint16_t *pitch_table) {
	
	uint8_t pitch_index = note>>3;
    2d64:	98 2f       	mov	r25, r24
    2d66:	96 95       	lsr	r25
    2d68:	96 95       	lsr	r25
    2d6a:	96 95       	lsr	r25
	uint8_t delta_note = note - pitch_index*8; //will range from 0 to 7
		
	uint16_t y0 = pitch_table[pitch_index -1];
    2d6c:	29 2f       	mov	r18, r25
    2d6e:	30 e0       	ldi	r19, 0x00	; 0
    2d70:	f9 01       	movw	r30, r18
    2d72:	31 97       	sbiw	r30, 0x01	; 1
    2d74:	ee 0f       	add	r30, r30
    2d76:	ff 1f       	adc	r31, r31
    2d78:	e6 0f       	add	r30, r22
    2d7a:	f7 1f       	adc	r31, r23
    2d7c:	01 90       	ld	r0, Z+
    2d7e:	f0 81       	ld	r31, Z
    2d80:	e0 2d       	mov	r30, r0
	uint16_t y1 = pitch_table[pitch_index];
    2d82:	22 0f       	add	r18, r18
    2d84:	33 1f       	adc	r19, r19
    2d86:	26 0f       	add	r18, r22
    2d88:	37 1f       	adc	r19, r23
	
	uint16_t interpolated_pitch_cv = y0 + (((y1 - y0)*delta_note)>>3); //mind order of operations here: + is evaluated before >>	also, might be possible to optimize this with 16MUL8SHIFT8 from Anushri ASM util
    2d8a:	d9 01       	movw	r26, r18
    2d8c:	4d 91       	ld	r20, X+
    2d8e:	5c 91       	ld	r21, X
    2d90:	11 97       	sbiw	r26, 0x01	; 1
    2d92:	4e 1b       	sub	r20, r30
    2d94:	5f 0b       	sbc	r21, r31
}			
	
uint16_t interpolate_pitch_cv(uint8_t note, uint16_t *pitch_table) {
	
	uint8_t pitch_index = note>>3;
	uint8_t delta_note = note - pitch_index*8; //will range from 0 to 7
    2d96:	99 0f       	add	r25, r25
    2d98:	99 0f       	add	r25, r25
    2d9a:	99 0f       	add	r25, r25
    2d9c:	89 1b       	sub	r24, r25
		
	uint16_t y0 = pitch_table[pitch_index -1];
	uint16_t y1 = pitch_table[pitch_index];
	
	uint16_t interpolated_pitch_cv = y0 + (((y1 - y0)*delta_note)>>3); //mind order of operations here: + is evaluated before >>	also, might be possible to optimize this with 16MUL8SHIFT8 from Anushri ASM util
    2d9e:	90 e0       	ldi	r25, 0x00	; 0
    2da0:	48 9f       	mul	r20, r24
    2da2:	90 01       	movw	r18, r0
    2da4:	49 9f       	mul	r20, r25
    2da6:	30 0d       	add	r19, r0
    2da8:	58 9f       	mul	r21, r24
    2daa:	30 0d       	add	r19, r0
    2dac:	11 24       	eor	r1, r1
    2dae:	36 95       	lsr	r19
    2db0:	27 95       	ror	r18
    2db2:	36 95       	lsr	r19
    2db4:	27 95       	ror	r18
    2db6:	36 95       	lsr	r19
    2db8:	27 95       	ror	r18
    2dba:	e2 0f       	add	r30, r18
    2dbc:	f3 1f       	adc	r31, r19
	
	
	
	return interpolated_pitch_cv;
	
}
    2dbe:	8e 2f       	mov	r24, r30
    2dc0:	9f 2f       	mov	r25, r31
    2dc2:	08 95       	ret

00002dc4 <set_one_volt_per_octave>:

void set_one_volt_per_octave(void) { //does this get stored in RAM? Should it go in progmem instead?
    2dc4:	cf 93       	push	r28
    2dc6:	df 93       	push	r29
    2dc8:	cd b7       	in	r28, 0x3d	; 61
    2dca:	de b7       	in	r29, 0x3e	; 62
    2dcc:	a2 97       	sbiw	r28, 0x22	; 34
    2dce:	0f b6       	in	r0, 0x3f	; 63
    2dd0:	f8 94       	cli
    2dd2:	de bf       	out	0x3e, r29	; 62
    2dd4:	0f be       	out	0x3f, r0	; 63
    2dd6:	cd bf       	out	0x3d, r28	; 61
	
	uint16_t vpo_pitch_table[17] = {
    2dd8:	de 01       	movw	r26, r28
    2dda:	11 96       	adiw	r26, 0x01	; 1
    2ddc:	ed e8       	ldi	r30, 0x8D	; 141
    2dde:	f2 e0       	ldi	r31, 0x02	; 2
    2de0:	82 e2       	ldi	r24, 0x22	; 34
    2de2:	01 90       	ld	r0, Z+
    2de4:	0d 92       	st	X+, r0
    2de6:	81 50       	subi	r24, 0x01	; 1
    2de8:	e1 f7       	brne	.-8      	; 0x2de2 <set_one_volt_per_octave+0x1e>
		16384
		
	};
	
	
	memcpy((void*)vco1_pitch_table, (const void*)vpo_pitch_table, (size_t)sizeof(vpo_pitch_table));
    2dea:	a5 e5       	ldi	r26, 0x55	; 85
    2dec:	b3 e0       	ldi	r27, 0x03	; 3
    2dee:	fe 01       	movw	r30, r28
    2df0:	31 96       	adiw	r30, 0x01	; 1
    2df2:	82 e2       	ldi	r24, 0x22	; 34
    2df4:	01 90       	ld	r0, Z+
    2df6:	0d 92       	st	X+, r0
    2df8:	81 50       	subi	r24, 0x01	; 1
    2dfa:	e1 f7       	brne	.-8      	; 0x2df4 <set_one_volt_per_octave+0x30>
	memcpy((void*)vco2_pitch_table, (const void*)vpo_pitch_table, (size_t)sizeof(vpo_pitch_table));
    2dfc:	a3 e3       	ldi	r26, 0x33	; 51
    2dfe:	b3 e0       	ldi	r27, 0x03	; 3
    2e00:	fe 01       	movw	r30, r28
    2e02:	31 96       	adiw	r30, 0x01	; 1
    2e04:	82 e2       	ldi	r24, 0x22	; 34
    2e06:	01 90       	ld	r0, Z+
    2e08:	0d 92       	st	X+, r0
    2e0a:	81 50       	subi	r24, 0x01	; 1
    2e0c:	e1 f7       	brne	.-8      	; 0x2e06 <set_one_volt_per_octave+0x42>
	
	
}
    2e0e:	a2 96       	adiw	r28, 0x22	; 34
    2e10:	0f b6       	in	r0, 0x3f	; 63
    2e12:	f8 94       	cli
    2e14:	de bf       	out	0x3e, r29	; 62
    2e16:	0f be       	out	0x3f, r0	; 63
    2e18:	cd bf       	out	0x3d, r28	; 61
    2e1a:	df 91       	pop	r29
    2e1c:	cf 91       	pop	r28
    2e1e:	08 95       	ret

00002e20 <tune>:
void tune(void) {
	

			
			//turn off Timer1 output compare match now, it is used by the system clock
			TIMSK1 &= (1<<OCIE1A);
    2e20:	ef e6       	ldi	r30, 0x6F	; 111
    2e22:	f0 e0       	ldi	r31, 0x00	; 0
    2e24:	80 81       	ld	r24, Z
    2e26:	82 70       	andi	r24, 0x02	; 2
    2e28:	80 83       	st	Z, r24
			//get rid of CTC here for Timer1 too
			TCCR1B &= ~(1<<WGM12); //turn off CTC
    2e2a:	e1 e8       	ldi	r30, 0x81	; 129
    2e2c:	f0 e0       	ldi	r31, 0x00	; 0
    2e2e:	80 81       	ld	r24, Z
    2e30:	87 7f       	andi	r24, 0xF7	; 247
    2e32:	80 83       	st	Z, r24
			
			vco1_init_cv = set_vco_init_cv(VCO1, 24079);
    2e34:	8f e0       	ldi	r24, 0x0F	; 15
    2e36:	6f e0       	ldi	r22, 0x0F	; 15
    2e38:	7e e5       	ldi	r23, 0x5E	; 94
    2e3a:	0e 94 9e 11 	call	0x233c	; 0x233c <set_vco_init_cv>
    2e3e:	90 93 7a 03 	sts	0x037A, r25
    2e42:	80 93 79 03 	sts	0x0379, r24
			vco2_init_cv = set_vco_init_cv(VCO2, 24079);
    2e46:	80 ef       	ldi	r24, 0xF0	; 240
    2e48:	6f e0       	ldi	r22, 0x0F	; 15
    2e4a:	7e e5       	ldi	r23, 0x5E	; 94
    2e4c:	0e 94 9e 11 	call	0x233c	; 0x233c <set_vco_init_cv>
    2e50:	90 93 78 03 	sts	0x0378, r25
    2e54:	80 93 77 03 	sts	0x0377, r24
			//vco1_init_cv = vco2_init_cv;
			tune_8ths(VCO1);
    2e58:	8f e0       	ldi	r24, 0x0F	; 15
    2e5a:	0e 94 00 13 	call	0x2600	; 0x2600 <tune_8ths>
			tune_8ths(VCO2);
    2e5e:	80 ef       	ldi	r24, 0xF0	; 240
    2e60:	0e 94 00 13 	call	0x2600	; 0x2600 <tune_8ths>
			tune_filter();
    2e64:	0e 94 a2 14 	call	0x2944	; 0x2944 <tune_filter>
			save_tuning_tables();
    2e68:	0e 94 70 16 	call	0x2ce0	; 0x2ce0 <save_tuning_tables>
    2e6c:	8f e4       	ldi	r24, 0x4F	; 79
    2e6e:	93 ec       	ldi	r25, 0xC3	; 195
    2e70:	01 97       	sbiw	r24, 0x01	; 1
    2e72:	f1 f7       	brne	.-4      	; 0x2e70 <tune+0x50>
    2e74:	00 c0       	rjmp	.+0      	; 0x2e76 <tune+0x56>
    2e76:	00 00       	nop
			_delay_ms(200);	//give some time for release to decay to avoid pops
			
			//need to restore Timer1 settings. This currently happens after the function is called, but should really be included here
	
    2e78:	08 95       	ret

00002e7a <read_switch_port>:
uint8_t read_switch_port(void) {
	
	static uint8_t previous_port_state = 0;
	static uint16_t prog_hold_counter = 0;
	
	uint8_t current_port_state = SWITCH_PORT; //read switch state byte
    2e7a:	8f b1       	in	r24, 0x0f	; 15
	switch_press |= current_port_state & 0b00001100; //mask for four PROG buttons 
    2e7c:	98 2f       	mov	r25, r24
    2e7e:	9c 70       	andi	r25, 0x0C	; 12
    2e80:	20 91 c5 02 	lds	r18, 0x02C5
    2e84:	92 2b       	or	r25, r18
    2e86:	90 93 c5 02 	sts	0x02C5, r25
	
	if ((current_port_state >> PROG_DOWN_SW) & 1) { //press and hold handler for PROG DOWN switch. Should have a general framework for handling switch presses and holds
    2e8a:	98 2f       	mov	r25, r24
    2e8c:	92 95       	swap	r25
    2e8e:	96 95       	lsr	r25
    2e90:	97 70       	andi	r25, 0x07	; 7
    2e92:	90 ff       	sbrs	r25, 0
    2e94:	16 c0       	rjmp	.+44     	; 0x2ec2 <read_switch_port+0x48>
		
		if (++prog_hold_counter == 600) { //problem here is that the hold time is dependent on main loop execution speed. Could maybe somehow link this to Timer1, which is running at constant /1024
    2e96:	20 91 85 03 	lds	r18, 0x0385
    2e9a:	30 91 86 03 	lds	r19, 0x0386
    2e9e:	2f 5f       	subi	r18, 0xFF	; 255
    2ea0:	3f 4f       	sbci	r19, 0xFF	; 255
    2ea2:	30 93 86 03 	sts	0x0386, r19
    2ea6:	20 93 85 03 	sts	0x0385, r18
    2eaa:	92 e0       	ldi	r25, 0x02	; 2
    2eac:	28 35       	cpi	r18, 0x58	; 88
    2eae:	39 07       	cpc	r19, r25
    2eb0:	61 f4       	brne	.+24     	; 0x2eca <read_switch_port+0x50>
			
			prog_hold_counter = 0; //shouldn't need this as prog_hold_counter will overflow to 0 on next press
    2eb2:	10 92 86 03 	sts	0x0386, r1
    2eb6:	10 92 85 03 	sts	0x0385, r1
			current_patch.mode = CAL;
    2eba:	95 e0       	ldi	r25, 0x05	; 5
    2ebc:	90 93 0b 03 	sts	0x030B, r25
    2ec0:	04 c0       	rjmp	.+8      	; 0x2eca <read_switch_port+0x50>
			
		}
		
	} else { prog_hold_counter = 0;} //reset counter to 0
    2ec2:	10 92 86 03 	sts	0x0386, r1
    2ec6:	10 92 85 03 	sts	0x0385, r1
		
	//this toggle code works, but I haven't figured out how it works
	//source: http://forum.allaboutcircuits.com/threads/help-with-programming-uc-toggle-led-using-one-switch.51602/	
	current_port_state ^= previous_port_state;
    2eca:	90 91 87 03 	lds	r25, 0x0387
    2ece:	89 27       	eor	r24, r25
	previous_port_state ^= current_port_state;
    2ed0:	98 27       	eor	r25, r24
    2ed2:	90 93 87 03 	sts	0x0387, r25
	current_port_state &= previous_port_state;
	
	return current_port_state;
	
}
    2ed6:	89 23       	and	r24, r25
    2ed8:	08 95       	ret

00002eda <update_analog_switch_latch>:

void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    2eda:	ed ed       	ldi	r30, 0xDD	; 221
    2edc:	f0 e0       	ldi	r31, 0x00	; 0
    2ede:	90 81       	ld	r25, Z
    2ee0:	9f 7b       	andi	r25, 0xBF	; 191
    2ee2:	90 83       	st	Z, r25
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
	((switch_state_byte >> VCO_SYNC_SW) & 1) << VCO_SYNC_LATCH_BIT |
	((switch_state_byte >> VCO1_SAW_SW) & 1) << VCO1_SAW_LATCH_BIT |
	((switch_state_byte >> VCO1_TRI_SW) & 1) << VCO1_TRI_LATCH_BIT |
	((switch_state_byte >> VCO1_PULSE_SW) & 1) << VCO1_PULSE_LATCH_BIT |
    2ee4:	28 2f       	mov	r18, r24
    2ee6:	30 e0       	ldi	r19, 0x00	; 0
    2ee8:	21 70       	andi	r18, 0x01	; 1
    2eea:	30 70       	andi	r19, 0x00	; 0
    2eec:	22 0f       	add	r18, r18
    2eee:	33 1f       	adc	r19, r19
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
	((switch_state_byte >> VCO2_TRI_SW) & 1) << VCO2_TRI_LATCH_BIT |
    2ef0:	68 2f       	mov	r22, r24
    2ef2:	62 95       	swap	r22
    2ef4:	66 95       	lsr	r22
    2ef6:	67 70       	andi	r22, 0x07	; 7
    2ef8:	67 95       	ror	r22
    2efa:	66 27       	eor	r22, r22
    2efc:	67 95       	ror	r22
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2efe:	26 2b       	or	r18, r22
    2f00:	98 2f       	mov	r25, r24
    2f02:	96 95       	lsr	r25
    2f04:	96 95       	lsr	r25
    2f06:	91 70       	andi	r25, 0x01	; 1
    2f08:	29 2b       	or	r18, r25
	((switch_state_byte >> VCO_SYNC_SW) & 1) << VCO_SYNC_LATCH_BIT |
    2f0a:	68 2f       	mov	r22, r24
    2f0c:	66 1f       	adc	r22, r22
    2f0e:	66 27       	eor	r22, r22
    2f10:	66 1f       	adc	r22, r22
    2f12:	66 0f       	add	r22, r22
    2f14:	66 0f       	add	r22, r22
    2f16:	66 0f       	add	r22, r22
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2f18:	26 2b       	or	r18, r22
	((switch_state_byte >> VCO_SYNC_SW) & 1) << VCO_SYNC_LATCH_BIT |
	((switch_state_byte >> VCO1_SAW_SW) & 1) << VCO1_SAW_LATCH_BIT |
	((switch_state_byte >> VCO1_TRI_SW) & 1) << VCO1_TRI_LATCH_BIT |
    2f1a:	a8 2f       	mov	r26, r24
    2f1c:	a6 95       	lsr	r26
    2f1e:	b0 e0       	ldi	r27, 0x00	; 0
    2f20:	a1 70       	andi	r26, 0x01	; 1
    2f22:	b0 70       	andi	r27, 0x00	; 0
    2f24:	bd 01       	movw	r22, r26
    2f26:	66 0f       	add	r22, r22
    2f28:	77 1f       	adc	r23, r23
    2f2a:	66 0f       	add	r22, r22
    2f2c:	77 1f       	adc	r23, r23
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2f2e:	26 2b       	or	r18, r22
	((switch_state_byte >> VCO_SYNC_SW) & 1) << VCO_SYNC_LATCH_BIT |
	((switch_state_byte >> VCO1_SAW_SW) & 1) << VCO1_SAW_LATCH_BIT |
	((switch_state_byte >> VCO1_TRI_SW) & 1) << VCO1_TRI_LATCH_BIT |
	((switch_state_byte >> VCO1_PULSE_SW) & 1) << VCO1_PULSE_LATCH_BIT |
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
    2f30:	68 2f       	mov	r22, r24
    2f32:	62 95       	swap	r22
    2f34:	6f 70       	andi	r22, 0x0F	; 15
    2f36:	70 e0       	ldi	r23, 0x00	; 0
    2f38:	61 70       	andi	r22, 0x01	; 1
    2f3a:	70 70       	andi	r23, 0x00	; 0
    2f3c:	ab 01       	movw	r20, r22
    2f3e:	00 24       	eor	r0, r0
    2f40:	56 95       	lsr	r21
    2f42:	47 95       	ror	r20
    2f44:	07 94       	ror	r0
    2f46:	56 95       	lsr	r21
    2f48:	47 95       	ror	r20
    2f4a:	07 94       	ror	r0
    2f4c:	54 2f       	mov	r21, r20
    2f4e:	40 2d       	mov	r20, r0
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2f50:	62 2f       	mov	r22, r18
    2f52:	64 2b       	or	r22, r20
	((switch_state_byte >> VCO1_SAW_SW) & 1) << VCO1_SAW_LATCH_BIT |
	((switch_state_byte >> VCO1_TRI_SW) & 1) << VCO1_TRI_LATCH_BIT |
	((switch_state_byte >> VCO1_PULSE_SW) & 1) << VCO1_PULSE_LATCH_BIT |
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
	((switch_state_byte >> VCO2_TRI_SW) & 1) << VCO2_TRI_LATCH_BIT |
	((switch_state_byte >> VCO2_PULSE_SW) & 1) << VCO2_PULSE_LATCH_BIT |
    2f54:	48 2f       	mov	r20, r24
    2f56:	42 95       	swap	r20
    2f58:	46 95       	lsr	r20
    2f5a:	46 95       	lsr	r20
    2f5c:	43 70       	andi	r20, 0x03	; 3
    2f5e:	50 e0       	ldi	r21, 0x00	; 0
    2f60:	41 70       	andi	r20, 0x01	; 1
    2f62:	50 70       	andi	r21, 0x00	; 0
    2f64:	9a 01       	movw	r18, r20
    2f66:	22 0f       	add	r18, r18
    2f68:	33 1f       	adc	r19, r19
    2f6a:	22 95       	swap	r18
    2f6c:	32 95       	swap	r19
    2f6e:	30 7f       	andi	r19, 0xF0	; 240
    2f70:	32 27       	eor	r19, r18
    2f72:	20 7f       	andi	r18, 0xF0	; 240
    2f74:	32 27       	eor	r19, r18
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2f76:	46 2f       	mov	r20, r22
    2f78:	42 2b       	or	r20, r18
	((switch_state_byte >> VCO1_PULSE_SW) & 1) << VCO1_PULSE_LATCH_BIT |
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
	((switch_state_byte >> VCO2_TRI_SW) & 1) << VCO2_TRI_LATCH_BIT |
	((switch_state_byte >> VCO2_PULSE_SW) & 1) << VCO2_PULSE_LATCH_BIT |
	//BMOD_SW_ON << BMOD_LATCH_BIT;
	((switch_state_byte >> 3) & 1) << BMOD_LATCH_BIT;
    2f7a:	86 95       	lsr	r24
    2f7c:	86 95       	lsr	r24
    2f7e:	86 95       	lsr	r24
    2f80:	28 2f       	mov	r18, r24
    2f82:	30 e0       	ldi	r19, 0x00	; 0
    2f84:	21 70       	andi	r18, 0x01	; 1
    2f86:	30 70       	andi	r19, 0x00	; 0
    2f88:	c9 01       	movw	r24, r18
    2f8a:	82 95       	swap	r24
    2f8c:	92 95       	swap	r25
    2f8e:	90 7f       	andi	r25, 0xF0	; 240
    2f90:	98 27       	eor	r25, r24
    2f92:	80 7f       	andi	r24, 0xF0	; 240
    2f94:	98 27       	eor	r25, r24
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2f96:	84 2b       	or	r24, r20
    2f98:	82 b9       	out	0x02, r24	; 2
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
	((switch_state_byte >> VCO2_TRI_SW) & 1) << VCO2_TRI_LATCH_BIT |
	((switch_state_byte >> VCO2_PULSE_SW) & 1) << VCO2_PULSE_LATCH_BIT |
	//BMOD_SW_ON << BMOD_LATCH_BIT;
	((switch_state_byte >> 3) & 1) << BMOD_LATCH_BIT;
	VCO_SW_LATCH_PORT |= (1<<VCO_SW_LATCH);
    2f9a:	80 81       	ld	r24, Z
    2f9c:	80 64       	ori	r24, 0x40	; 64
    2f9e:	80 83       	st	Z, r24
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    2fa0:	80 81       	ld	r24, Z
    2fa2:	8f 7b       	andi	r24, 0xBF	; 191
    2fa4:	80 83       	st	Z, r24
	DATA_BUS = 0;
    2fa6:	12 b8       	out	0x02, r1	; 2
	
	
    2fa8:	08 95       	ret

00002faa <bytequeue_init>:
//along with avr-bytequeue.  If not, see <http://www.gnu.org/licenses/>.

#include "bytequeue.h"
#include "interrupt_setting.h"

void bytequeue_init(byteQueue_t * queue, uint8_t * dataArray, byteQueueIndex_t arrayLen){
    2faa:	fc 01       	movw	r30, r24
   queue->length = arrayLen;
    2fac:	42 83       	std	Z+2, r20	; 0x02
   queue->data = dataArray;
    2fae:	74 83       	std	Z+4, r23	; 0x04
    2fb0:	63 83       	std	Z+3, r22	; 0x03
   queue->start = queue->end = 0;
    2fb2:	11 82       	std	Z+1, r1	; 0x01
    2fb4:	10 82       	st	Z, r1
}
    2fb6:	08 95       	ret

00002fb8 <bytequeue_enqueue>:

bool bytequeue_enqueue(byteQueue_t * queue, uint8_t item){
    2fb8:	1f 93       	push	r17
    2fba:	cf 93       	push	r28
    2fbc:	df 93       	push	r29
    2fbe:	ec 01       	movw	r28, r24
    2fc0:	16 2f       	mov	r17, r22
   interrupt_setting_t setting = store_and_clear_interrupt();
    2fc2:	0e 94 4b 18 	call	0x3096	; 0x3096 <store_and_clear_interrupt>
    2fc6:	28 2f       	mov	r18, r24
   //full
   if(((queue->end + 1) % queue->length) == queue->start){
    2fc8:	39 81       	ldd	r19, Y+1	; 0x01
    2fca:	83 2f       	mov	r24, r19
    2fcc:	90 e0       	ldi	r25, 0x00	; 0
    2fce:	01 96       	adiw	r24, 0x01	; 1
    2fd0:	6a 81       	ldd	r22, Y+2	; 0x02
    2fd2:	70 e0       	ldi	r23, 0x00	; 0
    2fd4:	0e 94 c3 1e 	call	0x3d86	; 0x3d86 <__divmodhi4>
    2fd8:	48 81       	ld	r20, Y
    2fda:	50 e0       	ldi	r21, 0x00	; 0
    2fdc:	84 17       	cp	r24, r20
    2fde:	95 07       	cpc	r25, r21
    2fe0:	29 f4       	brne	.+10     	; 0x2fec <bytequeue_enqueue+0x34>
      restore_interrupt_setting(setting);
    2fe2:	82 2f       	mov	r24, r18
    2fe4:	0e 94 4e 18 	call	0x309c	; 0x309c <restore_interrupt_setting>
      return false;
    2fe8:	80 e0       	ldi	r24, 0x00	; 0
    2fea:	11 c0       	rjmp	.+34     	; 0x300e <bytequeue_enqueue+0x56>
   } else {
      queue->data[queue->end] = item;
    2fec:	eb 81       	ldd	r30, Y+3	; 0x03
    2fee:	fc 81       	ldd	r31, Y+4	; 0x04
    2ff0:	e3 0f       	add	r30, r19
    2ff2:	f1 1d       	adc	r31, r1
    2ff4:	10 83       	st	Z, r17
      queue->end = (queue->end + 1) % queue->length;
    2ff6:	89 81       	ldd	r24, Y+1	; 0x01
    2ff8:	90 e0       	ldi	r25, 0x00	; 0
    2ffa:	01 96       	adiw	r24, 0x01	; 1
    2ffc:	6a 81       	ldd	r22, Y+2	; 0x02
    2ffe:	70 e0       	ldi	r23, 0x00	; 0
    3000:	0e 94 c3 1e 	call	0x3d86	; 0x3d86 <__divmodhi4>
    3004:	89 83       	std	Y+1, r24	; 0x01
      restore_interrupt_setting(setting);
    3006:	82 2f       	mov	r24, r18
    3008:	0e 94 4e 18 	call	0x309c	; 0x309c <restore_interrupt_setting>
      return true;
    300c:	81 e0       	ldi	r24, 0x01	; 1
   }
}
    300e:	df 91       	pop	r29
    3010:	cf 91       	pop	r28
    3012:	1f 91       	pop	r17
    3014:	08 95       	ret

00003016 <bytequeue_length>:

byteQueueIndex_t bytequeue_length(byteQueue_t * queue){
    3016:	cf 93       	push	r28
    3018:	df 93       	push	r29
    301a:	ec 01       	movw	r28, r24
   byteQueueIndex_t len;
   interrupt_setting_t setting = store_and_clear_interrupt();
    301c:	0e 94 4b 18 	call	0x3096	; 0x3096 <store_and_clear_interrupt>
   if(queue->end >= queue->start)
    3020:	29 81       	ldd	r18, Y+1	; 0x01
    3022:	98 81       	ld	r25, Y
    3024:	29 17       	cp	r18, r25
    3026:	18 f0       	brcs	.+6      	; 0x302e <bytequeue_length+0x18>
      len = queue->end - queue->start;
    3028:	c2 2f       	mov	r28, r18
    302a:	c9 1b       	sub	r28, r25
    302c:	03 c0       	rjmp	.+6      	; 0x3034 <bytequeue_length+0x1e>
   else
      len = (queue->length - queue->start) + queue->end;
    302e:	ca 81       	ldd	r28, Y+2	; 0x02
    3030:	c2 0f       	add	r28, r18
    3032:	c9 1b       	sub	r28, r25
   restore_interrupt_setting(setting);
    3034:	0e 94 4e 18 	call	0x309c	; 0x309c <restore_interrupt_setting>
   return len;
}
    3038:	8c 2f       	mov	r24, r28
    303a:	df 91       	pop	r29
    303c:	cf 91       	pop	r28
    303e:	08 95       	ret

00003040 <bytequeue_get>:

//we don't need to avoid interrupts if there is only one reader
uint8_t bytequeue_get(byteQueue_t * queue, byteQueueIndex_t index){
    3040:	fc 01       	movw	r30, r24
   return queue->data[(queue->start + index) % queue->length];
    3042:	20 81       	ld	r18, Z
    3044:	86 2f       	mov	r24, r22
    3046:	90 e0       	ldi	r25, 0x00	; 0
    3048:	82 0f       	add	r24, r18
    304a:	91 1d       	adc	r25, r1
    304c:	62 81       	ldd	r22, Z+2	; 0x02
    304e:	70 e0       	ldi	r23, 0x00	; 0
    3050:	0e 94 c3 1e 	call	0x3d86	; 0x3d86 <__divmodhi4>
    3054:	03 80       	ldd	r0, Z+3	; 0x03
    3056:	f4 81       	ldd	r31, Z+4	; 0x04
    3058:	e0 2d       	mov	r30, r0
    305a:	e8 0f       	add	r30, r24
    305c:	f9 1f       	adc	r31, r25
}
    305e:	80 81       	ld	r24, Z
    3060:	08 95       	ret

00003062 <bytequeue_remove>:

//we just update the start index to remove elements
void bytequeue_remove(byteQueue_t * queue, byteQueueIndex_t numToRemove){
    3062:	1f 93       	push	r17
    3064:	cf 93       	push	r28
    3066:	df 93       	push	r29
    3068:	ec 01       	movw	r28, r24
    306a:	16 2f       	mov	r17, r22
   interrupt_setting_t setting = store_and_clear_interrupt();
    306c:	0e 94 4b 18 	call	0x3096	; 0x3096 <store_and_clear_interrupt>
    3070:	48 2f       	mov	r20, r24
   queue->start = (queue->start + numToRemove) % queue->length;
    3072:	88 81       	ld	r24, Y
    3074:	21 2f       	mov	r18, r17
    3076:	30 e0       	ldi	r19, 0x00	; 0
    3078:	28 0f       	add	r18, r24
    307a:	31 1d       	adc	r19, r1
    307c:	6a 81       	ldd	r22, Y+2	; 0x02
    307e:	c9 01       	movw	r24, r18
    3080:	70 e0       	ldi	r23, 0x00	; 0
    3082:	0e 94 c3 1e 	call	0x3d86	; 0x3d86 <__divmodhi4>
    3086:	88 83       	st	Y, r24
   restore_interrupt_setting(setting);
    3088:	84 2f       	mov	r24, r20
    308a:	0e 94 4e 18 	call	0x309c	; 0x309c <restore_interrupt_setting>
}
    308e:	df 91       	pop	r29
    3090:	cf 91       	pop	r28
    3092:	1f 91       	pop	r17
    3094:	08 95       	ret

00003096 <store_and_clear_interrupt>:

#include "interrupt_setting.h"
#include <avr/interrupt.h>

interrupt_setting_t store_and_clear_interrupt(void) {
   uint8_t sreg = SREG;
    3096:	8f b7       	in	r24, 0x3f	; 63
   cli();
    3098:	f8 94       	cli
   return sreg;
}
    309a:	08 95       	ret

0000309c <restore_interrupt_setting>:

void restore_interrupt_setting(interrupt_setting_t setting) {
   SREG = setting;
    309c:	8f bf       	out	0x3f, r24	; 63
}
    309e:	08 95       	ret

000030a0 <midi_is_statusbyte>:
#define NULL 0
#endif

bool midi_is_statusbyte(uint8_t theByte){
   return (bool)(theByte & MIDI_STATUSMASK);
}
    30a0:	88 1f       	adc	r24, r24
    30a2:	88 27       	eor	r24, r24
    30a4:	88 1f       	adc	r24, r24
    30a6:	08 95       	ret

000030a8 <midi_is_realtime>:

bool midi_is_realtime(uint8_t theByte){
   return (theByte >= MIDI_CLOCK);
    30a8:	91 e0       	ldi	r25, 0x01	; 1
    30aa:	88 3f       	cpi	r24, 0xF8	; 248
    30ac:	08 f4       	brcc	.+2      	; 0x30b0 <midi_is_realtime+0x8>
    30ae:	90 e0       	ldi	r25, 0x00	; 0
}
    30b0:	89 2f       	mov	r24, r25
    30b2:	08 95       	ret

000030b4 <midi_packet_length>:

midi_packet_length_t midi_packet_length(uint8_t status){
   switch(status & 0xF0){
    30b4:	28 2f       	mov	r18, r24
    30b6:	30 e0       	ldi	r19, 0x00	; 0
    30b8:	20 7f       	andi	r18, 0xF0	; 240
    30ba:	30 70       	andi	r19, 0x00	; 0
    30bc:	20 3c       	cpi	r18, 0xC0	; 192
    30be:	31 05       	cpc	r19, r1
    30c0:	e9 f1       	breq	.+122    	; 0x313c <midi_packet_length+0x88>
    30c2:	21 3c       	cpi	r18, 0xC1	; 193
    30c4:	31 05       	cpc	r19, r1
    30c6:	8c f4       	brge	.+34     	; 0x30ea <midi_packet_length+0x36>
    30c8:	20 39       	cpi	r18, 0x90	; 144
    30ca:	31 05       	cpc	r19, r1
    30cc:	e1 f0       	breq	.+56     	; 0x3106 <midi_packet_length+0x52>
    30ce:	21 39       	cpi	r18, 0x91	; 145
    30d0:	31 05       	cpc	r19, r1
    30d2:	24 f4       	brge	.+8      	; 0x30dc <midi_packet_length+0x28>
    30d4:	20 38       	cpi	r18, 0x80	; 128
    30d6:	31 05       	cpc	r19, r1
    30d8:	79 f5       	brne	.+94     	; 0x3138 <midi_packet_length+0x84>
    30da:	15 c0       	rjmp	.+42     	; 0x3106 <midi_packet_length+0x52>
    30dc:	20 3a       	cpi	r18, 0xA0	; 160
    30de:	31 05       	cpc	r19, r1
    30e0:	91 f0       	breq	.+36     	; 0x3106 <midi_packet_length+0x52>
    30e2:	20 3b       	cpi	r18, 0xB0	; 176
    30e4:	31 05       	cpc	r19, r1
    30e6:	41 f5       	brne	.+80     	; 0x3138 <midi_packet_length+0x84>
    30e8:	0e c0       	rjmp	.+28     	; 0x3106 <midi_packet_length+0x52>
    30ea:	20 3e       	cpi	r18, 0xE0	; 224
    30ec:	31 05       	cpc	r19, r1
    30ee:	59 f0       	breq	.+22     	; 0x3106 <midi_packet_length+0x52>
    30f0:	21 3e       	cpi	r18, 0xE1	; 225
    30f2:	31 05       	cpc	r19, r1
    30f4:	24 f4       	brge	.+8      	; 0x30fe <midi_packet_length+0x4a>
    30f6:	20 3d       	cpi	r18, 0xD0	; 208
    30f8:	31 05       	cpc	r19, r1
    30fa:	f1 f4       	brne	.+60     	; 0x3138 <midi_packet_length+0x84>
    30fc:	1f c0       	rjmp	.+62     	; 0x313c <midi_packet_length+0x88>
    30fe:	20 3f       	cpi	r18, 0xF0	; 240
    3100:	31 05       	cpc	r19, r1
    3102:	d1 f4       	brne	.+52     	; 0x3138 <midi_packet_length+0x84>
    3104:	02 c0       	rjmp	.+4      	; 0x310a <midi_packet_length+0x56>
      case MIDI_CC:
      case MIDI_NOTEON:
      case MIDI_NOTEOFF:
      case MIDI_AFTERTOUCH:
      case MIDI_PITCHBEND:
         return THREE3;
    3106:	83 e0       	ldi	r24, 0x03	; 3
    3108:	08 95       	ret
      case MIDI_PROGCHANGE:
      case MIDI_CHANPRESSURE:
      case MIDI_SONGSELECT:
         return TWO2;
      case 0xF0:
         switch(status) {
    310a:	86 3f       	cpi	r24, 0xF6	; 246
    310c:	79 f0       	breq	.+30     	; 0x312c <midi_packet_length+0x78>
    310e:	87 3f       	cpi	r24, 0xF7	; 247
    3110:	38 f4       	brcc	.+14     	; 0x3120 <midi_packet_length+0x6c>
    3112:	82 3f       	cpi	r24, 0xF2	; 242
    3114:	a9 f0       	breq	.+42     	; 0x3140 <midi_packet_length+0x8c>
    3116:	83 3f       	cpi	r24, 0xF3	; 243
    3118:	59 f0       	breq	.+22     	; 0x3130 <midi_packet_length+0x7c>
    311a:	81 3f       	cpi	r24, 0xF1	; 241
    311c:	59 f4       	brne	.+22     	; 0x3134 <midi_packet_length+0x80>
    311e:	08 c0       	rjmp	.+16     	; 0x3130 <midi_packet_length+0x7c>
    3120:	88 3f       	cpi	r24, 0xF8	; 248
    3122:	40 f0       	brcs	.+16     	; 0x3134 <midi_packet_length+0x80>
    3124:	8d 3f       	cpi	r24, 0xFD	; 253
    3126:	10 f0       	brcs	.+4      	; 0x312c <midi_packet_length+0x78>
    3128:	8e 3f       	cpi	r24, 0xFE	; 254
    312a:	20 f0       	brcs	.+8      	; 0x3134 <midi_packet_length+0x80>
            case MIDI_CONTINUE:
            case MIDI_STOP:
            case MIDI_ACTIVESENSE:
            case MIDI_RESET:
            case MIDI_TUNEREQUEST:
               return ONE1;
    312c:	81 e0       	ldi	r24, 0x01	; 1
    312e:	08 95       	ret
            case MIDI_SONGPOSITION:
               return THREE3;
            case MIDI_TC_QUARTERFRAME:
            case MIDI_SONGSELECT:
               return TWO2;
    3130:	82 e0       	ldi	r24, 0x02	; 2
    3132:	08 95       	ret
            case SYSEX_END:
            case SYSEX_BEGIN:
            default:
               return UNDEFINED;
    3134:	80 e0       	ldi	r24, 0x00	; 0
    3136:	08 95       	ret
         }
      default:
         return UNDEFINED;
    3138:	80 e0       	ldi	r24, 0x00	; 0
    313a:	08 95       	ret
      case MIDI_PITCHBEND:
         return THREE3;
      case MIDI_PROGCHANGE:
      case MIDI_CHANPRESSURE:
      case MIDI_SONGSELECT:
         return TWO2;
    313c:	82 e0       	ldi	r24, 0x02	; 2
    313e:	08 95       	ret
            case MIDI_ACTIVESENSE:
            case MIDI_RESET:
            case MIDI_TUNEREQUEST:
               return ONE1;
            case MIDI_SONGPOSITION:
               return THREE3;
    3140:	83 e0       	ldi	r24, 0x03	; 3
               return UNDEFINED;
         }
      default:
         return UNDEFINED;
   }
}
    3142:	08 95       	ret

00003144 <midi_send_cc>:

void midi_send_cc(MidiDevice * device, uint8_t chan, uint8_t num, uint8_t val){
    3144:	0f 93       	push	r16
    3146:	34 2f       	mov	r19, r20
    3148:	02 2f       	mov	r16, r18
   //CC Status: 0xB0 to 0xBF where the low nibble is the MIDI channel.
   //CC Data: Controller Num, Controller Val
   device->send_func(device, 3,
    314a:	46 2f       	mov	r20, r22
    314c:	4f 70       	andi	r20, 0x0F	; 15
    314e:	40 6b       	ori	r20, 0xB0	; 176
    3150:	23 2f       	mov	r18, r19
    3152:	2f 77       	andi	r18, 0x7F	; 127
    3154:	0f 77       	andi	r16, 0x7F	; 127
    3156:	dc 01       	movw	r26, r24
    3158:	ed 91       	ld	r30, X+
    315a:	fc 91       	ld	r31, X
    315c:	63 e0       	ldi	r22, 0x03	; 3
    315e:	70 e0       	ldi	r23, 0x00	; 0
    3160:	09 95       	icall
         MIDI_CC | (chan & MIDI_CHANMASK),
         num & 0x7F,
         val & 0x7F);
}
    3162:	0f 91       	pop	r16
    3164:	08 95       	ret

00003166 <midi_send_noteon>:

void midi_send_noteon(MidiDevice * device, uint8_t chan, uint8_t num, uint8_t vel){
    3166:	0f 93       	push	r16
    3168:	34 2f       	mov	r19, r20
    316a:	02 2f       	mov	r16, r18
   //Note Data: Note Num, Note Velocity
   device->send_func(device, 3,
    316c:	46 2f       	mov	r20, r22
    316e:	4f 70       	andi	r20, 0x0F	; 15
    3170:	40 69       	ori	r20, 0x90	; 144
    3172:	23 2f       	mov	r18, r19
    3174:	2f 77       	andi	r18, 0x7F	; 127
    3176:	0f 77       	andi	r16, 0x7F	; 127
    3178:	dc 01       	movw	r26, r24
    317a:	ed 91       	ld	r30, X+
    317c:	fc 91       	ld	r31, X
    317e:	63 e0       	ldi	r22, 0x03	; 3
    3180:	70 e0       	ldi	r23, 0x00	; 0
    3182:	09 95       	icall
         MIDI_NOTEON | (chan & MIDI_CHANMASK),
         num & 0x7F,
         vel & 0x7F);
}
    3184:	0f 91       	pop	r16
    3186:	08 95       	ret

00003188 <midi_send_noteoff>:

void midi_send_noteoff(MidiDevice * device, uint8_t chan, uint8_t num, uint8_t vel){
    3188:	0f 93       	push	r16
    318a:	34 2f       	mov	r19, r20
    318c:	02 2f       	mov	r16, r18
   //Note Data: Note Num, Note Velocity
   device->send_func(device, 3,
    318e:	46 2f       	mov	r20, r22
    3190:	4f 70       	andi	r20, 0x0F	; 15
    3192:	40 68       	ori	r20, 0x80	; 128
    3194:	23 2f       	mov	r18, r19
    3196:	2f 77       	andi	r18, 0x7F	; 127
    3198:	0f 77       	andi	r16, 0x7F	; 127
    319a:	dc 01       	movw	r26, r24
    319c:	ed 91       	ld	r30, X+
    319e:	fc 91       	ld	r31, X
    31a0:	63 e0       	ldi	r22, 0x03	; 3
    31a2:	70 e0       	ldi	r23, 0x00	; 0
    31a4:	09 95       	icall
         MIDI_NOTEOFF | (chan & MIDI_CHANMASK),
         num & 0x7F,
         vel & 0x7F);
}
    31a6:	0f 91       	pop	r16
    31a8:	08 95       	ret

000031aa <midi_send_aftertouch>:

void midi_send_aftertouch(MidiDevice * device, uint8_t chan, uint8_t note_num, uint8_t amt){
    31aa:	0f 93       	push	r16
    31ac:	34 2f       	mov	r19, r20
    31ae:	02 2f       	mov	r16, r18
   device->send_func(device, 3,
    31b0:	46 2f       	mov	r20, r22
    31b2:	4f 70       	andi	r20, 0x0F	; 15
    31b4:	40 6a       	ori	r20, 0xA0	; 160
    31b6:	23 2f       	mov	r18, r19
    31b8:	2f 77       	andi	r18, 0x7F	; 127
    31ba:	0f 77       	andi	r16, 0x7F	; 127
    31bc:	dc 01       	movw	r26, r24
    31be:	ed 91       	ld	r30, X+
    31c0:	fc 91       	ld	r31, X
    31c2:	63 e0       	ldi	r22, 0x03	; 3
    31c4:	70 e0       	ldi	r23, 0x00	; 0
    31c6:	09 95       	icall
         MIDI_AFTERTOUCH | (chan & MIDI_CHANMASK),
         note_num & 0x7F,
         amt & 0x7F);
}
    31c8:	0f 91       	pop	r16
    31ca:	08 95       	ret

000031cc <midi_send_pitchbend>:

//XXX does this work right?
//amt in range -0x2000, 0x1fff
//uAmt should be in range..
//0x0000 to 0x3FFF
void midi_send_pitchbend(MidiDevice * device, uint8_t chan, int16_t amt){
    31cc:	0f 93       	push	r16
    31ce:	1f 93       	push	r17
   uint16_t uAmt;
   //check range
   if(amt > 0x1fff){
    31d0:	20 e2       	ldi	r18, 0x20	; 32
    31d2:	40 30       	cpi	r20, 0x00	; 0
    31d4:	52 07       	cpc	r21, r18
    31d6:	44 f4       	brge	.+16     	; 0x31e8 <midi_send_pitchbend+0x1c>
      uAmt = 0x3FFF;
   } else if(amt < -0x2000){
    31d8:	a0 ee       	ldi	r26, 0xE0	; 224
    31da:	40 30       	cpi	r20, 0x00	; 0
    31dc:	5a 07       	cpc	r21, r26
    31de:	3c f0       	brlt	.+14     	; 0x31ee <midi_send_pitchbend+0x22>
      uAmt = 0;
   } else {
      uAmt = amt + 0x2000;
    31e0:	8a 01       	movw	r16, r20
    31e2:	00 50       	subi	r16, 0x00	; 0
    31e4:	10 4e       	sbci	r17, 0xE0	; 224
    31e6:	05 c0       	rjmp	.+10     	; 0x31f2 <midi_send_pitchbend+0x26>
//0x0000 to 0x3FFF
void midi_send_pitchbend(MidiDevice * device, uint8_t chan, int16_t amt){
   uint16_t uAmt;
   //check range
   if(amt > 0x1fff){
      uAmt = 0x3FFF;
    31e8:	0f ef       	ldi	r16, 0xFF	; 255
    31ea:	1f e3       	ldi	r17, 0x3F	; 63
    31ec:	02 c0       	rjmp	.+4      	; 0x31f2 <midi_send_pitchbend+0x26>
   } else if(amt < -0x2000){
      uAmt = 0;
    31ee:	00 e0       	ldi	r16, 0x00	; 0
    31f0:	10 e0       	ldi	r17, 0x00	; 0
   } else {
      uAmt = amt + 0x2000;
   }
   device->send_func(device, 3,
    31f2:	46 2f       	mov	r20, r22
    31f4:	4f 70       	andi	r20, 0x0F	; 15
    31f6:	40 6e       	ori	r20, 0xE0	; 224
    31f8:	20 2f       	mov	r18, r16
    31fa:	2f 77       	andi	r18, 0x7F	; 127
         MIDI_PITCHBEND | (chan & MIDI_CHANMASK),
         uAmt & 0x7F,
         (uAmt >> 7) & 0x7F);
    31fc:	00 0f       	add	r16, r16
    31fe:	01 2f       	mov	r16, r17
    3200:	00 1f       	adc	r16, r16
    3202:	11 0b       	sbc	r17, r17
    3204:	11 95       	neg	r17
   } else if(amt < -0x2000){
      uAmt = 0;
   } else {
      uAmt = amt + 0x2000;
   }
   device->send_func(device, 3,
    3206:	0f 77       	andi	r16, 0x7F	; 127
    3208:	dc 01       	movw	r26, r24
    320a:	ed 91       	ld	r30, X+
    320c:	fc 91       	ld	r31, X
    320e:	63 e0       	ldi	r22, 0x03	; 3
    3210:	70 e0       	ldi	r23, 0x00	; 0
    3212:	09 95       	icall
         MIDI_PITCHBEND | (chan & MIDI_CHANMASK),
         uAmt & 0x7F,
         (uAmt >> 7) & 0x7F);
}
    3214:	1f 91       	pop	r17
    3216:	0f 91       	pop	r16
    3218:	08 95       	ret

0000321a <midi_send_programchange>:

void midi_send_programchange(MidiDevice * device, uint8_t chan, uint8_t num){
    321a:	0f 93       	push	r16
    321c:	24 2f       	mov	r18, r20
   device->send_func(device, 2,
    321e:	46 2f       	mov	r20, r22
    3220:	4f 70       	andi	r20, 0x0F	; 15
    3222:	40 6c       	ori	r20, 0xC0	; 192
    3224:	2f 77       	andi	r18, 0x7F	; 127
    3226:	dc 01       	movw	r26, r24
    3228:	ed 91       	ld	r30, X+
    322a:	fc 91       	ld	r31, X
    322c:	62 e0       	ldi	r22, 0x02	; 2
    322e:	70 e0       	ldi	r23, 0x00	; 0
    3230:	00 e0       	ldi	r16, 0x00	; 0
    3232:	09 95       	icall
         MIDI_PROGCHANGE | (chan & MIDI_CHANMASK),
         num & 0x7F,
         0);
}
    3234:	0f 91       	pop	r16
    3236:	08 95       	ret

00003238 <midi_send_channelpressure>:

void midi_send_channelpressure(MidiDevice * device, uint8_t chan, uint8_t amt){
    3238:	0f 93       	push	r16
    323a:	24 2f       	mov	r18, r20
   device->send_func(device, 2,
    323c:	46 2f       	mov	r20, r22
    323e:	4f 70       	andi	r20, 0x0F	; 15
    3240:	40 6d       	ori	r20, 0xD0	; 208
    3242:	2f 77       	andi	r18, 0x7F	; 127
    3244:	dc 01       	movw	r26, r24
    3246:	ed 91       	ld	r30, X+
    3248:	fc 91       	ld	r31, X
    324a:	62 e0       	ldi	r22, 0x02	; 2
    324c:	70 e0       	ldi	r23, 0x00	; 0
    324e:	00 e0       	ldi	r16, 0x00	; 0
    3250:	09 95       	icall
         MIDI_CHANPRESSURE | (chan & MIDI_CHANMASK),
         amt & 0x7F,
         0);
}
    3252:	0f 91       	pop	r16
    3254:	08 95       	ret

00003256 <midi_send_clock>:

void midi_send_clock(MidiDevice * device){
    3256:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_CLOCK, 0, 0);
    3258:	dc 01       	movw	r26, r24
    325a:	ed 91       	ld	r30, X+
    325c:	fc 91       	ld	r31, X
    325e:	61 e0       	ldi	r22, 0x01	; 1
    3260:	70 e0       	ldi	r23, 0x00	; 0
    3262:	48 ef       	ldi	r20, 0xF8	; 248
    3264:	20 e0       	ldi	r18, 0x00	; 0
    3266:	00 e0       	ldi	r16, 0x00	; 0
    3268:	09 95       	icall
}
    326a:	0f 91       	pop	r16
    326c:	08 95       	ret

0000326e <midi_send_tick>:

void midi_send_tick(MidiDevice * device){
    326e:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_TICK, 0, 0);
    3270:	dc 01       	movw	r26, r24
    3272:	ed 91       	ld	r30, X+
    3274:	fc 91       	ld	r31, X
    3276:	61 e0       	ldi	r22, 0x01	; 1
    3278:	70 e0       	ldi	r23, 0x00	; 0
    327a:	49 ef       	ldi	r20, 0xF9	; 249
    327c:	20 e0       	ldi	r18, 0x00	; 0
    327e:	00 e0       	ldi	r16, 0x00	; 0
    3280:	09 95       	icall
}
    3282:	0f 91       	pop	r16
    3284:	08 95       	ret

00003286 <midi_send_start>:

void midi_send_start(MidiDevice * device){
    3286:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_START, 0, 0);
    3288:	dc 01       	movw	r26, r24
    328a:	ed 91       	ld	r30, X+
    328c:	fc 91       	ld	r31, X
    328e:	61 e0       	ldi	r22, 0x01	; 1
    3290:	70 e0       	ldi	r23, 0x00	; 0
    3292:	4a ef       	ldi	r20, 0xFA	; 250
    3294:	20 e0       	ldi	r18, 0x00	; 0
    3296:	00 e0       	ldi	r16, 0x00	; 0
    3298:	09 95       	icall
}
    329a:	0f 91       	pop	r16
    329c:	08 95       	ret

0000329e <midi_send_continue>:

void midi_send_continue(MidiDevice * device){
    329e:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_CONTINUE, 0, 0);
    32a0:	dc 01       	movw	r26, r24
    32a2:	ed 91       	ld	r30, X+
    32a4:	fc 91       	ld	r31, X
    32a6:	61 e0       	ldi	r22, 0x01	; 1
    32a8:	70 e0       	ldi	r23, 0x00	; 0
    32aa:	4b ef       	ldi	r20, 0xFB	; 251
    32ac:	20 e0       	ldi	r18, 0x00	; 0
    32ae:	00 e0       	ldi	r16, 0x00	; 0
    32b0:	09 95       	icall
}
    32b2:	0f 91       	pop	r16
    32b4:	08 95       	ret

000032b6 <midi_send_stop>:

void midi_send_stop(MidiDevice * device){
    32b6:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_STOP, 0, 0);
    32b8:	dc 01       	movw	r26, r24
    32ba:	ed 91       	ld	r30, X+
    32bc:	fc 91       	ld	r31, X
    32be:	61 e0       	ldi	r22, 0x01	; 1
    32c0:	70 e0       	ldi	r23, 0x00	; 0
    32c2:	4c ef       	ldi	r20, 0xFC	; 252
    32c4:	20 e0       	ldi	r18, 0x00	; 0
    32c6:	00 e0       	ldi	r16, 0x00	; 0
    32c8:	09 95       	icall
}
    32ca:	0f 91       	pop	r16
    32cc:	08 95       	ret

000032ce <midi_send_activesense>:

void midi_send_activesense(MidiDevice * device){
    32ce:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_ACTIVESENSE, 0, 0);
    32d0:	dc 01       	movw	r26, r24
    32d2:	ed 91       	ld	r30, X+
    32d4:	fc 91       	ld	r31, X
    32d6:	61 e0       	ldi	r22, 0x01	; 1
    32d8:	70 e0       	ldi	r23, 0x00	; 0
    32da:	4e ef       	ldi	r20, 0xFE	; 254
    32dc:	20 e0       	ldi	r18, 0x00	; 0
    32de:	00 e0       	ldi	r16, 0x00	; 0
    32e0:	09 95       	icall
}
    32e2:	0f 91       	pop	r16
    32e4:	08 95       	ret

000032e6 <midi_send_reset>:

void midi_send_reset(MidiDevice * device){
    32e6:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_RESET, 0, 0);
    32e8:	dc 01       	movw	r26, r24
    32ea:	ed 91       	ld	r30, X+
    32ec:	fc 91       	ld	r31, X
    32ee:	61 e0       	ldi	r22, 0x01	; 1
    32f0:	70 e0       	ldi	r23, 0x00	; 0
    32f2:	4f ef       	ldi	r20, 0xFF	; 255
    32f4:	20 e0       	ldi	r18, 0x00	; 0
    32f6:	00 e0       	ldi	r16, 0x00	; 0
    32f8:	09 95       	icall
}
    32fa:	0f 91       	pop	r16
    32fc:	08 95       	ret

000032fe <midi_send_tcquarterframe>:

void midi_send_tcquarterframe(MidiDevice * device, uint8_t time){
    32fe:	0f 93       	push	r16
   device->send_func(device, 2,
    3300:	26 2f       	mov	r18, r22
    3302:	2f 77       	andi	r18, 0x7F	; 127
    3304:	dc 01       	movw	r26, r24
    3306:	ed 91       	ld	r30, X+
    3308:	fc 91       	ld	r31, X
    330a:	62 e0       	ldi	r22, 0x02	; 2
    330c:	70 e0       	ldi	r23, 0x00	; 0
    330e:	41 ef       	ldi	r20, 0xF1	; 241
    3310:	00 e0       	ldi	r16, 0x00	; 0
    3312:	09 95       	icall
         MIDI_TC_QUARTERFRAME,
         time & 0x7F,
         0);
}
    3314:	0f 91       	pop	r16
    3316:	08 95       	ret

00003318 <midi_send_songposition>:

//XXX is this right?
void midi_send_songposition(MidiDevice * device, uint16_t pos){
    3318:	0f 93       	push	r16
    331a:	1f 93       	push	r17
   device->send_func(device, 3,
    331c:	26 2f       	mov	r18, r22
    331e:	2f 77       	andi	r18, 0x7F	; 127
         MIDI_SONGPOSITION,
         pos & 0x7F,
         (pos >> 7) & 0x7F);
    3320:	8b 01       	movw	r16, r22
    3322:	00 0f       	add	r16, r16
    3324:	01 2f       	mov	r16, r17
    3326:	00 1f       	adc	r16, r16
    3328:	11 0b       	sbc	r17, r17
    332a:	11 95       	neg	r17
         0);
}

//XXX is this right?
void midi_send_songposition(MidiDevice * device, uint16_t pos){
   device->send_func(device, 3,
    332c:	0f 77       	andi	r16, 0x7F	; 127
    332e:	dc 01       	movw	r26, r24
    3330:	ed 91       	ld	r30, X+
    3332:	fc 91       	ld	r31, X
    3334:	63 e0       	ldi	r22, 0x03	; 3
    3336:	70 e0       	ldi	r23, 0x00	; 0
    3338:	42 ef       	ldi	r20, 0xF2	; 242
    333a:	09 95       	icall
         MIDI_SONGPOSITION,
         pos & 0x7F,
         (pos >> 7) & 0x7F);
}
    333c:	1f 91       	pop	r17
    333e:	0f 91       	pop	r16
    3340:	08 95       	ret

00003342 <midi_send_songselect>:

void midi_send_songselect(MidiDevice * device, uint8_t song){
    3342:	0f 93       	push	r16
   device->send_func(device, 2,
    3344:	26 2f       	mov	r18, r22
    3346:	2f 77       	andi	r18, 0x7F	; 127
    3348:	dc 01       	movw	r26, r24
    334a:	ed 91       	ld	r30, X+
    334c:	fc 91       	ld	r31, X
    334e:	62 e0       	ldi	r22, 0x02	; 2
    3350:	70 e0       	ldi	r23, 0x00	; 0
    3352:	43 ef       	ldi	r20, 0xF3	; 243
    3354:	00 e0       	ldi	r16, 0x00	; 0
    3356:	09 95       	icall
         MIDI_SONGSELECT,
         song & 0x7F,
         0);
}
    3358:	0f 91       	pop	r16
    335a:	08 95       	ret

0000335c <midi_send_tunerequest>:

void midi_send_tunerequest(MidiDevice * device){
    335c:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_TUNEREQUEST, 0, 0);
    335e:	dc 01       	movw	r26, r24
    3360:	ed 91       	ld	r30, X+
    3362:	fc 91       	ld	r31, X
    3364:	61 e0       	ldi	r22, 0x01	; 1
    3366:	70 e0       	ldi	r23, 0x00	; 0
    3368:	46 ef       	ldi	r20, 0xF6	; 246
    336a:	20 e0       	ldi	r18, 0x00	; 0
    336c:	00 e0       	ldi	r16, 0x00	; 0
    336e:	09 95       	icall
}
    3370:	0f 91       	pop	r16
    3372:	08 95       	ret

00003374 <midi_send_byte>:

void midi_send_byte(MidiDevice * device, uint8_t b){
    3374:	0f 93       	push	r16
    3376:	46 2f       	mov	r20, r22
   device->send_func(device, 1, b, 0, 0);
    3378:	dc 01       	movw	r26, r24
    337a:	ed 91       	ld	r30, X+
    337c:	fc 91       	ld	r31, X
    337e:	61 e0       	ldi	r22, 0x01	; 1
    3380:	70 e0       	ldi	r23, 0x00	; 0
    3382:	20 e0       	ldi	r18, 0x00	; 0
    3384:	00 e0       	ldi	r16, 0x00	; 0
    3386:	09 95       	icall
}
    3388:	0f 91       	pop	r16
    338a:	08 95       	ret

0000338c <midi_send_data>:

void midi_send_data(MidiDevice * device, uint16_t count, uint8_t byte0, uint8_t byte1, uint8_t byte2){
    338c:	0f 93       	push	r16
   //ensure that the count passed along is always 3 or lower
   if (count > 3) {
      //TODO how to do this correctly?
   }
   device->send_func(device, count, byte0, byte1, byte2);
    338e:	dc 01       	movw	r26, r24
    3390:	ed 91       	ld	r30, X+
    3392:	fc 91       	ld	r31, X
    3394:	09 95       	icall
}
    3396:	0f 91       	pop	r16
    3398:	08 95       	ret

0000339a <midi_send_array>:

void midi_send_array(MidiDevice * device, uint16_t count, uint8_t * array) {
    339a:	6f 92       	push	r6
    339c:	7f 92       	push	r7
    339e:	8f 92       	push	r8
    33a0:	9f 92       	push	r9
    33a2:	af 92       	push	r10
    33a4:	bf 92       	push	r11
    33a6:	cf 92       	push	r12
    33a8:	df 92       	push	r13
    33aa:	ef 92       	push	r14
    33ac:	ff 92       	push	r15
    33ae:	0f 93       	push	r16
    33b0:	1f 93       	push	r17
    33b2:	cf 93       	push	r28
    33b4:	df 93       	push	r29
    33b6:	00 d0       	rcall	.+0      	; 0x33b8 <midi_send_array+0x1e>
    33b8:	0f 92       	push	r0
    33ba:	cd b7       	in	r28, 0x3d	; 61
    33bc:	de b7       	in	r29, 0x3e	; 62
    33be:	4c 01       	movw	r8, r24
    33c0:	6b 01       	movw	r12, r22
    33c2:	5a 01       	movw	r10, r20
  uint16_t i;
  for (i = 0; i < count; i += 3) {
    33c4:	61 15       	cp	r22, r1
    33c6:	71 05       	cpc	r23, r1
    33c8:	41 f1       	breq	.+80     	; 0x341a <midi_send_array+0x80>
    33ca:	ee 24       	eor	r14, r14
    33cc:	ff 24       	eor	r15, r15
    uint8_t b[3] = { 0, 0, 0 };
    uint16_t to_send = count - i;
    to_send = (to_send > 3) ? 3 : to_send;
    33ce:	0f 2e       	mov	r0, r31
    33d0:	f3 e0       	ldi	r31, 0x03	; 3
    33d2:	6f 2e       	mov	r6, r31
    33d4:	77 24       	eor	r7, r7
    33d6:	f0 2d       	mov	r31, r0
}

void midi_send_array(MidiDevice * device, uint16_t count, uint8_t * array) {
  uint16_t i;
  for (i = 0; i < count; i += 3) {
    uint8_t b[3] = { 0, 0, 0 };
    33d8:	19 82       	std	Y+1, r1	; 0x01
    33da:	1a 82       	std	Y+2, r1	; 0x02
    33dc:	1b 82       	std	Y+3, r1	; 0x03
    uint16_t to_send = count - i;
    33de:	86 01       	movw	r16, r12
    33e0:	0e 19       	sub	r16, r14
    33e2:	1f 09       	sbc	r17, r15
    to_send = (to_send > 3) ? 3 : to_send;
    33e4:	04 30       	cpi	r16, 0x04	; 4
    33e6:	11 05       	cpc	r17, r1
    33e8:	08 f0       	brcs	.+2      	; 0x33ec <midi_send_array+0x52>
    33ea:	83 01       	movw	r16, r6
      //TODO how to do this correctly?
   }
   device->send_func(device, count, byte0, byte1, byte2);
}

void midi_send_array(MidiDevice * device, uint16_t count, uint8_t * array) {
    33ec:	b5 01       	movw	r22, r10
    33ee:	6e 0d       	add	r22, r14
    33f0:	7f 1d       	adc	r23, r15
  uint16_t i;
  for (i = 0; i < count; i += 3) {
    uint8_t b[3] = { 0, 0, 0 };
    uint16_t to_send = count - i;
    to_send = (to_send > 3) ? 3 : to_send;
    memcpy(b, array + i, to_send);
    33f2:	ce 01       	movw	r24, r28
    33f4:	01 96       	adiw	r24, 0x01	; 1
    33f6:	40 2f       	mov	r20, r16
    33f8:	51 2f       	mov	r21, r17
    33fa:	0e 94 56 1f 	call	0x3eac	; 0x3eac <memcpy>
    midi_send_data(device, to_send, b[0], b[1], b[2]);
    33fe:	c4 01       	movw	r24, r8
    3400:	b8 01       	movw	r22, r16
    3402:	49 81       	ldd	r20, Y+1	; 0x01
    3404:	2a 81       	ldd	r18, Y+2	; 0x02
    3406:	0b 81       	ldd	r16, Y+3	; 0x03
    3408:	0e 94 c6 19 	call	0x338c	; 0x338c <midi_send_data>
   device->send_func(device, count, byte0, byte1, byte2);
}

void midi_send_array(MidiDevice * device, uint16_t count, uint8_t * array) {
  uint16_t i;
  for (i = 0; i < count; i += 3) {
    340c:	83 e0       	ldi	r24, 0x03	; 3
    340e:	90 e0       	ldi	r25, 0x00	; 0
    3410:	e8 0e       	add	r14, r24
    3412:	f9 1e       	adc	r15, r25
    3414:	ec 14       	cp	r14, r12
    3416:	fd 04       	cpc	r15, r13
    3418:	f8 f2       	brcs	.-66     	; 0x33d8 <midi_send_array+0x3e>
    uint16_t to_send = count - i;
    to_send = (to_send > 3) ? 3 : to_send;
    memcpy(b, array + i, to_send);
    midi_send_data(device, to_send, b[0], b[1], b[2]);
  }
}
    341a:	0f 90       	pop	r0
    341c:	0f 90       	pop	r0
    341e:	0f 90       	pop	r0
    3420:	df 91       	pop	r29
    3422:	cf 91       	pop	r28
    3424:	1f 91       	pop	r17
    3426:	0f 91       	pop	r16
    3428:	ff 90       	pop	r15
    342a:	ef 90       	pop	r14
    342c:	df 90       	pop	r13
    342e:	cf 90       	pop	r12
    3430:	bf 90       	pop	r11
    3432:	af 90       	pop	r10
    3434:	9f 90       	pop	r9
    3436:	8f 90       	pop	r8
    3438:	7f 90       	pop	r7
    343a:	6f 90       	pop	r6
    343c:	08 95       	ret

0000343e <midi_register_cc_callback>:


void midi_register_cc_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_cc_callback = func;
    343e:	fc 01       	movw	r30, r24
    3440:	73 83       	std	Z+3, r23	; 0x03
    3442:	62 83       	std	Z+2, r22	; 0x02
}
    3444:	08 95       	ret

00003446 <midi_register_noteon_callback>:

void midi_register_noteon_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_noteon_callback = func;
    3446:	fc 01       	movw	r30, r24
    3448:	75 83       	std	Z+5, r23	; 0x05
    344a:	64 83       	std	Z+4, r22	; 0x04
}
    344c:	08 95       	ret

0000344e <midi_register_noteoff_callback>:

void midi_register_noteoff_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_noteoff_callback = func;
    344e:	fc 01       	movw	r30, r24
    3450:	77 83       	std	Z+7, r23	; 0x07
    3452:	66 83       	std	Z+6, r22	; 0x06
}
    3454:	08 95       	ret

00003456 <midi_register_aftertouch_callback>:

void midi_register_aftertouch_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_aftertouch_callback = func;
    3456:	fc 01       	movw	r30, r24
    3458:	71 87       	std	Z+9, r23	; 0x09
    345a:	60 87       	std	Z+8, r22	; 0x08
}
    345c:	08 95       	ret

0000345e <midi_register_pitchbend_callback>:

void midi_register_pitchbend_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_pitchbend_callback = func;
    345e:	fc 01       	movw	r30, r24
    3460:	73 87       	std	Z+11, r23	; 0x0b
    3462:	62 87       	std	Z+10, r22	; 0x0a
}
    3464:	08 95       	ret

00003466 <midi_register_songposition_callback>:

void midi_register_songposition_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_songposition_callback = func;
    3466:	fc 01       	movw	r30, r24
    3468:	75 87       	std	Z+13, r23	; 0x0d
    346a:	64 87       	std	Z+12, r22	; 0x0c
}
    346c:	08 95       	ret

0000346e <midi_register_progchange_callback>:

void midi_register_progchange_callback(MidiDevice * device, midi_two_byte_func_t func) {
   device->input_progchange_callback = func;
    346e:	fc 01       	movw	r30, r24
    3470:	77 87       	std	Z+15, r23	; 0x0f
    3472:	66 87       	std	Z+14, r22	; 0x0e
}
    3474:	08 95       	ret

00003476 <midi_register_chanpressure_callback>:

void midi_register_chanpressure_callback(MidiDevice * device, midi_two_byte_func_t func) {
   device->input_chanpressure_callback = func;
    3476:	fc 01       	movw	r30, r24
    3478:	71 8b       	std	Z+17, r23	; 0x11
    347a:	60 8b       	std	Z+16, r22	; 0x10
}
    347c:	08 95       	ret

0000347e <midi_register_songselect_callback>:

void midi_register_songselect_callback(MidiDevice * device, midi_two_byte_func_t func) {
   device->input_songselect_callback = func;
    347e:	fc 01       	movw	r30, r24
    3480:	73 8b       	std	Z+19, r23	; 0x13
    3482:	62 8b       	std	Z+18, r22	; 0x12
}
    3484:	08 95       	ret

00003486 <midi_register_tc_quarterframe_callback>:

void midi_register_tc_quarterframe_callback(MidiDevice * device, midi_two_byte_func_t func) {
   device->input_tc_quarterframe_callback = func;
    3486:	fc 01       	movw	r30, r24
    3488:	75 8b       	std	Z+21, r23	; 0x15
    348a:	64 8b       	std	Z+20, r22	; 0x14
}
    348c:	08 95       	ret

0000348e <midi_register_realtime_callback>:

void midi_register_realtime_callback(MidiDevice * device, midi_one_byte_func_t func){
   device->input_realtime_callback = func;
    348e:	fc 01       	movw	r30, r24
    3490:	77 8b       	std	Z+23, r23	; 0x17
    3492:	66 8b       	std	Z+22, r22	; 0x16
}
    3494:	08 95       	ret

00003496 <midi_register_tunerequest_callback>:

void midi_register_tunerequest_callback(MidiDevice * device, midi_one_byte_func_t func){
   device->input_tunerequest_callback = func;
    3496:	fc 01       	movw	r30, r24
    3498:	71 8f       	std	Z+25, r23	; 0x19
    349a:	60 8f       	std	Z+24, r22	; 0x18
}
    349c:	08 95       	ret

0000349e <midi_register_sysex_callback>:

void midi_register_sysex_callback(MidiDevice * device, midi_sysex_func_t func) {
   device->input_sysex_callback = func;
    349e:	fc 01       	movw	r30, r24
    34a0:	73 8f       	std	Z+27, r23	; 0x1b
    34a2:	62 8f       	std	Z+26, r22	; 0x1a
}
    34a4:	08 95       	ret

000034a6 <midi_register_fallthrough_callback>:

void midi_register_fallthrough_callback(MidiDevice * device, midi_var_byte_func_t func){
   device->input_fallthrough_callback = func;
    34a6:	fc 01       	movw	r30, r24
    34a8:	75 8f       	std	Z+29, r23	; 0x1d
    34aa:	64 8f       	std	Z+28, r22	; 0x1c
}
    34ac:	08 95       	ret

000034ae <midi_register_catchall_callback>:

void midi_register_catchall_callback(MidiDevice * device, midi_var_byte_func_t func){
   device->input_catchall_callback = func;
    34ae:	fc 01       	movw	r30, r24
    34b0:	77 8f       	std	Z+31, r23	; 0x1f
    34b2:	66 8f       	std	Z+30, r22	; 0x1e
}
    34b4:	08 95       	ret

000034b6 <midi_device_init>:

//forward declarations, internally used to call the callbacks
void midi_input_callbacks(MidiDevice * device, uint16_t cnt, uint8_t byte0, uint8_t byte1, uint8_t byte2);
void midi_process_byte(MidiDevice * device, uint8_t input);

void midi_device_init(MidiDevice * device){
    34b6:	cf 93       	push	r28
    34b8:	df 93       	push	r29
    34ba:	ec 01       	movw	r28, r24
  device->input_state = IDLE;
    34bc:	1d a2       	lds	r17, 0x9d
  device->input_count = 0;
    34be:	1f a2       	lds	r17, 0x9f
    34c0:	1e a2       	lds	r17, 0x9e
  bytequeue_init(&device->input_queue, device->input_queue_data, MIDI_INPUT_QUEUE_LENGTH);
    34c2:	bc 01       	movw	r22, r24
    34c4:	68 5d       	subi	r22, 0xD8	; 216
    34c6:	7f 4f       	sbci	r23, 0xFF	; 255
    34c8:	88 51       	subi	r24, 0x18	; 24
    34ca:	9f 4f       	sbci	r25, 0xFF	; 255
    34cc:	40 ec       	ldi	r20, 0xC0	; 192
    34ce:	0e 94 d5 17 	call	0x2faa	; 0x2faa <bytequeue_init>

  //three byte funcs
  device->input_cc_callback = NULL;
    34d2:	1b 82       	std	Y+3, r1	; 0x03
    34d4:	1a 82       	std	Y+2, r1	; 0x02
  device->input_noteon_callback = NULL;
    34d6:	1d 82       	std	Y+5, r1	; 0x05
    34d8:	1c 82       	std	Y+4, r1	; 0x04
  device->input_noteoff_callback = NULL;
    34da:	1f 82       	std	Y+7, r1	; 0x07
    34dc:	1e 82       	std	Y+6, r1	; 0x06
  device->input_aftertouch_callback = NULL;
    34de:	19 86       	std	Y+9, r1	; 0x09
    34e0:	18 86       	std	Y+8, r1	; 0x08
  device->input_pitchbend_callback = NULL;
    34e2:	1b 86       	std	Y+11, r1	; 0x0b
    34e4:	1a 86       	std	Y+10, r1	; 0x0a
  device->input_songposition_callback = NULL;
    34e6:	1d 86       	std	Y+13, r1	; 0x0d
    34e8:	1c 86       	std	Y+12, r1	; 0x0c

  //two byte funcs
  device->input_progchange_callback = NULL;
    34ea:	1f 86       	std	Y+15, r1	; 0x0f
    34ec:	1e 86       	std	Y+14, r1	; 0x0e
  device->input_chanpressure_callback = NULL;
    34ee:	19 8a       	std	Y+17, r1	; 0x11
    34f0:	18 8a       	std	Y+16, r1	; 0x10
  device->input_songselect_callback = NULL;
    34f2:	1b 8a       	std	Y+19, r1	; 0x13
    34f4:	1a 8a       	std	Y+18, r1	; 0x12
  device->input_tc_quarterframe_callback = NULL;
    34f6:	1d 8a       	std	Y+21, r1	; 0x15
    34f8:	1c 8a       	std	Y+20, r1	; 0x14

  //one byte funcs
  device->input_realtime_callback = NULL;
    34fa:	1f 8a       	std	Y+23, r1	; 0x17
    34fc:	1e 8a       	std	Y+22, r1	; 0x16
  device->input_tunerequest_callback = NULL;
    34fe:	19 8e       	std	Y+25, r1	; 0x19
    3500:	18 8e       	std	Y+24, r1	; 0x18

  //var byte functions
  device->input_sysex_callback = NULL;
    3502:	1b 8e       	std	Y+27, r1	; 0x1b
    3504:	1a 8e       	std	Y+26, r1	; 0x1a
  device->input_fallthrough_callback = NULL;
    3506:	1d 8e       	std	Y+29, r1	; 0x1d
    3508:	1c 8e       	std	Y+28, r1	; 0x1c
  device->input_catchall_callback = NULL;
    350a:	1f 8e       	std	Y+31, r1	; 0x1f
    350c:	1e 8e       	std	Y+30, r1	; 0x1e

  device->pre_input_process_callback = NULL;
    350e:	19 a2       	lds	r17, 0x99
    3510:	18 a2       	lds	r17, 0x98
}
    3512:	df 91       	pop	r29
    3514:	cf 91       	pop	r28
    3516:	08 95       	ret

00003518 <midi_device_input>:

void midi_device_input(MidiDevice * device, uint8_t cnt, uint8_t * input) {
    3518:	ef 92       	push	r14
    351a:	ff 92       	push	r15
    351c:	0f 93       	push	r16
    351e:	1f 93       	push	r17
    3520:	cf 93       	push	r28
    3522:	df 93       	push	r29
    3524:	d6 2f       	mov	r29, r22
  uint8_t i;
  for (i = 0; i < cnt; i++)
    3526:	66 23       	and	r22, r22
    3528:	99 f0       	breq	.+38     	; 0x3550 <midi_device_input+0x38>
    352a:	04 2f       	mov	r16, r20
    352c:	15 2f       	mov	r17, r21
    352e:	c0 e0       	ldi	r28, 0x00	; 0
    bytequeue_enqueue(&device->input_queue, input[i]);
    3530:	0f 2e       	mov	r0, r31
    3532:	f8 ee       	ldi	r31, 0xE8	; 232
    3534:	ef 2e       	mov	r14, r31
    3536:	ff 24       	eor	r15, r15
    3538:	f0 2d       	mov	r31, r0
    353a:	e8 0e       	add	r14, r24
    353c:	f9 1e       	adc	r15, r25
    353e:	f8 01       	movw	r30, r16
    3540:	61 91       	ld	r22, Z+
    3542:	8f 01       	movw	r16, r30
    3544:	c7 01       	movw	r24, r14
    3546:	0e 94 dc 17 	call	0x2fb8	; 0x2fb8 <bytequeue_enqueue>
  device->pre_input_process_callback = NULL;
}

void midi_device_input(MidiDevice * device, uint8_t cnt, uint8_t * input) {
  uint8_t i;
  for (i = 0; i < cnt; i++)
    354a:	cf 5f       	subi	r28, 0xFF	; 255
    354c:	cd 17       	cp	r28, r29
    354e:	b9 f7       	brne	.-18     	; 0x353e <midi_device_input+0x26>
    bytequeue_enqueue(&device->input_queue, input[i]);
}
    3550:	df 91       	pop	r29
    3552:	cf 91       	pop	r28
    3554:	1f 91       	pop	r17
    3556:	0f 91       	pop	r16
    3558:	ff 90       	pop	r15
    355a:	ef 90       	pop	r14
    355c:	08 95       	ret

0000355e <midi_device_set_send_func>:

void midi_device_set_send_func(MidiDevice * device, midi_var_byte_func_t send_func){
  device->send_func = send_func;
    355e:	fc 01       	movw	r30, r24
    3560:	71 83       	std	Z+1, r23	; 0x01
    3562:	60 83       	st	Z, r22
}
    3564:	08 95       	ret

00003566 <midi_device_set_pre_input_process_func>:

void midi_device_set_pre_input_process_func(MidiDevice * device, midi_no_byte_func_t pre_process_func){
  device->pre_input_process_callback = pre_process_func;
    3566:	fc 01       	movw	r30, r24
    3568:	71 a3       	lds	r23, 0x51
    356a:	60 a3       	lds	r22, 0x50
}
    356c:	08 95       	ret

0000356e <midi_input_callbacks>:
      }
    }
  }
}

void midi_input_callbacks(MidiDevice * device, uint16_t cnt, uint8_t byte0, uint8_t byte1, uint8_t byte2) {
    356e:	af 92       	push	r10
    3570:	bf 92       	push	r11
    3572:	cf 92       	push	r12
    3574:	df 92       	push	r13
    3576:	ef 92       	push	r14
    3578:	ff 92       	push	r15
    357a:	0f 93       	push	r16
    357c:	1f 93       	push	r17
    357e:	cf 93       	push	r28
    3580:	df 93       	push	r29
    3582:	00 d0       	rcall	.+0      	; 0x3584 <midi_input_callbacks+0x16>
    3584:	0f 92       	push	r0
    3586:	cd b7       	in	r28, 0x3d	; 61
    3588:	de b7       	in	r29, 0x3e	; 62
    358a:	6c 01       	movw	r12, r24
    358c:	5b 01       	movw	r10, r22
    358e:	f4 2e       	mov	r15, r20
    3590:	e2 2e       	mov	r14, r18
    3592:	10 2f       	mov	r17, r16
  //did we end up calling a callback?
  bool called = false;
  if (device->input_state == SYSEX_MESSAGE) {
    3594:	dc 01       	movw	r26, r24
    3596:	95 96       	adiw	r26, 0x25	; 37
    3598:	8c 91       	ld	r24, X
    359a:	95 97       	sbiw	r26, 0x25	; 37
    359c:	84 30       	cpi	r24, 0x04	; 4
    359e:	e9 f4       	brne	.+58     	; 0x35da <midi_input_callbacks+0x6c>
    if (device->input_sysex_callback) {
    35a0:	5a 96       	adiw	r26, 0x1a	; 26
    35a2:	ed 91       	ld	r30, X+
    35a4:	fc 91       	ld	r31, X
    35a6:	5b 97       	sbiw	r26, 0x1b	; 27
    35a8:	30 97       	sbiw	r30, 0x00	; 0
    35aa:	09 f4       	brne	.+2      	; 0x35ae <midi_input_callbacks+0x40>
    35ac:	ee c0       	rjmp	.+476    	; 0x378a <midi_input_callbacks+0x21c>
      const uint16_t start = ((cnt - 1) / 3) * 3;
    35ae:	cb 01       	movw	r24, r22
    35b0:	01 97       	sbiw	r24, 0x01	; 1
    35b2:	63 e0       	ldi	r22, 0x03	; 3
    35b4:	70 e0       	ldi	r23, 0x00	; 0
    35b6:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <__udivmodhi4>
    35ba:	cb 01       	movw	r24, r22
    35bc:	88 0f       	add	r24, r24
    35be:	99 1f       	adc	r25, r25
    35c0:	68 0f       	add	r22, r24
    35c2:	79 1f       	adc	r23, r25
      const uint8_t length = (cnt - start);
      uint8_t data[3];
      data[0] = byte0;
    35c4:	49 83       	std	Y+1, r20	; 0x01
      data[1] = byte1;
    35c6:	2a 83       	std	Y+2, r18	; 0x02
      data[2] = byte2;
    35c8:	0b 83       	std	Y+3, r16	; 0x03
  //did we end up calling a callback?
  bool called = false;
  if (device->input_state == SYSEX_MESSAGE) {
    if (device->input_sysex_callback) {
      const uint16_t start = ((cnt - 1) / 3) * 3;
      const uint8_t length = (cnt - start);
    35ca:	4a 2d       	mov	r20, r10
    35cc:	46 1b       	sub	r20, r22
      uint8_t data[3];
      data[0] = byte0;
      data[1] = byte1;
      data[2] = byte2;
      device->input_sysex_callback(device, start, length, data);
    35ce:	c6 01       	movw	r24, r12
    35d0:	9e 01       	movw	r18, r28
    35d2:	2f 5f       	subi	r18, 0xFF	; 255
    35d4:	3f 4f       	sbci	r19, 0xFF	; 255
    35d6:	09 95       	icall
    35d8:	c8 c0       	rjmp	.+400    	; 0x376a <midi_input_callbacks+0x1fc>
      called = true;
    }
  } else {
    switch (cnt) {
    35da:	62 30       	cpi	r22, 0x02	; 2
    35dc:	71 05       	cpc	r23, r1
    35de:	09 f4       	brne	.+2      	; 0x35e2 <midi_input_callbacks+0x74>
    35e0:	5f c0       	rjmp	.+190    	; 0x36a0 <midi_input_callbacks+0x132>
    35e2:	63 30       	cpi	r22, 0x03	; 3
    35e4:	71 05       	cpc	r23, r1
    35e6:	29 f0       	breq	.+10     	; 0x35f2 <midi_input_callbacks+0x84>
    35e8:	61 30       	cpi	r22, 0x01	; 1
    35ea:	71 05       	cpc	r23, r1
    35ec:	09 f0       	breq	.+2      	; 0x35f0 <midi_input_callbacks+0x82>
    35ee:	b3 c0       	rjmp	.+358    	; 0x3756 <midi_input_callbacks+0x1e8>
    35f0:	99 c0       	rjmp	.+306    	; 0x3724 <midi_input_callbacks+0x1b6>
      case 3:
        {
          midi_three_byte_func_t func = NULL;
          switch (byte0 & 0xF0) {
    35f2:	84 2f       	mov	r24, r20
    35f4:	90 e0       	ldi	r25, 0x00	; 0
    35f6:	80 7f       	andi	r24, 0xF0	; 240
    35f8:	90 70       	andi	r25, 0x00	; 0
    35fa:	80 3a       	cpi	r24, 0xA0	; 160
    35fc:	91 05       	cpc	r25, r1
    35fe:	29 f1       	breq	.+74     	; 0x364a <midi_input_callbacks+0xdc>
    3600:	81 3a       	cpi	r24, 0xA1	; 161
    3602:	91 05       	cpc	r25, r1
    3604:	3c f4       	brge	.+14     	; 0x3614 <midi_input_callbacks+0xa6>
    3606:	80 38       	cpi	r24, 0x80	; 128
    3608:	91 05       	cpc	r25, r1
    360a:	c9 f0       	breq	.+50     	; 0x363e <midi_input_callbacks+0xd0>
    360c:	80 39       	cpi	r24, 0x90	; 144
    360e:	91 05       	cpc	r25, r1
    3610:	91 f5       	brne	.+100    	; 0x3676 <midi_input_callbacks+0x108>
    3612:	0f c0       	rjmp	.+30     	; 0x3632 <midi_input_callbacks+0xc4>
    3614:	80 3e       	cpi	r24, 0xE0	; 224
    3616:	91 05       	cpc	r25, r1
    3618:	f1 f0       	breq	.+60     	; 0x3656 <midi_input_callbacks+0xe8>
    361a:	80 3f       	cpi	r24, 0xF0	; 240
    361c:	91 05       	cpc	r25, r1
    361e:	09 f1       	breq	.+66     	; 0x3662 <midi_input_callbacks+0xf4>
    3620:	80 3b       	cpi	r24, 0xB0	; 176
    3622:	91 05       	cpc	r25, r1
    3624:	41 f5       	brne	.+80     	; 0x3676 <midi_input_callbacks+0x108>
            case MIDI_CC:
              func = device->input_cc_callback;
    3626:	d6 01       	movw	r26, r12
    3628:	12 96       	adiw	r26, 0x02	; 2
    362a:	ed 91       	ld	r30, X+
    362c:	fc 91       	ld	r31, X
    362e:	13 97       	sbiw	r26, 0x03	; 3
              break;
    3630:	24 c0       	rjmp	.+72     	; 0x367a <midi_input_callbacks+0x10c>
            case MIDI_NOTEON:
              func = device->input_noteon_callback;
    3632:	d6 01       	movw	r26, r12
    3634:	14 96       	adiw	r26, 0x04	; 4
    3636:	ed 91       	ld	r30, X+
    3638:	fc 91       	ld	r31, X
    363a:	15 97       	sbiw	r26, 0x05	; 5
              break;
    363c:	1e c0       	rjmp	.+60     	; 0x367a <midi_input_callbacks+0x10c>
            case MIDI_NOTEOFF:
              func = device->input_noteoff_callback;
    363e:	d6 01       	movw	r26, r12
    3640:	16 96       	adiw	r26, 0x06	; 6
    3642:	ed 91       	ld	r30, X+
    3644:	fc 91       	ld	r31, X
    3646:	17 97       	sbiw	r26, 0x07	; 7
              break;
    3648:	18 c0       	rjmp	.+48     	; 0x367a <midi_input_callbacks+0x10c>
            case MIDI_AFTERTOUCH:
              func = device->input_aftertouch_callback;
    364a:	d6 01       	movw	r26, r12
    364c:	18 96       	adiw	r26, 0x08	; 8
    364e:	ed 91       	ld	r30, X+
    3650:	fc 91       	ld	r31, X
    3652:	19 97       	sbiw	r26, 0x09	; 9
              break;
    3654:	12 c0       	rjmp	.+36     	; 0x367a <midi_input_callbacks+0x10c>
            case MIDI_PITCHBEND:
              func = device->input_pitchbend_callback;
    3656:	d6 01       	movw	r26, r12
    3658:	1a 96       	adiw	r26, 0x0a	; 10
    365a:	ed 91       	ld	r30, X+
    365c:	fc 91       	ld	r31, X
    365e:	1b 97       	sbiw	r26, 0x0b	; 11
              break;
    3660:	0c c0       	rjmp	.+24     	; 0x367a <midi_input_callbacks+0x10c>
            case 0xF0:
              if (byte0 == MIDI_SONGPOSITION)
    3662:	b2 ef       	ldi	r27, 0xF2	; 242
    3664:	4b 17       	cp	r20, r27
    3666:	09 f0       	breq	.+2      	; 0x366a <midi_input_callbacks+0xfc>
    3668:	90 c0       	rjmp	.+288    	; 0x378a <midi_input_callbacks+0x21c>
                func = device->input_songposition_callback;
    366a:	d6 01       	movw	r26, r12
    366c:	1c 96       	adiw	r26, 0x0c	; 12
    366e:	ed 91       	ld	r30, X+
    3670:	fc 91       	ld	r31, X
    3672:	1d 97       	sbiw	r26, 0x0d	; 13
    3674:	02 c0       	rjmp	.+4      	; 0x367a <midi_input_callbacks+0x10c>
    }
  } else {
    switch (cnt) {
      case 3:
        {
          midi_three_byte_func_t func = NULL;
    3676:	e0 e0       	ldi	r30, 0x00	; 0
    3678:	f0 e0       	ldi	r31, 0x00	; 0
                func = device->input_songposition_callback;
              break;
            default:
              break;
          }
          if(func) {
    367a:	30 97       	sbiw	r30, 0x00	; 0
    367c:	09 f4       	brne	.+2      	; 0x3680 <midi_input_callbacks+0x112>
    367e:	85 c0       	rjmp	.+266    	; 0x378a <midi_input_callbacks+0x21c>
            //mask off the channel for non song position functions
            if (byte0 == MIDI_SONGPOSITION)
    3680:	b2 ef       	ldi	r27, 0xF2	; 242
    3682:	fb 16       	cp	r15, r27
    3684:	31 f4       	brne	.+12     	; 0x3692 <midi_input_callbacks+0x124>
              func(device, byte0, byte1, byte2);
    3686:	c6 01       	movw	r24, r12
    3688:	62 ef       	ldi	r22, 0xF2	; 242
    368a:	4e 2d       	mov	r20, r14
    368c:	21 2f       	mov	r18, r17
    368e:	09 95       	icall
    3690:	6c c0       	rjmp	.+216    	; 0x376a <midi_input_callbacks+0x1fc>
            else
              func(device, byte0 & 0x0F, byte1, byte2);
    3692:	6f 2d       	mov	r22, r15
    3694:	6f 70       	andi	r22, 0x0F	; 15
    3696:	c6 01       	movw	r24, r12
    3698:	4e 2d       	mov	r20, r14
    369a:	21 2f       	mov	r18, r17
    369c:	09 95       	icall
    369e:	65 c0       	rjmp	.+202    	; 0x376a <midi_input_callbacks+0x1fc>
        }
        break;
      case 2:
        {
          midi_two_byte_func_t func = NULL;
          switch (byte0 & 0xF0) {
    36a0:	84 2f       	mov	r24, r20
    36a2:	90 e0       	ldi	r25, 0x00	; 0
    36a4:	80 7f       	andi	r24, 0xF0	; 240
    36a6:	90 70       	andi	r25, 0x00	; 0
    36a8:	80 3d       	cpi	r24, 0xD0	; 208
    36aa:	91 05       	cpc	r25, r1
    36ac:	61 f0       	breq	.+24     	; 0x36c6 <midi_input_callbacks+0x158>
    36ae:	80 3f       	cpi	r24, 0xF0	; 240
    36b0:	91 05       	cpc	r25, r1
    36b2:	79 f0       	breq	.+30     	; 0x36d2 <midi_input_callbacks+0x164>
    36b4:	80 3c       	cpi	r24, 0xC0	; 192
    36b6:	91 05       	cpc	r25, r1
    36b8:	f9 f4       	brne	.+62     	; 0x36f8 <midi_input_callbacks+0x18a>
            case MIDI_PROGCHANGE:
              func = device->input_progchange_callback;
    36ba:	d6 01       	movw	r26, r12
    36bc:	1e 96       	adiw	r26, 0x0e	; 14
    36be:	ed 91       	ld	r30, X+
    36c0:	fc 91       	ld	r31, X
    36c2:	1f 97       	sbiw	r26, 0x0f	; 15
              break;
    36c4:	1b c0       	rjmp	.+54     	; 0x36fc <midi_input_callbacks+0x18e>
            case MIDI_CHANPRESSURE:
              func = device->input_chanpressure_callback;
    36c6:	d6 01       	movw	r26, r12
    36c8:	50 96       	adiw	r26, 0x10	; 16
    36ca:	ed 91       	ld	r30, X+
    36cc:	fc 91       	ld	r31, X
    36ce:	51 97       	sbiw	r26, 0x11	; 17
              break;
    36d0:	15 c0       	rjmp	.+42     	; 0x36fc <midi_input_callbacks+0x18e>
            case 0xF0:
              if (byte0 == MIDI_SONGSELECT)
    36d2:	b3 ef       	ldi	r27, 0xF3	; 243
    36d4:	4b 17       	cp	r20, r27
    36d6:	31 f4       	brne	.+12     	; 0x36e4 <midi_input_callbacks+0x176>
                func = device->input_songselect_callback;
    36d8:	d6 01       	movw	r26, r12
    36da:	52 96       	adiw	r26, 0x12	; 18
    36dc:	ed 91       	ld	r30, X+
    36de:	fc 91       	ld	r31, X
    36e0:	53 97       	sbiw	r26, 0x13	; 19
    36e2:	0c c0       	rjmp	.+24     	; 0x36fc <midi_input_callbacks+0x18e>
              else if (byte0 == MIDI_TC_QUARTERFRAME)
    36e4:	b1 ef       	ldi	r27, 0xF1	; 241
    36e6:	4b 17       	cp	r20, r27
    36e8:	09 f0       	breq	.+2      	; 0x36ec <midi_input_callbacks+0x17e>
    36ea:	4f c0       	rjmp	.+158    	; 0x378a <midi_input_callbacks+0x21c>
                func = device->input_tc_quarterframe_callback;
    36ec:	d6 01       	movw	r26, r12
    36ee:	54 96       	adiw	r26, 0x14	; 20
    36f0:	ed 91       	ld	r30, X+
    36f2:	fc 91       	ld	r31, X
    36f4:	55 97       	sbiw	r26, 0x15	; 21
    36f6:	02 c0       	rjmp	.+4      	; 0x36fc <midi_input_callbacks+0x18e>
          }
        }
        break;
      case 2:
        {
          midi_two_byte_func_t func = NULL;
    36f8:	e0 e0       	ldi	r30, 0x00	; 0
    36fa:	f0 e0       	ldi	r31, 0x00	; 0
                func = device->input_tc_quarterframe_callback;
              break;
            default:
              break;
          }
          if(func) {
    36fc:	30 97       	sbiw	r30, 0x00	; 0
    36fe:	09 f4       	brne	.+2      	; 0x3702 <midi_input_callbacks+0x194>
    3700:	44 c0       	rjmp	.+136    	; 0x378a <midi_input_callbacks+0x21c>
            //mask off the channel
            if (byte0 == MIDI_SONGSELECT || byte0 == MIDI_TC_QUARTERFRAME)
    3702:	b3 ef       	ldi	r27, 0xF3	; 243
    3704:	fb 16       	cp	r15, r27
    3706:	19 f0       	breq	.+6      	; 0x370e <midi_input_callbacks+0x1a0>
    3708:	81 ef       	ldi	r24, 0xF1	; 241
    370a:	f8 16       	cp	r15, r24
    370c:	29 f4       	brne	.+10     	; 0x3718 <midi_input_callbacks+0x1aa>
              func(device, byte0, byte1);
    370e:	c6 01       	movw	r24, r12
    3710:	6f 2d       	mov	r22, r15
    3712:	4e 2d       	mov	r20, r14
    3714:	09 95       	icall
    3716:	29 c0       	rjmp	.+82     	; 0x376a <midi_input_callbacks+0x1fc>
            else
              func(device, byte0 & 0x0F, byte1);
    3718:	6f 2d       	mov	r22, r15
    371a:	6f 70       	andi	r22, 0x0F	; 15
    371c:	c6 01       	movw	r24, r12
    371e:	4e 2d       	mov	r20, r14
    3720:	09 95       	icall
    3722:	23 c0       	rjmp	.+70     	; 0x376a <midi_input_callbacks+0x1fc>
        }
        break;
      case 1:
        {
          midi_one_byte_func_t func = NULL;
          if (midi_is_realtime(byte0))
    3724:	84 2f       	mov	r24, r20
    3726:	0e 94 54 18 	call	0x30a8	; 0x30a8 <midi_is_realtime>
    372a:	88 23       	and	r24, r24
    372c:	31 f0       	breq	.+12     	; 0x373a <midi_input_callbacks+0x1cc>
            func = device->input_realtime_callback;
    372e:	d6 01       	movw	r26, r12
    3730:	56 96       	adiw	r26, 0x16	; 22
    3732:	ed 91       	ld	r30, X+
    3734:	fc 91       	ld	r31, X
    3736:	57 97       	sbiw	r26, 0x17	; 23
    3738:	08 c0       	rjmp	.+16     	; 0x374a <midi_input_callbacks+0x1dc>
          else if (byte0 == MIDI_TUNEREQUEST)
    373a:	b6 ef       	ldi	r27, 0xF6	; 246
    373c:	fb 16       	cp	r15, r27
    373e:	29 f5       	brne	.+74     	; 0x378a <midi_input_callbacks+0x21c>
            func = device->input_tunerequest_callback;
    3740:	d6 01       	movw	r26, r12
    3742:	58 96       	adiw	r26, 0x18	; 24
    3744:	ed 91       	ld	r30, X+
    3746:	fc 91       	ld	r31, X
    3748:	59 97       	sbiw	r26, 0x19	; 25
          if (func) {
    374a:	30 97       	sbiw	r30, 0x00	; 0
    374c:	f1 f0       	breq	.+60     	; 0x378a <midi_input_callbacks+0x21c>
            func(device, byte0);
    374e:	c6 01       	movw	r24, r12
    3750:	6f 2d       	mov	r22, r15
    3752:	09 95       	icall
    3754:	0a c0       	rjmp	.+20     	; 0x376a <midi_input_callbacks+0x1fc>
          }
        }
        break;
      default:
        //just in case
        if (cnt > 3)
    3756:	64 30       	cpi	r22, 0x04	; 4
    3758:	71 05       	cpc	r23, r1
    375a:	a8 f4       	brcc	.+42     	; 0x3786 <midi_input_callbacks+0x218>
    375c:	16 c0       	rjmp	.+44     	; 0x378a <midi_input_callbacks+0x21c>
  }

  //if there is fallthrough default callback and we haven't called a more specific one, 
  //call the fallthrough
  if (!called && device->input_fallthrough_callback)
    device->input_fallthrough_callback(device, cnt, byte0, byte1, byte2);
    375e:	c6 01       	movw	r24, r12
    3760:	b5 01       	movw	r22, r10
    3762:	4f 2d       	mov	r20, r15
    3764:	2e 2d       	mov	r18, r14
    3766:	01 2f       	mov	r16, r17
    3768:	09 95       	icall
  //always call the catch all if it exists
  if (device->input_catchall_callback)
    376a:	d6 01       	movw	r26, r12
    376c:	5e 96       	adiw	r26, 0x1e	; 30
    376e:	ed 91       	ld	r30, X+
    3770:	fc 91       	ld	r31, X
    3772:	5f 97       	sbiw	r26, 0x1f	; 31
    3774:	30 97       	sbiw	r30, 0x00	; 0
    3776:	89 f0       	breq	.+34     	; 0x379a <midi_input_callbacks+0x22c>
    device->input_catchall_callback(device, cnt, byte0, byte1, byte2);
    3778:	c6 01       	movw	r24, r12
    377a:	b5 01       	movw	r22, r10
    377c:	4f 2d       	mov	r20, r15
    377e:	2e 2d       	mov	r18, r14
    3780:	01 2f       	mov	r16, r17
    3782:	09 95       	icall
    3784:	0a c0       	rjmp	.+20     	; 0x379a <midi_input_callbacks+0x22c>
        }
        break;
      default:
        //just in case
        if (cnt > 3)
          cnt = 0;
    3786:	aa 24       	eor	r10, r10
    3788:	bb 24       	eor	r11, r11
    }
  }

  //if there is fallthrough default callback and we haven't called a more specific one, 
  //call the fallthrough
  if (!called && device->input_fallthrough_callback)
    378a:	d6 01       	movw	r26, r12
    378c:	5c 96       	adiw	r26, 0x1c	; 28
    378e:	ed 91       	ld	r30, X+
    3790:	fc 91       	ld	r31, X
    3792:	5d 97       	sbiw	r26, 0x1d	; 29
    3794:	30 97       	sbiw	r30, 0x00	; 0
    3796:	19 f7       	brne	.-58     	; 0x375e <midi_input_callbacks+0x1f0>
    3798:	e8 cf       	rjmp	.-48     	; 0x376a <midi_input_callbacks+0x1fc>
    device->input_fallthrough_callback(device, cnt, byte0, byte1, byte2);
  //always call the catch all if it exists
  if (device->input_catchall_callback)
    device->input_catchall_callback(device, cnt, byte0, byte1, byte2);
}
    379a:	0f 90       	pop	r0
    379c:	0f 90       	pop	r0
    379e:	0f 90       	pop	r0
    37a0:	df 91       	pop	r29
    37a2:	cf 91       	pop	r28
    37a4:	1f 91       	pop	r17
    37a6:	0f 91       	pop	r16
    37a8:	ff 90       	pop	r15
    37aa:	ef 90       	pop	r14
    37ac:	df 90       	pop	r13
    37ae:	cf 90       	pop	r12
    37b0:	bf 90       	pop	r11
    37b2:	af 90       	pop	r10
    37b4:	08 95       	ret

000037b6 <midi_process_byte>:
    midi_process_byte(device, val);
    bytequeue_remove(&device->input_queue, 1);
  }
}

void midi_process_byte(MidiDevice * device, uint8_t input) {
    37b6:	ef 92       	push	r14
    37b8:	ff 92       	push	r15
    37ba:	0f 93       	push	r16
    37bc:	cf 93       	push	r28
    37be:	df 93       	push	r29
    37c0:	7c 01       	movw	r14, r24
    37c2:	c6 2f       	mov	r28, r22
  if (midi_is_realtime(input)) {
    37c4:	86 2f       	mov	r24, r22
    37c6:	0e 94 54 18 	call	0x30a8	; 0x30a8 <midi_is_realtime>
    37ca:	88 23       	and	r24, r24
    37cc:	91 f0       	breq	.+36     	; 0x37f2 <midi_process_byte+0x3c>
    //call callback, store and restore state
    input_state_t state = device->input_state;
    37ce:	d7 01       	movw	r26, r14
    37d0:	95 96       	adiw	r26, 0x25	; 37
    37d2:	dc 91       	ld	r29, X
    37d4:	95 97       	sbiw	r26, 0x25	; 37
    device->input_state = ONE_BYTE_MESSAGE;
    37d6:	81 e0       	ldi	r24, 0x01	; 1
    37d8:	95 96       	adiw	r26, 0x25	; 37
    37da:	8c 93       	st	X, r24
    midi_input_callbacks(device, 1, input, 0, 0);
    37dc:	c7 01       	movw	r24, r14
    37de:	61 e0       	ldi	r22, 0x01	; 1
    37e0:	70 e0       	ldi	r23, 0x00	; 0
    37e2:	4c 2f       	mov	r20, r28
    37e4:	20 e0       	ldi	r18, 0x00	; 0
    37e6:	00 e0       	ldi	r16, 0x00	; 0
    37e8:	0e 94 b7 1a 	call	0x356e	; 0x356e <midi_input_callbacks>
    device->input_state = state;
    37ec:	f7 01       	movw	r30, r14
    37ee:	d5 a3       	lds	r29, 0x55
    37f0:	b7 c0       	rjmp	.+366    	; 0x3960 <midi_process_byte+0x1aa>
  } else if (midi_is_statusbyte(input)) {
    37f2:	8c 2f       	mov	r24, r28
    37f4:	0e 94 50 18 	call	0x30a0	; 0x30a0 <midi_is_statusbyte>
    37f8:	88 23       	and	r24, r24
    37fa:	09 f4       	brne	.+2      	; 0x37fe <midi_process_byte+0x48>
    37fc:	73 c0       	rjmp	.+230    	; 0x38e4 <midi_process_byte+0x12e>
    //store the byte
    if (device->input_state != SYSEX_MESSAGE) {
    37fe:	d7 01       	movw	r26, r14
    3800:	95 96       	adiw	r26, 0x25	; 37
    3802:	8c 91       	ld	r24, X
    3804:	95 97       	sbiw	r26, 0x25	; 37
    3806:	84 30       	cpi	r24, 0x04	; 4
    3808:	49 f0       	breq	.+18     	; 0x381c <midi_process_byte+0x66>
      device->input_buffer[0] = input;
    380a:	92 96       	adiw	r26, 0x22	; 34
    380c:	cc 93       	st	X, r28
    380e:	92 97       	sbiw	r26, 0x22	; 34
      device->input_count = 1;
    3810:	81 e0       	ldi	r24, 0x01	; 1
    3812:	90 e0       	ldi	r25, 0x00	; 0
    3814:	97 96       	adiw	r26, 0x27	; 39
    3816:	9c 93       	st	X, r25
    3818:	8e 93       	st	-X, r24
    381a:	96 97       	sbiw	r26, 0x26	; 38
    }
    switch (midi_packet_length(input)) {
    381c:	8c 2f       	mov	r24, r28
    381e:	0e 94 5a 18 	call	0x30b4	; 0x30b4 <midi_packet_length>
    3822:	81 30       	cpi	r24, 0x01	; 1
    3824:	41 f0       	breq	.+16     	; 0x3836 <midi_process_byte+0x80>
    3826:	81 30       	cpi	r24, 0x01	; 1
    3828:	00 f1       	brcs	.+64     	; 0x386a <midi_process_byte+0xb4>
    382a:	82 30       	cpi	r24, 0x02	; 2
    382c:	a1 f0       	breq	.+40     	; 0x3856 <midi_process_byte+0xa0>
    382e:	83 30       	cpi	r24, 0x03	; 3
    3830:	09 f0       	breq	.+2      	; 0x3834 <midi_process_byte+0x7e>
    3832:	4f c0       	rjmp	.+158    	; 0x38d2 <midi_process_byte+0x11c>
    3834:	14 c0       	rjmp	.+40     	; 0x385e <midi_process_byte+0xa8>
      case ONE1:
        device->input_state = ONE_BYTE_MESSAGE;;
    3836:	81 e0       	ldi	r24, 0x01	; 1
    3838:	f7 01       	movw	r30, r14
    383a:	85 a3       	lds	r24, 0x55
        midi_input_callbacks(device, 1, input, 0, 0);
    383c:	c7 01       	movw	r24, r14
    383e:	61 e0       	ldi	r22, 0x01	; 1
    3840:	70 e0       	ldi	r23, 0x00	; 0
    3842:	4c 2f       	mov	r20, r28
    3844:	20 e0       	ldi	r18, 0x00	; 0
    3846:	00 e0       	ldi	r16, 0x00	; 0
    3848:	0e 94 b7 1a 	call	0x356e	; 0x356e <midi_input_callbacks>
        device->input_state = IDLE;
    384c:	d7 01       	movw	r26, r14
    384e:	95 96       	adiw	r26, 0x25	; 37
    3850:	1c 92       	st	X, r1
    3852:	95 97       	sbiw	r26, 0x25	; 37
        break;
    3854:	85 c0       	rjmp	.+266    	; 0x3960 <midi_process_byte+0x1aa>
      case TWO2:
        device->input_state = TWO_BYTE_MESSAGE;
    3856:	82 e0       	ldi	r24, 0x02	; 2
    3858:	f7 01       	movw	r30, r14
    385a:	85 a3       	lds	r24, 0x55
        break;
    385c:	81 c0       	rjmp	.+258    	; 0x3960 <midi_process_byte+0x1aa>
      case THREE3:
        device->input_state = THREE_BYTE_MESSAGE;
    385e:	83 e0       	ldi	r24, 0x03	; 3
    3860:	d7 01       	movw	r26, r14
    3862:	95 96       	adiw	r26, 0x25	; 37
    3864:	8c 93       	st	X, r24
    3866:	95 97       	sbiw	r26, 0x25	; 37
        break;
    3868:	7b c0       	rjmp	.+246    	; 0x3960 <midi_process_byte+0x1aa>
      case UNDEFINED:
        switch(input) {
    386a:	c0 3f       	cpi	r28, 0xF0	; 240
    386c:	19 f0       	breq	.+6      	; 0x3874 <midi_process_byte+0xbe>
    386e:	c7 3f       	cpi	r28, 0xF7	; 247
    3870:	59 f5       	brne	.+86     	; 0x38c8 <midi_process_byte+0x112>
    3872:	0a c0       	rjmp	.+20     	; 0x3888 <midi_process_byte+0xd2>
          case SYSEX_BEGIN:
            device->input_state = SYSEX_MESSAGE;
    3874:	84 e0       	ldi	r24, 0x04	; 4
    3876:	f7 01       	movw	r30, r14
    3878:	85 a3       	lds	r24, 0x55
            device->input_buffer[0] = input;
    387a:	80 ef       	ldi	r24, 0xF0	; 240
    387c:	82 a3       	lds	r24, 0x52
            device->input_count = 1;
    387e:	81 e0       	ldi	r24, 0x01	; 1
    3880:	90 e0       	ldi	r25, 0x00	; 0
    3882:	97 a3       	lds	r25, 0x57
    3884:	86 a3       	lds	r24, 0x56
            break;
    3886:	6c c0       	rjmp	.+216    	; 0x3960 <midi_process_byte+0x1aa>
          case SYSEX_END:
            //send what is left in the input buffer, set idle
            device->input_buffer[device->input_count % 3] = input;
    3888:	d7 01       	movw	r26, r14
    388a:	96 96       	adiw	r26, 0x26	; 38
    388c:	2d 91       	ld	r18, X+
    388e:	3c 91       	ld	r19, X
    3890:	97 97       	sbiw	r26, 0x27	; 39
    3892:	c9 01       	movw	r24, r18
    3894:	63 e0       	ldi	r22, 0x03	; 3
    3896:	70 e0       	ldi	r23, 0x00	; 0
    3898:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <__udivmodhi4>
    389c:	f7 01       	movw	r30, r14
    389e:	e8 0f       	add	r30, r24
    38a0:	f9 1f       	adc	r31, r25
    38a2:	87 ef       	ldi	r24, 0xF7	; 247
    38a4:	82 a3       	lds	r24, 0x52
            device->input_count += 1;
    38a6:	b9 01       	movw	r22, r18
    38a8:	6f 5f       	subi	r22, 0xFF	; 255
    38aa:	7f 4f       	sbci	r23, 0xFF	; 255
    38ac:	f7 01       	movw	r30, r14
    38ae:	77 a3       	lds	r23, 0x57
    38b0:	66 a3       	lds	r22, 0x56
            //call the callback
            midi_input_callbacks(device, device->input_count, 
    38b2:	c7 01       	movw	r24, r14
    38b4:	42 a1       	lds	r20, 0x42
    38b6:	23 a1       	lds	r18, 0x43
    38b8:	04 a1       	lds	r16, 0x44
    38ba:	0e 94 b7 1a 	call	0x356e	; 0x356e <midi_input_callbacks>
                device->input_buffer[0], device->input_buffer[1], device->input_buffer[2]);
            device->input_state = IDLE;
    38be:	d7 01       	movw	r26, r14
    38c0:	95 96       	adiw	r26, 0x25	; 37
    38c2:	1c 92       	st	X, r1
    38c4:	95 97       	sbiw	r26, 0x25	; 37
            break;
    38c6:	4c c0       	rjmp	.+152    	; 0x3960 <midi_process_byte+0x1aa>
          default:
            device->input_state = IDLE;
    38c8:	f7 01       	movw	r30, r14
    38ca:	15 a2       	lds	r17, 0x95
            device->input_count = 0;
    38cc:	17 a2       	lds	r17, 0x97
    38ce:	16 a2       	lds	r17, 0x96
    38d0:	47 c0       	rjmp	.+142    	; 0x3960 <midi_process_byte+0x1aa>
        }

        break;
      default:
        device->input_state = IDLE;
    38d2:	d7 01       	movw	r26, r14
    38d4:	95 96       	adiw	r26, 0x25	; 37
    38d6:	1c 92       	st	X, r1
    38d8:	95 97       	sbiw	r26, 0x25	; 37
        device->input_count = 0;
    38da:	97 96       	adiw	r26, 0x27	; 39
    38dc:	1c 92       	st	X, r1
    38de:	1e 92       	st	-X, r1
    38e0:	96 97       	sbiw	r26, 0x26	; 38
        break;
    38e2:	3e c0       	rjmp	.+124    	; 0x3960 <midi_process_byte+0x1aa>
    }
  } else {
    if (device->input_state != IDLE) {
    38e4:	f7 01       	movw	r30, r14
    38e6:	25 a1       	lds	r18, 0x45
    38e8:	22 23       	and	r18, r18
    38ea:	d1 f1       	breq	.+116    	; 0x3960 <midi_process_byte+0x1aa>
      //store the byte
      device->input_buffer[device->input_count % 3] = input;
    38ec:	06 a0       	lds	r16, 0x86
    38ee:	f7 a1       	lds	r31, 0x47
    38f0:	e0 2d       	mov	r30, r0
    38f2:	cf 01       	movw	r24, r30
    38f4:	63 e0       	ldi	r22, 0x03	; 3
    38f6:	70 e0       	ldi	r23, 0x00	; 0
    38f8:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <__udivmodhi4>
    38fc:	ac 01       	movw	r20, r24
    38fe:	8e 0d       	add	r24, r14
    3900:	9f 1d       	adc	r25, r15
    3902:	dc 01       	movw	r26, r24
    3904:	92 96       	adiw	r26, 0x22	; 34
    3906:	cc 93       	st	X, r28
    3908:	92 97       	sbiw	r26, 0x22	; 34
      //increment count
      uint16_t prev = device->input_count;
      device->input_count += 1;
    390a:	bf 01       	movw	r22, r30
    390c:	6f 5f       	subi	r22, 0xFF	; 255
    390e:	7f 4f       	sbci	r23, 0xFF	; 255
    3910:	f7 01       	movw	r30, r14
    3912:	77 a3       	lds	r23, 0x57
    3914:	66 a3       	lds	r22, 0x56

      switch(prev % 3) {
    3916:	41 30       	cpi	r20, 0x01	; 1
    3918:	51 05       	cpc	r21, r1
    391a:	91 f0       	breq	.+36     	; 0x3940 <midi_process_byte+0x18a>
    391c:	42 30       	cpi	r20, 0x02	; 2
    391e:	51 05       	cpc	r21, r1
    3920:	f9 f4       	brne	.+62     	; 0x3960 <midi_process_byte+0x1aa>
        case 2:
          //call callback
          midi_input_callbacks(device, device->input_count,
    3922:	c7 01       	movw	r24, r14
    3924:	42 a1       	lds	r20, 0x42
    3926:	23 a1       	lds	r18, 0x43
    3928:	04 a1       	lds	r16, 0x44
    392a:	0e 94 b7 1a 	call	0x356e	; 0x356e <midi_input_callbacks>
              device->input_buffer[0], device->input_buffer[1], device->input_buffer[2]);
          if (device->input_state != SYSEX_MESSAGE) {
    392e:	f7 01       	movw	r30, r14
    3930:	85 a1       	lds	r24, 0x45
    3932:	84 30       	cpi	r24, 0x04	; 4
    3934:	a9 f0       	breq	.+42     	; 0x3960 <midi_process_byte+0x1aa>
            //set to 1, keeping status byte, allowing for running status
            device->input_count = 1;
    3936:	81 e0       	ldi	r24, 0x01	; 1
    3938:	90 e0       	ldi	r25, 0x00	; 0
    393a:	97 a3       	lds	r25, 0x57
    393c:	86 a3       	lds	r24, 0x56
    393e:	10 c0       	rjmp	.+32     	; 0x3960 <midi_process_byte+0x1aa>
          }
          break;
        case 1:
          if (device->input_state == TWO_BYTE_MESSAGE) {
    3940:	22 30       	cpi	r18, 0x02	; 2
    3942:	71 f4       	brne	.+28     	; 0x3960 <midi_process_byte+0x1aa>
            //call callback
            midi_input_callbacks(device, device->input_count,
    3944:	c7 01       	movw	r24, r14
    3946:	42 a1       	lds	r20, 0x42
    3948:	23 a1       	lds	r18, 0x43
    394a:	00 e0       	ldi	r16, 0x00	; 0
    394c:	0e 94 b7 1a 	call	0x356e	; 0x356e <midi_input_callbacks>
                device->input_buffer[0], device->input_buffer[1], 0);
            if (device->input_state != SYSEX_MESSAGE) {
    3950:	f7 01       	movw	r30, r14
    3952:	85 a1       	lds	r24, 0x45
    3954:	84 30       	cpi	r24, 0x04	; 4
    3956:	21 f0       	breq	.+8      	; 0x3960 <midi_process_byte+0x1aa>
              //set to 1, keeping status byte, allowing for running status
              device->input_count = 1;
    3958:	81 e0       	ldi	r24, 0x01	; 1
    395a:	90 e0       	ldi	r25, 0x00	; 0
    395c:	97 a3       	lds	r25, 0x57
    395e:	86 a3       	lds	r24, 0x56
          //one byte messages are dealt with directly
          break;
      }
    }
  }
}
    3960:	df 91       	pop	r29
    3962:	cf 91       	pop	r28
    3964:	0f 91       	pop	r16
    3966:	ff 90       	pop	r15
    3968:	ef 90       	pop	r14
    396a:	08 95       	ret

0000396c <midi_device_process>:

void midi_device_set_pre_input_process_func(MidiDevice * device, midi_no_byte_func_t pre_process_func){
  device->pre_input_process_callback = pre_process_func;
}

void midi_device_process(MidiDevice * device) {
    396c:	cf 92       	push	r12
    396e:	df 92       	push	r13
    3970:	ef 92       	push	r14
    3972:	ff 92       	push	r15
    3974:	0f 93       	push	r16
    3976:	1f 93       	push	r17
    3978:	cf 93       	push	r28
    397a:	df 93       	push	r29
    397c:	6c 01       	movw	r12, r24
  //call the pre_input_process_callback if there is one
  if(device->pre_input_process_callback)
    397e:	dc 01       	movw	r26, r24
    3980:	90 96       	adiw	r26, 0x20	; 32
    3982:	ed 91       	ld	r30, X+
    3984:	fc 91       	ld	r31, X
    3986:	91 97       	sbiw	r26, 0x21	; 33
    3988:	30 97       	sbiw	r30, 0x00	; 0
    398a:	09 f0       	breq	.+2      	; 0x398e <midi_device_process+0x22>
    device->pre_input_process_callback(device);
    398c:	09 95       	icall

  //pull stuff off the queue and process
  byteQueueIndex_t len = bytequeue_length(&device->input_queue);
    398e:	0f 2e       	mov	r0, r31
    3990:	f8 ee       	ldi	r31, 0xE8	; 232
    3992:	ef 2e       	mov	r14, r31
    3994:	ff 24       	eor	r15, r15
    3996:	f0 2d       	mov	r31, r0
    3998:	ec 0c       	add	r14, r12
    399a:	fd 1c       	adc	r15, r13
    399c:	c7 01       	movw	r24, r14
    399e:	0e 94 0b 18 	call	0x3016	; 0x3016 <bytequeue_length>
  uint16_t i;
  //TODO limit number of bytes processed?
  for(i = 0; i < len; i++) {
    39a2:	c8 2f       	mov	r28, r24
    39a4:	d0 e0       	ldi	r29, 0x00	; 0
    39a6:	20 97       	sbiw	r28, 0x00	; 0
    39a8:	99 f0       	breq	.+38     	; 0x39d0 <midi_device_process+0x64>
    39aa:	00 e0       	ldi	r16, 0x00	; 0
    39ac:	10 e0       	ldi	r17, 0x00	; 0
    uint8_t val = bytequeue_get(&device->input_queue, 0);
    39ae:	c7 01       	movw	r24, r14
    39b0:	60 e0       	ldi	r22, 0x00	; 0
    39b2:	0e 94 20 18 	call	0x3040	; 0x3040 <bytequeue_get>
    39b6:	68 2f       	mov	r22, r24
    midi_process_byte(device, val);
    39b8:	c6 01       	movw	r24, r12
    39ba:	0e 94 db 1b 	call	0x37b6	; 0x37b6 <midi_process_byte>
    bytequeue_remove(&device->input_queue, 1);
    39be:	c7 01       	movw	r24, r14
    39c0:	61 e0       	ldi	r22, 0x01	; 1
    39c2:	0e 94 31 18 	call	0x3062	; 0x3062 <bytequeue_remove>

  //pull stuff off the queue and process
  byteQueueIndex_t len = bytequeue_length(&device->input_queue);
  uint16_t i;
  //TODO limit number of bytes processed?
  for(i = 0; i < len; i++) {
    39c6:	0f 5f       	subi	r16, 0xFF	; 255
    39c8:	1f 4f       	sbci	r17, 0xFF	; 255
    39ca:	0c 17       	cp	r16, r28
    39cc:	1d 07       	cpc	r17, r29
    39ce:	78 f3       	brcs	.-34     	; 0x39ae <midi_device_process+0x42>
    uint8_t val = bytequeue_get(&device->input_queue, 0);
    midi_process_byte(device, val);
    bytequeue_remove(&device->input_queue, 1);
  }
}
    39d0:	df 91       	pop	r29
    39d2:	cf 91       	pop	r28
    39d4:	1f 91       	pop	r17
    39d6:	0f 91       	pop	r16
    39d8:	ff 90       	pop	r15
    39da:	ef 90       	pop	r14
    39dc:	df 90       	pop	r13
    39de:	cf 90       	pop	r12
    39e0:	08 95       	ret

000039e2 <sysex_encoded_length>:
//You should have received a copy of the GNU General Public License
//along with avr-midi.  If not, see <http://www.gnu.org/licenses/>.

#include "sysex_tools.h"

uint16_t sysex_encoded_length(uint16_t decoded_length){
    39e2:	9c 01       	movw	r18, r24
   uint8_t remainder = decoded_length % 7;
    39e4:	67 e0       	ldi	r22, 0x07	; 7
    39e6:	70 e0       	ldi	r23, 0x00	; 0
    39e8:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <__udivmodhi4>
    39ec:	48 2f       	mov	r20, r24
   if (remainder)
    39ee:	88 23       	and	r24, r24
    39f0:	81 f0       	breq	.+32     	; 0x3a12 <sysex_encoded_length+0x30>
      return (decoded_length / 7) * 8 + remainder + 1;
    39f2:	c9 01       	movw	r24, r18
    39f4:	67 e0       	ldi	r22, 0x07	; 7
    39f6:	70 e0       	ldi	r23, 0x00	; 0
    39f8:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <__udivmodhi4>
    39fc:	cb 01       	movw	r24, r22
    39fe:	88 0f       	add	r24, r24
    3a00:	99 1f       	adc	r25, r25
    3a02:	88 0f       	add	r24, r24
    3a04:	99 1f       	adc	r25, r25
    3a06:	88 0f       	add	r24, r24
    3a08:	99 1f       	adc	r25, r25
    3a0a:	01 96       	adiw	r24, 0x01	; 1
    3a0c:	84 0f       	add	r24, r20
    3a0e:	91 1d       	adc	r25, r1
    3a10:	08 95       	ret
   else
      return (decoded_length / 7) * 8;
    3a12:	c9 01       	movw	r24, r18
    3a14:	67 e0       	ldi	r22, 0x07	; 7
    3a16:	70 e0       	ldi	r23, 0x00	; 0
    3a18:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <__udivmodhi4>
    3a1c:	cb 01       	movw	r24, r22
    3a1e:	88 0f       	add	r24, r24
    3a20:	99 1f       	adc	r25, r25
    3a22:	88 0f       	add	r24, r24
    3a24:	99 1f       	adc	r25, r25
    3a26:	88 0f       	add	r24, r24
    3a28:	99 1f       	adc	r25, r25
}
    3a2a:	08 95       	ret

00003a2c <sysex_decoded_length>:

uint16_t sysex_decoded_length(uint16_t encoded_length){
   uint8_t remainder = encoded_length % 8;
    3a2c:	48 2f       	mov	r20, r24
    3a2e:	47 70       	andi	r20, 0x07	; 7
   if (remainder)
    3a30:	a1 f0       	breq	.+40     	; 0x3a5a <sysex_decoded_length+0x2e>
      return (encoded_length / 8) * 7 + remainder - 1;
    3a32:	9c 01       	movw	r18, r24
    3a34:	36 95       	lsr	r19
    3a36:	27 95       	ror	r18
    3a38:	36 95       	lsr	r19
    3a3a:	27 95       	ror	r18
    3a3c:	36 95       	lsr	r19
    3a3e:	27 95       	ror	r18
    3a40:	c9 01       	movw	r24, r18
    3a42:	88 0f       	add	r24, r24
    3a44:	99 1f       	adc	r25, r25
    3a46:	88 0f       	add	r24, r24
    3a48:	99 1f       	adc	r25, r25
    3a4a:	88 0f       	add	r24, r24
    3a4c:	99 1f       	adc	r25, r25
    3a4e:	82 1b       	sub	r24, r18
    3a50:	93 0b       	sbc	r25, r19
    3a52:	01 97       	sbiw	r24, 0x01	; 1
    3a54:	84 0f       	add	r24, r20
    3a56:	91 1d       	adc	r25, r1
    3a58:	08 95       	ret
   else
      return (encoded_length / 8) * 7;
    3a5a:	9c 01       	movw	r18, r24
    3a5c:	36 95       	lsr	r19
    3a5e:	27 95       	ror	r18
    3a60:	36 95       	lsr	r19
    3a62:	27 95       	ror	r18
    3a64:	36 95       	lsr	r19
    3a66:	27 95       	ror	r18
    3a68:	c9 01       	movw	r24, r18
    3a6a:	88 0f       	add	r24, r24
    3a6c:	99 1f       	adc	r25, r25
    3a6e:	88 0f       	add	r24, r24
    3a70:	99 1f       	adc	r25, r25
    3a72:	88 0f       	add	r24, r24
    3a74:	99 1f       	adc	r25, r25
    3a76:	82 1b       	sub	r24, r18
    3a78:	93 0b       	sbc	r25, r19
}
    3a7a:	08 95       	ret

00003a7c <sysex_encode>:

uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
    3a7c:	2f 92       	push	r2
    3a7e:	3f 92       	push	r3
    3a80:	4f 92       	push	r4
    3a82:	5f 92       	push	r5
    3a84:	6f 92       	push	r6
    3a86:	7f 92       	push	r7
    3a88:	8f 92       	push	r8
    3a8a:	9f 92       	push	r9
    3a8c:	af 92       	push	r10
    3a8e:	bf 92       	push	r11
    3a90:	cf 92       	push	r12
    3a92:	df 92       	push	r13
    3a94:	ef 92       	push	r14
    3a96:	ff 92       	push	r15
    3a98:	0f 93       	push	r16
    3a9a:	1f 93       	push	r17
    3a9c:	cf 93       	push	r28
    3a9e:	df 93       	push	r29
    3aa0:	00 d0       	rcall	.+0      	; 0x3aa2 <sysex_encode+0x26>
    3aa2:	00 d0       	rcall	.+0      	; 0x3aa4 <sysex_encode+0x28>
    3aa4:	00 d0       	rcall	.+0      	; 0x3aa6 <sysex_encode+0x2a>
    3aa6:	cd b7       	in	r28, 0x3d	; 61
    3aa8:	de b7       	in	r29, 0x3e	; 62
    3aaa:	1c 01       	movw	r2, r24
    3aac:	7a 83       	std	Y+2, r23	; 0x02
    3aae:	69 83       	std	Y+1, r22	; 0x01
    3ab0:	3a 01       	movw	r6, r20
   uint16_t encoded_full = length / 7; //number of full 8 byte sections from 7 bytes of input
    3ab2:	ca 01       	movw	r24, r20
    3ab4:	67 e0       	ldi	r22, 0x07	; 7
    3ab6:	70 e0       	ldi	r23, 0x00	; 0
    3ab8:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <__udivmodhi4>
    3abc:	2b 01       	movw	r4, r22
    3abe:	5b 01       	movw	r10, r22
   uint16_t i,j;

   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
    3ac0:	61 15       	cp	r22, r1
    3ac2:	71 05       	cpc	r23, r1
    3ac4:	b1 f1       	breq	.+108    	; 0x3b32 <sysex_encode+0xb6>
    3ac6:	81 01       	movw	r16, r2
    3ac8:	e9 80       	ldd	r14, Y+1	; 0x01
    3aca:	fa 80       	ldd	r15, Y+2	; 0x02
    3acc:	cc 24       	eor	r12, r12
    3ace:	dd 24       	eor	r13, r13
      uint16_t encoded_msb_idx = i * 8;
      uint16_t input_start_idx = i * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < 7; j++){
    3ad0:	88 24       	eor	r8, r8
    3ad2:	99 24       	eor	r9, r9
      return (encoded_length / 8) * 7 + remainder - 1;
   else
      return (encoded_length / 8) * 7;
}

uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
    3ad4:	1e 83       	std	Y+6, r17	; 0x06
    3ad6:	0d 83       	std	Y+5, r16	; 0x05

   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t input_start_idx = i * 7;
      encoded[encoded_msb_idx] = 0;
    3ad8:	f8 01       	movw	r30, r16
    3ada:	11 92       	st	Z+, r1
      return (encoded_length / 8) * 7 + remainder - 1;
   else
      return (encoded_length / 8) * 7;
}

uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
    3adc:	fc 82       	std	Y+4, r15	; 0x04
    3ade:	eb 82       	std	Y+3, r14	; 0x03
   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t input_start_idx = i * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < 7; j++){
    3ae0:	a4 01       	movw	r20, r8
         uint8_t current = source[input_start_idx + j];
    3ae2:	ab 81       	ldd	r26, Y+3	; 0x03
    3ae4:	bc 81       	ldd	r27, Y+4	; 0x04
    3ae6:	2d 91       	ld	r18, X+
    3ae8:	bc 83       	std	Y+4, r27	; 0x04
    3aea:	ab 83       	std	Y+3, r26	; 0x03
         encoded[encoded_msb_idx] |= (0x80 & current) >> (1 + j);
    3aec:	4f 5f       	subi	r20, 0xFF	; 255
    3aee:	5f 4f       	sbci	r21, 0xFF	; 255
    3af0:	82 2f       	mov	r24, r18
    3af2:	90 e0       	ldi	r25, 0x00	; 0
    3af4:	80 78       	andi	r24, 0x80	; 128
    3af6:	90 70       	andi	r25, 0x00	; 0
    3af8:	bc 01       	movw	r22, r24
    3afa:	04 2e       	mov	r0, r20
    3afc:	02 c0       	rjmp	.+4      	; 0x3b02 <sysex_encode+0x86>
    3afe:	75 95       	asr	r23
    3b00:	67 95       	ror	r22
    3b02:	0a 94       	dec	r0
    3b04:	e2 f7       	brpl	.-8      	; 0x3afe <sysex_encode+0x82>
    3b06:	ad 81       	ldd	r26, Y+5	; 0x05
    3b08:	be 81       	ldd	r27, Y+6	; 0x06
    3b0a:	8c 91       	ld	r24, X
    3b0c:	86 2b       	or	r24, r22
    3b0e:	8c 93       	st	X, r24
         encoded[encoded_msb_idx + 1 + j] = 0x7F & current;
    3b10:	2f 77       	andi	r18, 0x7F	; 127
    3b12:	21 93       	st	Z+, r18
   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t input_start_idx = i * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < 7; j++){
    3b14:	47 30       	cpi	r20, 0x07	; 7
    3b16:	51 05       	cpc	r21, r1
    3b18:	21 f7       	brne	.-56     	; 0x3ae2 <sysex_encode+0x66>
uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
   uint16_t encoded_full = length / 7; //number of full 8 byte sections from 7 bytes of input
   uint16_t i,j;

   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
    3b1a:	08 94       	sec
    3b1c:	c1 1c       	adc	r12, r1
    3b1e:	d1 1c       	adc	r13, r1
    3b20:	08 5f       	subi	r16, 0xF8	; 248
    3b22:	1f 4f       	sbci	r17, 0xFF	; 255
    3b24:	e7 e0       	ldi	r30, 0x07	; 7
    3b26:	f0 e0       	ldi	r31, 0x00	; 0
    3b28:	ee 0e       	add	r14, r30
    3b2a:	ff 1e       	adc	r15, r31
    3b2c:	ca 14       	cp	r12, r10
    3b2e:	db 04       	cpc	r13, r11
    3b30:	89 f6       	brne	.-94     	; 0x3ad4 <sysex_encode+0x58>
         encoded[encoded_msb_idx + 1 + j] = 0x7F & current;
      }
   }

   //fill out the rest if there is any more
   uint8_t remainder = length % 7;
    3b32:	c3 01       	movw	r24, r6
    3b34:	67 e0       	ldi	r22, 0x07	; 7
    3b36:	70 e0       	ldi	r23, 0x00	; 0
    3b38:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <__udivmodhi4>
   if (remainder) {
    3b3c:	88 23       	and	r24, r24
    3b3e:	d9 f1       	breq	.+118    	; 0x3bb6 <sysex_encode+0x13a>
      uint16_t encoded_msb_idx = encoded_full * 8;
    3b40:	82 01       	movw	r16, r4
    3b42:	00 0f       	add	r16, r16
    3b44:	11 1f       	adc	r17, r17
    3b46:	00 0f       	add	r16, r16
    3b48:	11 1f       	adc	r17, r17
    3b4a:	00 0f       	add	r16, r16
    3b4c:	11 1f       	adc	r17, r17
      uint16_t input_start_idx = encoded_full * 7;
    3b4e:	78 01       	movw	r14, r16
    3b50:	e4 18       	sub	r14, r4
    3b52:	f5 08       	sbc	r15, r5
      encoded[encoded_msb_idx] = 0;
    3b54:	d1 01       	movw	r26, r2
    3b56:	a0 0f       	add	r26, r16
    3b58:	b1 1f       	adc	r27, r17
    3b5a:	1c 92       	st	X, r1
      for(j = 0; j < remainder; j++){
    3b5c:	68 2f       	mov	r22, r24
    3b5e:	70 e0       	ldi	r23, 0x00	; 0
    3b60:	61 15       	cp	r22, r1
    3b62:	71 05       	cpc	r23, r1
    3b64:	19 f1       	breq	.+70     	; 0x3bac <sysex_encode+0x130>
      return (encoded_length / 8) * 7 + remainder - 1;
   else
      return (encoded_length / 8) * 7;
}

uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
    3b66:	e9 81       	ldd	r30, Y+1	; 0x01
    3b68:	fa 81       	ldd	r31, Y+2	; 0x02
    3b6a:	ee 0e       	add	r14, r30
    3b6c:	ff 1e       	adc	r15, r31
    3b6e:	c8 01       	movw	r24, r16
    3b70:	01 96       	adiw	r24, 0x01	; 1
    3b72:	28 0e       	add	r2, r24
    3b74:	39 1e       	adc	r3, r25
   uint8_t remainder = length % 7;
   if (remainder) {
      uint16_t encoded_msb_idx = encoded_full * 8;
      uint16_t input_start_idx = encoded_full * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < remainder; j++){
    3b76:	20 e0       	ldi	r18, 0x00	; 0
    3b78:	30 e0       	ldi	r19, 0x00	; 0
         uint8_t current = source[input_start_idx + j];
    3b7a:	f7 01       	movw	r30, r14
    3b7c:	41 91       	ld	r20, Z+
    3b7e:	7f 01       	movw	r14, r30
         encoded[encoded_msb_idx] |= (0x80 & current) >> (1 + j);
    3b80:	2f 5f       	subi	r18, 0xFF	; 255
    3b82:	3f 4f       	sbci	r19, 0xFF	; 255
    3b84:	84 2f       	mov	r24, r20
    3b86:	90 e0       	ldi	r25, 0x00	; 0
    3b88:	80 78       	andi	r24, 0x80	; 128
    3b8a:	90 70       	andi	r25, 0x00	; 0
    3b8c:	02 2e       	mov	r0, r18
    3b8e:	02 c0       	rjmp	.+4      	; 0x3b94 <sysex_encode+0x118>
    3b90:	95 95       	asr	r25
    3b92:	87 95       	ror	r24
    3b94:	0a 94       	dec	r0
    3b96:	e2 f7       	brpl	.-8      	; 0x3b90 <sysex_encode+0x114>
    3b98:	9c 91       	ld	r25, X
    3b9a:	89 2b       	or	r24, r25
    3b9c:	8c 93       	st	X, r24
         encoded[encoded_msb_idx + 1 + j] = 0x7F & current;
    3b9e:	4f 77       	andi	r20, 0x7F	; 127
    3ba0:	f1 01       	movw	r30, r2
    3ba2:	41 93       	st	Z+, r20
    3ba4:	1f 01       	movw	r2, r30
   uint8_t remainder = length % 7;
   if (remainder) {
      uint16_t encoded_msb_idx = encoded_full * 8;
      uint16_t input_start_idx = encoded_full * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < remainder; j++){
    3ba6:	26 17       	cp	r18, r22
    3ba8:	37 07       	cpc	r19, r23
    3baa:	38 f3       	brcs	.-50     	; 0x3b7a <sysex_encode+0xfe>
         uint8_t current = source[input_start_idx + j];
         encoded[encoded_msb_idx] |= (0x80 & current) >> (1 + j);
         encoded[encoded_msb_idx + 1 + j] = 0x7F & current;
      }
      return encoded_msb_idx + remainder + 1;
    3bac:	c8 01       	movw	r24, r16
    3bae:	01 96       	adiw	r24, 0x01	; 1
    3bb0:	86 0f       	add	r24, r22
    3bb2:	97 1f       	adc	r25, r23
    3bb4:	07 c0       	rjmp	.+14     	; 0x3bc4 <sysex_encode+0x148>
   } else {
      return encoded_full * 8;
    3bb6:	c2 01       	movw	r24, r4
    3bb8:	88 0f       	add	r24, r24
    3bba:	99 1f       	adc	r25, r25
    3bbc:	88 0f       	add	r24, r24
    3bbe:	99 1f       	adc	r25, r25
    3bc0:	88 0f       	add	r24, r24
    3bc2:	99 1f       	adc	r25, r25
   }
}
    3bc4:	26 96       	adiw	r28, 0x06	; 6
    3bc6:	0f b6       	in	r0, 0x3f	; 63
    3bc8:	f8 94       	cli
    3bca:	de bf       	out	0x3e, r29	; 62
    3bcc:	0f be       	out	0x3f, r0	; 63
    3bce:	cd bf       	out	0x3d, r28	; 61
    3bd0:	df 91       	pop	r29
    3bd2:	cf 91       	pop	r28
    3bd4:	1f 91       	pop	r17
    3bd6:	0f 91       	pop	r16
    3bd8:	ff 90       	pop	r15
    3bda:	ef 90       	pop	r14
    3bdc:	df 90       	pop	r13
    3bde:	cf 90       	pop	r12
    3be0:	bf 90       	pop	r11
    3be2:	af 90       	pop	r10
    3be4:	9f 90       	pop	r9
    3be6:	8f 90       	pop	r8
    3be8:	7f 90       	pop	r7
    3bea:	6f 90       	pop	r6
    3bec:	5f 90       	pop	r5
    3bee:	4f 90       	pop	r4
    3bf0:	3f 90       	pop	r3
    3bf2:	2f 90       	pop	r2
    3bf4:	08 95       	ret

00003bf6 <sysex_decode>:

uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
    3bf6:	6f 92       	push	r6
    3bf8:	7f 92       	push	r7
    3bfa:	8f 92       	push	r8
    3bfc:	9f 92       	push	r9
    3bfe:	af 92       	push	r10
    3c00:	bf 92       	push	r11
    3c02:	cf 92       	push	r12
    3c04:	df 92       	push	r13
    3c06:	ef 92       	push	r14
    3c08:	ff 92       	push	r15
    3c0a:	0f 93       	push	r16
    3c0c:	1f 93       	push	r17
    3c0e:	cf 93       	push	r28
    3c10:	df 93       	push	r29
    3c12:	3c 01       	movw	r6, r24
    3c14:	4b 01       	movw	r8, r22
    3c16:	5a 01       	movw	r10, r20
   uint16_t decoded_full = length / 8;
   uint16_t i,j;

   if (length < 2)
    3c18:	42 30       	cpi	r20, 0x02	; 2
    3c1a:	51 05       	cpc	r21, r1
    3c1c:	08 f4       	brcc	.+2      	; 0x3c20 <sysex_decode+0x2a>
    3c1e:	6f c0       	rjmp	.+222    	; 0x3cfe <sysex_decode+0x108>
      return encoded_full * 8;
   }
}

uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
   uint16_t decoded_full = length / 8;
    3c20:	7a 01       	movw	r14, r20
    3c22:	f6 94       	lsr	r15
    3c24:	e7 94       	ror	r14
    3c26:	f6 94       	lsr	r15
    3c28:	e7 94       	ror	r14
    3c2a:	f6 94       	lsr	r15
    3c2c:	e7 94       	ror	r14

   if (length < 2)
      return 0;

   //fill out the fully encoded sections
   for(i = 0; i < decoded_full; i++) {
    3c2e:	e1 14       	cp	r14, r1
    3c30:	f1 04       	cpc	r15, r1
    3c32:	29 f1       	breq	.+74     	; 0x3c7e <sysex_decode+0x88>
    3c34:	eb 01       	movw	r28, r22
    3c36:	b3 01       	movw	r22, r6
    3c38:	00 e0       	ldi	r16, 0x00	; 0
    3c3a:	10 e0       	ldi	r17, 0x00	; 0
      uint16_t encoded_msb_idx = i * 8;
      uint16_t output_start_index = i * 7;
      for(j = 0; j < 7; j++){
    3c3c:	cc 24       	eor	r12, r12
    3c3e:	dd 24       	eor	r13, r13
   } else {
      return encoded_full * 8;
   }
}

uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
    3c40:	de 01       	movw	r26, r28
    3c42:	11 96       	adiw	r26, 0x01	; 1
    3c44:	fb 01       	movw	r30, r22

   //fill out the fully encoded sections
   for(i = 0; i < decoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t output_start_index = i * 7;
      for(j = 0; j < 7; j++){
    3c46:	a6 01       	movw	r20, r12
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
    3c48:	2d 91       	ld	r18, X+
    3c4a:	2f 77       	andi	r18, 0x7F	; 127
    3c4c:	20 83       	st	Z, r18
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
    3c4e:	4f 5f       	subi	r20, 0xFF	; 255
    3c50:	5f 4f       	sbci	r21, 0xFF	; 255
    3c52:	88 81       	ld	r24, Y
    3c54:	90 e0       	ldi	r25, 0x00	; 0
    3c56:	04 2e       	mov	r0, r20
    3c58:	02 c0       	rjmp	.+4      	; 0x3c5e <sysex_decode+0x68>
    3c5a:	88 0f       	add	r24, r24
    3c5c:	99 1f       	adc	r25, r25
    3c5e:	0a 94       	dec	r0
    3c60:	e2 f7       	brpl	.-8      	; 0x3c5a <sysex_decode+0x64>
    3c62:	80 78       	andi	r24, 0x80	; 128
    3c64:	28 2b       	or	r18, r24
    3c66:	21 93       	st	Z+, r18

   //fill out the fully encoded sections
   for(i = 0; i < decoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t output_start_index = i * 7;
      for(j = 0; j < 7; j++){
    3c68:	47 30       	cpi	r20, 0x07	; 7
    3c6a:	51 05       	cpc	r21, r1
    3c6c:	69 f7       	brne	.-38     	; 0x3c48 <sysex_decode+0x52>

   if (length < 2)
      return 0;

   //fill out the fully encoded sections
   for(i = 0; i < decoded_full; i++) {
    3c6e:	0f 5f       	subi	r16, 0xFF	; 255
    3c70:	1f 4f       	sbci	r17, 0xFF	; 255
    3c72:	28 96       	adiw	r28, 0x08	; 8
    3c74:	69 5f       	subi	r22, 0xF9	; 249
    3c76:	7f 4f       	sbci	r23, 0xFF	; 255
    3c78:	0e 15       	cp	r16, r14
    3c7a:	1f 05       	cpc	r17, r15
    3c7c:	09 f7       	brne	.-62     	; 0x3c40 <sysex_decode+0x4a>
      for(j = 0; j < 7; j++){
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
      }
   }
   uint8_t remainder = length % 8;
    3c7e:	5a 2d       	mov	r21, r10
    3c80:	57 70       	andi	r21, 0x07	; 7
   if (remainder) {
    3c82:	99 f1       	breq	.+102    	; 0x3cea <sysex_decode+0xf4>
      uint16_t encoded_msb_idx = decoded_full * 8;
    3c84:	e7 01       	movw	r28, r14
    3c86:	cc 0f       	add	r28, r28
    3c88:	dd 1f       	adc	r29, r29
    3c8a:	cc 0f       	add	r28, r28
    3c8c:	dd 1f       	adc	r29, r29
    3c8e:	cc 0f       	add	r28, r28
    3c90:	dd 1f       	adc	r29, r29
      uint16_t output_start_index = decoded_full * 7;
    3c92:	8e 01       	movw	r16, r28
    3c94:	0e 19       	sub	r16, r14
    3c96:	1f 09       	sbc	r17, r15
      for(j = 0; j < (remainder - 1); j++) {
    3c98:	65 2f       	mov	r22, r21
    3c9a:	70 e0       	ldi	r23, 0x00	; 0
    3c9c:	61 50       	subi	r22, 0x01	; 1
    3c9e:	70 40       	sbci	r23, 0x00	; 0
    3ca0:	f9 f0       	breq	.+62     	; 0x3ce0 <sysex_decode+0xea>
   } else {
      return encoded_full * 8;
   }
}

uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
    3ca2:	ce 01       	movw	r24, r28
    3ca4:	01 96       	adiw	r24, 0x01	; 1
    3ca6:	d4 01       	movw	r26, r8
    3ca8:	a8 0f       	add	r26, r24
    3caa:	b9 1f       	adc	r27, r25
    3cac:	f3 01       	movw	r30, r6
    3cae:	e0 0f       	add	r30, r16
    3cb0:	f1 1f       	adc	r31, r17
   }
   uint8_t remainder = length % 8;
   if (remainder) {
      uint16_t encoded_msb_idx = decoded_full * 8;
      uint16_t output_start_index = decoded_full * 7;
      for(j = 0; j < (remainder - 1); j++) {
    3cb2:	20 e0       	ldi	r18, 0x00	; 0
    3cb4:	30 e0       	ldi	r19, 0x00	; 0
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
    3cb6:	c8 0d       	add	r28, r8
    3cb8:	d9 1d       	adc	r29, r9
   uint8_t remainder = length % 8;
   if (remainder) {
      uint16_t encoded_msb_idx = decoded_full * 8;
      uint16_t output_start_index = decoded_full * 7;
      for(j = 0; j < (remainder - 1); j++) {
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
    3cba:	4d 91       	ld	r20, X+
    3cbc:	4f 77       	andi	r20, 0x7F	; 127
    3cbe:	40 83       	st	Z, r20
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
    3cc0:	2f 5f       	subi	r18, 0xFF	; 255
    3cc2:	3f 4f       	sbci	r19, 0xFF	; 255
    3cc4:	88 81       	ld	r24, Y
    3cc6:	90 e0       	ldi	r25, 0x00	; 0
    3cc8:	02 2e       	mov	r0, r18
    3cca:	02 c0       	rjmp	.+4      	; 0x3cd0 <sysex_decode+0xda>
    3ccc:	88 0f       	add	r24, r24
    3cce:	99 1f       	adc	r25, r25
    3cd0:	0a 94       	dec	r0
    3cd2:	e2 f7       	brpl	.-8      	; 0x3ccc <sysex_decode+0xd6>
    3cd4:	80 78       	andi	r24, 0x80	; 128
    3cd6:	48 2b       	or	r20, r24
    3cd8:	41 93       	st	Z+, r20
   }
   uint8_t remainder = length % 8;
   if (remainder) {
      uint16_t encoded_msb_idx = decoded_full * 8;
      uint16_t output_start_index = decoded_full * 7;
      for(j = 0; j < (remainder - 1); j++) {
    3cda:	26 17       	cp	r18, r22
    3cdc:	37 07       	cpc	r19, r23
    3cde:	68 f3       	brcs	.-38     	; 0x3cba <sysex_decode+0xc4>
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
      }
      return decoded_full * 7 + remainder - 1;
    3ce0:	c8 01       	movw	r24, r16
    3ce2:	01 97       	sbiw	r24, 0x01	; 1
    3ce4:	85 0f       	add	r24, r21
    3ce6:	91 1d       	adc	r25, r1
    3ce8:	0c c0       	rjmp	.+24     	; 0x3d02 <sysex_decode+0x10c>
   } else {
      return decoded_full * 7;
    3cea:	c7 01       	movw	r24, r14
    3cec:	88 0f       	add	r24, r24
    3cee:	99 1f       	adc	r25, r25
    3cf0:	88 0f       	add	r24, r24
    3cf2:	99 1f       	adc	r25, r25
    3cf4:	88 0f       	add	r24, r24
    3cf6:	99 1f       	adc	r25, r25
    3cf8:	8e 19       	sub	r24, r14
    3cfa:	9f 09       	sbc	r25, r15
    3cfc:	02 c0       	rjmp	.+4      	; 0x3d02 <sysex_decode+0x10c>
uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
   uint16_t decoded_full = length / 8;
   uint16_t i,j;

   if (length < 2)
      return 0;
    3cfe:	80 e0       	ldi	r24, 0x00	; 0
    3d00:	90 e0       	ldi	r25, 0x00	; 0
      }
      return decoded_full * 7 + remainder - 1;
   } else {
      return decoded_full * 7;
   }
}
    3d02:	df 91       	pop	r29
    3d04:	cf 91       	pop	r28
    3d06:	1f 91       	pop	r17
    3d08:	0f 91       	pop	r16
    3d0a:	ff 90       	pop	r15
    3d0c:	ef 90       	pop	r14
    3d0e:	df 90       	pop	r13
    3d10:	cf 90       	pop	r12
    3d12:	bf 90       	pop	r11
    3d14:	af 90       	pop	r10
    3d16:	9f 90       	pop	r9
    3d18:	8f 90       	pop	r8
    3d1a:	7f 90       	pop	r7
    3d1c:	6f 90       	pop	r6
    3d1e:	08 95       	ret

00003d20 <__mulsi3>:
    3d20:	62 9f       	mul	r22, r18
    3d22:	d0 01       	movw	r26, r0
    3d24:	73 9f       	mul	r23, r19
    3d26:	f0 01       	movw	r30, r0
    3d28:	82 9f       	mul	r24, r18
    3d2a:	e0 0d       	add	r30, r0
    3d2c:	f1 1d       	adc	r31, r1
    3d2e:	64 9f       	mul	r22, r20
    3d30:	e0 0d       	add	r30, r0
    3d32:	f1 1d       	adc	r31, r1
    3d34:	92 9f       	mul	r25, r18
    3d36:	f0 0d       	add	r31, r0
    3d38:	83 9f       	mul	r24, r19
    3d3a:	f0 0d       	add	r31, r0
    3d3c:	74 9f       	mul	r23, r20
    3d3e:	f0 0d       	add	r31, r0
    3d40:	65 9f       	mul	r22, r21
    3d42:	f0 0d       	add	r31, r0
    3d44:	99 27       	eor	r25, r25
    3d46:	72 9f       	mul	r23, r18
    3d48:	b0 0d       	add	r27, r0
    3d4a:	e1 1d       	adc	r30, r1
    3d4c:	f9 1f       	adc	r31, r25
    3d4e:	63 9f       	mul	r22, r19
    3d50:	b0 0d       	add	r27, r0
    3d52:	e1 1d       	adc	r30, r1
    3d54:	f9 1f       	adc	r31, r25
    3d56:	bd 01       	movw	r22, r26
    3d58:	cf 01       	movw	r24, r30
    3d5a:	11 24       	eor	r1, r1
    3d5c:	08 95       	ret

00003d5e <__udivmodhi4>:
    3d5e:	aa 1b       	sub	r26, r26
    3d60:	bb 1b       	sub	r27, r27
    3d62:	51 e1       	ldi	r21, 0x11	; 17
    3d64:	07 c0       	rjmp	.+14     	; 0x3d74 <__udivmodhi4_ep>

00003d66 <__udivmodhi4_loop>:
    3d66:	aa 1f       	adc	r26, r26
    3d68:	bb 1f       	adc	r27, r27
    3d6a:	a6 17       	cp	r26, r22
    3d6c:	b7 07       	cpc	r27, r23
    3d6e:	10 f0       	brcs	.+4      	; 0x3d74 <__udivmodhi4_ep>
    3d70:	a6 1b       	sub	r26, r22
    3d72:	b7 0b       	sbc	r27, r23

00003d74 <__udivmodhi4_ep>:
    3d74:	88 1f       	adc	r24, r24
    3d76:	99 1f       	adc	r25, r25
    3d78:	5a 95       	dec	r21
    3d7a:	a9 f7       	brne	.-22     	; 0x3d66 <__udivmodhi4_loop>
    3d7c:	80 95       	com	r24
    3d7e:	90 95       	com	r25
    3d80:	bc 01       	movw	r22, r24
    3d82:	cd 01       	movw	r24, r26
    3d84:	08 95       	ret

00003d86 <__divmodhi4>:
    3d86:	97 fb       	bst	r25, 7
    3d88:	09 2e       	mov	r0, r25
    3d8a:	07 26       	eor	r0, r23
    3d8c:	0a d0       	rcall	.+20     	; 0x3da2 <__divmodhi4_neg1>
    3d8e:	77 fd       	sbrc	r23, 7
    3d90:	04 d0       	rcall	.+8      	; 0x3d9a <__divmodhi4_neg2>
    3d92:	e5 df       	rcall	.-54     	; 0x3d5e <__udivmodhi4>
    3d94:	06 d0       	rcall	.+12     	; 0x3da2 <__divmodhi4_neg1>
    3d96:	00 20       	and	r0, r0
    3d98:	1a f4       	brpl	.+6      	; 0x3da0 <__divmodhi4_exit>

00003d9a <__divmodhi4_neg2>:
    3d9a:	70 95       	com	r23
    3d9c:	61 95       	neg	r22
    3d9e:	7f 4f       	sbci	r23, 0xFF	; 255

00003da0 <__divmodhi4_exit>:
    3da0:	08 95       	ret

00003da2 <__divmodhi4_neg1>:
    3da2:	f6 f7       	brtc	.-4      	; 0x3da0 <__divmodhi4_exit>
    3da4:	90 95       	com	r25
    3da6:	81 95       	neg	r24
    3da8:	9f 4f       	sbci	r25, 0xFF	; 255
    3daa:	08 95       	ret

00003dac <__udivmodsi4>:
    3dac:	a1 e2       	ldi	r26, 0x21	; 33
    3dae:	1a 2e       	mov	r1, r26
    3db0:	aa 1b       	sub	r26, r26
    3db2:	bb 1b       	sub	r27, r27
    3db4:	fd 01       	movw	r30, r26
    3db6:	0d c0       	rjmp	.+26     	; 0x3dd2 <__udivmodsi4_ep>

00003db8 <__udivmodsi4_loop>:
    3db8:	aa 1f       	adc	r26, r26
    3dba:	bb 1f       	adc	r27, r27
    3dbc:	ee 1f       	adc	r30, r30
    3dbe:	ff 1f       	adc	r31, r31
    3dc0:	a2 17       	cp	r26, r18
    3dc2:	b3 07       	cpc	r27, r19
    3dc4:	e4 07       	cpc	r30, r20
    3dc6:	f5 07       	cpc	r31, r21
    3dc8:	20 f0       	brcs	.+8      	; 0x3dd2 <__udivmodsi4_ep>
    3dca:	a2 1b       	sub	r26, r18
    3dcc:	b3 0b       	sbc	r27, r19
    3dce:	e4 0b       	sbc	r30, r20
    3dd0:	f5 0b       	sbc	r31, r21

00003dd2 <__udivmodsi4_ep>:
    3dd2:	66 1f       	adc	r22, r22
    3dd4:	77 1f       	adc	r23, r23
    3dd6:	88 1f       	adc	r24, r24
    3dd8:	99 1f       	adc	r25, r25
    3dda:	1a 94       	dec	r1
    3ddc:	69 f7       	brne	.-38     	; 0x3db8 <__udivmodsi4_loop>
    3dde:	60 95       	com	r22
    3de0:	70 95       	com	r23
    3de2:	80 95       	com	r24
    3de4:	90 95       	com	r25
    3de6:	9b 01       	movw	r18, r22
    3de8:	ac 01       	movw	r20, r24
    3dea:	bd 01       	movw	r22, r26
    3dec:	cf 01       	movw	r24, r30
    3dee:	08 95       	ret

00003df0 <do_random>:
    3df0:	a0 e0       	ldi	r26, 0x00	; 0
    3df2:	b0 e0       	ldi	r27, 0x00	; 0
    3df4:	ee ef       	ldi	r30, 0xFE	; 254
    3df6:	fe e1       	ldi	r31, 0x1E	; 30
    3df8:	0c 94 cf 1f 	jmp	0x3f9e	; 0x3f9e <__prologue_saves__+0xc>
    3dfc:	ec 01       	movw	r28, r24
    3dfe:	88 81       	ld	r24, Y
    3e00:	99 81       	ldd	r25, Y+1	; 0x01
    3e02:	aa 81       	ldd	r26, Y+2	; 0x02
    3e04:	bb 81       	ldd	r27, Y+3	; 0x03
    3e06:	00 97       	sbiw	r24, 0x00	; 0
    3e08:	a1 05       	cpc	r26, r1
    3e0a:	b1 05       	cpc	r27, r1
    3e0c:	21 f4       	brne	.+8      	; 0x3e16 <do_random+0x26>
    3e0e:	84 e2       	ldi	r24, 0x24	; 36
    3e10:	99 ed       	ldi	r25, 0xD9	; 217
    3e12:	ab e5       	ldi	r26, 0x5B	; 91
    3e14:	b7 e0       	ldi	r27, 0x07	; 7
    3e16:	bc 01       	movw	r22, r24
    3e18:	cd 01       	movw	r24, r26
    3e1a:	2d e1       	ldi	r18, 0x1D	; 29
    3e1c:	33 ef       	ldi	r19, 0xF3	; 243
    3e1e:	41 e0       	ldi	r20, 0x01	; 1
    3e20:	50 e0       	ldi	r21, 0x00	; 0
    3e22:	0e 94 ae 1f 	call	0x3f5c	; 0x3f5c <__divmodsi4>
    3e26:	49 01       	movw	r8, r18
    3e28:	5a 01       	movw	r10, r20
    3e2a:	27 ea       	ldi	r18, 0xA7	; 167
    3e2c:	31 e4       	ldi	r19, 0x41	; 65
    3e2e:	40 e0       	ldi	r20, 0x00	; 0
    3e30:	50 e0       	ldi	r21, 0x00	; 0
    3e32:	0e 94 90 1e 	call	0x3d20	; 0x3d20 <__mulsi3>
    3e36:	6b 01       	movw	r12, r22
    3e38:	7c 01       	movw	r14, r24
    3e3a:	c5 01       	movw	r24, r10
    3e3c:	b4 01       	movw	r22, r8
    3e3e:	2c ee       	ldi	r18, 0xEC	; 236
    3e40:	34 ef       	ldi	r19, 0xF4	; 244
    3e42:	4f ef       	ldi	r20, 0xFF	; 255
    3e44:	5f ef       	ldi	r21, 0xFF	; 255
    3e46:	0e 94 90 1e 	call	0x3d20	; 0x3d20 <__mulsi3>
    3e4a:	dc 01       	movw	r26, r24
    3e4c:	cb 01       	movw	r24, r22
    3e4e:	c8 0e       	add	r12, r24
    3e50:	d9 1e       	adc	r13, r25
    3e52:	ea 1e       	adc	r14, r26
    3e54:	fb 1e       	adc	r15, r27
    3e56:	f7 fe       	sbrs	r15, 7
    3e58:	08 c0       	rjmp	.+16     	; 0x3e6a <do_random+0x7a>
    3e5a:	8f ef       	ldi	r24, 0xFF	; 255
    3e5c:	9f ef       	ldi	r25, 0xFF	; 255
    3e5e:	af ef       	ldi	r26, 0xFF	; 255
    3e60:	bf e7       	ldi	r27, 0x7F	; 127
    3e62:	c8 0e       	add	r12, r24
    3e64:	d9 1e       	adc	r13, r25
    3e66:	ea 1e       	adc	r14, r26
    3e68:	fb 1e       	adc	r15, r27
    3e6a:	c8 82       	st	Y, r12
    3e6c:	d9 82       	std	Y+1, r13	; 0x01
    3e6e:	ea 82       	std	Y+2, r14	; 0x02
    3e70:	fb 82       	std	Y+3, r15	; 0x03
    3e72:	97 01       	movw	r18, r14
    3e74:	86 01       	movw	r16, r12
    3e76:	3f 77       	andi	r19, 0x7F	; 127
    3e78:	b8 01       	movw	r22, r16
    3e7a:	c9 01       	movw	r24, r18
    3e7c:	cd b7       	in	r28, 0x3d	; 61
    3e7e:	de b7       	in	r29, 0x3e	; 62
    3e80:	ec e0       	ldi	r30, 0x0C	; 12
    3e82:	0c 94 eb 1f 	jmp	0x3fd6	; 0x3fd6 <__epilogue_restores__+0xc>

00003e86 <random_r>:
    3e86:	0e 94 f8 1e 	call	0x3df0	; 0x3df0 <do_random>
    3e8a:	08 95       	ret

00003e8c <random>:
    3e8c:	80 eb       	ldi	r24, 0xB0	; 176
    3e8e:	92 e0       	ldi	r25, 0x02	; 2
    3e90:	0e 94 f8 1e 	call	0x3df0	; 0x3df0 <do_random>
    3e94:	08 95       	ret

00003e96 <srandom>:
    3e96:	dc 01       	movw	r26, r24
    3e98:	cb 01       	movw	r24, r22
    3e9a:	80 93 b0 02 	sts	0x02B0, r24
    3e9e:	90 93 b1 02 	sts	0x02B1, r25
    3ea2:	a0 93 b2 02 	sts	0x02B2, r26
    3ea6:	b0 93 b3 02 	sts	0x02B3, r27
    3eaa:	08 95       	ret

00003eac <memcpy>:
    3eac:	fb 01       	movw	r30, r22
    3eae:	dc 01       	movw	r26, r24
    3eb0:	02 c0       	rjmp	.+4      	; 0x3eb6 <memcpy+0xa>
    3eb2:	01 90       	ld	r0, Z+
    3eb4:	0d 92       	st	X+, r0
    3eb6:	41 50       	subi	r20, 0x01	; 1
    3eb8:	50 40       	sbci	r21, 0x00	; 0
    3eba:	d8 f7       	brcc	.-10     	; 0x3eb2 <memcpy+0x6>
    3ebc:	08 95       	ret

00003ebe <memmove>:
    3ebe:	68 17       	cp	r22, r24
    3ec0:	79 07       	cpc	r23, r25
    3ec2:	68 f4       	brcc	.+26     	; 0x3ede <memmove+0x20>
    3ec4:	fb 01       	movw	r30, r22
    3ec6:	dc 01       	movw	r26, r24
    3ec8:	e4 0f       	add	r30, r20
    3eca:	f5 1f       	adc	r31, r21
    3ecc:	a4 0f       	add	r26, r20
    3ece:	b5 1f       	adc	r27, r21
    3ed0:	02 c0       	rjmp	.+4      	; 0x3ed6 <memmove+0x18>
    3ed2:	02 90       	ld	r0, -Z
    3ed4:	0e 92       	st	-X, r0
    3ed6:	41 50       	subi	r20, 0x01	; 1
    3ed8:	50 40       	sbci	r21, 0x00	; 0
    3eda:	d8 f7       	brcc	.-10     	; 0x3ed2 <memmove+0x14>
    3edc:	08 95       	ret
    3ede:	0c 94 56 1f 	jmp	0x3eac	; 0x3eac <memcpy>

00003ee2 <__eerd_block_m6450a>:
    3ee2:	dc 01       	movw	r26, r24
    3ee4:	cb 01       	movw	r24, r22

00003ee6 <__eerd_blraw_m6450a>:
    3ee6:	fc 01       	movw	r30, r24
    3ee8:	f9 99       	sbic	0x1f, 1	; 31
    3eea:	fe cf       	rjmp	.-4      	; 0x3ee8 <__eerd_blraw_m6450a+0x2>
    3eec:	06 c0       	rjmp	.+12     	; 0x3efa <__eerd_blraw_m6450a+0x14>
    3eee:	f2 bd       	out	0x22, r31	; 34
    3ef0:	e1 bd       	out	0x21, r30	; 33
    3ef2:	f8 9a       	sbi	0x1f, 0	; 31
    3ef4:	31 96       	adiw	r30, 0x01	; 1
    3ef6:	00 b4       	in	r0, 0x20	; 32
    3ef8:	0d 92       	st	X+, r0
    3efa:	41 50       	subi	r20, 0x01	; 1
    3efc:	50 40       	sbci	r21, 0x00	; 0
    3efe:	b8 f7       	brcc	.-18     	; 0x3eee <__eerd_blraw_m6450a+0x8>
    3f00:	08 95       	ret

00003f02 <__eerd_word_m6450a>:
    3f02:	a8 e1       	ldi	r26, 0x18	; 24
    3f04:	b0 e0       	ldi	r27, 0x00	; 0
    3f06:	42 e0       	ldi	r20, 0x02	; 2
    3f08:	50 e0       	ldi	r21, 0x00	; 0
    3f0a:	0c 94 73 1f 	jmp	0x3ee6	; 0x3ee6 <__eerd_blraw_m6450a>

00003f0e <__eeupd_block_m6450a>:
    3f0e:	dc 01       	movw	r26, r24
    3f10:	a4 0f       	add	r26, r20
    3f12:	b5 1f       	adc	r27, r21
    3f14:	41 50       	subi	r20, 0x01	; 1
    3f16:	50 40       	sbci	r21, 0x00	; 0
    3f18:	48 f0       	brcs	.+18     	; 0x3f2c <__eeupd_block_m6450a+0x1e>
    3f1a:	cb 01       	movw	r24, r22
    3f1c:	84 0f       	add	r24, r20
    3f1e:	95 1f       	adc	r25, r21
    3f20:	2e 91       	ld	r18, -X
    3f22:	0e 94 98 1f 	call	0x3f30	; 0x3f30 <__eeupd_r18_m6450a>
    3f26:	41 50       	subi	r20, 0x01	; 1
    3f28:	50 40       	sbci	r21, 0x00	; 0
    3f2a:	d0 f7       	brcc	.-12     	; 0x3f20 <__eeupd_block_m6450a+0x12>
    3f2c:	08 95       	ret

00003f2e <__eeupd_byte_m6450a>:
    3f2e:	26 2f       	mov	r18, r22

00003f30 <__eeupd_r18_m6450a>:
    3f30:	f9 99       	sbic	0x1f, 1	; 31
    3f32:	fe cf       	rjmp	.-4      	; 0x3f30 <__eeupd_r18_m6450a>
    3f34:	92 bd       	out	0x22, r25	; 34
    3f36:	81 bd       	out	0x21, r24	; 33
    3f38:	f8 9a       	sbi	0x1f, 0	; 31
    3f3a:	01 97       	sbiw	r24, 0x01	; 1
    3f3c:	00 b4       	in	r0, 0x20	; 32
    3f3e:	02 16       	cp	r0, r18
    3f40:	31 f0       	breq	.+12     	; 0x3f4e <__eeupd_r18_m6450a+0x1e>
    3f42:	20 bd       	out	0x20, r18	; 32
    3f44:	0f b6       	in	r0, 0x3f	; 63
    3f46:	f8 94       	cli
    3f48:	fa 9a       	sbi	0x1f, 2	; 31
    3f4a:	f9 9a       	sbi	0x1f, 1	; 31
    3f4c:	0f be       	out	0x3f, r0	; 63
    3f4e:	08 95       	ret

00003f50 <__eeupd_word_m6450a>:
    3f50:	01 96       	adiw	r24, 0x01	; 1
    3f52:	27 2f       	mov	r18, r23
    3f54:	0e 94 98 1f 	call	0x3f30	; 0x3f30 <__eeupd_r18_m6450a>
    3f58:	0c 94 97 1f 	jmp	0x3f2e	; 0x3f2e <__eeupd_byte_m6450a>

00003f5c <__divmodsi4>:
    3f5c:	97 fb       	bst	r25, 7
    3f5e:	09 2e       	mov	r0, r25
    3f60:	05 26       	eor	r0, r21
    3f62:	0e d0       	rcall	.+28     	; 0x3f80 <__divmodsi4_neg1>
    3f64:	57 fd       	sbrc	r21, 7
    3f66:	04 d0       	rcall	.+8      	; 0x3f70 <__divmodsi4_neg2>
    3f68:	21 df       	rcall	.-446    	; 0x3dac <__udivmodsi4>
    3f6a:	0a d0       	rcall	.+20     	; 0x3f80 <__divmodsi4_neg1>
    3f6c:	00 1c       	adc	r0, r0
    3f6e:	38 f4       	brcc	.+14     	; 0x3f7e <__divmodsi4_exit>

00003f70 <__divmodsi4_neg2>:
    3f70:	50 95       	com	r21
    3f72:	40 95       	com	r20
    3f74:	30 95       	com	r19
    3f76:	21 95       	neg	r18
    3f78:	3f 4f       	sbci	r19, 0xFF	; 255
    3f7a:	4f 4f       	sbci	r20, 0xFF	; 255
    3f7c:	5f 4f       	sbci	r21, 0xFF	; 255

00003f7e <__divmodsi4_exit>:
    3f7e:	08 95       	ret

00003f80 <__divmodsi4_neg1>:
    3f80:	f6 f7       	brtc	.-4      	; 0x3f7e <__divmodsi4_exit>
    3f82:	90 95       	com	r25
    3f84:	80 95       	com	r24
    3f86:	70 95       	com	r23
    3f88:	61 95       	neg	r22
    3f8a:	7f 4f       	sbci	r23, 0xFF	; 255
    3f8c:	8f 4f       	sbci	r24, 0xFF	; 255
    3f8e:	9f 4f       	sbci	r25, 0xFF	; 255
    3f90:	08 95       	ret

00003f92 <__prologue_saves__>:
    3f92:	2f 92       	push	r2
    3f94:	3f 92       	push	r3
    3f96:	4f 92       	push	r4
    3f98:	5f 92       	push	r5
    3f9a:	6f 92       	push	r6
    3f9c:	7f 92       	push	r7
    3f9e:	8f 92       	push	r8
    3fa0:	9f 92       	push	r9
    3fa2:	af 92       	push	r10
    3fa4:	bf 92       	push	r11
    3fa6:	cf 92       	push	r12
    3fa8:	df 92       	push	r13
    3faa:	ef 92       	push	r14
    3fac:	ff 92       	push	r15
    3fae:	0f 93       	push	r16
    3fb0:	1f 93       	push	r17
    3fb2:	cf 93       	push	r28
    3fb4:	df 93       	push	r29
    3fb6:	cd b7       	in	r28, 0x3d	; 61
    3fb8:	de b7       	in	r29, 0x3e	; 62
    3fba:	ca 1b       	sub	r28, r26
    3fbc:	db 0b       	sbc	r29, r27
    3fbe:	0f b6       	in	r0, 0x3f	; 63
    3fc0:	f8 94       	cli
    3fc2:	de bf       	out	0x3e, r29	; 62
    3fc4:	0f be       	out	0x3f, r0	; 63
    3fc6:	cd bf       	out	0x3d, r28	; 61
    3fc8:	09 94       	ijmp

00003fca <__epilogue_restores__>:
    3fca:	2a 88       	ldd	r2, Y+18	; 0x12
    3fcc:	39 88       	ldd	r3, Y+17	; 0x11
    3fce:	48 88       	ldd	r4, Y+16	; 0x10
    3fd0:	5f 84       	ldd	r5, Y+15	; 0x0f
    3fd2:	6e 84       	ldd	r6, Y+14	; 0x0e
    3fd4:	7d 84       	ldd	r7, Y+13	; 0x0d
    3fd6:	8c 84       	ldd	r8, Y+12	; 0x0c
    3fd8:	9b 84       	ldd	r9, Y+11	; 0x0b
    3fda:	aa 84       	ldd	r10, Y+10	; 0x0a
    3fdc:	b9 84       	ldd	r11, Y+9	; 0x09
    3fde:	c8 84       	ldd	r12, Y+8	; 0x08
    3fe0:	df 80       	ldd	r13, Y+7	; 0x07
    3fe2:	ee 80       	ldd	r14, Y+6	; 0x06
    3fe4:	fd 80       	ldd	r15, Y+5	; 0x05
    3fe6:	0c 81       	ldd	r16, Y+4	; 0x04
    3fe8:	1b 81       	ldd	r17, Y+3	; 0x03
    3fea:	aa 81       	ldd	r26, Y+2	; 0x02
    3fec:	b9 81       	ldd	r27, Y+1	; 0x01
    3fee:	ce 0f       	add	r28, r30
    3ff0:	d1 1d       	adc	r29, r1
    3ff2:	0f b6       	in	r0, 0x3f	; 63
    3ff4:	f8 94       	cli
    3ff6:	de bf       	out	0x3e, r29	; 62
    3ff8:	0f be       	out	0x3f, r0	; 63
    3ffa:	cd bf       	out	0x3d, r28	; 61
    3ffc:	ed 01       	movw	r28, r26
    3ffe:	08 95       	ret

00004000 <_exit>:
    4000:	f8 94       	cli

00004002 <__stop_program>:
    4002:	ff cf       	rjmp	.-2      	; 0x4002 <__stop_program>
