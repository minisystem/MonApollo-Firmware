
monapollo-firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001b4  00800100  00003f60  00004014  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003f60  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000218  008002b4  008002b4  000041c8  2**0
                  ALLOC
  3 .eeprom       00000674  00810000  00810000  000041c8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00000bf4  00000000  00000000  0000483c  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      0000033e  00000000  00000000  00005430  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 000003b8  00000000  00000000  00005770  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00007092  00000000  00000000  00005b28  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000019e5  00000000  00000000  0000cbba  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000024cb  00000000  00000000  0000e59f  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000e20  00000000  00000000  00010a6c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001a25  00000000  00000000  0001188c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00003006  00000000  00000000  000132b1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000138  00000000  00000000  000162b7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 32 00 	jmp	0x64	; 0x64 <__ctors_end>
       4:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
       8:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
       c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      10:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      14:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      18:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      1c:	0c 94 95 03 	jmp	0x72a	; 0x72a <__vector_7>
      20:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      24:	0c 94 89 03 	jmp	0x712	; 0x712 <__vector_9>
      28:	0c 94 4a 03 	jmp	0x694	; 0x694 <__vector_10>
      2c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      30:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      34:	0c 94 91 04 	jmp	0x922	; 0x922 <__vector_13>
      38:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      3c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      40:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      44:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      48:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      4c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      50:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      54:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      58:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      5c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      60:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>

00000064 <__ctors_end>:
      64:	11 24       	eor	r1, r1
      66:	1f be       	out	0x3f, r1	; 63
      68:	cf ef       	ldi	r28, 0xFF	; 255
      6a:	d0 e1       	ldi	r29, 0x10	; 16
      6c:	de bf       	out	0x3e, r29	; 62
      6e:	cd bf       	out	0x3d, r28	; 61

00000070 <__do_copy_data>:
      70:	12 e0       	ldi	r17, 0x02	; 2
      72:	a0 e0       	ldi	r26, 0x00	; 0
      74:	b1 e0       	ldi	r27, 0x01	; 1
      76:	e0 e6       	ldi	r30, 0x60	; 96
      78:	ff e3       	ldi	r31, 0x3F	; 63
      7a:	02 c0       	rjmp	.+4      	; 0x80 <__do_copy_data+0x10>
      7c:	05 90       	lpm	r0, Z+
      7e:	0d 92       	st	X+, r0
      80:	a4 3b       	cpi	r26, 0xB4	; 180
      82:	b1 07       	cpc	r27, r17
      84:	d9 f7       	brne	.-10     	; 0x7c <__do_copy_data+0xc>

00000086 <__do_clear_bss>:
      86:	14 e0       	ldi	r17, 0x04	; 4
      88:	a4 eb       	ldi	r26, 0xB4	; 180
      8a:	b2 e0       	ldi	r27, 0x02	; 2
      8c:	01 c0       	rjmp	.+2      	; 0x90 <.do_clear_bss_start>

0000008e <.do_clear_bss_loop>:
      8e:	1d 92       	st	X+, r1

00000090 <.do_clear_bss_start>:
      90:	ac 3c       	cpi	r26, 0xCC	; 204
      92:	b1 07       	cpc	r27, r17
      94:	e1 f7       	brne	.-8      	; 0x8e <.do_clear_bss_loop>
      96:	0e 94 c6 04 	call	0x98c	; 0x98c <main>
      9a:	0c 94 ae 1f 	jmp	0x3f5c	; 0x3f5c <_exit>

0000009e <__bad_interrupt>:
      9e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a2 <setup_adc>:

void setup_adc(void)
{
	//ADCSRA |= (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0); //set ADC clock to 156.25 KHz for 20 MHz clock
	//ADCSRA |= (1<<ADPS2) | (1<<ADPS1); //set ADC clock to 312.5 KHz for 20 MHz clock
	ADCSRA |= (1<<ADPS2);// | (1<<ADPS0); //set ADC clock to 1.25 MHz for 20 MHz clock
      a2:	ea e7       	ldi	r30, 0x7A	; 122
      a4:	f0 e0       	ldi	r31, 0x00	; 0
      a6:	80 81       	ld	r24, Z
      a8:	84 60       	ori	r24, 0x04	; 4
      aa:	80 83       	st	Z, r24
	ADMUX |= (1<<REFS0); //set ADC reference to AVCC (+5V)
      ac:	ac e7       	ldi	r26, 0x7C	; 124
      ae:	b0 e0       	ldi	r27, 0x00	; 0
      b0:	8c 91       	ld	r24, X
      b2:	80 64       	ori	r24, 0x40	; 64
      b4:	8c 93       	st	X, r24
	
	DIDR0 |= 0x01; //disable digital input buffer for ADC0
      b6:	ae e7       	ldi	r26, 0x7E	; 126
      b8:	b0 e0       	ldi	r27, 0x00	; 0
      ba:	8c 91       	ld	r24, X
      bc:	81 60       	ori	r24, 0x01	; 1
      be:	8c 93       	st	X, r24
	
	ADCSRA |= (1<<ADEN); //enable ADC
      c0:	80 81       	ld	r24, Z
      c2:	80 68       	ori	r24, 0x80	; 128
      c4:	80 83       	st	Z, r24
}
      c6:	08 95       	ret

000000c8 <read_pot>:

uint16_t read_pot(struct potentiometer *pot) {
      c8:	fc 01       	movw	r30, r24
	
	DATA_BUS = pot->channel;
      ca:	83 81       	ldd	r24, Z+3	; 0x03
      cc:	8f 70       	andi	r24, 0x0F	; 15
      ce:	82 b9       	out	0x02, r24	; 2
	POT_MUX &= ~(1<<pot->mux_addr);
      d0:	aa ed       	ldi	r26, 0xDA	; 218
      d2:	b0 e0       	ldi	r27, 0x00	; 0
      d4:	4c 91       	ld	r20, X
      d6:	83 81       	ldd	r24, Z+3	; 0x03
      d8:	82 95       	swap	r24
      da:	8f 70       	andi	r24, 0x0F	; 15
      dc:	87 70       	andi	r24, 0x07	; 7
      de:	21 e0       	ldi	r18, 0x01	; 1
      e0:	30 e0       	ldi	r19, 0x00	; 0
      e2:	b9 01       	movw	r22, r18
      e4:	02 c0       	rjmp	.+4      	; 0xea <read_pot+0x22>
      e6:	66 0f       	add	r22, r22
      e8:	77 1f       	adc	r23, r23
      ea:	8a 95       	dec	r24
      ec:	e2 f7       	brpl	.-8      	; 0xe6 <read_pot+0x1e>
      ee:	cb 01       	movw	r24, r22
      f0:	80 95       	com	r24
      f2:	84 23       	and	r24, r20
      f4:	8c 93       	st	X, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
      f6:	7d e0       	ldi	r23, 0x0D	; 13
      f8:	7a 95       	dec	r23
      fa:	f1 f7       	brne	.-4      	; 0xf8 <read_pot+0x30>
      fc:	00 00       	nop
	_delay_us(2); //ADC settling time. Previously used 10 us, testing 2 us now. Now testing 1 us. See how it sounds. Nope. Needs to 2 us minimum to prevent crosstalk between multiplexer channels
	ADCSRA |= (1<<ADSC); //start ADC conversion
      fe:	aa e7       	ldi	r26, 0x7A	; 122
     100:	b0 e0       	ldi	r27, 0x00	; 0
     102:	8c 91       	ld	r24, X
     104:	80 64       	ori	r24, 0x40	; 64
     106:	8c 93       	st	X, r24
	while ((ADCSRA & (1<<ADSC))); //wait for ADC conversion to complete (13 cycles of ADC clock - 10.4 us for 1.25Mhz clock) - need to figure out what to do with this time - would interrupt be more efficient?
     108:	8c 91       	ld	r24, X
     10a:	86 fd       	sbrc	r24, 6
     10c:	fd cf       	rjmp	.-6      	; 0x108 <read_pot+0x40>
	POT_MUX |= (1<<pot->mux_addr); //disable pot multiplexer
     10e:	aa ed       	ldi	r26, 0xDA	; 218
     110:	b0 e0       	ldi	r27, 0x00	; 0
     112:	4c 91       	ld	r20, X
     114:	83 81       	ldd	r24, Z+3	; 0x03
     116:	82 95       	swap	r24
     118:	8f 70       	andi	r24, 0x0F	; 15
     11a:	87 70       	andi	r24, 0x07	; 7
     11c:	21 e0       	ldi	r18, 0x01	; 1
     11e:	30 e0       	ldi	r19, 0x00	; 0
     120:	b9 01       	movw	r22, r18
     122:	02 c0       	rjmp	.+4      	; 0x128 <read_pot+0x60>
     124:	66 0f       	add	r22, r22
     126:	77 1f       	adc	r23, r23
     128:	8a 95       	dec	r24
     12a:	e2 f7       	brpl	.-8      	; 0x124 <read_pot+0x5c>
     12c:	cb 01       	movw	r24, r22
     12e:	84 2b       	or	r24, r20
     130:	8c 93       	st	X, r24
	//note that ADSC reads HIGH as long as conversion is in progress, goes LOW when conversion is complete
			
			
	uint16_t adc_read = ADCL;
     132:	80 91 78 00 	lds	r24, 0x0078
     136:	90 e0       	ldi	r25, 0x00	; 0
	adc_read = adc_read | (ADCH <<8);
     138:	40 91 79 00 	lds	r20, 0x0079
     13c:	34 2f       	mov	r19, r20
     13e:	20 e0       	ldi	r18, 0x00	; 0
     140:	82 2b       	or	r24, r18
     142:	93 2b       	or	r25, r19
			
	return adc_read;
     144:	08 95       	ret

00000146 <update_arp_sequence>:
//#include "display.h"

struct arp arp;


void update_arp_sequence(void) {
     146:	4f 92       	push	r4
     148:	5f 92       	push	r5
     14a:	6f 92       	push	r6
     14c:	7f 92       	push	r7
     14e:	8f 92       	push	r8
     150:	9f 92       	push	r9
     152:	af 92       	push	r10
     154:	bf 92       	push	r11
     156:	cf 92       	push	r12
     158:	df 92       	push	r13
     15a:	ef 92       	push	r14
     15c:	ff 92       	push	r15
     15e:	0f 93       	push	r16
     160:	1f 93       	push	r17
     162:	cf 93       	push	r28
     164:	df 93       	push	r29
	


	arp.step_number = gate_buffer*(arp.range + 1);
     166:	90 91 88 03 	lds	r25, 0x0388
     16a:	9f 5f       	subi	r25, 0xFF	; 255
     16c:	80 91 b4 02 	lds	r24, 0x02B4
     170:	98 9f       	mul	r25, r24
     172:	80 2d       	mov	r24, r0
     174:	11 24       	eor	r1, r1
     176:	80 93 89 03 	sts	0x0389, r24
     17a:	88 24       	eor	r8, r8
     17c:	99 24       	eor	r9, r9
	//arp.step_position = 0; //would use this if note retrigger feature was added
	
	uint8_t step = 0;
	
	//set arp sequence
	for (int range = 0; range <= arp.range; range++) {
     17e:	66 24       	eor	r6, r6
     180:	77 24       	eor	r7, r7


	arp.step_number = gate_buffer*(arp.range + 1);
	//arp.step_position = 0; //would use this if note retrigger feature was added
	
	uint8_t step = 0;
     182:	ff 24       	eor	r15, r15
					break;
					
				case DOWN:
					
					 //handle min note out of range here
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
     184:	44 24       	eor	r4, r4
     186:	55 24       	eor	r5, r5
		for (int i = 0; i < gate_buffer; i++) { // NOTE < rather than <= - <= was causing extra iteration that was over incrementing step!!!!!
			
			uint8_t root_note = get_indexed_note(gate_buffer - i - 1); //need to get notes in reverse order out of note pool
			//uint8_t root_note = get_indexed_note(i);
				
			switch(arp.mode) {
     188:	0f 2e       	mov	r0, r31
     18a:	f2 e9       	ldi	r31, 0x92	; 146
     18c:	cf 2e       	mov	r12, r31
     18e:	f3 e0       	ldi	r31, 0x03	; 3
     190:	df 2e       	mov	r13, r31
     192:	f0 2d       	mov	r31, r0
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
						
						root_note += 12;
						
					}
					arp.sequence[step++].note = root_note - (range*12);
     194:	0f 2e       	mov	r0, r31
     196:	f8 e8       	ldi	r31, 0x88	; 136
     198:	af 2e       	mov	r10, r31
     19a:	f3 e0       	ldi	r31, 0x03	; 3
     19c:	bf 2e       	mov	r11, r31
     19e:	f0 2d       	mov	r31, r0
     1a0:	4a c0       	rjmp	.+148    	; 0x236 <update_arp_sequence+0xf0>
	//set arp sequence
	for (int range = 0; range <= arp.range; range++) {
			
		for (int i = 0; i < gate_buffer; i++) { // NOTE < rather than <= - <= was causing extra iteration that was over incrementing step!!!!!
			
			uint8_t root_note = get_indexed_note(gate_buffer - i - 1); //need to get notes in reverse order out of note pool
     1a2:	81 50       	subi	r24, 0x01	; 1
     1a4:	80 1b       	sub	r24, r16
     1a6:	0e 94 85 01 	call	0x30a	; 0x30a <get_indexed_note>
     1aa:	28 2f       	mov	r18, r24
			//uint8_t root_note = get_indexed_note(i);
				
			switch(arp.mode) {
     1ac:	f6 01       	movw	r30, r12
     1ae:	80 81       	ld	r24, Z
     1b0:	82 30       	cpi	r24, 0x02	; 2
     1b2:	41 f0       	breq	.+16     	; 0x1c4 <update_arp_sequence+0x7e>
     1b4:	83 30       	cpi	r24, 0x03	; 3
     1b6:	18 f4       	brcc	.+6      	; 0x1be <update_arp_sequence+0x78>
     1b8:	81 30       	cpi	r24, 0x01	; 1
     1ba:	39 f5       	brne	.+78     	; 0x20a <update_arp_sequence+0xc4>
     1bc:	0a c0       	rjmp	.+20     	; 0x1d2 <update_arp_sequence+0x8c>
     1be:	85 30       	cpi	r24, 0x05	; 5
     1c0:	20 f5       	brcc	.+72     	; 0x20a <update_arp_sequence+0xc4>
     1c2:	07 c0       	rjmp	.+14     	; 0x1d2 <update_arp_sequence+0x8c>
					break;
					
				case DOWN:
					
					 //handle min note out of range here
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
     1c4:	ce 01       	movw	r24, r28
     1c6:	82 0f       	add	r24, r18
     1c8:	91 1d       	adc	r25, r1
     1ca:	88 30       	cpi	r24, 0x08	; 8
     1cc:	91 05       	cpc	r25, r1
     1ce:	64 f0       	brlt	.+24     	; 0x1e8 <update_arp_sequence+0xa2>
     1d0:	12 c0       	rjmp	.+36     	; 0x1f6 <update_arp_sequence+0xb0>
			switch(arp.mode) {
				
				case UP:
				case UP_DOWN:
				case RANDOM:
					arp.sequence[step++].note = root_note + (range*12); //will need to handle max note out of range here
     1d2:	8f 2d       	mov	r24, r15
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	88 0f       	add	r24, r24
     1d8:	99 1f       	adc	r25, r25
     1da:	8a 0d       	add	r24, r10
     1dc:	9b 1d       	adc	r25, r11
     1de:	2e 19       	sub	r18, r14
     1e0:	fc 01       	movw	r30, r24
     1e2:	23 87       	std	Z+11, r18	; 0x0b
     1e4:	f3 94       	inc	r15
				
					break;
     1e6:	11 c0       	rjmp	.+34     	; 0x20a <update_arp_sequence+0xc4>
				case DOWN:
					
					 //handle min note out of range here
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
						
						root_note += 12;
     1e8:	24 5f       	subi	r18, 0xF4	; 244
					break;
					
				case DOWN:
					
					 //handle min note out of range here
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
     1ea:	ce 01       	movw	r24, r28
     1ec:	82 0f       	add	r24, r18
     1ee:	91 1d       	adc	r25, r1
     1f0:	88 30       	cpi	r24, 0x08	; 8
     1f2:	91 05       	cpc	r25, r1
     1f4:	cc f3       	brlt	.-14     	; 0x1e8 <update_arp_sequence+0xa2>
						
						root_note += 12;
						
					}
					arp.sequence[step++].note = root_note - (range*12);
     1f6:	8f 2d       	mov	r24, r15
     1f8:	90 e0       	ldi	r25, 0x00	; 0
     1fa:	88 0f       	add	r24, r24
     1fc:	99 1f       	adc	r25, r25
     1fe:	8a 0d       	add	r24, r10
     200:	9b 1d       	adc	r25, r11
     202:	2e 0d       	add	r18, r14
     204:	fc 01       	movw	r30, r24
     206:	23 87       	std	Z+11, r18	; 0x0b
     208:	f3 94       	inc	r15
	uint8_t step = 0;
	
	//set arp sequence
	for (int range = 0; range <= arp.range; range++) {
			
		for (int i = 0; i < gate_buffer; i++) { // NOTE < rather than <= - <= was causing extra iteration that was over incrementing step!!!!!
     20a:	0f 5f       	subi	r16, 0xFF	; 255
     20c:	1f 4f       	sbci	r17, 0xFF	; 255
     20e:	80 91 b4 02 	lds	r24, 0x02B4
     212:	28 2f       	mov	r18, r24
     214:	30 e0       	ldi	r19, 0x00	; 0
     216:	02 17       	cp	r16, r18
     218:	13 07       	cpc	r17, r19
     21a:	1c f2       	brlt	.-122    	; 0x1a2 <update_arp_sequence+0x5c>
	//arp.step_position = 0; //would use this if note retrigger feature was added
	
	uint8_t step = 0;
	
	//set arp sequence
	for (int range = 0; range <= arp.range; range++) {
     21c:	08 94       	sec
     21e:	61 1c       	adc	r6, r1
     220:	71 1c       	adc	r7, r1
     222:	84 ef       	ldi	r24, 0xF4	; 244
     224:	9f ef       	ldi	r25, 0xFF	; 255
     226:	88 0e       	add	r8, r24
     228:	99 1e       	adc	r9, r25
     22a:	f5 01       	movw	r30, r10
     22c:	80 81       	ld	r24, Z
     22e:	90 e0       	ldi	r25, 0x00	; 0
     230:	86 15       	cp	r24, r6
     232:	97 05       	cpc	r25, r7
     234:	44 f0       	brlt	.+16     	; 0x246 <update_arp_sequence+0x100>
			
		for (int i = 0; i < gate_buffer; i++) { // NOTE < rather than <= - <= was causing extra iteration that was over incrementing step!!!!!
     236:	80 91 b4 02 	lds	r24, 0x02B4
     23a:	88 23       	and	r24, r24
     23c:	79 f3       	breq	.-34     	; 0x21c <update_arp_sequence+0xd6>
//#include "display.h"

struct arp arp;


void update_arp_sequence(void) {
     23e:	e8 2c       	mov	r14, r8
					break;
					
				case DOWN:
					
					 //handle min note out of range here
					while (((int)root_note - (range*12)) < MIN_NOTE) { //tested
     240:	e4 01       	movw	r28, r8
     242:	82 01       	movw	r16, r4
     244:	ae cf       	rjmp	.-164    	; 0x1a2 <update_arp_sequence+0x5c>
		//value_to_display = step;

	}
	
	
}
     246:	df 91       	pop	r29
     248:	cf 91       	pop	r28
     24a:	1f 91       	pop	r17
     24c:	0f 91       	pop	r16
     24e:	ff 90       	pop	r15
     250:	ef 90       	pop	r14
     252:	df 90       	pop	r13
     254:	cf 90       	pop	r12
     256:	bf 90       	pop	r11
     258:	af 90       	pop	r10
     25a:	9f 90       	pop	r9
     25c:	8f 90       	pop	r8
     25e:	7f 90       	pop	r7
     260:	6f 90       	pop	r6
     262:	5f 90       	pop	r5
     264:	4f 90       	pop	r4
     266:	08 95       	ret

00000268 <step_arp_note>:

void step_arp_note(void) { //updates arp note according to step position in sequence
	
	arp.current_note = arp.sequence[arp.step_position].note;
     268:	90 91 8a 03 	lds	r25, 0x038A
     26c:	a9 2f       	mov	r26, r25
     26e:	b0 e0       	ldi	r27, 0x00	; 0
     270:	e8 e8       	ldi	r30, 0x88	; 136
     272:	f3 e0       	ldi	r31, 0x03	; 3
     274:	aa 0f       	add	r26, r26
     276:	bb 1f       	adc	r27, r27
     278:	ae 0f       	add	r26, r30
     27a:	bf 1f       	adc	r27, r31
     27c:	1b 96       	adiw	r26, 0x0b	; 11
     27e:	8c 91       	ld	r24, X
     280:	1b 97       	sbiw	r26, 0x0b	; 11
     282:	85 83       	std	Z+5, r24	; 0x05
	arp.previous_note = arp.current_note;
     284:	84 83       	std	Z+4, r24	; 0x04
	
	switch (arp.mode) {
     286:	82 85       	ldd	r24, Z+10	; 0x0a
     288:	83 30       	cpi	r24, 0x03	; 3
     28a:	19 f0       	breq	.+6      	; 0x292 <step_arp_note+0x2a>
     28c:	84 30       	cpi	r24, 0x04	; 4
     28e:	99 f5       	brne	.+102    	; 0x2f6 <step_arp_note+0x8e>
     290:	28 c0       	rjmp	.+80     	; 0x2e2 <step_arp_note+0x7a>
		
		case UP_DOWN:
			
			if (arp.direction == UP) {
     292:	80 91 8b 03 	lds	r24, 0x038B
     296:	81 30       	cpi	r24, 0x01	; 1
     298:	91 f4       	brne	.+36     	; 0x2be <step_arp_note+0x56>
				arp.step_position++;	
     29a:	9f 5f       	subi	r25, 0xFF	; 255
     29c:	90 93 8a 03 	sts	0x038A, r25
				
				if (arp.step_position >= arp.step_number) {
     2a0:	80 91 89 03 	lds	r24, 0x0389
     2a4:	98 17       	cp	r25, r24
     2a6:	80 f1       	brcs	.+96     	; 0x308 <step_arp_note+0xa0>
					arp.step_position = arp.step_number == 1 ? 0 : arp.step_number - 2; //Omar handles edge case here
     2a8:	81 30       	cpi	r24, 0x01	; 1
     2aa:	11 f0       	breq	.+4      	; 0x2b0 <step_arp_note+0x48>
     2ac:	82 50       	subi	r24, 0x02	; 2
     2ae:	01 c0       	rjmp	.+2      	; 0x2b2 <step_arp_note+0x4a>
     2b0:	80 e0       	ldi	r24, 0x00	; 0
     2b2:	80 93 8a 03 	sts	0x038A, r24
					arp.direction = DOWN;
     2b6:	82 e0       	ldi	r24, 0x02	; 2
     2b8:	80 93 8b 03 	sts	0x038B, r24
     2bc:	08 95       	ret
				}				
				
			} else {
				if (arp.step_position <= 0) {
     2be:	99 23       	and	r25, r25
     2c0:	61 f4       	brne	.+24     	; 0x2da <step_arp_note+0x72>
					
					arp.step_position = arp.step_number == 1 ? 0 : 1; //Omar handles edge case here
     2c2:	81 e0       	ldi	r24, 0x01	; 1
     2c4:	90 91 89 03 	lds	r25, 0x0389
     2c8:	91 30       	cpi	r25, 0x01	; 1
     2ca:	09 f4       	brne	.+2      	; 0x2ce <step_arp_note+0x66>
     2cc:	80 e0       	ldi	r24, 0x00	; 0
     2ce:	80 93 8a 03 	sts	0x038A, r24
					arp.direction = UP;
     2d2:	81 e0       	ldi	r24, 0x01	; 1
     2d4:	80 93 8b 03 	sts	0x038B, r24
     2d8:	08 95       	ret
					
				} else {
					arp.step_position--;
     2da:	91 50       	subi	r25, 0x01	; 1
     2dc:	90 93 8a 03 	sts	0x038A, r25
     2e0:	08 95       	ret
			
			break;
			
		case RANDOM:
		
			arp.step_position = random() % arp.step_number;
     2e2:	0e 94 d2 1e 	call	0x3da4	; 0x3da4 <random>
     2e6:	60 91 89 03 	lds	r22, 0x0389
     2ea:	70 e0       	ldi	r23, 0x00	; 0
     2ec:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <__divmodhi4>
     2f0:	80 93 8a 03 	sts	0x038A, r24
		
			break;
     2f4:	08 95       	ret
			
		default:
		
			if (++arp.step_position >= arp.step_number) arp.step_position  = 0;//reset step position when at end of sequence 
     2f6:	9f 5f       	subi	r25, 0xFF	; 255
     2f8:	90 93 8a 03 	sts	0x038A, r25
     2fc:	80 91 89 03 	lds	r24, 0x0389
     300:	98 17       	cp	r25, r24
     302:	10 f0       	brcs	.+4      	; 0x308 <step_arp_note+0xa0>
     304:	10 92 8a 03 	sts	0x038A, r1
     308:	08 95       	ret

0000030a <get_indexed_note>:

static uint8_t current_note = 0; //this acts as a buffer for the current note to maintain pitch during release stage of envelopes

uint8_t get_indexed_note(uint8_t index) {
	
	return note_pool[index].note;
     30a:	e8 2f       	mov	r30, r24
     30c:	f0 e0       	ldi	r31, 0x00	; 0
     30e:	ee 0f       	add	r30, r30
     310:	ff 1f       	adc	r31, r31
     312:	e8 54       	subi	r30, 0x48	; 72
     314:	fe 4f       	sbci	r31, 0xFE	; 254
	
	
	
}
     316:	80 81       	ld	r24, Z
     318:	08 95       	ret

0000031a <get_current_note>:
uint8_t get_current_note() { //Force inline this function? Ask Omar. BUT, this could be where interpolation is calculated!
	
	uint8_t note = 0;
	if (arp.mode) {
     31a:	80 91 92 03 	lds	r24, 0x0392
     31e:	88 23       	and	r24, r24
     320:	19 f0       	breq	.+6      	; 0x328 <get_current_note+0xe>
		
		
		//do something here to determine what arp note should be
		note = arp.current_note; //yeah, like this!
     322:	80 91 8d 03 	lds	r24, 0x038D
     326:	08 95       	ret
		

		
	} else {
		
		note = current_note;
     328:	80 91 b5 02 	lds	r24, 0x02B5
				
	}
	return note;
	
}
     32c:	08 95       	ret

0000032e <new_note>:

void new_note(uint8_t note, uint8_t velocity) {
     32e:	0f 93       	push	r16
     330:	1f 93       	push	r17
     332:	cf 93       	push	r28
     334:	df 93       	push	r29
     336:	18 2f       	mov	r17, r24
     338:	06 2f       	mov	r16, r22
	
	
	//shift contents of note_pool right by one element
	memmove(note_pool + 1, note_pool, sizeof(note_pool) -sizeof(*note_pool)); //last argument: sizeof struct - sizeof one element of struct. See http://www.cplusplus.com/forum/beginner/1936/
     33a:	8a eb       	ldi	r24, 0xBA	; 186
     33c:	91 e0       	ldi	r25, 0x01	; 1
     33e:	ec 01       	movw	r28, r24
     340:	22 97       	sbiw	r28, 0x02	; 2
     342:	be 01       	movw	r22, r28
     344:	4e e0       	ldi	r20, 0x0E	; 14
     346:	50 e0       	ldi	r21, 0x00	; 0
     348:	0e 94 eb 1e 	call	0x3dd6	; 0x3dd6 <memmove>
	
	//add new note to pool
	note_pool[0].note = note;
     34c:	18 83       	st	Y, r17
	note_pool[0].velocity = velocity;
     34e:	09 83       	std	Y+1, r16	; 0x01
	
	current_note = note; //set current note
     350:	10 93 b5 02 	sts	0x02B5, r17
	
} 
     354:	df 91       	pop	r29
     356:	cf 91       	pop	r28
     358:	1f 91       	pop	r17
     35a:	0f 91       	pop	r16
     35c:	08 95       	ret

0000035e <remove_note>:
void remove_note(uint8_t note){
     35e:	cf 93       	push	r28
	
	uint8_t free_slot = 0;
	uint8_t temp_note = note_pool[0].note; //holder for current note
     360:	c0 91 b8 01 	lds	r28, 0x01B8
	for (int i = 0; i <= 7; i++) { //search for note in note stack
		
		if (note_pool[i].note == note) {
     364:	c8 17       	cp	r28, r24
     366:	41 f0       	breq	.+16     	; 0x378 <remove_note+0x1a>
     368:	ea eb       	ldi	r30, 0xBA	; 186
     36a:	f1 e0       	ldi	r31, 0x01	; 1
} 
void remove_note(uint8_t note){
	
	uint8_t free_slot = 0;
	uint8_t temp_note = note_pool[0].note; //holder for current note
	for (int i = 0; i <= 7; i++) { //search for note in note stack
     36c:	41 e0       	ldi	r20, 0x01	; 1
     36e:	50 e0       	ldi	r21, 0x00	; 0
		
		if (note_pool[i].note == note) {
     370:	90 81       	ld	r25, Z
     372:	98 17       	cp	r25, r24
     374:	59 f4       	brne	.+22     	; 0x38c <remove_note+0x2e>
     376:	02 c0       	rjmp	.+4      	; 0x37c <remove_note+0x1e>
} 
void remove_note(uint8_t note){
	
	uint8_t free_slot = 0;
	uint8_t temp_note = note_pool[0].note; //holder for current note
	for (int i = 0; i <= 7; i++) { //search for note in note stack
     378:	40 e0       	ldi	r20, 0x00	; 0
     37a:	50 e0       	ldi	r21, 0x00	; 0
		
		if (note_pool[i].note == note) {
			
			note_pool[i].note = EMPTY;
     37c:	fa 01       	movw	r30, r20
     37e:	ee 0f       	add	r30, r30
     380:	ff 1f       	adc	r31, r31
     382:	e8 54       	subi	r30, 0x48	; 72
     384:	fe 4f       	sbci	r31, 0xFE	; 254
     386:	8f ef       	ldi	r24, 0xFF	; 255
     388:	80 83       	st	Z, r24
			free_slot = i;
			break;
     38a:	07 c0       	rjmp	.+14     	; 0x39a <remove_note+0x3c>
} 
void remove_note(uint8_t note){
	
	uint8_t free_slot = 0;
	uint8_t temp_note = note_pool[0].note; //holder for current note
	for (int i = 0; i <= 7; i++) { //search for note in note stack
     38c:	4f 5f       	subi	r20, 0xFF	; 255
     38e:	5f 4f       	sbci	r21, 0xFF	; 255
     390:	32 96       	adiw	r30, 0x02	; 2
     392:	48 30       	cpi	r20, 0x08	; 8
     394:	51 05       	cpc	r21, r1
     396:	61 f7       	brne	.-40     	; 0x370 <remove_note+0x12>
	current_note = note; //set current note
	
} 
void remove_note(uint8_t note){
	
	uint8_t free_slot = 0;
     398:	40 e0       	ldi	r20, 0x00	; 0
		
	}
	
	
	//now shift elements left	
	memmove(note_pool + free_slot, note_pool + free_slot + 1, sizeof(note_pool) - (sizeof(*note_pool)*(free_slot + 1)));
     39a:	50 e0       	ldi	r21, 0x00	; 0
     39c:	ca 01       	movw	r24, r20
     39e:	88 0f       	add	r24, r24
     3a0:	99 1f       	adc	r25, r25
     3a2:	bc 01       	movw	r22, r24
     3a4:	66 54       	subi	r22, 0x46	; 70
     3a6:	7e 4f       	sbci	r23, 0xFE	; 254
     3a8:	40 95       	com	r20
     3aa:	50 95       	com	r21
     3ac:	48 5f       	subi	r20, 0xF8	; 248
     3ae:	5f 4f       	sbci	r21, 0xFF	; 255
     3b0:	44 0f       	add	r20, r20
     3b2:	55 1f       	adc	r21, r21
     3b4:	88 54       	subi	r24, 0x48	; 72
     3b6:	9e 4f       	sbci	r25, 0xFE	; 254
     3b8:	0e 94 eb 1e 	call	0x3dd6	; 0x3dd6 <memmove>
	note_pool[7].note = EMPTY;	
     3bc:	8f ef       	ldi	r24, 0xFF	; 255
     3be:	80 93 c6 01 	sts	0x01C6, r24
	
	//check to see if this is the last note released		
	//if it is, this might be a good place to ensure gate_buffer is empty
	if (note_pool[0].note == EMPTY) {
     3c2:	80 91 b8 01 	lds	r24, 0x01B8
     3c6:	8f 3f       	cpi	r24, 0xFF	; 255
     3c8:	19 f4       	brne	.+6      	; 0x3d0 <remove_note+0x72>
		
		current_note = temp_note; //store last note released for maintaining pitch during envelope release stage
     3ca:	c0 93 b5 02 	sts	0x02B5, r28
     3ce:	02 c0       	rjmp	.+4      	; 0x3d4 <remove_note+0x76>
		
	} else {		
		
		current_note = note_pool[0].note; //otherwise, the current note is the next one in the note stack
     3d0:	80 93 b5 02 	sts	0x02B5, r24

	}	
	
}
     3d4:	cf 91       	pop	r28
     3d6:	08 95       	ret

000003d8 <setup_system_clock>:
struct clock system_clock;

void setup_system_clock(void) {
	
	
	TCCR1B = (1<<CS10) | (1<<CS12) | (1<<WGM12);//TIMER1_DIVIDE_1024;
     3d8:	8d e0       	ldi	r24, 0x0D	; 13
     3da:	80 93 81 00 	sts	0x0081, r24
	TIMSK1 = (1<<OCIE1A);
     3de:	82 e0       	ldi	r24, 0x02	; 2
     3e0:	80 93 6f 00 	sts	0x006F, r24
	
	
	
}
     3e4:	08 95       	ret

000003e6 <update_clock_rate>:

void update_clock_rate(uint16_t rate) {
	
	OCR1A = rate;
     3e6:	90 93 89 00 	sts	0x0089, r25
     3ea:	80 93 88 00 	sts	0x0088, r24
	if (TCNT1 > rate) TCNT1 = rate - 1; //this prevents wrapping. setting TCNT1 = rate would cause immediate interrupt. Is that OK?
     3ee:	20 91 84 00 	lds	r18, 0x0084
     3f2:	30 91 85 00 	lds	r19, 0x0085
     3f6:	82 17       	cp	r24, r18
     3f8:	93 07       	cpc	r25, r19
     3fa:	28 f4       	brcc	.+10     	; 0x406 <update_clock_rate+0x20>
     3fc:	01 97       	sbiw	r24, 0x01	; 1
     3fe:	90 93 85 00 	sts	0x0085, r25
     402:	80 93 84 00 	sts	0x0084, r24
     406:	08 95       	ret

00000408 <set_control_voltage>:
struct control_voltage sustain_2_cv		={SUSTAIN_2,	DAC_MUX_EN3};
struct control_voltage sustain_1_cv		={SUSTAIN_1,	DAC_MUX_EN3};
struct control_voltage release_2_cv		={RELEASE_2,	DAC_MUX_EN3};
struct control_voltage release_1_cv		={RELEASE_1,	DAC_MUX_EN3};		

void set_control_voltage (struct control_voltage * cv, uint16_t value) {
     408:	dc 01       	movw	r26, r24

	DAC_BUS_LOW = value & 0b00000011111111; //mask top 6 MSBs to set low byte
     40a:	6b b9       	out	0x0b, r22	; 11
	
	DAC_BUS_HIGH = value >> 8; //shift away bottom LSBs to set high byte
     40c:	78 b9       	out	0x08, r23	; 8
	
	DAC_CTRL &= ~(1<<DAC_WR); //write DATA
     40e:	a0 98       	cbi	0x14, 0	; 20
	DAC_CTRL |= (1<<DAC_WR);	
     410:	a0 9a       	sbi	0x14, 0	; 20

	DATA_BUS = cv->channel; //set channel for DG408 multiplexer output
     412:	8c 91       	ld	r24, X
     414:	87 70       	andi	r24, 0x07	; 7
     416:	82 b9       	out	0x02, r24	; 2
     418:	66 e0       	ldi	r22, 0x06	; 6
     41a:	6a 95       	dec	r22
     41c:	f1 f7       	brne	.-4      	; 0x41a <set_control_voltage+0x12>
     41e:	00 c0       	rjmp	.+0      	; 0x420 <set_control_voltage+0x18>

	_delay_us(1); //AD5556 DAC has 0.5 us settling time. 1 us wasn't long enough for transitions from 10V to 0V
	DAC_MUX |= (1<<cv->mux_addr); //enable multiplexer
     420:	ea ed       	ldi	r30, 0xDA	; 218
     422:	f0 e0       	ldi	r31, 0x00	; 0
     424:	40 81       	ld	r20, Z
     426:	8c 91       	ld	r24, X
     428:	86 95       	lsr	r24
     42a:	86 95       	lsr	r24
     42c:	86 95       	lsr	r24
     42e:	87 70       	andi	r24, 0x07	; 7
     430:	21 e0       	ldi	r18, 0x01	; 1
     432:	30 e0       	ldi	r19, 0x00	; 0
     434:	b9 01       	movw	r22, r18
     436:	02 c0       	rjmp	.+4      	; 0x43c <set_control_voltage+0x34>
     438:	66 0f       	add	r22, r22
     43a:	77 1f       	adc	r23, r23
     43c:	8a 95       	dec	r24
     43e:	e2 f7       	brpl	.-8      	; 0x438 <set_control_voltage+0x30>
     440:	cb 01       	movw	r24, r22
     442:	84 2b       	or	r24, r20
     444:	80 83       	st	Z, r24
     446:	76 e0       	ldi	r23, 0x06	; 6
     448:	7a 95       	dec	r23
     44a:	f1 f7       	brne	.-4      	; 0x448 <set_control_voltage+0x40>
     44c:	00 c0       	rjmp	.+0      	; 0x44e <set_control_voltage+0x46>
	_delay_us(1); //wait for S&H cap to charge - need to figure out how to do this more time efficiently
	DAC_MUX &= ~(1<<cv->mux_addr); //disable multiplexer
     44e:	80 81       	ld	r24, Z
     450:	9c 91       	ld	r25, X
     452:	96 95       	lsr	r25
     454:	96 95       	lsr	r25
     456:	96 95       	lsr	r25
     458:	97 70       	andi	r25, 0x07	; 7
     45a:	02 c0       	rjmp	.+4      	; 0x460 <set_control_voltage+0x58>
     45c:	22 0f       	add	r18, r18
     45e:	33 1f       	adc	r19, r19
     460:	9a 95       	dec	r25
     462:	e2 f7       	brpl	.-8      	; 0x45c <set_control_voltage+0x54>
     464:	20 95       	com	r18
     466:	28 23       	and	r18, r24
     468:	20 83       	st	Z, r18
	
}	
     46a:	08 95       	ret

0000046c <setup_dac>:

	
void setup_dac(void) //set up DAC
{
	DDRG |= (1<<DAC_WR) | (1<<DAC_RS); //set DAC control bits as outputs
     46c:	83 b3       	in	r24, 0x13	; 19
     46e:	83 60       	ori	r24, 0x03	; 3
     470:	83 bb       	out	0x13, r24	; 19
	DDRD = 0xFF; //set DAC_BUS_LOW bits to outputs
     472:	8f ef       	ldi	r24, 0xFF	; 255
     474:	8a b9       	out	0x0a, r24	; 10
	DDRC |= 0xFF;//set DAC_BUS_HIGH bits to outputs
     476:	97 b1       	in	r25, 0x07	; 7
     478:	87 b9       	out	0x07, r24	; 7
	DDRH |= (1<<DAC_MUX_EN0) | (1<<DAC_MUX_EN1) | (1<<DAC_MUX_EN2) | (1<<DAC_MUX_EN3); //set DAC_MUX_EN pins as outputs
     47a:	e9 ed       	ldi	r30, 0xD9	; 217
     47c:	f0 e0       	ldi	r31, 0x00	; 0
     47e:	80 81       	ld	r24, Z
     480:	8f 60       	ori	r24, 0x0F	; 15
     482:	80 83       	st	Z, r24
	
	DAC_MUX &= ~((1<<DAC_MUX_EN0) | (1<<DAC_MUX_EN1) | (1<<DAC_MUX_EN2) | (1<<DAC_MUX_EN3)); //disable DG408 VDAC multiplexers
     484:	ea ed       	ldi	r30, 0xDA	; 218
     486:	f0 e0       	ldi	r31, 0x00	; 0
     488:	80 81       	ld	r24, Z
     48a:	80 7f       	andi	r24, 0xF0	; 240
     48c:	80 83       	st	Z, r24
	
	DAC_CTRL |= (1<<DAC_RS) | (1<<DAC_WR); //disable DAC
     48e:	84 b3       	in	r24, 0x14	; 20
     490:	83 60       	ori	r24, 0x03	; 3
     492:	84 bb       	out	0x14, r24	; 20
	
	DAC_CTRL &= ~(1<<DAC_RS); //reset DAC
     494:	a1 98       	cbi	0x14, 1	; 20
	DAC_CTRL |= (1<<DAC_RS);
     496:	a1 9a       	sbi	0x14, 1	; 20
	
	DAC_CTRL &= ~(1<<DAC_WR); //write DATA - falling edge then rising edge to toggle DAC bits to output register
     498:	a0 98       	cbi	0x14, 0	; 20
	DAC_CTRL |= (1<<DAC_WR);
     49a:	a0 9a       	sbi	0x14, 0	; 20
}
     49c:	08 95       	ret

0000049e <display_dec>:
#include "synth.h"



void display_dec(uint16_t number, uint8_t place)
{
     49e:	0f 93       	push	r16
     4a0:	1f 93       	push	r17
     4a2:	cf 93       	push	r28
     4a4:	df 93       	push	r29
     4a6:	cd b7       	in	r28, 0x3d	; 61
     4a8:	de b7       	in	r29, 0x3e	; 62
     4aa:	2e 97       	sbiw	r28, 0x0e	; 14
     4ac:	0f b6       	in	r0, 0x3f	; 63
     4ae:	f8 94       	cli
     4b0:	de bf       	out	0x3e, r29	; 62
     4b2:	0f be       	out	0x3f, r0	; 63
     4b4:	cd bf       	out	0x3d, r28	; 61
	
	uint8_t digit[] = {
     4b6:	28 e0       	ldi	r18, 0x08	; 8
     4b8:	29 83       	std	Y+1, r18	; 0x01
     4ba:	21 e0       	ldi	r18, 0x01	; 1
     4bc:	2a 83       	std	Y+2, r18	; 0x02
     4be:	22 e0       	ldi	r18, 0x02	; 2
     4c0:	2b 83       	std	Y+3, r18	; 0x03
     4c2:	24 e0       	ldi	r18, 0x04	; 4
     4c4:	2c 83       	std	Y+4, r18	; 0x04
		TENS,
		HUNDS,
		THOUS,
	};
	
	uint8_t dec[] = {
     4c6:	de 01       	movw	r26, r28
     4c8:	15 96       	adiw	r26, 0x05	; 5
     4ca:	e7 ee       	ldi	r30, 0xE7	; 231
     4cc:	f1 e0       	ldi	r31, 0x01	; 1
     4ce:	2a e0       	ldi	r18, 0x0A	; 10
     4d0:	01 90       	ld	r0, Z+
     4d2:	0d 92       	st	X+, r0
     4d4:	21 50       	subi	r18, 0x01	; 1
     4d6:	e1 f7       	brne	.-8      	; 0x4d0 <display_dec+0x32>
		
		
	};
	
	//clear cathode bits
	DATA_BUS = 0xFF; //set bits for cathode (current sinks, active LOW)
     4d8:	2f ef       	ldi	r18, 0xFF	; 255
     4da:	22 b9       	out	0x02, r18	; 2
	//latch data to cathode lines
	DISPLAY_PORT |= (1<<DISP_CATHODE_LATCH);
     4dc:	ea ed       	ldi	r30, 0xDA	; 218
     4de:	f0 e0       	ldi	r31, 0x00	; 0
     4e0:	20 81       	ld	r18, Z
     4e2:	20 61       	ori	r18, 0x10	; 16
     4e4:	20 83       	st	Z, r18
	DISPLAY_PORT &= ~(1<<DISP_CATHODE_LATCH);
     4e6:	20 81       	ld	r18, Z
     4e8:	2f 7e       	andi	r18, 0xEF	; 239
     4ea:	20 83       	st	Z, r18
	
	//set anode bit
	DATA_BUS = digit[place];
     4ec:	06 2f       	mov	r16, r22
     4ee:	10 e0       	ldi	r17, 0x00	; 0
     4f0:	de 01       	movw	r26, r28
     4f2:	a0 0f       	add	r26, r16
     4f4:	b1 1f       	adc	r27, r17
     4f6:	11 96       	adiw	r26, 0x01	; 1
     4f8:	2c 91       	ld	r18, X
     4fa:	11 97       	sbiw	r26, 0x01	; 1
     4fc:	22 b9       	out	0x02, r18	; 2
	//latch data to anode lines
	DISPLAY_PORT |= (1<<DISP_ANODE_LATCH);
     4fe:	20 81       	ld	r18, Z
     500:	20 62       	ori	r18, 0x20	; 32
     502:	20 83       	st	Z, r18
	DISPLAY_PORT &= ~(1<<DISP_ANODE_LATCH);
     504:	20 81       	ld	r18, Z
     506:	2f 7d       	andi	r18, 0xDF	; 223
     508:	20 83       	st	Z, r18
     50a:	48 2f       	mov	r20, r24
     50c:	59 2f       	mov	r21, r25
     50e:	87 e2       	ldi	r24, 0x27	; 39
     510:	40 31       	cpi	r20, 0x10	; 16
     512:	58 07       	cpc	r21, r24
     514:	10 f0       	brcs	.+4      	; 0x51a <display_dec+0x7c>
     516:	4f e0       	ldi	r20, 0x0F	; 15
     518:	57 e2       	ldi	r21, 0x27	; 39
	if (number > 9999) {
		number = 9999;
		}
	
	/* First division by 10 */
	q1 = (number >> 1) + (number >> 2);
     51a:	ca 01       	movw	r24, r20
     51c:	96 95       	lsr	r25
     51e:	87 95       	ror	r24
     520:	96 95       	lsr	r25
     522:	87 95       	ror	r24
     524:	9a 01       	movw	r18, r20
     526:	36 95       	lsr	r19
     528:	27 95       	ror	r18
     52a:	28 0f       	add	r18, r24
     52c:	39 1f       	adc	r19, r25
	q1 += q1 >> 4;
     52e:	c9 01       	movw	r24, r18
     530:	92 95       	swap	r25
     532:	82 95       	swap	r24
     534:	8f 70       	andi	r24, 0x0F	; 15
     536:	89 27       	eor	r24, r25
     538:	9f 70       	andi	r25, 0x0F	; 15
     53a:	89 27       	eor	r24, r25
     53c:	82 0f       	add	r24, r18
     53e:	93 1f       	adc	r25, r19
	q1 += q1 >> 8;
     540:	29 2f       	mov	r18, r25
     542:	33 27       	eor	r19, r19
     544:	82 0f       	add	r24, r18
     546:	93 1f       	adc	r25, r19
	q2 = q1 >> 3;
     548:	96 95       	lsr	r25
     54a:	87 95       	ror	r24
     54c:	96 95       	lsr	r25
     54e:	87 95       	ror	r24
     550:	96 95       	lsr	r25
     552:	87 95       	ror	r24
	r = number - q2 * 10;
     554:	28 2f       	mov	r18, r24
     556:	22 0f       	add	r18, r18
     558:	32 2f       	mov	r19, r18
     55a:	33 0f       	add	r19, r19
     55c:	33 0f       	add	r19, r19
     55e:	23 0f       	add	r18, r19
     560:	e4 2f       	mov	r30, r20
     562:	e2 1b       	sub	r30, r18
	//r = number - (((q2 << 2) + q2) << 1);
	qa = q2 + (r > 9);
     564:	61 e0       	ldi	r22, 0x01	; 1
     566:	70 e0       	ldi	r23, 0x00	; 0
     568:	ea 30       	cpi	r30, 0x0A	; 10
     56a:	10 f4       	brcc	.+4      	; 0x570 <display_dec+0xd2>
     56c:	60 e0       	ldi	r22, 0x00	; 0
     56e:	70 e0       	ldi	r23, 0x00	; 0
     570:	68 0f       	add	r22, r24
     572:	79 1f       	adc	r23, r25
	ones_place = rem[r];

	/* second division by 10 */

	q2 = (qa >> 1) + (qa >> 2);
     574:	9b 01       	movw	r18, r22
     576:	36 95       	lsr	r19
     578:	27 95       	ror	r18
     57a:	36 95       	lsr	r19
     57c:	27 95       	ror	r18
     57e:	ab 01       	movw	r20, r22
     580:	56 95       	lsr	r21
     582:	47 95       	ror	r20
     584:	24 0f       	add	r18, r20
     586:	35 1f       	adc	r19, r21
	q2 += q2 >> 4;
     588:	c9 01       	movw	r24, r18
     58a:	92 95       	swap	r25
     58c:	82 95       	swap	r24
     58e:	8f 70       	andi	r24, 0x0F	; 15
     590:	89 27       	eor	r24, r25
     592:	9f 70       	andi	r25, 0x0F	; 15
     594:	89 27       	eor	r24, r25
     596:	82 0f       	add	r24, r18
     598:	93 1f       	adc	r25, r19
	q2 += q2 >> 8;
     59a:	29 2f       	mov	r18, r25
     59c:	33 27       	eor	r19, r19
     59e:	82 0f       	add	r24, r18
     5a0:	93 1f       	adc	r25, r19
	q3 = q2 >> 3;
     5a2:	96 95       	lsr	r25
     5a4:	87 95       	ror	r24
     5a6:	96 95       	lsr	r25
     5a8:	87 95       	ror	r24
     5aa:	96 95       	lsr	r25
     5ac:	87 95       	ror	r24
	r = qa - q3 * 10;
     5ae:	98 2f       	mov	r25, r24
     5b0:	99 0f       	add	r25, r25
     5b2:	29 2f       	mov	r18, r25
     5b4:	22 0f       	add	r18, r18
     5b6:	22 0f       	add	r18, r18
     5b8:	92 0f       	add	r25, r18
     5ba:	69 1b       	sub	r22, r25
	qb = q3 + (r > 9);
     5bc:	91 e0       	ldi	r25, 0x01	; 1
     5be:	6a 30       	cpi	r22, 0x0A	; 10
     5c0:	08 f4       	brcc	.+2      	; 0x5c4 <display_dec+0x126>
     5c2:	90 e0       	ldi	r25, 0x00	; 0
     5c4:	89 0f       	add	r24, r25
	tens_place = rem[r];
     5c6:	41 ef       	ldi	r20, 0xF1	; 241
     5c8:	51 e0       	ldi	r21, 0x01	; 1
     5ca:	da 01       	movw	r26, r20
     5cc:	a6 0f       	add	r26, r22
     5ce:	b1 1d       	adc	r27, r1
     5d0:	3c 91       	ld	r19, X

	/* third division by 10 */

	q4 = (qb >> 1) + (qb >> 2);
     5d2:	28 2f       	mov	r18, r24
     5d4:	26 95       	lsr	r18
     5d6:	26 95       	lsr	r18
     5d8:	98 2f       	mov	r25, r24
     5da:	96 95       	lsr	r25
     5dc:	92 0f       	add	r25, r18
	q4 += q4 >> 4;
     5de:	29 2f       	mov	r18, r25
     5e0:	22 95       	swap	r18
     5e2:	2f 70       	andi	r18, 0x0F	; 15
     5e4:	92 0f       	add	r25, r18
	q4 = q4 >> 3;
     5e6:	96 95       	lsr	r25
     5e8:	96 95       	lsr	r25
     5ea:	96 95       	lsr	r25
	r = qb - q4 * 10;
     5ec:	29 2f       	mov	r18, r25
     5ee:	22 0f       	add	r18, r18
     5f0:	62 2f       	mov	r22, r18
     5f2:	66 0f       	add	r22, r22
     5f4:	66 0f       	add	r22, r22
     5f6:	26 0f       	add	r18, r22
     5f8:	82 1b       	sub	r24, r18
	thous_place = q4 + (r > 9);
	hunds_place = rem[r];
     5fa:	da 01       	movw	r26, r20
     5fc:	a8 0f       	add	r26, r24
     5fe:	b1 1d       	adc	r27, r1
     600:	2c 91       	ld	r18, X
	q1 += q1 >> 8;
	q2 = q1 >> 3;
	r = number - q2 * 10;
	//r = number - (((q2 << 2) + q2) << 1);
	qa = q2 + (r > 9);
	ones_place = rem[r];
     602:	4e 0f       	add	r20, r30
     604:	51 1d       	adc	r21, r1
	q4 = q4 >> 3;
	r = qb - q4 * 10;
	thous_place = q4 + (r > 9);
	hunds_place = rem[r];

	digit_index[0] = ones_place;
     606:	fa 01       	movw	r30, r20
     608:	40 81       	ld	r20, Z
     60a:	40 93 b8 02 	sts	0x02B8, r20
	digit_index[1] = tens_place;
     60e:	30 93 b9 02 	sts	0x02B9, r19
	digit_index[2] = hunds_place;
     612:	20 93 ba 02 	sts	0x02BA, r18

	q4 = (qb >> 1) + (qb >> 2);
	q4 += q4 >> 4;
	q4 = q4 >> 3;
	r = qb - q4 * 10;
	thous_place = q4 + (r > 9);
     616:	21 e0       	ldi	r18, 0x01	; 1
     618:	8a 30       	cpi	r24, 0x0A	; 10
     61a:	08 f4       	brcc	.+2      	; 0x61e <display_dec+0x180>
     61c:	20 e0       	ldi	r18, 0x00	; 0
     61e:	92 0f       	add	r25, r18
	hunds_place = rem[r];

	digit_index[0] = ones_place;
	digit_index[1] = tens_place;
	digit_index[2] = hunds_place;
	digit_index[3] = thous_place;
     620:	90 93 bb 02 	sts	0x02BB, r25

	cathode_byte = dec[digit_index[place]];
     624:	f8 01       	movw	r30, r16
     626:	e8 54       	subi	r30, 0x48	; 72
     628:	fd 4f       	sbci	r31, 0xFD	; 253
     62a:	80 81       	ld	r24, Z
     62c:	fe 01       	movw	r30, r28
     62e:	e8 0f       	add	r30, r24
     630:	f1 1d       	adc	r31, r1
     632:	85 81       	ldd	r24, Z+5	; 0x05
	
	if (current_patch.mode == EDIT) cathode_byte |= dp;
     634:	90 91 0b 03 	lds	r25, 0x030B
     638:	92 30       	cpi	r25, 0x02	; 2
     63a:	11 f4       	brne	.+4      	; 0x640 <display_dec+0x1a2>
     63c:	80 62       	ori	r24, 0x20	; 32
     63e:	03 c0       	rjmp	.+6      	; 0x646 <display_dec+0x1a8>
	if (current_patch.mode == MANUAL) cathode_byte = g; //Roland style dash for MANUAL mode. Could move this to the top as manual mode precludes the need to parse digit
     640:	91 30       	cpi	r25, 0x01	; 1
     642:	09 f4       	brne	.+2      	; 0x646 <display_dec+0x1a8>
     644:	88 e0       	ldi	r24, 0x08	; 8
	
	
	//set cathode byte
	DATA_BUS = ~(cathode_byte); //set bits for cathode (current sinks, active LOW)
     646:	80 95       	com	r24
     648:	82 b9       	out	0x02, r24	; 2
	//latch data to cathode lines
	DISPLAY_PORT |= (1<<DISP_CATHODE_LATCH);
     64a:	ea ed       	ldi	r30, 0xDA	; 218
     64c:	f0 e0       	ldi	r31, 0x00	; 0
     64e:	80 81       	ld	r24, Z
     650:	80 61       	ori	r24, 0x10	; 16
     652:	80 83       	st	Z, r24
	DISPLAY_PORT &= ~(1<<DISP_CATHODE_LATCH);
     654:	80 81       	ld	r24, Z
     656:	8f 7e       	andi	r24, 0xEF	; 239
     658:	80 83       	st	Z, r24
	
	//DATA_BUS = 0; //clear DATA_BUS before return
}
     65a:	2e 96       	adiw	r28, 0x0e	; 14
     65c:	0f b6       	in	r0, 0x3f	; 63
     65e:	f8 94       	cli
     660:	de bf       	out	0x3e, r29	; 62
     662:	0f be       	out	0x3f, r0	; 63
     664:	cd bf       	out	0x3d, r28	; 61
     666:	df 91       	pop	r29
     668:	cf 91       	pop	r28
     66a:	1f 91       	pop	r17
     66c:	0f 91       	pop	r16
     66e:	08 95       	ret

00000670 <update_display>:

void update_display(uint16_t number, uint8_t type) {
     670:	cf 93       	push	r28
	
	static uint8_t place = 0;
	

	
	if (type == DEC) {
     672:	66 23       	and	r22, r22
     674:	69 f4       	brne	.+26     	; 0x690 <update_display+0x20>

		
			
		display_dec(number, place);
     676:	c0 91 bc 02 	lds	r28, 0x02BC
     67a:	6c 2f       	mov	r22, r28
     67c:	0e 94 4f 02 	call	0x49e	; 0x49e <display_dec>
		//increment digit display place
		if (place++ == 3) //post increment
     680:	8c 2f       	mov	r24, r28
     682:	8f 5f       	subi	r24, 0xFF	; 255
     684:	80 93 bc 02 	sts	0x02BC, r24
     688:	c3 30       	cpi	r28, 0x03	; 3
     68a:	11 f4       	brne	.+4      	; 0x690 <update_display+0x20>
		{
			place = 0;
     68c:	10 92 bc 02 	sts	0x02BC, r1
		
		
	}
	
	
     690:	cf 91       	pop	r28
     692:	08 95       	ret

00000694 <__vector_10>:
#include "display.h"
#include "clock.h"
#include "assigner.h"
#include "arp.h"

ISR (TIMER0_COMP_vect) { //timer 0 output compare interrupt for tuning
     694:	1f 92       	push	r1
     696:	0f 92       	push	r0
     698:	0f b6       	in	r0, 0x3f	; 63
     69a:	0f 92       	push	r0
     69c:	11 24       	eor	r1, r1
     69e:	8f 93       	push	r24
     6a0:	9f 93       	push	r25
     6a2:	ef 93       	push	r30
     6a4:	ff 93       	push	r31
	
	OCR0A = period-1; //OCR0A counts n-1 periods - see comment in tune.c about setting OCR0A
     6a6:	80 91 80 03 	lds	r24, 0x0380
     6aa:	81 50       	subi	r24, 0x01	; 1
     6ac:	87 bd       	out	0x27, r24	; 39
	//PORTB ^= (1<<ARP_SYNC_LED); //toggle arp ARP_SYNC LED
	if (period_counter == 0) {
     6ae:	80 91 81 03 	lds	r24, 0x0381
     6b2:	88 23       	and	r24, r24
     6b4:	a1 f4       	brne	.+40     	; 0x6de <__vector_10+0x4a>
		count_finished = FALSE;
     6b6:	10 92 7e 03 	sts	0x037E, r1
		no_overflow = TRUE;
     6ba:	81 e0       	ldi	r24, 0x01	; 1
     6bc:	80 93 af 02 	sts	0x02AF, r24
		period_counter = 1; //set period counter to 1
     6c0:	80 93 81 03 	sts	0x0381, r24
		//set up 16 bit timer/counter1		
		TCCR1B |= timer1_clock; //clock /64 to run at 312.5 KHz or /8 to run at 2.5 MHz, dependent on note frequency being measured
     6c4:	e1 e8       	ldi	r30, 0x81	; 129
     6c6:	f0 e0       	ldi	r31, 0x00	; 0
     6c8:	80 81       	ld	r24, Z
     6ca:	90 91 7f 03 	lds	r25, 0x037F
     6ce:	89 2b       	or	r24, r25
     6d0:	80 83       	st	Z, r24
		TIMSK1 |= (1<<TOIE1); //enable timer1 overflow interrupt
     6d2:	ef e6       	ldi	r30, 0x6F	; 111
     6d4:	f0 e0       	ldi	r31, 0x00	; 0
     6d6:	80 81       	ld	r24, Z
     6d8:	81 60       	ori	r24, 0x01	; 1
     6da:	80 83       	st	Z, r24
     6dc:	11 c0       	rjmp	.+34     	; 0x700 <__vector_10+0x6c>
		
	} else {
		
		osc_count = TCNT1;		
     6de:	e4 e8       	ldi	r30, 0x84	; 132
     6e0:	f0 e0       	ldi	r31, 0x00	; 0
     6e2:	80 81       	ld	r24, Z
     6e4:	91 81       	ldd	r25, Z+1	; 0x01
     6e6:	90 93 7d 03 	sts	0x037D, r25
     6ea:	80 93 7c 03 	sts	0x037C, r24
		TCCR1B = 0; //turn off 16 bit timer/counter1
     6ee:	10 92 81 00 	sts	0x0081, r1
		count_finished = TRUE;
     6f2:	81 e0       	ldi	r24, 0x01	; 1
     6f4:	80 93 7e 03 	sts	0x037E, r24
		period_counter = 0;
     6f8:	10 92 81 03 	sts	0x0381, r1
		TCNT1 = 0; //reset timer/counter 1
     6fc:	11 82       	std	Z+1, r1	; 0x01
     6fe:	10 82       	st	Z, r1
	}
	
	
	
	
}
     700:	ff 91       	pop	r31
     702:	ef 91       	pop	r30
     704:	9f 91       	pop	r25
     706:	8f 91       	pop	r24
     708:	0f 90       	pop	r0
     70a:	0f be       	out	0x3f, r0	; 63
     70c:	0f 90       	pop	r0
     70e:	1f 90       	pop	r1
     710:	18 95       	reti

00000712 <__vector_9>:



ISR (TIMER1_OVF_vect) {
     712:	1f 92       	push	r1
     714:	0f 92       	push	r0
     716:	0f b6       	in	r0, 0x3f	; 63
     718:	0f 92       	push	r0
     71a:	11 24       	eor	r1, r1
	
	//during frequency counting, if timer1 overflow occurs set overflow flag
	no_overflow = FALSE;
     71c:	10 92 af 02 	sts	0x02AF, r1
	//PORTB ^= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED
	
}
     720:	0f 90       	pop	r0
     722:	0f be       	out	0x3f, r0	; 63
     724:	0f 90       	pop	r0
     726:	1f 90       	pop	r1
     728:	18 95       	reti

0000072a <__vector_7>:

ISR (TIMER1_COMPA_vect) { //output compare match for master clock
     72a:	1f 92       	push	r1
     72c:	0f 92       	push	r0
     72e:	0f b6       	in	r0, 0x3f	; 63
     730:	0f 92       	push	r0
     732:	11 24       	eor	r1, r1
     734:	2f 93       	push	r18
     736:	3f 93       	push	r19
     738:	4f 93       	push	r20
     73a:	5f 93       	push	r21
     73c:	6f 93       	push	r22
     73e:	7f 93       	push	r23
     740:	8f 93       	push	r24
     742:	9f 93       	push	r25
     744:	af 93       	push	r26
     746:	bf 93       	push	r27
     748:	ef 93       	push	r30
     74a:	ff 93       	push	r31
	//PORTB ^= (1<<ARP_SYNC_LED);
	
	if (system_clock.ppqn_counter == system_clock.divider >> 1) { //50% gate width
     74c:	80 91 d3 03 	lds	r24, 0x03D3
     750:	86 95       	lsr	r24
     752:	90 91 d4 03 	lds	r25, 0x03D4
     756:	98 17       	cp	r25, r24
     758:	51 f4       	brne	.+20     	; 0x76e <__vector_7+0x44>
				
		
		if ((arp.clock_source == INTERNAL_CLOCK) && (arp.mode)) {
     75a:	80 91 91 03 	lds	r24, 0x0391
     75e:	81 30       	cpi	r24, 0x01	; 1
     760:	31 f4       	brne	.+12     	; 0x76e <__vector_7+0x44>
     762:	80 91 92 03 	lds	r24, 0x0392
     766:	88 23       	and	r24, r24
     768:	11 f0       	breq	.+4      	; 0x76e <__vector_7+0x44>
			
			PORTF &= ~(1<<GATE); //if arp is running, turn gate off
     76a:	89 98       	cbi	0x11, 1	; 17
			PORTB &= ~ (1<<ARP_SYNC_LED); //turn off arp sync LED
     76c:	2f 98       	cbi	0x05, 7	; 5
			
		}
	}			
		
	if (++system_clock.ppqn_counter == system_clock.divider) {
     76e:	80 91 d4 03 	lds	r24, 0x03D4
     772:	8f 5f       	subi	r24, 0xFF	; 255
     774:	80 93 d4 03 	sts	0x03D4, r24
     778:	90 91 d3 03 	lds	r25, 0x03D3
     77c:	89 17       	cp	r24, r25
     77e:	91 f4       	brne	.+36     	; 0x7a4 <__vector_7+0x7a>
		
		system_clock.ppqn_counter = 0;
     780:	10 92 d4 03 	sts	0x03D4, r1
		
		if ((arp.clock_source == INTERNAL_CLOCK) && (arp.mode)) {
     784:	80 91 91 03 	lds	r24, 0x0391
     788:	81 30       	cpi	r24, 0x01	; 1
     78a:	61 f4       	brne	.+24     	; 0x7a4 <__vector_7+0x7a>
     78c:	80 91 92 03 	lds	r24, 0x0392
     790:	88 23       	and	r24, r24
     792:	41 f0       	breq	.+16     	; 0x7a4 <__vector_7+0x7a>
			
			//step arp note here based on range and note sequence from assigner	
			
			if (gate_buffer) { //if there are still notes in gate buffer
     794:	80 91 b4 02 	lds	r24, 0x02B4
     798:	88 23       	and	r24, r24
     79a:	21 f0       	breq	.+8      	; 0x7a4 <__vector_7+0x7a>
				step_arp_note(); //will need to force inline this function. It will need to be used elsewhere for arp MIDI sync.
     79c:	0e 94 34 01 	call	0x268	; 0x268 <step_arp_note>
				PORTF |= (1<<GATE);
     7a0:	89 9a       	sbi	0x11, 1	; 17
				PORTB |= (1<<ARP_SYNC_LED);
     7a2:	2f 9a       	sbi	0x05, 7	; 5
			} 
		}			
	}
	
     7a4:	ff 91       	pop	r31
     7a6:	ef 91       	pop	r30
     7a8:	bf 91       	pop	r27
     7aa:	af 91       	pop	r26
     7ac:	9f 91       	pop	r25
     7ae:	8f 91       	pop	r24
     7b0:	7f 91       	pop	r23
     7b2:	6f 91       	pop	r22
     7b4:	5f 91       	pop	r21
     7b6:	4f 91       	pop	r20
     7b8:	3f 91       	pop	r19
     7ba:	2f 91       	pop	r18
     7bc:	0f 90       	pop	r0
     7be:	0f be       	out	0x3f, r0	; 63
     7c0:	0f 90       	pop	r0
     7c2:	1f 90       	pop	r1
     7c4:	18 95       	reti

000007c6 <song_position_event>:
uint8_t switch_timer = 0;


void song_position_event(MidiDevice * device, uint8_t byte0, uint8_t byte1, uint8_t byte2) {
	
	arp.display = 42;
     7c6:	8a e2       	ldi	r24, 0x2A	; 42
     7c8:	80 93 90 03 	sts	0x0390, r24
	
}
     7cc:	08 95       	ret

000007ce <real_time_event>:
}

void real_time_event(MidiDevice * device, uint8_t real_time_byte) {
	//PORTB ^= (1<<ARP_SYNC_LED);
	//if (~(current_patch.byte_2 & (1<<LFO_KEY_SYNC) >> 1)) return; //if not in a sync mode, then retrun
	switch (real_time_byte) {
     7ce:	6a 3f       	cpi	r22, 0xFA	; 250
     7d0:	09 f4       	brne	.+2      	; 0x7d4 <real_time_event+0x6>
     7d2:	40 c0       	rjmp	.+128    	; 0x854 <real_time_event+0x86>
     7d4:	6c 3f       	cpi	r22, 0xFC	; 252
     7d6:	09 f4       	brne	.+2      	; 0x7da <real_time_event+0xc>
     7d8:	4a c0       	rjmp	.+148    	; 0x86e <real_time_event+0xa0>
     7da:	68 3f       	cpi	r22, 0xF8	; 248
     7dc:	09 f0       	breq	.+2      	; 0x7e0 <real_time_event+0x12>
     7de:	4a c0       	rjmp	.+148    	; 0x874 <real_time_event+0xa6>
		
		case MIDI_CLOCK:
		
			if (++midi_clock.ppqn_counter == midi_clock.divider) {
     7e0:	80 91 da 03 	lds	r24, 0x03DA
     7e4:	8f 5f       	subi	r24, 0xFF	; 255
     7e6:	80 93 da 03 	sts	0x03DA, r24
     7ea:	90 91 d9 03 	lds	r25, 0x03D9
     7ee:	89 17       	cp	r24, r25
     7f0:	41 f4       	brne	.+16     	; 0x802 <real_time_event+0x34>
				PORTB |= (1<< LFO_RESET);
     7f2:	2c 9a       	sbi	0x05, 4	; 5
     7f4:	86 e0       	ldi	r24, 0x06	; 6
     7f6:	8a 95       	dec	r24
     7f8:	f1 f7       	brne	.-4      	; 0x7f6 <real_time_event+0x28>
     7fa:	00 c0       	rjmp	.+0      	; 0x7fc <real_time_event+0x2e>
				_delay_us(1); //what is minimum pulse width required for LFO reset?
				
				//PORTB ^= (1<<ARP_SYNC_LED);
				//register clock event - this will do something  - reset LFO or initiate LFO
				midi_clock.ppqn_counter = 0; //reset MIDI ppqn clock	
     7fc:	10 92 da 03 	sts	0x03DA, r1
				PORTB &= ~(1<< LFO_RESET); //turn off LFO reset pin
     800:	2c 98       	cbi	0x05, 4	; 5
			}
			//
			if (arp.mode) { //if arp is running
     802:	80 91 92 03 	lds	r24, 0x0392
     806:	88 23       	and	r24, r24
     808:	a9 f1       	breq	.+106    	; 0x874 <real_time_event+0xa6>
				
				//arp.ppqn_counter++;
			
				if (arp.ppqn_counter == arp.divider) {
     80a:	90 91 8e 03 	lds	r25, 0x038E
     80e:	80 91 8f 03 	lds	r24, 0x038F
     812:	98 17       	cp	r25, r24
     814:	51 f4       	brne	.+20     	; 0x82a <real_time_event+0x5c>
				
				
					arp.ppqn_counter = 0;
     816:	10 92 8e 03 	sts	0x038E, r1
					if (gate_buffer) { //if there are still notes in gate buffer
     81a:	80 91 b4 02 	lds	r24, 0x02B4
     81e:	88 23       	and	r24, r24
     820:	21 f0       	breq	.+8      	; 0x82a <real_time_event+0x5c>
						
						step_arp_note(); //should force inline this function.
     822:	0e 94 34 01 	call	0x268	; 0x268 <step_arp_note>
						PORTF |= (1<<GATE);
     826:	89 9a       	sbi	0x11, 1	; 17
						PORTB |= (1<<ARP_SYNC_LED);
     828:	2f 9a       	sbi	0x05, 7	; 5
					}	
				
				}
				
				if (arp.ppqn_counter == arp.divider - (arp.divider >> 1)) { //50% gate width
     82a:	40 91 8f 03 	lds	r20, 0x038F
     82e:	20 91 8e 03 	lds	r18, 0x038E
     832:	30 e0       	ldi	r19, 0x00	; 0
     834:	84 2f       	mov	r24, r20
     836:	90 e0       	ldi	r25, 0x00	; 0
     838:	46 95       	lsr	r20
     83a:	84 1b       	sub	r24, r20
     83c:	91 09       	sbc	r25, r1
     83e:	28 17       	cp	r18, r24
     840:	39 07       	cpc	r19, r25
     842:	11 f4       	brne	.+4      	; 0x848 <real_time_event+0x7a>
								
					PORTF &= ~(1<<GATE);
     844:	89 98       	cbi	0x11, 1	; 17
					PORTB &= ~ (1<<ARP_SYNC_LED); //turn off arp sync LED
     846:	2f 98       	cbi	0x05, 7	; 5
								
				}
				arp.ppqn_counter++; //post increment means ppqn_counter is never 0, lowest is 1. Does this make sense for counting from 1 to arp.divide?
     848:	80 91 8e 03 	lds	r24, 0x038E
     84c:	8f 5f       	subi	r24, 0xFF	; 255
     84e:	80 93 8e 03 	sts	0x038E, r24
     852:	08 95       	ret
			
			break;
			
		case MIDI_START:
			
			midi_clock.ppqn_counter = 0;
     854:	10 92 da 03 	sts	0x03DA, r1
			arp.ppqn_counter = arp.divider-1; //trigger arp step on next MIDI clock tick
     858:	80 91 8f 03 	lds	r24, 0x038F
     85c:	81 50       	subi	r24, 0x01	; 1
     85e:	80 93 8e 03 	sts	0x038E, r24
			arp.clock_source = MIDI_CLOCK;
     862:	88 ef       	ldi	r24, 0xF8	; 248
     864:	80 93 91 03 	sts	0x0391, r24
			arp.step_position = 0; 
     868:	10 92 8a 03 	sts	0x038A, r1
			break;
     86c:	08 95       	ret
			
		case MIDI_STOP:
		
			arp.clock_source = INTERNAL_CLOCK; //revert to internal clock when MIDI STOP message received
     86e:	81 e0       	ldi	r24, 0x01	; 1
     870:	80 93 91 03 	sts	0x0391, r24
     874:	08 95       	ret

00000876 <note_off_event>:
		}		
	}
	//PORTB &= ~(1<< LFO_RESET);
	
}
void note_off_event(MidiDevice * device, uint8_t status, uint8_t note, uint8_t velocity) {
     876:	84 2f       	mov	r24, r20
	
	remove_note(note);
     878:	0e 94 af 01 	call	0x35e	; 0x35e <remove_note>
	gate_buffer--;
     87c:	80 91 b4 02 	lds	r24, 0x02B4
     880:	81 50       	subi	r24, 0x01	; 1
     882:	80 93 b4 02 	sts	0x02B4, r24
	//
	if (arp.mode) {	//if arp on, update arp sequence
     886:	90 91 92 03 	lds	r25, 0x0392
     88a:	99 23       	and	r25, r25
     88c:	71 f0       	breq	.+28     	; 0x8aa <note_off_event+0x34>
		//gate_buffer--;
		if (gate_buffer == 0) {
     88e:	88 23       	and	r24, r24
     890:	49 f4       	brne	.+18     	; 0x8a4 <note_off_event+0x2e>
			arp.current_note = arp.previous_note; //handle last note prevservation for release phase
     892:	80 91 8c 03 	lds	r24, 0x038C
     896:	80 93 8d 03 	sts	0x038D, r24
			//if (arp.clock_source == INTERNAL_CLOCK) arp.step_position = 0; //if arp is synced to MIDI clock, then step position is reset when MIDI START message received
			arp.step_position = 0;
     89a:	10 92 8a 03 	sts	0x038A, r1
			arp.direction = UP; //this is to initialize UP/DOWN mode
     89e:	81 e0       	ldi	r24, 0x01	; 1
     8a0:	80 93 8b 03 	sts	0x038B, r24
		}			
		update_arp_sequence();
     8a4:	0e 94 a3 00 	call	0x146	; 0x146 <update_arp_sequence>
     8a8:	08 95       	ret
	} else {
		
		//update_arp_sequence();
		if (gate_buffer == 0) PORTF &= ~(1<<GATE);
     8aa:	88 23       	and	r24, r24
     8ac:	09 f4       	brne	.+2      	; 0x8b0 <note_off_event+0x3a>
     8ae:	89 98       	cbi	0x11, 1	; 17
     8b0:	08 95       	ret

000008b2 <note_on_event>:
	
}



void note_on_event(MidiDevice * device, uint8_t status, uint8_t note, uint8_t velocity) {
     8b2:	84 2f       	mov	r24, r20
	
	if ((current_patch.byte_2 >> LFO_KEY_SYNC) & 1) {
     8b4:	90 91 03 03 	lds	r25, 0x0303
     8b8:	90 ff       	sbrs	r25, 0
     8ba:	06 c0       	rjmp	.+12     	; 0x8c8 <note_on_event+0x16>
		
		PORTB |= (1<< LFO_RESET);
     8bc:	2c 9a       	sbi	0x05, 4	; 5
     8be:	96 e0       	ldi	r25, 0x06	; 6
     8c0:	9a 95       	dec	r25
     8c2:	f1 f7       	brne	.-4      	; 0x8c0 <note_on_event+0xe>
     8c4:	00 c0       	rjmp	.+0      	; 0x8c6 <note_on_event+0x14>
		_delay_us(1); //what is minimum pulse width required for LFO reset?
		PORTB &= ~(1<< LFO_RESET);
     8c6:	2c 98       	cbi	0x05, 4	; 5
			
	}		
	
	midi_note_number = note;
     8c8:	80 93 be 02 	sts	0x02BE, r24
	if (velocity == 0) { //if velocity is 0 then it is a note off event - just call note off function rather than duplicate code here. arp will need to handle this too
     8cc:	22 23       	and	r18, r18
     8ce:	59 f4       	brne	.+22     	; 0x8e6 <note_on_event+0x34>
		remove_note(note);
     8d0:	0e 94 af 01 	call	0x35e	; 0x35e <remove_note>
		gate_buffer--;
     8d4:	80 91 b4 02 	lds	r24, 0x02B4
     8d8:	81 50       	subi	r24, 0x01	; 1
     8da:	80 93 b4 02 	sts	0x02B4, r24
		if (gate_buffer == 0) PORTF &= ~(1<<GATE);
     8de:	88 23       	and	r24, r24
     8e0:	b1 f4       	brne	.+44     	; 0x90e <note_on_event+0x5c>
     8e2:	89 98       	cbi	0x11, 1	; 17
     8e4:	08 95       	ret
				
	} else {
		
		new_note(note, velocity);
     8e6:	62 2f       	mov	r22, r18
     8e8:	0e 94 97 01 	call	0x32e	; 0x32e <new_note>
		
		gate_buffer++;
     8ec:	80 91 b4 02 	lds	r24, 0x02B4
     8f0:	8f 5f       	subi	r24, 0xFF	; 255
     8f2:	80 93 b4 02 	sts	0x02B4, r24
		if (arp.mode) { //if arp is off, handle gate
     8f6:	80 91 92 03 	lds	r24, 0x0392
     8fa:	88 23       	and	r24, r24
     8fc:	39 f0       	breq	.+14     	; 0x90c <note_on_event+0x5a>
			//new_note(note, velocity);
			//gate_buffer++; //increment gate_buffer
			arp.display = arp.ppqn_counter;
     8fe:	80 91 8e 03 	lds	r24, 0x038E
     902:	80 93 90 03 	sts	0x0390, r24
			update_arp_sequence();
     906:	0e 94 a3 00 	call	0x146	; 0x146 <update_arp_sequence>
     90a:	08 95       	ret
				//arp.ppqn_counter = arp.divider; //reset ppqn counter to trigger arp step. This should implement KEY SYNC
				//ok, if note on comes on an arp divider beat, then it needs to be triggered, but if it isn't on a divider beat, then it shouldn't be triggered, right?	
				//arp.step_position = 0; //reset step position when new note arrives? Have a look here to get into nitty gritty details of arp sync behaviour: http://lauterzeit.com/arp_lfo_seq_sync/
			}			
		} else {
			PORTF |= (1<<GATE); //if arp is OFF then turn on gate. Otherwise arpeggiator handles GATE
     90c:	89 9a       	sbi	0x11, 1	; 17
     90e:	08 95       	ret

00000910 <setup_midi_usart>:

void setup_midi_usart(void)
{
    uint16_t ubbr_value = 39; //20MHz/(16*31250 BAUD) - 1
    //write ubbr_value to H and L UBBR1 registers:
    UBRR0L = (unsigned char) ubbr_value;
     910:	87 e2       	ldi	r24, 0x27	; 39
     912:	80 93 c4 00 	sts	0x00C4, r24
    UBRR0H = (unsigned char) (ubbr_value >> 8);
     916:	10 92 c5 00 	sts	0x00C5, r1
	
	UCSR0B = (1<<RXEN0)|(1<<TXEN0) | (1<<RXCIE0);
     91a:	88 e9       	ldi	r24, 0x98	; 152
     91c:	80 93 c1 00 	sts	0x00C1, r24
	//UCSR0C |= (0<<UMSEL0)|(0<<UMSEL01)|(0<<UPM01)|(0<<UPM00)|(0<<USBS0)|(0<<UCSZ02)|(1<<UCSZ01)|(1<<UCSZ00);  	
}
     920:	08 95       	ret

00000922 <__vector_13>:



ISR (USART_RX_vect) { // USART receive interrupt
     922:	1f 92       	push	r1
     924:	0f 92       	push	r0
     926:	0f b6       	in	r0, 0x3f	; 63
     928:	0f 92       	push	r0
     92a:	11 24       	eor	r1, r1
     92c:	2f 93       	push	r18
     92e:	3f 93       	push	r19
     930:	4f 93       	push	r20
     932:	5f 93       	push	r21
     934:	6f 93       	push	r22
     936:	7f 93       	push	r23
     938:	8f 93       	push	r24
     93a:	9f 93       	push	r25
     93c:	af 93       	push	r26
     93e:	bf 93       	push	r27
     940:	ef 93       	push	r30
     942:	ff 93       	push	r31
     944:	cf 93       	push	r28
     946:	df 93       	push	r29
     948:	0f 92       	push	r0
     94a:	cd b7       	in	r28, 0x3d	; 61
     94c:	de b7       	in	r29, 0x3e	; 62
	//PORTB ^= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED 
	uint8_t inByte = UDR0;
     94e:	80 91 c6 00 	lds	r24, 0x00C6
     952:	89 83       	std	Y+1, r24	; 0x01
	midi_device_input(&midi_device, 1, &inByte); 
     954:	8f ed       	ldi	r24, 0xDF	; 223
     956:	93 e0       	ldi	r25, 0x03	; 3
     958:	61 e0       	ldi	r22, 0x01	; 1
     95a:	ae 01       	movw	r20, r28
     95c:	4f 5f       	subi	r20, 0xFF	; 255
     95e:	5f 4f       	sbci	r21, 0xFF	; 255
     960:	0e 94 3a 1a 	call	0x3474	; 0x3474 <midi_device_input>
	//calling a function in an interrupt is inefficient according to AVR C guidelines
	// so this function should maybe be inlined in main loop if inByte is made volatile	
	//***HOWEVER***, xnor-midi example code has this function being called from USART_RX_vect ISR  	
}
     964:	0f 90       	pop	r0
     966:	df 91       	pop	r29
     968:	cf 91       	pop	r28
     96a:	ff 91       	pop	r31
     96c:	ef 91       	pop	r30
     96e:	bf 91       	pop	r27
     970:	af 91       	pop	r26
     972:	9f 91       	pop	r25
     974:	8f 91       	pop	r24
     976:	7f 91       	pop	r23
     978:	6f 91       	pop	r22
     97a:	5f 91       	pop	r21
     97c:	4f 91       	pop	r20
     97e:	3f 91       	pop	r19
     980:	2f 91       	pop	r18
     982:	0f 90       	pop	r0
     984:	0f be       	out	0x3f, r0	; 63
     986:	0f 90       	pop	r0
     988:	1f 90       	pop	r1
     98a:	18 95       	reti

0000098c <main>:


int main(void)
{
	//turn off JTAG so all outputs of PORTC can be used
	MCUCR = (1<<JTD);
     98c:	c0 e8       	ldi	r28, 0x80	; 128
     98e:	c5 bf       	out	0x35, r28	; 53
	MCUCR = (1<<JTD);
     990:	c5 bf       	out	0x35, r28	; 53
		
	//SET PORTB PIN 7 (PB7) as OUTPUT
	DDRB |= (1<<ARP_SYNC_LED);
     992:	27 9a       	sbi	0x04, 7	; 4
	
	DDRB |= (1<< LFO_RESET); //set LFO reset as output. This affects LFO rate and TRI balance - needed to trim both rate and balance.
     994:	24 9a       	sbi	0x04, 4	; 4
	//PORTB |= (1<< LFO_RESET);
	
	
	DDRF |= (1<<GATE); //set gate as output
     996:	81 9a       	sbi	0x10, 1	; 16
	//PORTF |= (1<<GATE); //turn gate on for testing
	
	DDRG |= (1<<TUNE_SELECT); //set tune select bit as output on PORTG
     998:	9a 9a       	sbi	0x13, 2	; 19
	PORTG &= ~(1<<TUNE_SELECT); //set tune select bit to 0 to select VCF/VCA output for oscillator tuning
     99a:	a2 98       	cbi	0x14, 2	; 20
	//PORTG |= (1<<TUNE_SELECT);
	
	setup_spi(); 
     99c:	0e 94 25 08 	call	0x104a	; 0x104a <setup_spi>
	
	DDRH |= (1<<POTMUX_EN0) | (1<<POTMUX_EN1); //set POTMUX_EN pins as outputs
     9a0:	a9 ed       	ldi	r26, 0xD9	; 217
     9a2:	b0 e0       	ldi	r27, 0x00	; 0
     9a4:	8c 91       	ld	r24, X
     9a6:	80 6c       	ori	r24, 0xC0	; 192
     9a8:	8c 93       	st	X, r24
	POT_MUX |= (1<<POTMUX_EN0) | (1<<POTMUX_EN1); //set POTMUX_EN pins HIGH (active LOW)
     9aa:	ea ed       	ldi	r30, 0xDA	; 218
     9ac:	f0 e0       	ldi	r31, 0x00	; 0
     9ae:	80 81       	ld	r24, Z
     9b0:	80 6c       	ori	r24, 0xC0	; 192
     9b2:	80 83       	st	Z, r24
	//POT_MUX |= (1<<POTMUX_EN1);
	
	//set up LED display
	DDRA |= 0b11111111; //set all lines or DATA_BUS to outputs
     9b4:	81 b1       	in	r24, 0x01	; 1
     9b6:	8f ef       	ldi	r24, 0xFF	; 255
     9b8:	81 b9       	out	0x01, r24	; 1
	DATA_BUS |= 0b11111111; //set all DATA_BUS lines to HIGH (cathodes OFF)
     9ba:	92 b1       	in	r25, 0x02	; 2
     9bc:	82 b9       	out	0x02, r24	; 2
	DDRH |= (1<<DISP_CATHODE_LATCH) | (1<<DISP_ANODE_LATCH); //set display latches to outputs
     9be:	8c 91       	ld	r24, X
     9c0:	80 63       	ori	r24, 0x30	; 48
     9c2:	8c 93       	st	X, r24
	DISPLAY_PORT &= ~(1<<DISP_ANODE_LATCH | 1<< DISP_CATHODE_LATCH); //set DISP latches to LOW (inactive)
     9c4:	80 81       	ld	r24, Z
     9c6:	8f 7c       	andi	r24, 0xCF	; 207
     9c8:	80 83       	st	Z, r24
	
	//set up switch port
	DDRF &= ~(1<<BMOD_SW); //set BMOD_SW pin as input
     9ca:	82 98       	cbi	0x10, 2	; 16
	
	//set up LFO DEMUX LATCH
	DDRJ |= (1<<LFO_SW_LATCH); //set LFO_SW_LATCH pin as output
     9cc:	ec ed       	ldi	r30, 0xDC	; 220
     9ce:	f0 e0       	ldi	r31, 0x00	; 0
     9d0:	80 81       	ld	r24, Z
     9d2:	80 62       	ori	r24, 0x20	; 32
     9d4:	80 83       	st	Z, r24
	DATA_BUS = LFO_TRI_ADDR;
     9d6:	12 b8       	out	0x02, r1	; 2
	LFO_LATCH_PORT |= (1<<LFO_SW_LATCH);
     9d8:	ed ed       	ldi	r30, 0xDD	; 221
     9da:	f0 e0       	ldi	r31, 0x00	; 0
     9dc:	80 81       	ld	r24, Z
     9de:	80 62       	ori	r24, 0x20	; 32
     9e0:	80 83       	st	Z, r24
	LFO_LATCH_PORT &= ~(1<<LFO_SW_LATCH);
     9e2:	80 81       	ld	r24, Z
     9e4:	8f 7d       	andi	r24, 0xDF	; 223
     9e6:	80 83       	st	Z, r24
	DATA_BUS = 0;
     9e8:	12 b8       	out	0x02, r1	; 2
	current_patch.byte_2 = (1<<LFO_TRI);
     9ea:	c0 93 03 03 	sts	0x0303, r28
	
	//setup ADC
    setup_adc();		
     9ee:	0e 94 51 00 	call	0xa2	; 0xa2 <setup_adc>
	//setup DAC
	setup_dac();
     9f2:	0e 94 36 02 	call	0x46c	; 0x46c <setup_dac>
	
	//setup MIDI
	//initialize MIDI device
	midi_device_init(&midi_device);
     9f6:	cf ed       	ldi	r28, 0xDF	; 223
     9f8:	d3 e0       	ldi	r29, 0x03	; 3
     9fa:	ce 01       	movw	r24, r28
     9fc:	0e 94 09 1a 	call	0x3412	; 0x3412 <midi_device_init>
	//register callbacks
	midi_register_noteon_callback(&midi_device, note_on_event);
     a00:	ce 01       	movw	r24, r28
     a02:	69 e5       	ldi	r22, 0x59	; 89
     a04:	74 e0       	ldi	r23, 0x04	; 4
     a06:	0e 94 d1 19 	call	0x33a2	; 0x33a2 <midi_register_noteon_callback>
	midi_register_noteoff_callback(&midi_device, note_off_event);
     a0a:	ce 01       	movw	r24, r28
     a0c:	6b e3       	ldi	r22, 0x3B	; 59
     a0e:	74 e0       	ldi	r23, 0x04	; 4
     a10:	0e 94 d5 19 	call	0x33aa	; 0x33aa <midi_register_noteoff_callback>
	midi_register_realtime_callback(&midi_device, real_time_event);
     a14:	ce 01       	movw	r24, r28
     a16:	67 ee       	ldi	r22, 0xE7	; 231
     a18:	73 e0       	ldi	r23, 0x03	; 3
     a1a:	0e 94 f5 19 	call	0x33ea	; 0x33ea <midi_register_realtime_callback>
	midi_register_songposition_callback(&midi_device, song_position_event);
     a1e:	ce 01       	movw	r24, r28
     a20:	63 ee       	ldi	r22, 0xE3	; 227
     a22:	73 e0       	ldi	r23, 0x03	; 3
     a24:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <midi_register_songposition_callback>
	//setup MIDI USART
	setup_midi_usart();
     a28:	0e 94 88 04 	call	0x910	; 0x910 <setup_midi_usart>
	
	update_spi(); //initial update of SPI - will eventual be useful for picking up special power up switch holds
     a2c:	0e 94 4a 08 	call	0x1094	; 0x1094 <update_spi>
	
	
	current_patch.number = 1;
     a30:	c1 e0       	ldi	r28, 0x01	; 1
     a32:	c0 93 07 03 	sts	0x0307, r28
		
	sei(); //enable global interrupts
     a36:	78 94       	sei

	
	//eeprom_update_word((uint16_t*)109, test_word);
	//value_to_display = eeprom_read_word((uint16_t*)109);
	
	load_tuning_tables();
     a38:	0e 94 37 16 	call	0x2c6e	; 0x2c6e <load_tuning_tables>
	//value_to_display = vco1_init_cv;
	//set_one_volt_per_octave(); //overwrite tuning tables with 1V/octave data for calibration purposes
	//set initial switch states
	//switch_states.byte0 = (1<<VCO1_PULSE_SW) | (1<<VCO2_PULSE_SW);
	//current_patch.byte_4 = (1<<VCO1_32F) | (1<<VCO2_32F);
	load_patch(1);
     a3c:	81 e0       	ldi	r24, 0x01	; 1
     a3e:	0e 94 c3 0a 	call	0x1586	; 0x1586 <load_patch>
	
	setup_system_clock();
     a42:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <setup_system_clock>
	//update_clock_speed(244);
	system_clock.divider = 24;
     a46:	88 e1       	ldi	r24, 0x18	; 24
     a48:	80 93 d3 03 	sts	0x03D3, r24
	arp.step_position = 0; //initialize step position
     a4c:	10 92 8a 03 	sts	0x038A, r1
	arp.clock_source = INTERNAL_CLOCK;
     a50:	c0 93 91 03 	sts	0x0391, r28
	arp.mode = OFF;
     a54:	10 92 92 03 	sts	0x0392, r1
	arp.ppqn_counter = 1;
     a58:	c0 93 8e 03 	sts	0x038E, r28

	while(1)
	{	
		
		
		midi_device_process(&midi_device); //this needs to be called 'frequently' in order for MIDI to work
     a5c:	0f ed       	ldi	r16, 0xDF	; 223
     a5e:	13 e0       	ldi	r17, 0x03	; 3
		if (switch_timer++ == 5)
		{
			switch_timer = 0;
			switch_press = 0; //reset global switch press flag
			//read switches directly connected to MCU	
			switch_states.byte2 ^= read_switch_port(); //toggle switch states
     a60:	0f 2e       	mov	r0, r31
     a62:	f4 e8       	ldi	r31, 0x84	; 132
     a64:	ef 2e       	mov	r14, r31
     a66:	f3 e0       	ldi	r31, 0x03	; 3
     a68:	ff 2e       	mov	r15, r31
     a6a:	f0 2d       	mov	r31, r0
			switch_states.byte2 |= (current_patch.mode == MANUAL) << PROG_MANUAL_SW; //if MANUAL then don't toggle switch
     a6c:	0f 2e       	mov	r0, r31
     a6e:	fb e0       	ldi	r31, 0x0B	; 11
     a70:	cf 2e       	mov	r12, r31
     a72:	f3 e0       	ldi	r31, 0x03	; 3
     a74:	df 2e       	mov	r13, r31
     a76:	f0 2d       	mov	r31, r0
			//switch_states.byte2 |= (current_patch.mode == WRITE) << PROG_WRITE_SW; //if WRITE then don't toggle switch
			update_spi();
			if (switch_press) { 
				update_patch();
				if (current_patch.mode == MEMORY) current_patch.mode = EDIT; //change mode to EDIT if non-program switch is detected
     a78:	bb 24       	eor	r11, r11
     a7a:	68 94       	set
     a7c:	b1 f8       	bld	r11, 1
		{
			switch_timer = 0;
			switch_press = 0; //reset global switch press flag
			//read switches directly connected to MCU	
			switch_states.byte2 ^= read_switch_port(); //toggle switch states
			switch_states.byte2 |= (current_patch.mode == MANUAL) << PROG_MANUAL_SW; //if MANUAL then don't toggle switch
     a7e:	d0 e8       	ldi	r29, 0x80	; 128

	while(1)
	{	
		
		
		midi_device_process(&midi_device); //this needs to be called 'frequently' in order for MIDI to work
     a80:	c8 01       	movw	r24, r16
     a82:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <midi_device_process>
		//value_to_display = vco1_init_cv;
		//PORTB |= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED
		update_display(value_to_display, DEC); //maybe move this into switch_timer loop. Probably doesn't need to be updated this frequently
     a86:	80 91 fd 01 	lds	r24, 0x01FD
     a8a:	90 91 fe 01 	lds	r25, 0x01FE
     a8e:	60 e0       	ldi	r22, 0x00	; 0
     a90:	0e 94 38 03 	call	0x670	; 0x670 <update_display>
		//PORTB &= ~(1<<ARP_SYNC_LED);
		 	
		//scan_pots_and_update_control_voltages();
		scan_pots();
     a94:	0e 94 79 05 	call	0xaf2	; 0xaf2 <scan_pots>
		update_control_voltages();
     a98:	0e 94 06 06 	call	0xc0c	; 0xc0c <update_control_voltages>
			
		//do SPI read/write every 5 loops. This is quite clumsy. Not sure yet how to better implement it
		if (switch_timer++ == 5)
     a9c:	80 91 bd 02 	lds	r24, 0x02BD
     aa0:	98 2f       	mov	r25, r24
     aa2:	9f 5f       	subi	r25, 0xFF	; 255
     aa4:	90 93 bd 02 	sts	0x02BD, r25
     aa8:	85 30       	cpi	r24, 0x05	; 5
     aaa:	51 f7       	brne	.-44     	; 0xa80 <main+0xf4>
		{
			switch_timer = 0;
     aac:	10 92 bd 02 	sts	0x02BD, r1
			switch_press = 0; //reset global switch press flag
     ab0:	10 92 c5 02 	sts	0x02C5, r1
			//read switches directly connected to MCU	
			switch_states.byte2 ^= read_switch_port(); //toggle switch states
     ab4:	f7 01       	movw	r30, r14
     ab6:	c0 81       	ld	r28, Z
     ab8:	0e 94 eb 16 	call	0x2dd6	; 0x2dd6 <read_switch_port>
     abc:	8c 27       	eor	r24, r28
			switch_states.byte2 |= (current_patch.mode == MANUAL) << PROG_MANUAL_SW; //if MANUAL then don't toggle switch
     abe:	f6 01       	movw	r30, r12
     ac0:	90 81       	ld	r25, Z
     ac2:	91 30       	cpi	r25, 0x01	; 1
     ac4:	11 f4       	brne	.+4      	; 0xaca <main+0x13e>
     ac6:	cd 2f       	mov	r28, r29
     ac8:	01 c0       	rjmp	.+2      	; 0xacc <main+0x140>
     aca:	c0 e0       	ldi	r28, 0x00	; 0
     acc:	c8 2b       	or	r28, r24
     ace:	f7 01       	movw	r30, r14
     ad0:	c0 83       	st	Z, r28
			//switch_states.byte2 |= (current_patch.mode == WRITE) << PROG_WRITE_SW; //if WRITE then don't toggle switch
			update_spi();
     ad2:	0e 94 4a 08 	call	0x1094	; 0x1094 <update_spi>
			if (switch_press) { 
     ad6:	80 91 c5 02 	lds	r24, 0x02C5
     ada:	88 23       	and	r24, r24
     adc:	39 f0       	breq	.+14     	; 0xaec <main+0x160>
				update_patch();
     ade:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <update_patch>
				if (current_patch.mode == MEMORY) current_patch.mode = EDIT; //change mode to EDIT if non-program switch is detected
     ae2:	f6 01       	movw	r30, r12
     ae4:	80 81       	ld	r24, Z
     ae6:	88 23       	and	r24, r24
     ae8:	09 f4       	brne	.+2      	; 0xaec <main+0x160>
     aea:	b0 82       	st	Z, r11
			}				
			update_patch_programmer();	
     aec:	0e 94 3f 10 	call	0x207e	; 0x207e <update_patch_programmer>
     af0:	c7 cf       	rjmp	.-114    	; 0xa80 <main+0xf4>

00000af2 <scan_pots>:

uint8_t midi_note_number = 0; //store incoming MIDI note here for pitch lookup table

volatile uint16_t value_to_display = 79; //global to hold display value
	
void scan_pots(void) { //should probably move this to adc.c
     af2:	bf 92       	push	r11
     af4:	cf 92       	push	r12
     af6:	df 92       	push	r13
     af8:	ef 92       	push	r14
     afa:	ff 92       	push	r15
     afc:	0f 93       	push	r16
     afe:	1f 93       	push	r17
     b00:	cf 93       	push	r28
     b02:	df 93       	push	r29
     b04:	c0 e0       	ldi	r28, 0x00	; 0
     b06:	d1 e0       	ldi	r29, 0x01	; 1
     b08:	06 ec       	ldi	r16, 0xC6	; 198
     b0a:	12 e0       	ldi	r17, 0x02	; 2
     b0c:	0f 2e       	mov	r0, r31
     b0e:	fc e3       	ldi	r31, 0x3C	; 60
     b10:	cf 2e       	mov	r12, r31
     b12:	dd 24       	eor	r13, r13
     b14:	f0 2d       	mov	r31, r0
     b16:	cc 0e       	add	r12, r28
     b18:	dd 1e       	adc	r13, r29
		//what happens next depends on mode. if pot is locked, then the value of the pot is not written to the current patch unless it is different from the pot's locked value
		
		uint8_t delta_pot = pot_id[i]->locked_value - ((pot_id[i]->value >> 2)); //quick and dirty subtraction, where unsigned delta pot will overflow if value > locked value. see below
		
		
		if ((current_patch.mode == MANUAL) || (pot_id[i]->locked == 0)) { //if in manual mode or pot is already unlocked
     b1a:	0f 2e       	mov	r0, r31
     b1c:	fb e0       	ldi	r31, 0x0B	; 11
     b1e:	ef 2e       	mov	r14, r31
     b20:	f3 e0       	ldi	r31, 0x03	; 3
     b22:	ff 2e       	mov	r15, r31
     b24:	f0 2d       	mov	r31, r0
		//} else if ((((pot_id[i]->value >> 2) != pot_id[i]->locked_value)) && (pot_id[i]->locked == 1)) { //need to figure out delta threshold here. 10 bit to 8 bit resolution should be enough???
			
		} else if (((delta_pot > 2) && (delta_pot < 253)) && (pot_id[i]->locked == 1)) { //set a threshold of +/- 3 for pot change  		  		  	
			*(patch_value + i) = pot_id[i]->value;
			pot_id[i]->locked = 0; //unlock pot
			current_patch.mode = EDIT;
     b26:	bb 24       	eor	r11, r11
     b28:	68 94       	set
     b2a:	b1 f8       	bld	r11, 1
	
	uint16_t *patch_value = &(current_patch.vco2_mix); //pointer to first element of current_patch struct
	//scan 30 parameter pots
	for (int i = 0; i <= NUM_POTS; i++) {
		
		adc_value = read_pot(pot_id[i]);
     b2c:	88 81       	ld	r24, Y
     b2e:	99 81       	ldd	r25, Y+1	; 0x01
     b30:	0e 94 64 00 	call	0xc8	; 0xc8 <read_pot>
     b34:	90 93 c0 02 	sts	0x02C0, r25
     b38:	80 93 bf 02 	sts	0x02BF, r24
		adc_change = adc_value - pot_id[i]->value;
     b3c:	e8 81       	ld	r30, Y
     b3e:	f9 81       	ldd	r31, Y+1	; 0x01
     b40:	40 81       	ld	r20, Z
     b42:	21 81       	ldd	r18, Z+1	; 0x01
     b44:	52 2f       	mov	r21, r18
     b46:	53 70       	andi	r21, 0x03	; 3
     b48:	84 1b       	sub	r24, r20
     b4a:	95 0b       	sbc	r25, r21
		pot_id[i]->value = pot_id[i]->value + (adc_change >> 2);
     b4c:	95 95       	asr	r25
     b4e:	87 95       	ror	r24
     b50:	95 95       	asr	r25
     b52:	87 95       	ror	r24
     b54:	84 0f       	add	r24, r20
     b56:	95 1f       	adc	r25, r21
     b58:	80 83       	st	Z, r24
     b5a:	89 2f       	mov	r24, r25
     b5c:	83 70       	andi	r24, 0x03	; 3
     b5e:	2c 7f       	andi	r18, 0xFC	; 252
     b60:	28 2b       	or	r18, r24
     b62:	21 83       	std	Z+1, r18	; 0x01
		//what happens next depends on mode. if pot is locked, then the value of the pot is not written to the current patch unless it is different from the pot's locked value
		
		uint8_t delta_pot = pot_id[i]->locked_value - ((pot_id[i]->value >> 2)); //quick and dirty subtraction, where unsigned delta pot will overflow if value > locked value. see below
     b64:	e9 91       	ld	r30, Y+
     b66:	f9 91       	ld	r31, Y+
     b68:	92 81       	ldd	r25, Z+2	; 0x02
     b6a:	20 81       	ld	r18, Z
     b6c:	81 81       	ldd	r24, Z+1	; 0x01
     b6e:	38 2f       	mov	r19, r24
     b70:	33 70       	andi	r19, 0x03	; 3
		
		
		if ((current_patch.mode == MANUAL) || (pot_id[i]->locked == 0)) { //if in manual mode or pot is already unlocked
     b72:	d7 01       	movw	r26, r14
     b74:	8c 91       	ld	r24, X
     b76:	81 30       	cpi	r24, 0x01	; 1
     b78:	19 f0       	breq	.+6      	; 0xb80 <scan_pots+0x8e>
     b7a:	83 81       	ldd	r24, Z+3	; 0x03
     b7c:	88 23       	and	r24, r24
     b7e:	24 f0       	brlt	.+8      	; 0xb88 <scan_pots+0x96>
			
			*(patch_value + i) = pot_id[i]->value; //this is a hacked way of indexing the patch structure. Depends on order of pots in pot array being the same as order of parameters in patch struct
     b80:	f8 01       	movw	r30, r16
     b82:	31 83       	std	Z+1, r19	; 0x01
     b84:	20 83       	st	Z, r18
     b86:	14 c0       	rjmp	.+40     	; 0xbb0 <scan_pots+0xbe>
		adc_value = read_pot(pot_id[i]);
		adc_change = adc_value - pot_id[i]->value;
		pot_id[i]->value = pot_id[i]->value + (adc_change >> 2);
		//what happens next depends on mode. if pot is locked, then the value of the pot is not written to the current patch unless it is different from the pot's locked value
		
		uint8_t delta_pot = pot_id[i]->locked_value - ((pot_id[i]->value >> 2)); //quick and dirty subtraction, where unsigned delta pot will overflow if value > locked value. see below
     b88:	49 2f       	mov	r20, r25
     b8a:	43 50       	subi	r20, 0x03	; 3
     b8c:	c9 01       	movw	r24, r18
     b8e:	95 95       	asr	r25
     b90:	87 95       	ror	r24
     b92:	95 95       	asr	r25
     b94:	87 95       	ror	r24
			
			*(patch_value + i) = pot_id[i]->value; //this is a hacked way of indexing the patch structure. Depends on order of pots in pot array being the same as order of parameters in patch struct
			
		//} else if ((((pot_id[i]->value >> 2) != pot_id[i]->locked_value)) && (pot_id[i]->locked == 1)) { //need to figure out delta threshold here. 10 bit to 8 bit resolution should be enough???
			
		} else if (((delta_pot > 2) && (delta_pot < 253)) && (pot_id[i]->locked == 1)) { //set a threshold of +/- 3 for pot change  		  		  	
     b96:	94 2f       	mov	r25, r20
     b98:	98 1b       	sub	r25, r24
     b9a:	9a 3f       	cpi	r25, 0xFA	; 250
     b9c:	48 f4       	brcc	.+18     	; 0xbb0 <scan_pots+0xbe>
			*(patch_value + i) = pot_id[i]->value;
     b9e:	d8 01       	movw	r26, r16
     ba0:	11 96       	adiw	r26, 0x01	; 1
     ba2:	3c 93       	st	X, r19
     ba4:	2e 93       	st	-X, r18
			pot_id[i]->locked = 0; //unlock pot
     ba6:	83 81       	ldd	r24, Z+3	; 0x03
     ba8:	8f 77       	andi	r24, 0x7F	; 127
     baa:	83 83       	std	Z+3, r24	; 0x03
			current_patch.mode = EDIT;
     bac:	f7 01       	movw	r30, r14
     bae:	b0 82       	st	Z, r11
     bb0:	0e 5f       	subi	r16, 0xFE	; 254
     bb2:	1f 4f       	sbci	r17, 0xFF	; 255

	int adc_change = 0;
	
	uint16_t *patch_value = &(current_patch.vco2_mix); //pointer to first element of current_patch struct
	//scan 30 parameter pots
	for (int i = 0; i <= NUM_POTS; i++) {
     bb4:	cc 15       	cp	r28, r12
     bb6:	dd 05       	cpc	r29, r13
     bb8:	09 f0       	breq	.+2      	; 0xbbc <scan_pots+0xca>
     bba:	b8 cf       	rjmp	.-144    	; 0xb2c <scan_pots+0x3a>
		
	}
	
	
	//scan volume pot
	adc_value = read_pot(&volume_pot);
     bbc:	8c e7       	ldi	r24, 0x7C	; 124
     bbe:	91 e0       	ldi	r25, 0x01	; 1
     bc0:	0e 94 64 00 	call	0xc8	; 0xc8 <read_pot>
     bc4:	90 93 c0 02 	sts	0x02C0, r25
     bc8:	80 93 bf 02 	sts	0x02BF, r24
	adc_change = adc_value - volume_pot.value;
     bcc:	20 91 7c 01 	lds	r18, 0x017C
     bd0:	40 91 7d 01 	lds	r20, 0x017D
     bd4:	34 2f       	mov	r19, r20
     bd6:	33 70       	andi	r19, 0x03	; 3
     bd8:	82 1b       	sub	r24, r18
     bda:	93 0b       	sbc	r25, r19
	volume_pot.value = volume_pot.value + (adc_change >> 2);
     bdc:	95 95       	asr	r25
     bde:	87 95       	ror	r24
     be0:	95 95       	asr	r25
     be2:	87 95       	ror	r24
     be4:	28 0f       	add	r18, r24
     be6:	39 1f       	adc	r19, r25
     be8:	20 93 7c 01 	sts	0x017C, r18
     bec:	83 2f       	mov	r24, r19
     bee:	83 70       	andi	r24, 0x03	; 3
     bf0:	4c 7f       	andi	r20, 0xFC	; 252
     bf2:	48 2b       	or	r20, r24
     bf4:	40 93 7d 01 	sts	0x017D, r20
	
}
     bf8:	df 91       	pop	r29
     bfa:	cf 91       	pop	r28
     bfc:	1f 91       	pop	r17
     bfe:	0f 91       	pop	r16
     c00:	ff 90       	pop	r15
     c02:	ef 90       	pop	r14
     c04:	df 90       	pop	r13
     c06:	cf 90       	pop	r12
     c08:	bf 90       	pop	r11
     c0a:	08 95       	ret

00000c0c <update_control_voltages>:

void update_control_voltages(void) { //keep everything updated in the current order of pots. Probably arbitrary, but try to minimize change from old CV update to new CV update
     c0c:	cf 93       	push	r28
     c0e:	df 93       	push	r29
	
	set_control_voltage(&vco2_mix_cv, (current_patch.vco2_mix << 4));
     c10:	60 91 c6 02 	lds	r22, 0x02C6
     c14:	70 91 c7 02 	lds	r23, 0x02C7
     c18:	62 95       	swap	r22
     c1a:	72 95       	swap	r23
     c1c:	70 7f       	andi	r23, 0xF0	; 240
     c1e:	76 27       	eor	r23, r22
     c20:	60 7f       	andi	r22, 0xF0	; 240
     c22:	76 27       	eor	r23, r22
     c24:	84 ee       	ldi	r24, 0xE4	; 228
     c26:	91 e0       	ldi	r25, 0x01	; 1
     c28:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&vco1_mix_cv, (current_patch.vco1_mix << 4));
     c2c:	60 91 c8 02 	lds	r22, 0x02C8
     c30:	70 91 c9 02 	lds	r23, 0x02C9
     c34:	62 95       	swap	r22
     c36:	72 95       	swap	r23
     c38:	70 7f       	andi	r23, 0xF0	; 240
     c3a:	76 27       	eor	r23, r22
     c3c:	60 7f       	andi	r22, 0xF0	; 240
     c3e:	76 27       	eor	r23, r22
     c40:	83 ee       	ldi	r24, 0xE3	; 227
     c42:	91 e0       	ldi	r25, 0x01	; 1
     c44:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pitch_eg2_cv, (current_patch.pitch_eg2 << 3)); //1/4 scale
     c48:	60 91 ca 02 	lds	r22, 0x02CA
     c4c:	70 91 cb 02 	lds	r23, 0x02CB
     c50:	66 0f       	add	r22, r22
     c52:	77 1f       	adc	r23, r23
     c54:	66 0f       	add	r22, r22
     c56:	77 1f       	adc	r23, r23
     c58:	66 0f       	add	r22, r22
     c5a:	77 1f       	adc	r23, r23
     c5c:	82 ee       	ldi	r24, 0xE2	; 226
     c5e:	91 e0       	ldi	r25, 0x01	; 1
     c60:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pitch_vco2_cv, (current_patch.pitch_vco2 << 4));
     c64:	60 91 cc 02 	lds	r22, 0x02CC
     c68:	70 91 cd 02 	lds	r23, 0x02CD
     c6c:	62 95       	swap	r22
     c6e:	72 95       	swap	r23
     c70:	70 7f       	andi	r23, 0xF0	; 240
     c72:	76 27       	eor	r23, r22
     c74:	60 7f       	andi	r22, 0xF0	; 240
     c76:	76 27       	eor	r23, r22
     c78:	87 eb       	ldi	r24, 0xB7	; 183
     c7a:	92 e0       	ldi	r25, 0x02	; 2
     c7c:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pitch_lfo_cv, (current_patch.pitch_lfo << 3)); // 1/4 scale
     c80:	60 91 ce 02 	lds	r22, 0x02CE
     c84:	70 91 cf 02 	lds	r23, 0x02CF
     c88:	66 0f       	add	r22, r22
     c8a:	77 1f       	adc	r23, r23
     c8c:	66 0f       	add	r22, r22
     c8e:	77 1f       	adc	r23, r23
     c90:	66 0f       	add	r22, r22
     c92:	77 1f       	adc	r23, r23
     c94:	81 ee       	ldi	r24, 0xE1	; 225
     c96:	91 e0       	ldi	r25, 0x01	; 1
     c98:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pwm_lfo_cv, (current_patch.pwm_lfo) << 4);
     c9c:	60 91 d0 02 	lds	r22, 0x02D0
     ca0:	70 91 d1 02 	lds	r23, 0x02D1
     ca4:	62 95       	swap	r22
     ca6:	72 95       	swap	r23
     ca8:	70 7f       	andi	r23, 0xF0	; 240
     caa:	76 27       	eor	r23, r22
     cac:	60 7f       	andi	r22, 0xF0	; 240
     cae:	76 27       	eor	r23, r22
     cb0:	80 ee       	ldi	r24, 0xE0	; 224
     cb2:	91 e0       	ldi	r25, 0x01	; 1
     cb4:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pwm_eg2_cv, (current_patch.pwm_eg2) << 4);
     cb8:	60 91 d2 02 	lds	r22, 0x02D2
     cbc:	70 91 d3 02 	lds	r23, 0x02D3
     cc0:	62 95       	swap	r22
     cc2:	72 95       	swap	r23
     cc4:	70 7f       	andi	r23, 0xF0	; 240
     cc6:	76 27       	eor	r23, r22
     cc8:	60 7f       	andi	r22, 0xF0	; 240
     cca:	76 27       	eor	r23, r22
     ccc:	8f ed       	ldi	r24, 0xDF	; 223
     cce:	91 e0       	ldi	r25, 0x01	; 1
     cd0:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&vco1_pw_cv, (current_patch.vco1_pw) << 4);
     cd4:	60 91 d4 02 	lds	r22, 0x02D4
     cd8:	70 91 d5 02 	lds	r23, 0x02D5
     cdc:	62 95       	swap	r22
     cde:	72 95       	swap	r23
     ce0:	70 7f       	andi	r23, 0xF0	; 240
     ce2:	76 27       	eor	r23, r22
     ce4:	60 7f       	andi	r22, 0xF0	; 240
     ce6:	76 27       	eor	r23, r22
     ce8:	8e ed       	ldi	r24, 0xDE	; 222
     cea:	91 e0       	ldi	r25, 0x01	; 1
     cec:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	
	int tune_offset = 512 - current_patch.tune; //master tune offset
     cf0:	80 91 d8 02 	lds	r24, 0x02D8
     cf4:	90 91 d9 02 	lds	r25, 0x02D9
     cf8:	c0 e0       	ldi	r28, 0x00	; 0
     cfa:	d2 e0       	ldi	r29, 0x02	; 2
     cfc:	c8 1b       	sub	r28, r24
     cfe:	d9 0b       	sbc	r29, r25
	
	int fine_offset = 512 - current_patch.fine; //fine tune offset
     d00:	60 91 77 03 	lds	r22, 0x0377
     d04:	70 91 78 03 	lds	r23, 0x0378
     d08:	60 50       	subi	r22, 0x00	; 0
     d0a:	7e 4f       	sbci	r23, 0xFE	; 254
	
	set_control_voltage(&fine_cv, vco2_init_cv + tune_offset + fine_offset);
     d0c:	80 91 d6 02 	lds	r24, 0x02D6
     d10:	90 91 d7 02 	lds	r25, 0x02D7
     d14:	68 1b       	sub	r22, r24
     d16:	79 0b       	sbc	r23, r25
     d18:	6c 0f       	add	r22, r28
     d1a:	7d 1f       	adc	r23, r29
     d1c:	8d ed       	ldi	r24, 0xDD	; 221
     d1e:	91 e0       	ldi	r25, 0x01	; 1
     d20:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&tune_cv, vco1_init_cv + tune_offset);
     d24:	60 91 79 03 	lds	r22, 0x0379
     d28:	70 91 7a 03 	lds	r23, 0x037A
     d2c:	6c 0f       	add	r22, r28
     d2e:	7d 1f       	adc	r23, r29
     d30:	8c ed       	ldi	r24, 0xDC	; 220
     d32:	91 e0       	ldi	r25, 0x01	; 1
     d34:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	
	set_control_voltage(&lfo_rate_cv, (current_patch.lfo_rate) << 4);
     d38:	60 91 da 02 	lds	r22, 0x02DA
     d3c:	70 91 db 02 	lds	r23, 0x02DB
     d40:	62 95       	swap	r22
     d42:	72 95       	swap	r23
     d44:	70 7f       	andi	r23, 0xF0	; 240
     d46:	76 27       	eor	r23, r22
     d48:	60 7f       	andi	r22, 0xF0	; 240
     d4a:	76 27       	eor	r23, r22
     d4c:	8b ed       	ldi	r24, 0xDB	; 219
     d4e:	91 e0       	ldi	r25, 0x01	; 1
     d50:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&glide_cv, (current_patch.glide) << 4);
     d54:	60 91 de 02 	lds	r22, 0x02DE
     d58:	70 91 df 02 	lds	r23, 0x02DF
     d5c:	62 95       	swap	r22
     d5e:	72 95       	swap	r23
     d60:	70 7f       	andi	r23, 0xF0	; 240
     d62:	76 27       	eor	r23, r22
     d64:	60 7f       	andi	r22, 0xF0	; 240
     d66:	76 27       	eor	r23, r22
     d68:	8a ed       	ldi	r24, 0xDA	; 218
     d6a:	91 e0       	ldi	r25, 0x01	; 1
     d6c:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&amp_lfo_cv, (current_patch.amp_lfo) << 4);
     d70:	60 91 e0 02 	lds	r22, 0x02E0
     d74:	70 91 e1 02 	lds	r23, 0x02E1
     d78:	62 95       	swap	r22
     d7a:	72 95       	swap	r23
     d7c:	70 7f       	andi	r23, 0xF0	; 240
     d7e:	76 27       	eor	r23, r22
     d80:	60 7f       	andi	r22, 0xF0	; 240
     d82:	76 27       	eor	r23, r22
     d84:	89 ed       	ldi	r24, 0xD9	; 217
     d86:	91 e0       	ldi	r25, 0x01	; 1
     d88:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&volume_cv, (volume_pot.value << 4)); //volume level not a patch parameter
     d8c:	60 91 7c 01 	lds	r22, 0x017C
     d90:	80 91 7d 01 	lds	r24, 0x017D
     d94:	78 2f       	mov	r23, r24
     d96:	73 70       	andi	r23, 0x03	; 3
     d98:	62 95       	swap	r22
     d9a:	72 95       	swap	r23
     d9c:	70 7f       	andi	r23, 0xF0	; 240
     d9e:	76 27       	eor	r23, r22
     da0:	60 7f       	andi	r22, 0xF0	; 240
     da2:	76 27       	eor	r23, r22
     da4:	88 ed       	ldi	r24, 0xD8	; 216
     da6:	91 e0       	ldi	r25, 0x01	; 1
     da8:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&vco2_pw_cv, (current_patch.vco2_pw) << 4);	
     dac:	60 91 e2 02 	lds	r22, 0x02E2
     db0:	70 91 e3 02 	lds	r23, 0x02E3
     db4:	62 95       	swap	r22
     db6:	72 95       	swap	r23
     db8:	70 7f       	andi	r23, 0xF0	; 240
     dba:	76 27       	eor	r23, r22
     dbc:	60 7f       	andi	r22, 0xF0	; 240
     dbe:	76 27       	eor	r23, r22
     dc0:	87 ed       	ldi	r24, 0xD7	; 215
     dc2:	91 e0       	ldi	r25, 0x01	; 1
     dc4:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	
	set_control_voltage(&fil_eg2_cv, (current_patch.fil_eg2) << 4);
     dc8:	60 91 e4 02 	lds	r22, 0x02E4
     dcc:	70 91 e5 02 	lds	r23, 0x02E5
     dd0:	62 95       	swap	r22
     dd2:	72 95       	swap	r23
     dd4:	70 7f       	andi	r23, 0xF0	; 240
     dd6:	76 27       	eor	r23, r22
     dd8:	60 7f       	andi	r22, 0xF0	; 240
     dda:	76 27       	eor	r23, r22
     ddc:	86 ed       	ldi	r24, 0xD6	; 214
     dde:	91 e0       	ldi	r25, 0x01	; 1
     de0:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&res_cv, (current_patch.res) << 4);
     de4:	60 91 e6 02 	lds	r22, 0x02E6
     de8:	70 91 e7 02 	lds	r23, 0x02E7
     dec:	62 95       	swap	r22
     dee:	72 95       	swap	r23
     df0:	70 7f       	andi	r23, 0xF0	; 240
     df2:	76 27       	eor	r23, r22
     df4:	60 7f       	andi	r22, 0xF0	; 240
     df6:	76 27       	eor	r23, r22
     df8:	85 ed       	ldi	r24, 0xD5	; 213
     dfa:	91 e0       	ldi	r25, 0x01	; 1
     dfc:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	
	//this next bit should be separated out, but leave it here for now while testing decoupled adc/dac read/write
	uint8_t note = get_current_note(); //get current note from assigner
     e00:	0e 94 8d 01 	call	0x31a	; 0x31a <get_current_note>
     e04:	c8 2f       	mov	r28, r24
	if (note < 8) note = 8; //init_cv gives VCO range from MIDI note 8 to MIDI note 127+. If you don't set notes <8 to 8 then you get array out of bounds problems. Should find a better way to handle this.
     e06:	88 30       	cpi	r24, 0x08	; 8
     e08:	08 f4       	brcc	.+2      	; 0xe0c <update_control_voltages+0x200>
     e0a:	c8 e0       	ldi	r28, 0x08	; 8
	//value_to_display = current_patch.number + 100*(arp.sequence[arp.step_position].note); //100*note;
	//value_to_display = arp.sequence[arp.step_position].note;
	//uint8_t arp_note = arp.sequence[arp.step_position].note;
	//if (arp_note == EMPTY) arp_note = 0;
	value_to_display = current_patch.number + 100*arp.display;
     e0c:	60 91 07 03 	lds	r22, 0x0307
     e10:	40 91 90 03 	lds	r20, 0x0390
     e14:	50 e0       	ldi	r21, 0x00	; 0
     e16:	24 e6       	ldi	r18, 0x64	; 100
     e18:	30 e0       	ldi	r19, 0x00	; 0
     e1a:	42 9f       	mul	r20, r18
     e1c:	c0 01       	movw	r24, r0
     e1e:	43 9f       	mul	r20, r19
     e20:	90 0d       	add	r25, r0
     e22:	52 9f       	mul	r21, r18
     e24:	90 0d       	add	r25, r0
     e26:	11 24       	eor	r1, r1
     e28:	86 0f       	add	r24, r22
     e2a:	91 1d       	adc	r25, r1
     e2c:	90 93 fe 01 	sts	0x01FE, r25
     e30:	80 93 fd 01 	sts	0x01FD, r24
		
	uint16_t interpolated_pitch_cv = 0; //holder for interpolated pitch values
	
	interpolated_pitch_cv = interpolate_pitch_cv(note-8, filter_pitch_table); //subtract 8 from note because filter pitch is calibrated so that 0V is E, 20.6 Hz
     e34:	8c 2f       	mov	r24, r28
     e36:	88 50       	subi	r24, 0x08	; 8
     e38:	63 e1       	ldi	r22, 0x13	; 19
     e3a:	73 e0       	ldi	r23, 0x03	; 3
     e3c:	0e 94 60 16 	call	0x2cc0	; 0x2cc0 <interpolate_pitch_cv>
	//note that product of key_track and interpolated_pitch_cv needs to be cast as uint32t - otherwise product is evaluated incorrectly
	uint16_t divided_pitch_cv = ((uint32_t)current_patch.key_track*interpolated_pitch_cv) >> 10;
     e40:	bc 01       	movw	r22, r24
     e42:	80 e0       	ldi	r24, 0x00	; 0
     e44:	90 e0       	ldi	r25, 0x00	; 0
     e46:	20 91 ea 02 	lds	r18, 0x02EA
     e4a:	30 91 eb 02 	lds	r19, 0x02EB
     e4e:	40 e0       	ldi	r20, 0x00	; 0
     e50:	50 e0       	ldi	r21, 0x00	; 0
     e52:	0e 94 3e 1e 	call	0x3c7c	; 0x3c7c <__mulsi3>
     e56:	dc 01       	movw	r26, r24
     e58:	cb 01       	movw	r24, r22
     e5a:	07 2e       	mov	r0, r23
     e5c:	7a e0       	ldi	r23, 0x0A	; 10
     e5e:	b6 95       	lsr	r27
     e60:	a7 95       	ror	r26
     e62:	97 95       	ror	r25
     e64:	87 95       	ror	r24
     e66:	7a 95       	dec	r23
     e68:	d1 f7       	brne	.-12     	; 0xe5e <update_control_voltages+0x252>
     e6a:	70 2d       	mov	r23, r0
	uint16_t filter_cutoff_cv = divided_pitch_cv + (current_patch.cutoff << 4); //filter cutoff CV is the sum of filter cutoff pot and key track amount.
     e6c:	60 91 e8 02 	lds	r22, 0x02E8
     e70:	70 91 e9 02 	lds	r23, 0x02E9
     e74:	62 95       	swap	r22
     e76:	72 95       	swap	r23
     e78:	70 7f       	andi	r23, 0xF0	; 240
     e7a:	76 27       	eor	r23, r22
     e7c:	60 7f       	andi	r22, 0xF0	; 240
     e7e:	76 27       	eor	r23, r22
     e80:	86 0f       	add	r24, r22
     e82:	97 1f       	adc	r25, r23
	if (filter_cutoff_cv > MAX) filter_cutoff_cv = MAX; //make sure there is no overflow/wrap by capping max
	set_control_voltage(&cutoff_cv, filter_cutoff_cv);	
     e84:	bc 01       	movw	r22, r24
     e86:	80 e4       	ldi	r24, 0x40	; 64
     e88:	60 30       	cpi	r22, 0x00	; 0
     e8a:	78 07       	cpc	r23, r24
     e8c:	10 f0       	brcs	.+4      	; 0xe92 <update_control_voltages+0x286>
     e8e:	6f ef       	ldi	r22, 0xFF	; 255
     e90:	7f e3       	ldi	r23, 0x3F	; 63
     e92:	84 ed       	ldi	r24, 0xD4	; 212
     e94:	91 e0       	ldi	r25, 0x01	; 1
     e96:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	
	set_control_voltage(&fil_vco2_cv, (current_patch.fil_vco2) << 4);
     e9a:	60 91 ec 02 	lds	r22, 0x02EC
     e9e:	70 91 ed 02 	lds	r23, 0x02ED
     ea2:	62 95       	swap	r22
     ea4:	72 95       	swap	r23
     ea6:	70 7f       	andi	r23, 0xF0	; 240
     ea8:	76 27       	eor	r23, r22
     eaa:	60 7f       	andi	r22, 0xF0	; 240
     eac:	76 27       	eor	r23, r22
     eae:	82 ed       	ldi	r24, 0xD2	; 210
     eb0:	91 e0       	ldi	r25, 0x01	; 1
     eb2:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&fil_lfo_cv, (current_patch.fil_lfo) << 4);
     eb6:	60 91 ee 02 	lds	r22, 0x02EE
     eba:	70 91 ef 02 	lds	r23, 0x02EF
     ebe:	62 95       	swap	r22
     ec0:	72 95       	swap	r23
     ec2:	70 7f       	andi	r23, 0xF0	; 240
     ec4:	76 27       	eor	r23, r22
     ec6:	60 7f       	andi	r22, 0xF0	; 240
     ec8:	76 27       	eor	r23, r22
     eca:	81 ed       	ldi	r24, 0xD1	; 209
     ecc:	91 e0       	ldi	r25, 0x01	; 1
     ece:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&noise_mix_cv, (current_patch.noise_mix) << 4);
     ed2:	60 91 f0 02 	lds	r22, 0x02F0
     ed6:	70 91 f1 02 	lds	r23, 0x02F1
     eda:	62 95       	swap	r22
     edc:	72 95       	swap	r23
     ede:	70 7f       	andi	r23, 0xF0	; 240
     ee0:	76 27       	eor	r23, r22
     ee2:	60 7f       	andi	r22, 0xF0	; 240
     ee4:	76 27       	eor	r23, r22
     ee6:	80 ed       	ldi	r24, 0xD0	; 208
     ee8:	91 e0       	ldi	r25, 0x01	; 1
     eea:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&attack_2_cv, (current_patch.attack_2) << 4);
     eee:	60 91 f2 02 	lds	r22, 0x02F2
     ef2:	70 91 f3 02 	lds	r23, 0x02F3
     ef6:	62 95       	swap	r22
     ef8:	72 95       	swap	r23
     efa:	70 7f       	andi	r23, 0xF0	; 240
     efc:	76 27       	eor	r23, r22
     efe:	60 7f       	andi	r22, 0xF0	; 240
     f00:	76 27       	eor	r23, r22
     f02:	8f ec       	ldi	r24, 0xCF	; 207
     f04:	91 e0       	ldi	r25, 0x01	; 1
     f06:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&attack_1_cv, (current_patch.attack_1) << 4);
     f0a:	60 91 f4 02 	lds	r22, 0x02F4
     f0e:	70 91 f5 02 	lds	r23, 0x02F5
     f12:	62 95       	swap	r22
     f14:	72 95       	swap	r23
     f16:	70 7f       	andi	r23, 0xF0	; 240
     f18:	76 27       	eor	r23, r22
     f1a:	60 7f       	andi	r22, 0xF0	; 240
     f1c:	76 27       	eor	r23, r22
     f1e:	8e ec       	ldi	r24, 0xCE	; 206
     f20:	91 e0       	ldi	r25, 0x01	; 1
     f22:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&decay_2_cv, (current_patch.decay_2) << 4);
     f26:	60 91 f6 02 	lds	r22, 0x02F6
     f2a:	70 91 f7 02 	lds	r23, 0x02F7
     f2e:	62 95       	swap	r22
     f30:	72 95       	swap	r23
     f32:	70 7f       	andi	r23, 0xF0	; 240
     f34:	76 27       	eor	r23, r22
     f36:	60 7f       	andi	r22, 0xF0	; 240
     f38:	76 27       	eor	r23, r22
     f3a:	8d ec       	ldi	r24, 0xCD	; 205
     f3c:	91 e0       	ldi	r25, 0x01	; 1
     f3e:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&decay_1_cv, (current_patch.decay_1) << 4);
     f42:	60 91 f8 02 	lds	r22, 0x02F8
     f46:	70 91 f9 02 	lds	r23, 0x02F9
     f4a:	62 95       	swap	r22
     f4c:	72 95       	swap	r23
     f4e:	70 7f       	andi	r23, 0xF0	; 240
     f50:	76 27       	eor	r23, r22
     f52:	60 7f       	andi	r22, 0xF0	; 240
     f54:	76 27       	eor	r23, r22
     f56:	8c ec       	ldi	r24, 0xCC	; 204
     f58:	91 e0       	ldi	r25, 0x01	; 1
     f5a:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&sustain_1_cv, (current_patch.sustain_1) << 4);
     f5e:	60 91 fc 02 	lds	r22, 0x02FC
     f62:	70 91 fd 02 	lds	r23, 0x02FD
     f66:	62 95       	swap	r22
     f68:	72 95       	swap	r23
     f6a:	70 7f       	andi	r23, 0xF0	; 240
     f6c:	76 27       	eor	r23, r22
     f6e:	60 7f       	andi	r22, 0xF0	; 240
     f70:	76 27       	eor	r23, r22
     f72:	8a ec       	ldi	r24, 0xCA	; 202
     f74:	91 e0       	ldi	r25, 0x01	; 1
     f76:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&sustain_2_cv, (current_patch.sustain_2) << 4);
     f7a:	60 91 fa 02 	lds	r22, 0x02FA
     f7e:	70 91 fb 02 	lds	r23, 0x02FB
     f82:	62 95       	swap	r22
     f84:	72 95       	swap	r23
     f86:	70 7f       	andi	r23, 0xF0	; 240
     f88:	76 27       	eor	r23, r22
     f8a:	60 7f       	andi	r22, 0xF0	; 240
     f8c:	76 27       	eor	r23, r22
     f8e:	8b ec       	ldi	r24, 0xCB	; 203
     f90:	91 e0       	ldi	r25, 0x01	; 1
     f92:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&release_1_cv, (current_patch.release_1) << 4);
     f96:	60 91 00 03 	lds	r22, 0x0300
     f9a:	70 91 01 03 	lds	r23, 0x0301
     f9e:	62 95       	swap	r22
     fa0:	72 95       	swap	r23
     fa2:	70 7f       	andi	r23, 0xF0	; 240
     fa4:	76 27       	eor	r23, r22
     fa6:	60 7f       	andi	r22, 0xF0	; 240
     fa8:	76 27       	eor	r23, r22
     faa:	88 ec       	ldi	r24, 0xC8	; 200
     fac:	91 e0       	ldi	r25, 0x01	; 1
     fae:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&release_2_cv, (current_patch.release_2) << 4);
     fb2:	60 91 fe 02 	lds	r22, 0x02FE
     fb6:	70 91 ff 02 	lds	r23, 0x02FF
     fba:	62 95       	swap	r22
     fbc:	72 95       	swap	r23
     fbe:	70 7f       	andi	r23, 0xF0	; 240
     fc0:	76 27       	eor	r23, r22
     fc2:	60 7f       	andi	r22, 0xF0	; 240
     fc4:	76 27       	eor	r23, r22
     fc6:	89 ec       	ldi	r24, 0xC9	; 201
     fc8:	91 e0       	ldi	r25, 0x01	; 1
     fca:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>

	//set VCO1 and VCO2 pitch control voltages. Remember, set_control_voltage() is expecting a pointer to a control_voltage struct
	//that contains the control_voltage multiplexer channel and the multiplexer address
	

	uint8_t vco1_note = transpose_note(note, VCO1); //transpose
     fce:	8c 2f       	mov	r24, r28
     fd0:	6f e0       	ldi	r22, 0x0F	; 15
     fd2:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <transpose_note>

	interpolated_pitch_cv = interpolate_pitch_cv(vco1_note, vco1_pitch_table);
     fd6:	65 e5       	ldi	r22, 0x55	; 85
     fd8:	73 e0       	ldi	r23, 0x03	; 3
     fda:	0e 94 60 16 	call	0x2cc0	; 0x2cc0 <interpolate_pitch_cv>
     fde:	bc 01       	movw	r22, r24
	
	//value_to_display = interpolated_pitch_cv;
	
	set_control_voltage(&vco1_pitch_cv, interpolated_pitch_cv);
     fe0:	86 ee       	ldi	r24, 0xE6	; 230
     fe2:	91 e0       	ldi	r25, 0x01	; 1
     fe4:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	
	uint8_t vco2_note = transpose_note(note, VCO2);
     fe8:	8c 2f       	mov	r24, r28
     fea:	60 ef       	ldi	r22, 0xF0	; 240
     fec:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <transpose_note>
	
	interpolated_pitch_cv = interpolate_pitch_cv(vco2_note, vco2_pitch_table);
     ff0:	63 e3       	ldi	r22, 0x33	; 51
     ff2:	73 e0       	ldi	r23, 0x03	; 3
     ff4:	0e 94 60 16 	call	0x2cc0	; 0x2cc0 <interpolate_pitch_cv>
     ff8:	bc 01       	movw	r22, r24
	
	set_control_voltage(&vco2_pitch_cv, interpolated_pitch_cv);
     ffa:	85 ee       	ldi	r24, 0xE5	; 229
     ffc:	91 e0       	ldi	r25, 0x01	; 1
     ffe:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
		
	DAC_CTRL &= ~(1<<DAC_RS); //reset DAC
    1002:	a1 98       	cbi	0x14, 1	; 20
	DAC_CTRL |= (1<<DAC_RS);
    1004:	a1 9a       	sbi	0x14, 1	; 20
	
	system_clock.rate = (1023 - arp_rate_pot.value) + 244;    
    1006:	20 91 88 01 	lds	r18, 0x0188
    100a:	80 91 89 01 	lds	r24, 0x0189
    100e:	38 2f       	mov	r19, r24
    1010:	33 70       	andi	r19, 0x03	; 3
    1012:	83 ef       	ldi	r24, 0xF3	; 243
    1014:	94 e0       	ldi	r25, 0x04	; 4
    1016:	82 1b       	sub	r24, r18
    1018:	93 0b       	sbc	r25, r19
    101a:	90 93 d6 03 	sts	0x03D6, r25
    101e:	80 93 d5 03 	sts	0x03D5, r24
	
	if (system_clock.rate != system_clock.previous_rate) {
    1022:	20 91 d7 03 	lds	r18, 0x03D7
    1026:	30 91 d8 03 	lds	r19, 0x03D8
    102a:	82 17       	cp	r24, r18
    102c:	93 07       	cpc	r25, r19
    102e:	11 f0       	breq	.+4      	; 0x1034 <update_control_voltages+0x428>
		
		update_clock_rate(system_clock.rate);
    1030:	0e 94 f3 01 	call	0x3e6	; 0x3e6 <update_clock_rate>
	
	}
	
	system_clock.previous_rate = system_clock.rate;
    1034:	80 91 d5 03 	lds	r24, 0x03D5
    1038:	90 91 d6 03 	lds	r25, 0x03D6
    103c:	90 93 d8 03 	sts	0x03D8, r25
    1040:	80 93 d7 03 	sts	0x03D7, r24
	
}			
    1044:	df 91       	pop	r29
    1046:	cf 91       	pop	r28
    1048:	08 95       	ret

0000104a <setup_spi>:
void setup_spi(void) {
	
		//SET SPI_DATA_OUT and SPI_CLK and SPI_SW_LATCH pins as outputs
		//also set Slave Select (PB0) as output just to ensure it doesn't interfere with SPI communication (currently floating)
		//ACTUALLY, Slave Select ***MUST*** be set as output. Leaving it floating without setting its data direction bit breaks SPI!
		DDRB |= (SPI_DATA_OUT | SPI_CLK | SPI_SW_LATCH |(1<<PB0));
    104a:	84 b1       	in	r24, 0x04	; 4
    104c:	87 62       	ori	r24, 0x27	; 39
    104e:	84 b9       	out	0x04, r24	; 4
		
		//SET SPI_EN and LED_LATCH and VCO_SW_LATCH and EG2_POL pins as outputs
		DDRJ |= (SPI_EN | LED_LATCH | (1<<VCO_SW_LATCH) | (1<<EG2_POL));
    1050:	ec ed       	ldi	r30, 0xDC	; 220
    1052:	f0 e0       	ldi	r31, 0x00	; 0
    1054:	80 81       	ld	r24, Z
    1056:	8c 65       	ori	r24, 0x5C	; 92
    1058:	80 83       	st	Z, r24
		
		//SET SPI_DATA_OUT and SPI_CLK and SPI_SW_LATCH outputs LOW
		SPI_PORT &= ~(SPI_DATA_OUT | SPI_CLK | SPI_SW_LATCH);
    105a:	85 b1       	in	r24, 0x05	; 5
    105c:	89 7d       	andi	r24, 0xD9	; 217
    105e:	85 b9       	out	0x05, r24	; 5
		
		//SET SPI_EN LOW (active) and LED_LATCH LOW (active)
		SPI_LATCH_PORT &= ~(SPI_EN | LED_LATCH);
    1060:	ed ed       	ldi	r30, 0xDD	; 221
    1062:	f0 e0       	ldi	r31, 0x00	; 0
    1064:	80 81       	ld	r24, Z
    1066:	83 7f       	andi	r24, 0xF3	; 243
    1068:	80 83       	st	Z, r24
		
		//SET UP SPI
		SPCR = (1<<SPE) | (1<<MSTR); //Start SPI as MASTER
    106a:	80 e5       	ldi	r24, 0x50	; 80
    106c:	8c bd       	out	0x2c, r24	; 44
		
		//Pull LED_LATCH LOW
		SPI_LATCH_PORT &= ~LED_LATCH;
    106e:	80 81       	ld	r24, Z
    1070:	87 7f       	andi	r24, 0xF7	; 247
    1072:	80 83       	st	Z, r24
		
		
		//Toggle LED_LATCH to shift data to 74HC595 shift register outputs
		
		SPI_LATCH_PORT &= ~LED_LATCH;
    1074:	80 81       	ld	r24, Z
    1076:	87 7f       	andi	r24, 0xF7	; 247
    1078:	80 83       	st	Z, r24
		SPI_LATCH_PORT |= LED_LATCH;
    107a:	80 81       	ld	r24, Z
    107c:	88 60       	ori	r24, 0x08	; 8
    107e:	80 83       	st	Z, r24
		
		//set EG2 POL
		EG2_POL_PORT &= ~(1 << EG2_POL); //0 for normal, 1 for inverted
    1080:	80 81       	ld	r24, Z
    1082:	8f 7e       	andi	r24, 0xEF	; 239
    1084:	80 83       	st	Z, r24
	
}
    1086:	08 95       	ret

00001088 <spi_shift_byte>:

uint8_t spi_shift_byte(uint8_t byte) { //shifts out byte for LED data and simultaneously reads switch data
	
	SPDR = byte;
    1088:	8e bd       	out	0x2e, r24	; 46
	while (!(SPSR & (1<<SPIF)));
    108a:	0d b4       	in	r0, 0x2d	; 45
    108c:	07 fe       	sbrs	r0, 7
    108e:	fd cf       	rjmp	.-6      	; 0x108a <spi_shift_byte+0x2>
	return SPDR;
    1090:	8e b5       	in	r24, 0x2e	; 46
	
}
    1092:	08 95       	ret

00001094 <update_spi>:

void update_spi(void) {
	
			SPI_PORT |= SPI_SW_LATCH;
    1094:	2d 9a       	sbi	0x05, 5	; 5
			
			//SHIFT 5th BYTE				
			//Read SPDR for switch data shifted in from 74XX165 U14 and write LED data to LED latch 5
			spi_sw_byte0_current_state = spi_shift_byte(current_patch.byte_5);
    1096:	80 91 06 03 	lds	r24, 0x0306
    109a:	0e 94 44 08 	call	0x1088	; 0x1088 <spi_shift_byte>
			switch_press |= spi_sw_byte0_current_state; //set switch press global flag
    109e:	90 91 c5 02 	lds	r25, 0x02C5
    10a2:	98 2b       	or	r25, r24
    10a4:	90 93 c5 02 	sts	0x02C5, r25
			spi_sw_byte0_current_state ^= spi_sw_byte0_previous_state;
    10a8:	20 91 c3 02 	lds	r18, 0x02C3
    10ac:	98 2f       	mov	r25, r24
    10ae:	92 27       	eor	r25, r18
			spi_sw_byte0_previous_state ^= spi_sw_byte0_current_state;
    10b0:	89 2f       	mov	r24, r25
    10b2:	82 27       	eor	r24, r18
    10b4:	80 93 c3 02 	sts	0x02C3, r24
			spi_sw_byte0_current_state &= spi_sw_byte0_previous_state;
    10b8:	89 23       	and	r24, r25
    10ba:	80 93 c4 02 	sts	0x02C4, r24
			
			//toggle switch state		
			switch_states.byte0 ^= spi_sw_byte0_current_state; //Omar's solution.
    10be:	90 91 82 03 	lds	r25, 0x0382
    10c2:	89 27       	eor	r24, r25
    10c4:	80 93 82 03 	sts	0x0382, r24
			//Now read SPDR for switch data shifted in from 74XX165 (U9)
			//uint8_t spi_data = (1<<VCO2_32F | 1<<VCO1_32F); //turn on 32' octave LEDs as default 
			
			uint8_t spi_data = current_patch.byte_4;
					
			spi_sw_byte1_current_state = spi_shift_byte(spi_data);
    10c8:	80 91 05 03 	lds	r24, 0x0305
    10cc:	0e 94 44 08 	call	0x1088	; 0x1088 <spi_shift_byte>
			switch_press |= spi_sw_byte1_current_state;
    10d0:	90 91 c5 02 	lds	r25, 0x02C5
    10d4:	98 2b       	or	r25, r24
    10d6:	90 93 c5 02 	sts	0x02C5, r25
			spi_sw_byte1_current_state ^= spi_sw_byte1_previous_state;
    10da:	20 91 c1 02 	lds	r18, 0x02C1
    10de:	98 2f       	mov	r25, r24
    10e0:	92 27       	eor	r25, r18
			spi_sw_byte1_previous_state ^= spi_sw_byte1_current_state;
    10e2:	89 2f       	mov	r24, r25
    10e4:	82 27       	eor	r24, r18
    10e6:	80 93 c1 02 	sts	0x02C1, r24
			spi_sw_byte1_current_state &= spi_sw_byte1_previous_state;
    10ea:	89 23       	and	r24, r25
    10ec:	80 93 c2 02 	sts	0x02C2, r24
			
			//toggle switch state
			switch_states.byte1 ^= spi_sw_byte1_current_state; //Omar's solution.			
    10f0:	90 91 83 03 	lds	r25, 0x0383
    10f4:	89 27       	eor	r24, r25
    10f6:	80 93 83 03 	sts	0x0383, r24
							
			//SHIFT 3th BYTE
			spi_shift_byte(current_patch.byte_3);
    10fa:	80 91 04 03 	lds	r24, 0x0304
    10fe:	0e 94 44 08 	call	0x1088	; 0x1088 <spi_shift_byte>

			//SHIFT 2th BYTE
			spi_shift_byte(current_patch.byte_2);
    1102:	80 91 03 03 	lds	r24, 0x0303
    1106:	0e 94 44 08 	call	0x1088	; 0x1088 <spi_shift_byte>
			
			//SHIFT 1st BYTE	//eventually need to parse this elsewhere		
			spi_data =	//((switch_states.byte1 >> ARP_MODE_SW) & 1) << ARP_MODE | 
    110a:	80 91 0b 03 	lds	r24, 0x030B
    110e:	83 30       	cpi	r24, 0x03	; 3
    1110:	11 f4       	brne	.+4      	; 0x1116 <__stack+0x17>
    1112:	20 e8       	ldi	r18, 0x80	; 128
    1114:	01 c0       	rjmp	.+2      	; 0x1118 <__stack+0x19>
    1116:	20 e0       	ldi	r18, 0x00	; 0
						//((switch_states.byte2 >> PROG_WRITE_SW) & 1) << PROG_WRITE | 
						((current_patch.mode == WRITE) << PROG_WRITE) | //hack to light PROG WRITE LED only when in WRITE mode
						//((switch_states.byte2 >> EG2_INV_SW) &1 ) << EG2_INV |
						((switch_states.byte2 >> PROG_MANUAL_SW &1) << PROG_MANUAL) |
    1118:	80 91 84 03 	lds	r24, 0x0384
    111c:	88 1f       	adc	r24, r24
    111e:	88 27       	eor	r24, r24
    1120:	88 1f       	adc	r24, r24
    1122:	82 95       	swap	r24
    1124:	88 0f       	add	r24, r24
    1126:	88 0f       	add	r24, r24
    1128:	80 7c       	andi	r24, 0xC0	; 192

			//SHIFT 2th BYTE
			spi_shift_byte(current_patch.byte_2);
			
			//SHIFT 1st BYTE	//eventually need to parse this elsewhere		
			spi_data =	//((switch_states.byte1 >> ARP_MODE_SW) & 1) << ARP_MODE | 
    112a:	90 91 02 03 	lds	r25, 0x0302
    112e:	89 2b       	or	r24, r25
						((current_patch.mode == WRITE) << PROG_WRITE) | //hack to light PROG WRITE LED only when in WRITE mode
						//((switch_states.byte2 >> EG2_INV_SW) &1 ) << EG2_INV |
						((switch_states.byte2 >> PROG_MANUAL_SW &1) << PROG_MANUAL) |
						((current_patch.byte_1)); 			
			//Wait for SPI shift to complete
			spi_shift_byte(spi_data);
    1130:	82 2b       	or	r24, r18
    1132:	0e 94 44 08 	call	0x1088	; 0x1088 <spi_shift_byte>
			
			//Toggle LED_LATCH to shift data to 74HC595 shift register outputs
			
			SPI_LATCH_PORT &= ~LED_LATCH;
    1136:	ed ed       	ldi	r30, 0xDD	; 221
    1138:	f0 e0       	ldi	r31, 0x00	; 0
    113a:	80 81       	ld	r24, Z
    113c:	87 7f       	andi	r24, 0xF7	; 247
    113e:	80 83       	st	Z, r24
			SPI_LATCH_PORT |= LED_LATCH;
    1140:	80 81       	ld	r24, Z
    1142:	88 60       	ori	r24, 0x08	; 8
    1144:	80 83       	st	Z, r24
			
			//clear SPI_SW_LATCH
			SPI_PORT &= ~SPI_SW_LATCH;
    1146:	2d 98       	cbi	0x05, 5	; 5
			
			

	
    1148:	08 95       	ret

0000114a <lock_pots>:
		LFO_PULSE_ADDR,
		LFO_RNDM_ADDR
	};
	

void lock_pots(void) { //run this every time new patch is loaded to lock pots and store locked values
    114a:	a0 e0       	ldi	r26, 0x00	; 0
    114c:	b1 e0       	ldi	r27, 0x01	; 1
    114e:	9d 01       	movw	r18, r26
    1150:	24 5c       	subi	r18, 0xC4	; 196
    1152:	3f 4f       	sbci	r19, 0xFF	; 255

for (int i = 0; i <= NUM_POTS; i++) {
	
	pot_id[i]->locked_value = (pot_id[i]->value) >> 2;
    1154:	ed 91       	ld	r30, X+
    1156:	fc 91       	ld	r31, X
    1158:	11 97       	sbiw	r26, 0x01	; 1
    115a:	80 81       	ld	r24, Z
    115c:	41 81       	ldd	r20, Z+1	; 0x01
    115e:	94 2f       	mov	r25, r20
    1160:	93 70       	andi	r25, 0x03	; 3
    1162:	95 95       	asr	r25
    1164:	87 95       	ror	r24
    1166:	95 95       	asr	r25
    1168:	87 95       	ror	r24
    116a:	82 83       	std	Z+2, r24	; 0x02
	pot_id[i]->locked = 1;
    116c:	ed 91       	ld	r30, X+
    116e:	fd 91       	ld	r31, X+
    1170:	83 81       	ldd	r24, Z+3	; 0x03
    1172:	80 68       	ori	r24, 0x80	; 128
    1174:	83 83       	std	Z+3, r24	; 0x03
	};
	

void lock_pots(void) { //run this every time new patch is loaded to lock pots and store locked values

for (int i = 0; i <= NUM_POTS; i++) {
    1176:	a2 17       	cp	r26, r18
    1178:	b3 07       	cpc	r27, r19
    117a:	61 f7       	brne	.-40     	; 0x1154 <lock_pots+0xa>
	pot_id[i]->locked_value = (pot_id[i]->value) >> 2;
	pot_id[i]->locked = 1;
	
}

}
    117c:	08 95       	ret

0000117e <unlock_pots>:

void unlock_pots(void) {
    117e:	e0 e0       	ldi	r30, 0x00	; 0
    1180:	f1 e0       	ldi	r31, 0x01	; 1
    1182:	cf 01       	movw	r24, r30
    1184:	cc 96       	adiw	r24, 0x3c	; 60
	
	for (int i = 0; i <= NUM_POTS; i++) {
		
		pot_id[i]->locked = 0;
    1186:	a1 91       	ld	r26, Z+
    1188:	b1 91       	ld	r27, Z+
    118a:	13 96       	adiw	r26, 0x03	; 3
    118c:	2c 91       	ld	r18, X
    118e:	13 97       	sbiw	r26, 0x03	; 3
    1190:	2f 77       	andi	r18, 0x7F	; 127
    1192:	13 96       	adiw	r26, 0x03	; 3
    1194:	2c 93       	st	X, r18
    1196:	13 97       	sbiw	r26, 0x03	; 3

}

void unlock_pots(void) {
	
	for (int i = 0; i <= NUM_POTS; i++) {
    1198:	e8 17       	cp	r30, r24
    119a:	f9 07       	cpc	r31, r25
    119c:	a1 f7       	brne	.-24     	; 0x1186 <unlock_pots+0x8>
		
		pot_id[i]->locked = 0;
		
	}
	
}			
    119e:	08 95       	ret

000011a0 <save_patch>:
	
	
void save_patch(uint8_t patch_number) {
    11a0:	1f 93       	push	r17
    11a2:	cf 93       	push	r28
    11a4:	df 93       	push	r29
    11a6:	cd b7       	in	r28, 0x3d	; 61
    11a8:	de b7       	in	r29, 0x3e	; 62
    11aa:	ab 97       	sbiw	r28, 0x2b	; 43
    11ac:	0f b6       	in	r0, 0x3f	; 63
    11ae:	f8 94       	cli
    11b0:	de bf       	out	0x3e, r29	; 62
    11b2:	0f be       	out	0x3f, r0	; 63
    11b4:	cd bf       	out	0x3d, r28	; 61
    11b6:	18 2f       	mov	r17, r24
	
	struct eeprom_patch patch_to_save;
	//because of bit fields in eeprom patch struct, a temporary eeprom patch needs to be filled with current_patch values and then saved to memory.
	
	patch_to_save.vco2_pw = current_patch.vco2_pw;
    11b8:	e2 ee       	ldi	r30, 0xE2	; 226
    11ba:	f2 e0       	ldi	r31, 0x02	; 2
    11bc:	20 91 e2 02 	lds	r18, 0x02E2
    11c0:	82 2f       	mov	r24, r18
    11c2:	82 95       	swap	r24
    11c4:	80 7f       	andi	r24, 0xF0	; 240
    11c6:	22 95       	swap	r18
    11c8:	2f 70       	andi	r18, 0x0F	; 15
    11ca:	90 91 e3 02 	lds	r25, 0x02E3
    11ce:	93 70       	andi	r25, 0x03	; 3
    11d0:	92 95       	swap	r25
    11d2:	90 7f       	andi	r25, 0xF0	; 240
	patch_to_save.vco1_mix = current_patch.vco1_mix;
    11d4:	df 01       	movw	r26, r30
    11d6:	5a 97       	sbiw	r26, 0x1a	; 26
    11d8:	3c 91       	ld	r19, X
    11da:	53 2f       	mov	r21, r19
    11dc:	55 0f       	add	r21, r21
    11de:	55 0f       	add	r21, r21
    11e0:	4a 81       	ldd	r20, Y+2	; 0x02
    11e2:	43 70       	andi	r20, 0x03	; 3
    11e4:	45 2b       	or	r20, r21
    11e6:	4a 83       	std	Y+2, r20	; 0x02
    11e8:	63 2f       	mov	r22, r19
    11ea:	62 95       	swap	r22
    11ec:	66 95       	lsr	r22
    11ee:	66 95       	lsr	r22
    11f0:	63 70       	andi	r22, 0x03	; 3
    11f2:	11 96       	adiw	r26, 0x01	; 1
    11f4:	4c 91       	ld	r20, X
    11f6:	43 70       	andi	r20, 0x03	; 3
    11f8:	44 0f       	add	r20, r20
    11fa:	44 0f       	add	r20, r20
	patch_to_save.pitch_eg2 = current_patch.pitch_eg2;
    11fc:	df 01       	movw	r26, r30
    11fe:	58 97       	sbiw	r26, 0x18	; 24
    1200:	3c 91       	ld	r19, X
    1202:	53 2f       	mov	r21, r19
    1204:	52 95       	swap	r21
    1206:	50 7f       	andi	r21, 0xF0	; 240
    1208:	46 2b       	or	r20, r22
    120a:	45 2b       	or	r20, r21
    120c:	4b 83       	std	Y+3, r20	; 0x03
    120e:	63 2f       	mov	r22, r19
    1210:	62 95       	swap	r22
    1212:	6f 70       	andi	r22, 0x0F	; 15
    1214:	11 96       	adiw	r26, 0x01	; 1
    1216:	4c 91       	ld	r20, X
    1218:	43 70       	andi	r20, 0x03	; 3
    121a:	42 95       	swap	r20
    121c:	40 7f       	andi	r20, 0xF0	; 240
	patch_to_save.pitch_vco2 = current_patch.pitch_vco2;
    121e:	df 01       	movw	r26, r30
    1220:	56 97       	sbiw	r26, 0x16	; 22
    1222:	3c 91       	ld	r19, X
    1224:	53 2f       	mov	r21, r19
    1226:	52 95       	swap	r21
    1228:	55 0f       	add	r21, r21
    122a:	55 0f       	add	r21, r21
    122c:	50 7c       	andi	r21, 0xC0	; 192
    122e:	46 2b       	or	r20, r22
    1230:	45 2b       	or	r20, r21
    1232:	4c 83       	std	Y+4, r20	; 0x04
    1234:	11 96       	adiw	r26, 0x01	; 1
    1236:	4c 91       	ld	r20, X
    1238:	42 95       	swap	r20
    123a:	44 0f       	add	r20, r20
    123c:	44 0f       	add	r20, r20
    123e:	40 7c       	andi	r20, 0xC0	; 192
    1240:	36 95       	lsr	r19
    1242:	36 95       	lsr	r19
    1244:	34 2b       	or	r19, r20
    1246:	3d 83       	std	Y+5, r19	; 0x05
	patch_to_save.pitch_lfo = current_patch.pitch_lfo;
    1248:	df 01       	movw	r26, r30
    124a:	54 97       	sbiw	r26, 0x14	; 20
    124c:	3c 91       	ld	r19, X
    124e:	3e 83       	std	Y+6, r19	; 0x06
    1250:	11 96       	adiw	r26, 0x01	; 1
    1252:	4c 91       	ld	r20, X
	patch_to_save.pwm_lfo = current_patch.pwm_lfo;
    1254:	df 01       	movw	r26, r30
    1256:	52 97       	sbiw	r26, 0x12	; 18
    1258:	3c 91       	ld	r19, X
    125a:	53 2f       	mov	r21, r19
    125c:	55 0f       	add	r21, r21
    125e:	55 0f       	add	r21, r21
    1260:	43 70       	andi	r20, 0x03	; 3
    1262:	45 2b       	or	r20, r21
    1264:	4f 83       	std	Y+7, r20	; 0x07
    1266:	63 2f       	mov	r22, r19
    1268:	62 95       	swap	r22
    126a:	66 95       	lsr	r22
    126c:	66 95       	lsr	r22
    126e:	63 70       	andi	r22, 0x03	; 3
    1270:	11 96       	adiw	r26, 0x01	; 1
    1272:	4c 91       	ld	r20, X
    1274:	43 70       	andi	r20, 0x03	; 3
    1276:	44 0f       	add	r20, r20
    1278:	44 0f       	add	r20, r20
	patch_to_save.pwm_eg2 = current_patch.pwm_eg2;
    127a:	df 01       	movw	r26, r30
    127c:	50 97       	sbiw	r26, 0x10	; 16
    127e:	3c 91       	ld	r19, X
    1280:	53 2f       	mov	r21, r19
    1282:	52 95       	swap	r21
    1284:	50 7f       	andi	r21, 0xF0	; 240
    1286:	46 2b       	or	r20, r22
    1288:	45 2b       	or	r20, r21
    128a:	48 87       	std	Y+8, r20	; 0x08
    128c:	63 2f       	mov	r22, r19
    128e:	62 95       	swap	r22
    1290:	6f 70       	andi	r22, 0x0F	; 15
    1292:	11 96       	adiw	r26, 0x01	; 1
    1294:	4c 91       	ld	r20, X
    1296:	43 70       	andi	r20, 0x03	; 3
    1298:	42 95       	swap	r20
    129a:	40 7f       	andi	r20, 0xF0	; 240
	patch_to_save.vco1_pw = current_patch.vco1_pw;
    129c:	df 01       	movw	r26, r30
    129e:	1e 97       	sbiw	r26, 0x0e	; 14
    12a0:	3c 91       	ld	r19, X
    12a2:	53 2f       	mov	r21, r19
    12a4:	52 95       	swap	r21
    12a6:	55 0f       	add	r21, r21
    12a8:	55 0f       	add	r21, r21
    12aa:	50 7c       	andi	r21, 0xC0	; 192
    12ac:	46 2b       	or	r20, r22
    12ae:	45 2b       	or	r20, r21
    12b0:	49 87       	std	Y+9, r20	; 0x09
    12b2:	11 96       	adiw	r26, 0x01	; 1
    12b4:	4c 91       	ld	r20, X
    12b6:	42 95       	swap	r20
    12b8:	44 0f       	add	r20, r20
    12ba:	44 0f       	add	r20, r20
    12bc:	40 7c       	andi	r20, 0xC0	; 192
    12be:	36 95       	lsr	r19
    12c0:	36 95       	lsr	r19
    12c2:	34 2b       	or	r19, r20
    12c4:	3a 87       	std	Y+10, r19	; 0x0a
	patch_to_save.fine = current_patch.fine;
    12c6:	df 01       	movw	r26, r30
    12c8:	1c 97       	sbiw	r26, 0x0c	; 12
    12ca:	3c 91       	ld	r19, X
    12cc:	3b 87       	std	Y+11, r19	; 0x0b
    12ce:	11 96       	adiw	r26, 0x01	; 1
    12d0:	4c 91       	ld	r20, X
	patch_to_save.tune = current_patch.tune; //probably shouldn't save master tune value. Like volume, it is a parameter that doesn't apply to a patch.
    12d2:	df 01       	movw	r26, r30
    12d4:	1a 97       	sbiw	r26, 0x0a	; 10
    12d6:	3c 91       	ld	r19, X
    12d8:	53 2f       	mov	r21, r19
    12da:	55 0f       	add	r21, r21
    12dc:	55 0f       	add	r21, r21
    12de:	43 70       	andi	r20, 0x03	; 3
    12e0:	45 2b       	or	r20, r21
    12e2:	4c 87       	std	Y+12, r20	; 0x0c
    12e4:	63 2f       	mov	r22, r19
    12e6:	62 95       	swap	r22
    12e8:	66 95       	lsr	r22
    12ea:	66 95       	lsr	r22
    12ec:	63 70       	andi	r22, 0x03	; 3
    12ee:	11 96       	adiw	r26, 0x01	; 1
    12f0:	4c 91       	ld	r20, X
    12f2:	43 70       	andi	r20, 0x03	; 3
    12f4:	44 0f       	add	r20, r20
    12f6:	44 0f       	add	r20, r20
	patch_to_save.lfo_rate = current_patch.lfo_rate;
    12f8:	df 01       	movw	r26, r30
    12fa:	18 97       	sbiw	r26, 0x08	; 8
    12fc:	3c 91       	ld	r19, X
    12fe:	53 2f       	mov	r21, r19
    1300:	52 95       	swap	r21
    1302:	50 7f       	andi	r21, 0xF0	; 240
    1304:	46 2b       	or	r20, r22
    1306:	45 2b       	or	r20, r21
    1308:	4d 87       	std	Y+13, r20	; 0x0d
    130a:	63 2f       	mov	r22, r19
    130c:	62 95       	swap	r22
    130e:	6f 70       	andi	r22, 0x0F	; 15
    1310:	11 96       	adiw	r26, 0x01	; 1
    1312:	4c 91       	ld	r20, X
    1314:	43 70       	andi	r20, 0x03	; 3
    1316:	42 95       	swap	r20
    1318:	40 7f       	andi	r20, 0xF0	; 240
	patch_to_save.arp_rate = current_patch.arp_rate;
    131a:	df 01       	movw	r26, r30
    131c:	16 97       	sbiw	r26, 0x06	; 6
    131e:	3c 91       	ld	r19, X
    1320:	53 2f       	mov	r21, r19
    1322:	52 95       	swap	r21
    1324:	55 0f       	add	r21, r21
    1326:	55 0f       	add	r21, r21
    1328:	50 7c       	andi	r21, 0xC0	; 192
    132a:	46 2b       	or	r20, r22
    132c:	45 2b       	or	r20, r21
    132e:	4e 87       	std	Y+14, r20	; 0x0e
    1330:	11 96       	adiw	r26, 0x01	; 1
    1332:	4c 91       	ld	r20, X
    1334:	42 95       	swap	r20
    1336:	44 0f       	add	r20, r20
    1338:	44 0f       	add	r20, r20
    133a:	40 7c       	andi	r20, 0xC0	; 192
    133c:	36 95       	lsr	r19
    133e:	36 95       	lsr	r19
    1340:	34 2b       	or	r19, r20
    1342:	3f 87       	std	Y+15, r19	; 0x0f
	patch_to_save.glide	= current_patch.glide;
    1344:	df 01       	movw	r26, r30
    1346:	14 97       	sbiw	r26, 0x04	; 4
    1348:	3c 91       	ld	r19, X
    134a:	38 8b       	std	Y+16, r19	; 0x10
    134c:	11 96       	adiw	r26, 0x01	; 1
    134e:	4c 91       	ld	r20, X
	patch_to_save.amp_lfo = current_patch.amp_lfo;
    1350:	df 01       	movw	r26, r30
    1352:	12 97       	sbiw	r26, 0x02	; 2
    1354:	3c 91       	ld	r19, X
    1356:	53 2f       	mov	r21, r19
    1358:	55 0f       	add	r21, r21
    135a:	55 0f       	add	r21, r21
    135c:	43 70       	andi	r20, 0x03	; 3
    135e:	45 2b       	or	r20, r21
    1360:	49 8b       	std	Y+17, r20	; 0x11
    1362:	32 95       	swap	r19
    1364:	36 95       	lsr	r19
    1366:	36 95       	lsr	r19
    1368:	33 70       	andi	r19, 0x03	; 3
    136a:	11 96       	adiw	r26, 0x01	; 1
    136c:	4c 91       	ld	r20, X
    136e:	43 70       	andi	r20, 0x03	; 3
    1370:	44 0f       	add	r20, r20
    1372:	44 0f       	add	r20, r20
    1374:	83 2b       	or	r24, r19
    1376:	84 2b       	or	r24, r20
    1378:	8a 8b       	std	Y+18, r24	; 0x12
	patch_to_save.vco2_pw = current_patch.vco2_pw;
	
	patch_to_save.fil_eg2 = current_patch.fil_eg2;
    137a:	80 91 e4 02 	lds	r24, 0x02E4
    137e:	38 2f       	mov	r19, r24
    1380:	32 95       	swap	r19
    1382:	33 0f       	add	r19, r19
    1384:	33 0f       	add	r19, r19
    1386:	30 7c       	andi	r19, 0xC0	; 192
    1388:	92 2b       	or	r25, r18
    138a:	93 2b       	or	r25, r19
    138c:	9b 8b       	std	Y+19, r25	; 0x13
    138e:	93 81       	ldd	r25, Z+3	; 0x03
    1390:	92 95       	swap	r25
    1392:	99 0f       	add	r25, r25
    1394:	99 0f       	add	r25, r25
    1396:	90 7c       	andi	r25, 0xC0	; 192
    1398:	86 95       	lsr	r24
    139a:	86 95       	lsr	r24
    139c:	89 2b       	or	r24, r25
    139e:	8c 8b       	std	Y+20, r24	; 0x14
	patch_to_save.res = current_patch.res;
    13a0:	80 91 e6 02 	lds	r24, 0x02E6
    13a4:	8d 8b       	std	Y+21, r24	; 0x15
    13a6:	95 81       	ldd	r25, Z+5	; 0x05
	patch_to_save.cutoff = current_patch.cutoff;
    13a8:	80 91 e8 02 	lds	r24, 0x02E8
    13ac:	28 2f       	mov	r18, r24
    13ae:	22 0f       	add	r18, r18
    13b0:	22 0f       	add	r18, r18
    13b2:	93 70       	andi	r25, 0x03	; 3
    13b4:	92 2b       	or	r25, r18
    13b6:	9e 8b       	std	Y+22, r25	; 0x16
    13b8:	38 2f       	mov	r19, r24
    13ba:	32 95       	swap	r19
    13bc:	36 95       	lsr	r19
    13be:	36 95       	lsr	r19
    13c0:	33 70       	andi	r19, 0x03	; 3
    13c2:	97 81       	ldd	r25, Z+7	; 0x07
    13c4:	93 70       	andi	r25, 0x03	; 3
    13c6:	99 0f       	add	r25, r25
    13c8:	99 0f       	add	r25, r25
	patch_to_save.key_track = current_patch.key_track;
    13ca:	80 91 ea 02 	lds	r24, 0x02EA
    13ce:	28 2f       	mov	r18, r24
    13d0:	22 95       	swap	r18
    13d2:	20 7f       	andi	r18, 0xF0	; 240
    13d4:	93 2b       	or	r25, r19
    13d6:	92 2b       	or	r25, r18
    13d8:	9f 8b       	std	Y+23, r25	; 0x17
    13da:	38 2f       	mov	r19, r24
    13dc:	32 95       	swap	r19
    13de:	3f 70       	andi	r19, 0x0F	; 15
    13e0:	91 85       	ldd	r25, Z+9	; 0x09
    13e2:	93 70       	andi	r25, 0x03	; 3
    13e4:	92 95       	swap	r25
    13e6:	90 7f       	andi	r25, 0xF0	; 240
	patch_to_save.fil_vco2 = current_patch.fil_vco2;
    13e8:	80 91 ec 02 	lds	r24, 0x02EC
    13ec:	28 2f       	mov	r18, r24
    13ee:	22 95       	swap	r18
    13f0:	22 0f       	add	r18, r18
    13f2:	22 0f       	add	r18, r18
    13f4:	20 7c       	andi	r18, 0xC0	; 192
    13f6:	93 2b       	or	r25, r19
    13f8:	92 2b       	or	r25, r18
    13fa:	98 8f       	std	Y+24, r25	; 0x18
    13fc:	93 85       	ldd	r25, Z+11	; 0x0b
    13fe:	92 95       	swap	r25
    1400:	99 0f       	add	r25, r25
    1402:	99 0f       	add	r25, r25
    1404:	90 7c       	andi	r25, 0xC0	; 192
    1406:	86 95       	lsr	r24
    1408:	86 95       	lsr	r24
    140a:	89 2b       	or	r24, r25
    140c:	89 8f       	std	Y+25, r24	; 0x19
	patch_to_save.fil_lfo = current_patch.fil_lfo;
    140e:	80 91 ee 02 	lds	r24, 0x02EE
    1412:	8a 8f       	std	Y+26, r24	; 0x1a
    1414:	95 85       	ldd	r25, Z+13	; 0x0d
	patch_to_save.noise_mix = current_patch.noise_mix;
    1416:	80 91 f0 02 	lds	r24, 0x02F0
    141a:	28 2f       	mov	r18, r24
    141c:	22 0f       	add	r18, r18
    141e:	22 0f       	add	r18, r18
    1420:	93 70       	andi	r25, 0x03	; 3
    1422:	92 2b       	or	r25, r18
    1424:	9b 8f       	std	Y+27, r25	; 0x1b
    1426:	38 2f       	mov	r19, r24
    1428:	32 95       	swap	r19
    142a:	36 95       	lsr	r19
    142c:	36 95       	lsr	r19
    142e:	33 70       	andi	r19, 0x03	; 3
    1430:	97 85       	ldd	r25, Z+15	; 0x0f
    1432:	93 70       	andi	r25, 0x03	; 3
    1434:	99 0f       	add	r25, r25
    1436:	99 0f       	add	r25, r25
	patch_to_save.attack_2 = current_patch.attack_2;
    1438:	80 91 f2 02 	lds	r24, 0x02F2
    143c:	28 2f       	mov	r18, r24
    143e:	22 95       	swap	r18
    1440:	20 7f       	andi	r18, 0xF0	; 240
    1442:	93 2b       	or	r25, r19
    1444:	92 2b       	or	r25, r18
    1446:	9c 8f       	std	Y+28, r25	; 0x1c
    1448:	38 2f       	mov	r19, r24
    144a:	32 95       	swap	r19
    144c:	3f 70       	andi	r19, 0x0F	; 15
    144e:	91 89       	ldd	r25, Z+17	; 0x11
    1450:	93 70       	andi	r25, 0x03	; 3
    1452:	92 95       	swap	r25
    1454:	90 7f       	andi	r25, 0xF0	; 240
	patch_to_save.attack_1 = current_patch.attack_1;
    1456:	80 91 f4 02 	lds	r24, 0x02F4
    145a:	28 2f       	mov	r18, r24
    145c:	22 95       	swap	r18
    145e:	22 0f       	add	r18, r18
    1460:	22 0f       	add	r18, r18
    1462:	20 7c       	andi	r18, 0xC0	; 192
    1464:	93 2b       	or	r25, r19
    1466:	92 2b       	or	r25, r18
    1468:	9d 8f       	std	Y+29, r25	; 0x1d
    146a:	93 89       	ldd	r25, Z+19	; 0x13
    146c:	92 95       	swap	r25
    146e:	99 0f       	add	r25, r25
    1470:	99 0f       	add	r25, r25
    1472:	90 7c       	andi	r25, 0xC0	; 192
    1474:	86 95       	lsr	r24
    1476:	86 95       	lsr	r24
    1478:	89 2b       	or	r24, r25
    147a:	8e 8f       	std	Y+30, r24	; 0x1e
	patch_to_save.decay_2 = current_patch.decay_2;
    147c:	80 91 f6 02 	lds	r24, 0x02F6
    1480:	8f 8f       	std	Y+31, r24	; 0x1f
    1482:	95 89       	ldd	r25, Z+21	; 0x15
	patch_to_save.decay_1 = current_patch.decay_1;
    1484:	80 91 f8 02 	lds	r24, 0x02F8
    1488:	28 2f       	mov	r18, r24
    148a:	22 0f       	add	r18, r18
    148c:	22 0f       	add	r18, r18
    148e:	93 70       	andi	r25, 0x03	; 3
    1490:	92 2b       	or	r25, r18
    1492:	98 a3       	lds	r25, 0x58
    1494:	38 2f       	mov	r19, r24
    1496:	32 95       	swap	r19
    1498:	36 95       	lsr	r19
    149a:	36 95       	lsr	r19
    149c:	33 70       	andi	r19, 0x03	; 3
    149e:	97 89       	ldd	r25, Z+23	; 0x17
    14a0:	93 70       	andi	r25, 0x03	; 3
    14a2:	99 0f       	add	r25, r25
    14a4:	99 0f       	add	r25, r25
	patch_to_save.sustain_2 = current_patch.sustain_2;
    14a6:	80 91 fa 02 	lds	r24, 0x02FA
    14aa:	28 2f       	mov	r18, r24
    14ac:	22 95       	swap	r18
    14ae:	20 7f       	andi	r18, 0xF0	; 240
    14b0:	93 2b       	or	r25, r19
    14b2:	92 2b       	or	r25, r18
    14b4:	99 a3       	lds	r25, 0x59
    14b6:	38 2f       	mov	r19, r24
    14b8:	32 95       	swap	r19
    14ba:	3f 70       	andi	r19, 0x0F	; 15
    14bc:	91 8d       	ldd	r25, Z+25	; 0x19
    14be:	93 70       	andi	r25, 0x03	; 3
    14c0:	92 95       	swap	r25
    14c2:	90 7f       	andi	r25, 0xF0	; 240
	patch_to_save.sustain_1 = current_patch.sustain_1;
    14c4:	80 91 fc 02 	lds	r24, 0x02FC
    14c8:	28 2f       	mov	r18, r24
    14ca:	22 95       	swap	r18
    14cc:	22 0f       	add	r18, r18
    14ce:	22 0f       	add	r18, r18
    14d0:	20 7c       	andi	r18, 0xC0	; 192
    14d2:	93 2b       	or	r25, r19
    14d4:	92 2b       	or	r25, r18
    14d6:	9a a3       	lds	r25, 0x5a
    14d8:	93 8d       	ldd	r25, Z+27	; 0x1b
    14da:	92 95       	swap	r25
    14dc:	99 0f       	add	r25, r25
    14de:	99 0f       	add	r25, r25
    14e0:	90 7c       	andi	r25, 0xC0	; 192
    14e2:	86 95       	lsr	r24
    14e4:	86 95       	lsr	r24
    14e6:	89 2b       	or	r24, r25
    14e8:	8b a3       	lds	r24, 0x5b
	patch_to_save.release_2 = current_patch.release_2;
    14ea:	80 91 fe 02 	lds	r24, 0x02FE
    14ee:	8c a3       	lds	r24, 0x5c
    14f0:	95 8d       	ldd	r25, Z+29	; 0x1d
	patch_to_save.release_1 = current_patch.release_1;
    14f2:	80 91 00 03 	lds	r24, 0x0300
    14f6:	28 2f       	mov	r18, r24
    14f8:	22 0f       	add	r18, r18
    14fa:	22 0f       	add	r18, r18
    14fc:	93 70       	andi	r25, 0x03	; 3
    14fe:	92 2b       	or	r25, r18
    1500:	9d a3       	lds	r25, 0x5d
    1502:	82 95       	swap	r24
    1504:	86 95       	lsr	r24
    1506:	86 95       	lsr	r24
    1508:	83 70       	andi	r24, 0x03	; 3
    150a:	2e a1       	lds	r18, 0x4e
    150c:	20 7f       	andi	r18, 0xF0	; 240
    150e:	97 8d       	ldd	r25, Z+31	; 0x1f
    1510:	93 70       	andi	r25, 0x03	; 3
    1512:	99 0f       	add	r25, r25
    1514:	99 0f       	add	r25, r25
    1516:	82 2b       	or	r24, r18
    1518:	89 2b       	or	r24, r25
    151a:	8e a3       	lds	r24, 0x5e
	
		
	patch_to_save.byte_1 = current_patch.byte_1;
    151c:	80 91 02 03 	lds	r24, 0x0302
    1520:	8f a3       	lds	r24, 0x5f
	patch_to_save.byte_2 = current_patch.byte_2;
    1522:	80 91 03 03 	lds	r24, 0x0303
    1526:	88 a7       	lds	r24, 0x78
	patch_to_save.byte_3 = current_patch.byte_3;
    1528:	80 91 04 03 	lds	r24, 0x0304
    152c:	89 a7       	lds	r24, 0x79
	patch_to_save.byte_4 = current_patch.byte_4;
    152e:	80 91 05 03 	lds	r24, 0x0305
    1532:	8a a7       	lds	r24, 0x7a
	patch_to_save.byte_5 = current_patch.byte_5;
    1534:	80 91 06 03 	lds	r24, 0x0306
    1538:	8b a7       	lds	r24, 0x7b
	
	
	lock_pots();
    153a:	0e 94 a5 08 	call	0x114a	; 0x114a <lock_pots>
	//if (current_patch.mode == MANUAL) switch_states.byte2 &= ~(1<< PROG_MANUAL_SW); //if in MANUAL mode, turn off MANUAL LED
	switch_states.byte2 &= ~(1<< PROG_MANUAL_SW);
    153e:	80 91 84 03 	lds	r24, 0x0384
    1542:	8f 77       	andi	r24, 0x7F	; 127
    1544:	80 93 84 03 	sts	0x0384, r24
	current_patch.mode = MEMORY;
    1548:	10 92 0b 03 	sts	0x030B, r1
	
	eeprom_update_block((const void*)&patch_to_save, (void*)&patch_memory[patch_number], sizeof(patch_to_save));
    154c:	21 2f       	mov	r18, r17
    154e:	30 e0       	ldi	r19, 0x00	; 0
    1550:	8b e2       	ldi	r24, 0x2B	; 43
    1552:	90 e0       	ldi	r25, 0x00	; 0
    1554:	28 9f       	mul	r18, r24
    1556:	b0 01       	movw	r22, r0
    1558:	29 9f       	mul	r18, r25
    155a:	70 0d       	add	r23, r0
    155c:	38 9f       	mul	r19, r24
    155e:	70 0d       	add	r23, r0
    1560:	11 24       	eor	r1, r1
    1562:	60 50       	subi	r22, 0x00	; 0
    1564:	70 40       	sbci	r23, 0x00	; 0
    1566:	ce 01       	movw	r24, r28
    1568:	01 96       	adiw	r24, 0x01	; 1
    156a:	4b e2       	ldi	r20, 0x2B	; 43
    156c:	50 e0       	ldi	r21, 0x00	; 0
    156e:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <__eeupd_block_m6450a>
}	
    1572:	ab 96       	adiw	r28, 0x2b	; 43
    1574:	0f b6       	in	r0, 0x3f	; 63
    1576:	f8 94       	cli
    1578:	de bf       	out	0x3e, r29	; 62
    157a:	0f be       	out	0x3f, r0	; 63
    157c:	cd bf       	out	0x3d, r28	; 61
    157e:	df 91       	pop	r29
    1580:	cf 91       	pop	r28
    1582:	1f 91       	pop	r17
    1584:	08 95       	ret

00001586 <load_patch>:
	
void load_patch(uint8_t patch_number) {
    1586:	1f 93       	push	r17
    1588:	cf 93       	push	r28
    158a:	df 93       	push	r29
    158c:	cd b7       	in	r28, 0x3d	; 61
    158e:	de b7       	in	r29, 0x3e	; 62
    1590:	c3 54       	subi	r28, 0x43	; 67
    1592:	d0 40       	sbci	r29, 0x00	; 0
    1594:	0f b6       	in	r0, 0x3f	; 63
    1596:	f8 94       	cli
    1598:	de bf       	out	0x3e, r29	; 62
    159a:	0f be       	out	0x3f, r0	; 63
    159c:	cd bf       	out	0x3d, r28	; 61
	
	struct eeprom_patch loaded_patch;
	//because of bit fields in eeprom patch struct, a temporary eeprom patch needs to be filled with current_patch values and then saved to memory.
	eeprom_read_block((void*)&loaded_patch, (const void*)&patch_memory[patch_number], sizeof(loaded_patch));
    159e:	90 e0       	ldi	r25, 0x00	; 0
    15a0:	2b e2       	ldi	r18, 0x2B	; 43
    15a2:	30 e0       	ldi	r19, 0x00	; 0
    15a4:	82 9f       	mul	r24, r18
    15a6:	b0 01       	movw	r22, r0
    15a8:	83 9f       	mul	r24, r19
    15aa:	70 0d       	add	r23, r0
    15ac:	92 9f       	mul	r25, r18
    15ae:	70 0d       	add	r23, r0
    15b0:	11 24       	eor	r1, r1
    15b2:	60 50       	subi	r22, 0x00	; 0
    15b4:	70 40       	sbci	r23, 0x00	; 0
    15b6:	ce 01       	movw	r24, r28
    15b8:	01 96       	adiw	r24, 0x01	; 1
    15ba:	4b e2       	ldi	r20, 0x2B	; 43
    15bc:	50 e0       	ldi	r21, 0x00	; 0
    15be:	0e 94 fd 1e 	call	0x3dfa	; 0x3dfa <__eerd_block_m6450a>
	
	
	
	current_patch.vco2_pw = loaded_patch.vco2_pw;
    15c2:	e2 ee       	ldi	r30, 0xE2	; 226
    15c4:	f2 e0       	ldi	r31, 0x02	; 2
    15c6:	8a 89       	ldd	r24, Y+18	; 0x12
    15c8:	28 2f       	mov	r18, r24
    15ca:	22 95       	swap	r18
    15cc:	2f 70       	andi	r18, 0x0F	; 15
    15ce:	9b 89       	ldd	r25, Y+19	; 0x13
    15d0:	39 2f       	mov	r19, r25
    15d2:	32 95       	swap	r19
    15d4:	30 7f       	andi	r19, 0xF0	; 240
    15d6:	32 2b       	or	r19, r18
    15d8:	29 2f       	mov	r18, r25
    15da:	22 95       	swap	r18
    15dc:	2f 70       	andi	r18, 0x0F	; 15
    15de:	23 70       	andi	r18, 0x03	; 3
    15e0:	30 93 e2 02 	sts	0x02E2, r19
    15e4:	20 93 e3 02 	sts	0x02E3, r18
	current_patch.vco1_mix = loaded_patch.vco1_mix;
    15e8:	df 01       	movw	r26, r30
    15ea:	5a 97       	sbiw	r26, 0x1a	; 26
    15ec:	4a 81       	ldd	r20, Y+2	; 0x02
    15ee:	46 95       	lsr	r20
    15f0:	46 95       	lsr	r20
    15f2:	2b 81       	ldd	r18, Y+3	; 0x03
    15f4:	32 2f       	mov	r19, r18
    15f6:	32 95       	swap	r19
    15f8:	33 0f       	add	r19, r19
    15fa:	33 0f       	add	r19, r19
    15fc:	30 7c       	andi	r19, 0xC0	; 192
    15fe:	43 2b       	or	r20, r19
    1600:	32 2f       	mov	r19, r18
    1602:	36 95       	lsr	r19
    1604:	36 95       	lsr	r19
    1606:	33 70       	andi	r19, 0x03	; 3
    1608:	4c 93       	st	X, r20
    160a:	11 96       	adiw	r26, 0x01	; 1
    160c:	3c 93       	st	X, r19
	current_patch.pitch_eg2 = loaded_patch.pitch_eg2;
    160e:	df 01       	movw	r26, r30
    1610:	58 97       	sbiw	r26, 0x18	; 24
    1612:	32 2f       	mov	r19, r18
    1614:	32 95       	swap	r19
    1616:	3f 70       	andi	r19, 0x0F	; 15
    1618:	2c 81       	ldd	r18, Y+4	; 0x04
    161a:	42 2f       	mov	r20, r18
    161c:	42 95       	swap	r20
    161e:	40 7f       	andi	r20, 0xF0	; 240
    1620:	43 2b       	or	r20, r19
    1622:	32 2f       	mov	r19, r18
    1624:	32 95       	swap	r19
    1626:	3f 70       	andi	r19, 0x0F	; 15
    1628:	33 70       	andi	r19, 0x03	; 3
    162a:	4c 93       	st	X, r20
    162c:	11 96       	adiw	r26, 0x01	; 1
    162e:	3c 93       	st	X, r19
	current_patch.pitch_vco2 = loaded_patch.pitch_vco2;
    1630:	df 01       	movw	r26, r30
    1632:	56 97       	sbiw	r26, 0x16	; 22
    1634:	22 95       	swap	r18
    1636:	26 95       	lsr	r18
    1638:	26 95       	lsr	r18
    163a:	23 70       	andi	r18, 0x03	; 3
    163c:	3d 81       	ldd	r19, Y+5	; 0x05
    163e:	43 2f       	mov	r20, r19
    1640:	44 0f       	add	r20, r20
    1642:	44 0f       	add	r20, r20
    1644:	24 2b       	or	r18, r20
    1646:	32 95       	swap	r19
    1648:	36 95       	lsr	r19
    164a:	36 95       	lsr	r19
    164c:	33 70       	andi	r19, 0x03	; 3
    164e:	2c 93       	st	X, r18
    1650:	11 96       	adiw	r26, 0x01	; 1
    1652:	3c 93       	st	X, r19
	current_patch.pitch_lfo = loaded_patch.pitch_lfo;
    1654:	df 01       	movw	r26, r30
    1656:	54 97       	sbiw	r26, 0x14	; 20
    1658:	4e 81       	ldd	r20, Y+6	; 0x06
    165a:	2f 81       	ldd	r18, Y+7	; 0x07
    165c:	32 2f       	mov	r19, r18
    165e:	33 70       	andi	r19, 0x03	; 3
    1660:	4c 93       	st	X, r20
    1662:	11 96       	adiw	r26, 0x01	; 1
    1664:	3c 93       	st	X, r19
	current_patch.pwm_lfo = loaded_patch.pwm_lfo;
    1666:	df 01       	movw	r26, r30
    1668:	52 97       	sbiw	r26, 0x12	; 18
    166a:	32 2f       	mov	r19, r18
    166c:	36 95       	lsr	r19
    166e:	36 95       	lsr	r19
    1670:	28 85       	ldd	r18, Y+8	; 0x08
    1672:	42 2f       	mov	r20, r18
    1674:	42 95       	swap	r20
    1676:	44 0f       	add	r20, r20
    1678:	44 0f       	add	r20, r20
    167a:	40 7c       	andi	r20, 0xC0	; 192
    167c:	43 2b       	or	r20, r19
    167e:	32 2f       	mov	r19, r18
    1680:	36 95       	lsr	r19
    1682:	36 95       	lsr	r19
    1684:	33 70       	andi	r19, 0x03	; 3
    1686:	4c 93       	st	X, r20
    1688:	11 96       	adiw	r26, 0x01	; 1
    168a:	3c 93       	st	X, r19
	current_patch.pwm_eg2 = loaded_patch.pwm_eg2;
    168c:	df 01       	movw	r26, r30
    168e:	50 97       	sbiw	r26, 0x10	; 16
    1690:	32 2f       	mov	r19, r18
    1692:	32 95       	swap	r19
    1694:	3f 70       	andi	r19, 0x0F	; 15
    1696:	29 85       	ldd	r18, Y+9	; 0x09
    1698:	42 2f       	mov	r20, r18
    169a:	42 95       	swap	r20
    169c:	40 7f       	andi	r20, 0xF0	; 240
    169e:	43 2b       	or	r20, r19
    16a0:	32 2f       	mov	r19, r18
    16a2:	32 95       	swap	r19
    16a4:	3f 70       	andi	r19, 0x0F	; 15
    16a6:	33 70       	andi	r19, 0x03	; 3
    16a8:	4c 93       	st	X, r20
    16aa:	11 96       	adiw	r26, 0x01	; 1
    16ac:	3c 93       	st	X, r19
	current_patch.vco1_pw = loaded_patch.vco1_pw;
    16ae:	df 01       	movw	r26, r30
    16b0:	1e 97       	sbiw	r26, 0x0e	; 14
    16b2:	22 95       	swap	r18
    16b4:	26 95       	lsr	r18
    16b6:	26 95       	lsr	r18
    16b8:	23 70       	andi	r18, 0x03	; 3
    16ba:	3a 85       	ldd	r19, Y+10	; 0x0a
    16bc:	43 2f       	mov	r20, r19
    16be:	44 0f       	add	r20, r20
    16c0:	44 0f       	add	r20, r20
    16c2:	24 2b       	or	r18, r20
    16c4:	32 95       	swap	r19
    16c6:	36 95       	lsr	r19
    16c8:	36 95       	lsr	r19
    16ca:	33 70       	andi	r19, 0x03	; 3
    16cc:	2c 93       	st	X, r18
    16ce:	11 96       	adiw	r26, 0x01	; 1
    16d0:	3c 93       	st	X, r19
	current_patch.fine = loaded_patch.fine;
    16d2:	df 01       	movw	r26, r30
    16d4:	1c 97       	sbiw	r26, 0x0c	; 12
    16d6:	4b 85       	ldd	r20, Y+11	; 0x0b
    16d8:	2c 85       	ldd	r18, Y+12	; 0x0c
    16da:	32 2f       	mov	r19, r18
    16dc:	33 70       	andi	r19, 0x03	; 3
    16de:	4c 93       	st	X, r20
    16e0:	11 96       	adiw	r26, 0x01	; 1
    16e2:	3c 93       	st	X, r19
	current_patch.tune = loaded_patch.tune; //probably shouldn't save master tune value. Like volume, it is a parameter that doesn't apply to a patch.
    16e4:	df 01       	movw	r26, r30
    16e6:	1a 97       	sbiw	r26, 0x0a	; 10
    16e8:	32 2f       	mov	r19, r18
    16ea:	36 95       	lsr	r19
    16ec:	36 95       	lsr	r19
    16ee:	2d 85       	ldd	r18, Y+13	; 0x0d
    16f0:	42 2f       	mov	r20, r18
    16f2:	42 95       	swap	r20
    16f4:	44 0f       	add	r20, r20
    16f6:	44 0f       	add	r20, r20
    16f8:	40 7c       	andi	r20, 0xC0	; 192
    16fa:	43 2b       	or	r20, r19
    16fc:	32 2f       	mov	r19, r18
    16fe:	36 95       	lsr	r19
    1700:	36 95       	lsr	r19
    1702:	33 70       	andi	r19, 0x03	; 3
    1704:	4c 93       	st	X, r20
    1706:	11 96       	adiw	r26, 0x01	; 1
    1708:	3c 93       	st	X, r19
	current_patch.lfo_rate = loaded_patch.lfo_rate;
    170a:	df 01       	movw	r26, r30
    170c:	18 97       	sbiw	r26, 0x08	; 8
    170e:	32 2f       	mov	r19, r18
    1710:	32 95       	swap	r19
    1712:	3f 70       	andi	r19, 0x0F	; 15
    1714:	2e 85       	ldd	r18, Y+14	; 0x0e
    1716:	42 2f       	mov	r20, r18
    1718:	42 95       	swap	r20
    171a:	40 7f       	andi	r20, 0xF0	; 240
    171c:	43 2b       	or	r20, r19
    171e:	32 2f       	mov	r19, r18
    1720:	32 95       	swap	r19
    1722:	3f 70       	andi	r19, 0x0F	; 15
    1724:	33 70       	andi	r19, 0x03	; 3
    1726:	4c 93       	st	X, r20
    1728:	11 96       	adiw	r26, 0x01	; 1
    172a:	3c 93       	st	X, r19
	current_patch.arp_rate = loaded_patch.arp_rate;
    172c:	df 01       	movw	r26, r30
    172e:	16 97       	sbiw	r26, 0x06	; 6
    1730:	22 95       	swap	r18
    1732:	26 95       	lsr	r18
    1734:	26 95       	lsr	r18
    1736:	23 70       	andi	r18, 0x03	; 3
    1738:	3f 85       	ldd	r19, Y+15	; 0x0f
    173a:	43 2f       	mov	r20, r19
    173c:	44 0f       	add	r20, r20
    173e:	44 0f       	add	r20, r20
    1740:	24 2b       	or	r18, r20
    1742:	32 95       	swap	r19
    1744:	36 95       	lsr	r19
    1746:	36 95       	lsr	r19
    1748:	33 70       	andi	r19, 0x03	; 3
    174a:	2c 93       	st	X, r18
    174c:	11 96       	adiw	r26, 0x01	; 1
    174e:	3c 93       	st	X, r19
	current_patch.glide	= loaded_patch.glide;
    1750:	df 01       	movw	r26, r30
    1752:	14 97       	sbiw	r26, 0x04	; 4
    1754:	48 89       	ldd	r20, Y+16	; 0x10
    1756:	29 89       	ldd	r18, Y+17	; 0x11
    1758:	32 2f       	mov	r19, r18
    175a:	33 70       	andi	r19, 0x03	; 3
    175c:	4c 93       	st	X, r20
    175e:	11 96       	adiw	r26, 0x01	; 1
    1760:	3c 93       	st	X, r19
	current_patch.amp_lfo = loaded_patch.amp_lfo;
    1762:	df 01       	movw	r26, r30
    1764:	12 97       	sbiw	r26, 0x02	; 2
    1766:	26 95       	lsr	r18
    1768:	26 95       	lsr	r18
    176a:	38 2f       	mov	r19, r24
    176c:	32 95       	swap	r19
    176e:	33 0f       	add	r19, r19
    1770:	33 0f       	add	r19, r19
    1772:	30 7c       	andi	r19, 0xC0	; 192
    1774:	23 2b       	or	r18, r19
    1776:	86 95       	lsr	r24
    1778:	86 95       	lsr	r24
    177a:	83 70       	andi	r24, 0x03	; 3
    177c:	2c 93       	st	X, r18
    177e:	11 96       	adiw	r26, 0x01	; 1
    1780:	8c 93       	st	X, r24
	current_patch.vco2_pw = loaded_patch.vco2_pw;
	
	current_patch.fil_eg2 = loaded_patch.fil_eg2;
    1782:	92 95       	swap	r25
    1784:	96 95       	lsr	r25
    1786:	96 95       	lsr	r25
    1788:	93 70       	andi	r25, 0x03	; 3
    178a:	8c 89       	ldd	r24, Y+20	; 0x14
    178c:	28 2f       	mov	r18, r24
    178e:	22 0f       	add	r18, r18
    1790:	22 0f       	add	r18, r18
    1792:	92 2b       	or	r25, r18
    1794:	82 95       	swap	r24
    1796:	86 95       	lsr	r24
    1798:	86 95       	lsr	r24
    179a:	83 70       	andi	r24, 0x03	; 3
    179c:	90 93 e4 02 	sts	0x02E4, r25
    17a0:	83 83       	std	Z+3, r24	; 0x03
	current_patch.res = loaded_patch.res;
    17a2:	2d 89       	ldd	r18, Y+21	; 0x15
    17a4:	8e 89       	ldd	r24, Y+22	; 0x16
    17a6:	98 2f       	mov	r25, r24
    17a8:	93 70       	andi	r25, 0x03	; 3
    17aa:	20 93 e6 02 	sts	0x02E6, r18
    17ae:	95 83       	std	Z+5, r25	; 0x05
	current_patch.cutoff = loaded_patch.cutoff;
    17b0:	98 2f       	mov	r25, r24
    17b2:	96 95       	lsr	r25
    17b4:	96 95       	lsr	r25
    17b6:	8f 89       	ldd	r24, Y+23	; 0x17
    17b8:	28 2f       	mov	r18, r24
    17ba:	22 95       	swap	r18
    17bc:	22 0f       	add	r18, r18
    17be:	22 0f       	add	r18, r18
    17c0:	20 7c       	andi	r18, 0xC0	; 192
    17c2:	29 2b       	or	r18, r25
    17c4:	98 2f       	mov	r25, r24
    17c6:	96 95       	lsr	r25
    17c8:	96 95       	lsr	r25
    17ca:	93 70       	andi	r25, 0x03	; 3
    17cc:	20 93 e8 02 	sts	0x02E8, r18
    17d0:	97 83       	std	Z+7, r25	; 0x07
	current_patch.key_track = loaded_patch.key_track;
    17d2:	98 2f       	mov	r25, r24
    17d4:	92 95       	swap	r25
    17d6:	9f 70       	andi	r25, 0x0F	; 15
    17d8:	88 8d       	ldd	r24, Y+24	; 0x18
    17da:	28 2f       	mov	r18, r24
    17dc:	22 95       	swap	r18
    17de:	20 7f       	andi	r18, 0xF0	; 240
    17e0:	29 2b       	or	r18, r25
    17e2:	98 2f       	mov	r25, r24
    17e4:	92 95       	swap	r25
    17e6:	9f 70       	andi	r25, 0x0F	; 15
    17e8:	93 70       	andi	r25, 0x03	; 3
    17ea:	20 93 ea 02 	sts	0x02EA, r18
    17ee:	91 87       	std	Z+9, r25	; 0x09
	current_patch.fil_vco2 = loaded_patch.fil_vco2;
    17f0:	82 95       	swap	r24
    17f2:	86 95       	lsr	r24
    17f4:	86 95       	lsr	r24
    17f6:	83 70       	andi	r24, 0x03	; 3
    17f8:	99 8d       	ldd	r25, Y+25	; 0x19
    17fa:	29 2f       	mov	r18, r25
    17fc:	22 0f       	add	r18, r18
    17fe:	22 0f       	add	r18, r18
    1800:	82 2b       	or	r24, r18
    1802:	92 95       	swap	r25
    1804:	96 95       	lsr	r25
    1806:	96 95       	lsr	r25
    1808:	93 70       	andi	r25, 0x03	; 3
    180a:	80 93 ec 02 	sts	0x02EC, r24
    180e:	93 87       	std	Z+11, r25	; 0x0b
	current_patch.fil_lfo = loaded_patch.fil_lfo;
    1810:	2a 8d       	ldd	r18, Y+26	; 0x1a
    1812:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1814:	98 2f       	mov	r25, r24
    1816:	93 70       	andi	r25, 0x03	; 3
    1818:	20 93 ee 02 	sts	0x02EE, r18
    181c:	95 87       	std	Z+13, r25	; 0x0d
	current_patch.noise_mix = loaded_patch.noise_mix;
    181e:	98 2f       	mov	r25, r24
    1820:	96 95       	lsr	r25
    1822:	96 95       	lsr	r25
    1824:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1826:	28 2f       	mov	r18, r24
    1828:	22 95       	swap	r18
    182a:	22 0f       	add	r18, r18
    182c:	22 0f       	add	r18, r18
    182e:	20 7c       	andi	r18, 0xC0	; 192
    1830:	29 2b       	or	r18, r25
    1832:	98 2f       	mov	r25, r24
    1834:	96 95       	lsr	r25
    1836:	96 95       	lsr	r25
    1838:	93 70       	andi	r25, 0x03	; 3
    183a:	20 93 f0 02 	sts	0x02F0, r18
    183e:	97 87       	std	Z+15, r25	; 0x0f
	current_patch.attack_2 = loaded_patch.attack_2;
    1840:	98 2f       	mov	r25, r24
    1842:	92 95       	swap	r25
    1844:	9f 70       	andi	r25, 0x0F	; 15
    1846:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1848:	28 2f       	mov	r18, r24
    184a:	22 95       	swap	r18
    184c:	20 7f       	andi	r18, 0xF0	; 240
    184e:	29 2b       	or	r18, r25
    1850:	98 2f       	mov	r25, r24
    1852:	92 95       	swap	r25
    1854:	9f 70       	andi	r25, 0x0F	; 15
    1856:	93 70       	andi	r25, 0x03	; 3
    1858:	20 93 f2 02 	sts	0x02F2, r18
    185c:	91 8b       	std	Z+17, r25	; 0x11
	current_patch.attack_1 = loaded_patch.attack_1;
    185e:	82 95       	swap	r24
    1860:	86 95       	lsr	r24
    1862:	86 95       	lsr	r24
    1864:	83 70       	andi	r24, 0x03	; 3
    1866:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1868:	29 2f       	mov	r18, r25
    186a:	22 0f       	add	r18, r18
    186c:	22 0f       	add	r18, r18
    186e:	82 2b       	or	r24, r18
    1870:	92 95       	swap	r25
    1872:	96 95       	lsr	r25
    1874:	96 95       	lsr	r25
    1876:	93 70       	andi	r25, 0x03	; 3
    1878:	80 93 f4 02 	sts	0x02F4, r24
    187c:	93 8b       	std	Z+19, r25	; 0x13
	current_patch.decay_2 = loaded_patch.decay_2;
    187e:	2f 8d       	ldd	r18, Y+31	; 0x1f
    1880:	88 a1       	lds	r24, 0x48
    1882:	98 2f       	mov	r25, r24
    1884:	93 70       	andi	r25, 0x03	; 3
    1886:	20 93 f6 02 	sts	0x02F6, r18
    188a:	95 8b       	std	Z+21, r25	; 0x15
	current_patch.decay_1 = loaded_patch.decay_1;
    188c:	98 2f       	mov	r25, r24
    188e:	96 95       	lsr	r25
    1890:	96 95       	lsr	r25
    1892:	89 a1       	lds	r24, 0x49
    1894:	28 2f       	mov	r18, r24
    1896:	22 95       	swap	r18
    1898:	22 0f       	add	r18, r18
    189a:	22 0f       	add	r18, r18
    189c:	20 7c       	andi	r18, 0xC0	; 192
    189e:	29 2b       	or	r18, r25
    18a0:	98 2f       	mov	r25, r24
    18a2:	96 95       	lsr	r25
    18a4:	96 95       	lsr	r25
    18a6:	93 70       	andi	r25, 0x03	; 3
    18a8:	20 93 f8 02 	sts	0x02F8, r18
    18ac:	97 8b       	std	Z+23, r25	; 0x17
	current_patch.sustain_2 = loaded_patch.sustain_2;
    18ae:	98 2f       	mov	r25, r24
    18b0:	92 95       	swap	r25
    18b2:	9f 70       	andi	r25, 0x0F	; 15
    18b4:	8a a1       	lds	r24, 0x4a
    18b6:	28 2f       	mov	r18, r24
    18b8:	22 95       	swap	r18
    18ba:	20 7f       	andi	r18, 0xF0	; 240
    18bc:	29 2b       	or	r18, r25
    18be:	98 2f       	mov	r25, r24
    18c0:	92 95       	swap	r25
    18c2:	9f 70       	andi	r25, 0x0F	; 15
    18c4:	93 70       	andi	r25, 0x03	; 3
    18c6:	20 93 fa 02 	sts	0x02FA, r18
    18ca:	91 8f       	std	Z+25, r25	; 0x19
	current_patch.sustain_1 = loaded_patch.sustain_1;
    18cc:	82 95       	swap	r24
    18ce:	86 95       	lsr	r24
    18d0:	86 95       	lsr	r24
    18d2:	83 70       	andi	r24, 0x03	; 3
    18d4:	9b a1       	lds	r25, 0x4b
    18d6:	29 2f       	mov	r18, r25
    18d8:	22 0f       	add	r18, r18
    18da:	22 0f       	add	r18, r18
    18dc:	82 2b       	or	r24, r18
    18de:	92 95       	swap	r25
    18e0:	96 95       	lsr	r25
    18e2:	96 95       	lsr	r25
    18e4:	93 70       	andi	r25, 0x03	; 3
    18e6:	80 93 fc 02 	sts	0x02FC, r24
    18ea:	93 8f       	std	Z+27, r25	; 0x1b
	current_patch.release_2 = loaded_patch.release_2;
    18ec:	2c a1       	lds	r18, 0x4c
    18ee:	8d a1       	lds	r24, 0x4d
    18f0:	98 2f       	mov	r25, r24
    18f2:	93 70       	andi	r25, 0x03	; 3
    18f4:	20 93 fe 02 	sts	0x02FE, r18
    18f8:	95 8f       	std	Z+29, r25	; 0x1d
	current_patch.release_1 = loaded_patch.release_1;
    18fa:	98 2f       	mov	r25, r24
    18fc:	96 95       	lsr	r25
    18fe:	96 95       	lsr	r25
    1900:	8e a1       	lds	r24, 0x4e
    1902:	28 2f       	mov	r18, r24
    1904:	22 95       	swap	r18
    1906:	22 0f       	add	r18, r18
    1908:	22 0f       	add	r18, r18
    190a:	20 7c       	andi	r18, 0xC0	; 192
    190c:	29 2b       	or	r18, r25
    190e:	86 95       	lsr	r24
    1910:	86 95       	lsr	r24
    1912:	98 2f       	mov	r25, r24
    1914:	93 70       	andi	r25, 0x03	; 3
    1916:	20 93 00 03 	sts	0x0300, r18
    191a:	97 8f       	std	Z+31, r25	; 0x1f
	
	
	current_patch.byte_1 = loaded_patch.byte_1;
    191c:	7f a1       	lds	r23, 0x4f
    191e:	70 93 02 03 	sts	0x0302, r23
	current_patch.byte_2 = loaded_patch.byte_2;
    1922:	68 a5       	lds	r22, 0x68
    1924:	60 93 03 03 	sts	0x0303, r22
	current_patch.byte_3 = loaded_patch.byte_3;
    1928:	89 a5       	lds	r24, 0x69
    192a:	80 93 04 03 	sts	0x0304, r24
	current_patch.byte_4 = loaded_patch.byte_4;
    192e:	9a a5       	lds	r25, 0x6a
    1930:	90 93 05 03 	sts	0x0305, r25
	current_patch.byte_5 = loaded_patch.byte_5;
    1934:	1b a5       	lds	r17, 0x6b
    1936:	10 93 06 03 	sts	0x0306, r17
	
	//using De Bruijn sequence to determine which bit is set. For alphabet size k = 2 (binary - 0 and 1) and n = 3. 2^3 = 8. The minimum number of bits required to represent the 5 octave positions
	uint8_t vco1_lookup[] = {7, 2, 5, 0, 6, 4, 3, 1}; // *modified* De Bruijn lookup table for octave number, see: http://stackoverflow.com/questions/14429661/determine-which-single-bit-in-the-byte-is-set
    193a:	de 01       	movw	r26, r28
    193c:	9c 96       	adiw	r26, 0x2c	; 44
    193e:	ef ef       	ldi	r30, 0xFF	; 255
    1940:	f1 e0       	ldi	r31, 0x01	; 1
    1942:	28 e0       	ldi	r18, 0x08	; 8
    1944:	01 90       	ld	r0, Z+
    1946:	0d 92       	st	X+, r0
    1948:	21 50       	subi	r18, 0x01	; 1
    194a:	e1 f7       	brne	.-8      	; 0x1944 <load_patch+0x3be>
	//lookup table modified from standard 8 bit De Bruijn sequence to handle non sequential order of octave LEDs in byte_4
	uint8_t vco1_bitfield = current_patch.byte_4 & 0b00011111; //clear top 3 bits, which are used for VCO2 octave lookup - probably don't need to clear these bits
    194c:	e9 2f       	mov	r30, r25
    194e:	ef 71       	andi	r30, 0x1F	; 31
	uint8_t bit_index = ((vco1_bitfield*0x1D) >> 4) & 0x7;	//0x1D 0b11101 is the De Bruijn sequence for 8 bits 
    1950:	f0 e0       	ldi	r31, 0x00	; 0
    1952:	9f 01       	movw	r18, r30
    1954:	22 0f       	add	r18, r18
    1956:	33 1f       	adc	r19, r19
    1958:	22 0f       	add	r18, r18
    195a:	33 1f       	adc	r19, r19
    195c:	a9 01       	movw	r20, r18
    195e:	44 0f       	add	r20, r20
    1960:	55 1f       	adc	r21, r21
    1962:	44 0f       	add	r20, r20
    1964:	55 1f       	adc	r21, r21
    1966:	44 0f       	add	r20, r20
    1968:	55 1f       	adc	r21, r21
    196a:	42 1b       	sub	r20, r18
    196c:	53 0b       	sbc	r21, r19
    196e:	4e 0f       	add	r20, r30
    1970:	5f 1f       	adc	r21, r31
    1972:	55 95       	asr	r21
    1974:	47 95       	ror	r20
    1976:	55 95       	asr	r21
    1978:	47 95       	ror	r20
    197a:	55 95       	asr	r21
    197c:	47 95       	ror	r20
    197e:	55 95       	asr	r21
    1980:	47 95       	ror	r20
    1982:	47 70       	andi	r20, 0x07	; 7
	octave_index.vco1 = vco1_lookup[bit_index];	
    1984:	fe 01       	movw	r30, r28
    1986:	e4 0f       	add	r30, r20
    1988:	f1 1d       	adc	r31, r1
    198a:	24 a5       	lds	r18, 0x64
    198c:	20 93 0c 03 	sts	0x030C, r18
	
	uint8_t vco2_lookup[] = {7, 4, 5, 3, 6, 2, 1, 0}; 
    1990:	de 01       	movw	r26, r28
    1992:	d4 96       	adiw	r26, 0x34	; 52
    1994:	e7 e0       	ldi	r30, 0x07	; 7
    1996:	f2 e0       	ldi	r31, 0x02	; 2
    1998:	28 e0       	ldi	r18, 0x08	; 8
    199a:	01 90       	ld	r0, Z+
    199c:	0d 92       	st	X+, r0
    199e:	21 50       	subi	r18, 0x01	; 1
    19a0:	e1 f7       	brne	.-8      	; 0x199a <load_patch+0x414>
																																				 //bit order 4   3    2    1   0
	uint8_t vco2_bitfield = ((current_patch.byte_4 & 0b11100000) >> 3) | (current_patch.byte_3 & 0b00000011); //combine  all VCO2 octave bits into one byte: 8', 16', 32', 4', 2'
    19a2:	29 2f       	mov	r18, r25
    19a4:	30 e0       	ldi	r19, 0x00	; 0
    19a6:	20 7e       	andi	r18, 0xE0	; 224
    19a8:	30 70       	andi	r19, 0x00	; 0
    19aa:	35 95       	asr	r19
    19ac:	27 95       	ror	r18
    19ae:	35 95       	asr	r19
    19b0:	27 95       	ror	r18
    19b2:	35 95       	asr	r19
    19b4:	27 95       	ror	r18
    19b6:	83 70       	andi	r24, 0x03	; 3
    19b8:	28 2b       	or	r18, r24
	bit_index = ((vco2_bitfield*0x1D) >> 4) & 0x7;																								     //index 2   1    0    3   4
    19ba:	42 2f       	mov	r20, r18
    19bc:	50 e0       	ldi	r21, 0x00	; 0
    19be:	ca 01       	movw	r24, r20
    19c0:	88 0f       	add	r24, r24
    19c2:	99 1f       	adc	r25, r25
    19c4:	88 0f       	add	r24, r24
    19c6:	99 1f       	adc	r25, r25
    19c8:	9c 01       	movw	r18, r24
    19ca:	22 0f       	add	r18, r18
    19cc:	33 1f       	adc	r19, r19
    19ce:	22 0f       	add	r18, r18
    19d0:	33 1f       	adc	r19, r19
    19d2:	22 0f       	add	r18, r18
    19d4:	33 1f       	adc	r19, r19
    19d6:	28 1b       	sub	r18, r24
    19d8:	39 0b       	sbc	r19, r25
    19da:	42 0f       	add	r20, r18
    19dc:	53 1f       	adc	r21, r19
    19de:	ca 01       	movw	r24, r20
    19e0:	95 95       	asr	r25
    19e2:	87 95       	ror	r24
    19e4:	95 95       	asr	r25
    19e6:	87 95       	ror	r24
    19e8:	95 95       	asr	r25
    19ea:	87 95       	ror	r24
    19ec:	95 95       	asr	r25
    19ee:	87 95       	ror	r24
    19f0:	87 70       	andi	r24, 0x07	; 7
	octave_index.vco2 = vco2_lookup[bit_index];
    19f2:	fe 01       	movw	r30, r28
    19f4:	e8 0f       	add	r30, r24
    19f6:	f1 1d       	adc	r31, r1
    19f8:	84 a9       	sts	0x44, r24
    19fa:	80 93 0d 03 	sts	0x030D, r24
	
	uint8_t lfo_lookup[] = {0, 0, 2, 2, 1, 3, 3, 1}; //bits 7, 5, 4, 6 are irrelevant here. Complier seems to be reformatting this table???
    19fe:	de 01       	movw	r26, r28
    1a00:	dc 96       	adiw	r26, 0x3c	; 60
    1a02:	ef e0       	ldi	r30, 0x0F	; 15
    1a04:	f2 e0       	ldi	r31, 0x02	; 2
    1a06:	88 e0       	ldi	r24, 0x08	; 8
    1a08:	01 90       	ld	r0, Z+
    1a0a:	0d 92       	st	X+, r0
    1a0c:	81 50       	subi	r24, 0x01	; 1
    1a0e:	e1 f7       	brne	.-8      	; 0x1a08 <load_patch+0x482>
	uint8_t lfo_bitfield = current_patch.byte_2 & 0b11110000; //shave off 4 LSBs. Really could use 4 bit De Bruijn sequence here
    1a10:	60 7f       	andi	r22, 0xF0	; 240
	bit_index = ((lfo_bitfield*0x1D) >> 4) & 0x7;
    1a12:	46 2f       	mov	r20, r22
    1a14:	50 e0       	ldi	r21, 0x00	; 0
    1a16:	ca 01       	movw	r24, r20
    1a18:	88 0f       	add	r24, r24
    1a1a:	99 1f       	adc	r25, r25
    1a1c:	88 0f       	add	r24, r24
    1a1e:	99 1f       	adc	r25, r25
    1a20:	9c 01       	movw	r18, r24
    1a22:	22 0f       	add	r18, r18
    1a24:	33 1f       	adc	r19, r19
    1a26:	22 0f       	add	r18, r18
    1a28:	33 1f       	adc	r19, r19
    1a2a:	22 0f       	add	r18, r18
    1a2c:	33 1f       	adc	r19, r19
    1a2e:	28 1b       	sub	r18, r24
    1a30:	39 0b       	sbc	r19, r25
    1a32:	42 0f       	add	r20, r18
    1a34:	53 1f       	adc	r21, r19
    1a36:	ca 01       	movw	r24, r20
    1a38:	95 95       	asr	r25
    1a3a:	87 95       	ror	r24
    1a3c:	95 95       	asr	r25
    1a3e:	87 95       	ror	r24
    1a40:	95 95       	asr	r25
    1a42:	87 95       	ror	r24
    1a44:	95 95       	asr	r25
    1a46:	87 95       	ror	r24
    1a48:	87 70       	andi	r24, 0x07	; 7
	lfo_shape_index = lfo_lookup[bit_index];
    1a4a:	fe 01       	movw	r30, r28
    1a4c:	e8 0f       	add	r30, r24
    1a4e:	f1 1d       	adc	r31, r1
    1a50:	84 ad       	sts	0x64, r24
    1a52:	80 93 0e 03 	sts	0x030E, r24
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1a56:	21 2f       	mov	r18, r17
    1a58:	26 95       	lsr	r18
    1a5a:	27 95       	ror	r18
    1a5c:	22 27       	eor	r18, r18
    1a5e:	27 95       	ror	r18
    1a60:	81 2f       	mov	r24, r17
    1a62:	81 70       	andi	r24, 0x01	; 1
    1a64:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
    1a66:	81 2f       	mov	r24, r17
    1a68:	86 95       	lsr	r24
    1a6a:	86 95       	lsr	r24
    1a6c:	90 e0       	ldi	r25, 0x00	; 0
    1a6e:	81 70       	andi	r24, 0x01	; 1
    1a70:	90 70       	andi	r25, 0x00	; 0
    1a72:	88 0f       	add	r24, r24
    1a74:	99 1f       	adc	r25, r25
    1a76:	88 0f       	add	r24, r24
    1a78:	99 1f       	adc	r25, r25
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1a7a:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
							((current_patch.byte_5 >> VCO1_TRI) & 1) << VCO1_TRI_SW |
    1a7c:	81 2f       	mov	r24, r17
    1a7e:	86 95       	lsr	r24
    1a80:	86 95       	lsr	r24
    1a82:	86 95       	lsr	r24
    1a84:	90 e0       	ldi	r25, 0x00	; 0
    1a86:	81 70       	andi	r24, 0x01	; 1
    1a88:	90 70       	andi	r25, 0x00	; 0
    1a8a:	88 0f       	add	r24, r24
    1a8c:	99 1f       	adc	r25, r25
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1a8e:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
							((current_patch.byte_5 >> VCO1_TRI) & 1) << VCO1_TRI_SW |
							((current_patch.byte_5 >> VCO1_PULSE) & 1) << VCO1_PULSE_SW |
							((current_patch.byte_5 >> VCO2_SAW) & 1) << VCO2_SAW_SW |
    1a90:	81 2f       	mov	r24, r17
    1a92:	82 95       	swap	r24
    1a94:	8f 70       	andi	r24, 0x0F	; 15
    1a96:	90 e0       	ldi	r25, 0x00	; 0
    1a98:	81 70       	andi	r24, 0x01	; 1
    1a9a:	90 70       	andi	r25, 0x00	; 0
    1a9c:	82 95       	swap	r24
    1a9e:	92 95       	swap	r25
    1aa0:	90 7f       	andi	r25, 0xF0	; 240
    1aa2:	98 27       	eor	r25, r24
    1aa4:	80 7f       	andi	r24, 0xF0	; 240
    1aa6:	98 27       	eor	r25, r24
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1aa8:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
							((current_patch.byte_5 >> VCO1_TRI) & 1) << VCO1_TRI_SW |
							((current_patch.byte_5 >> VCO1_PULSE) & 1) << VCO1_PULSE_SW |
							((current_patch.byte_5 >> VCO2_SAW) & 1) << VCO2_SAW_SW |
							((current_patch.byte_5 >> VCO2_TRI) & 1) << VCO2_TRI_SW |
    1aaa:	81 2f       	mov	r24, r17
    1aac:	82 95       	swap	r24
    1aae:	86 95       	lsr	r24
    1ab0:	87 70       	andi	r24, 0x07	; 7
    1ab2:	90 e0       	ldi	r25, 0x00	; 0
    1ab4:	81 70       	andi	r24, 0x01	; 1
    1ab6:	90 70       	andi	r25, 0x00	; 0
    1ab8:	88 0f       	add	r24, r24
    1aba:	99 1f       	adc	r25, r25
    1abc:	82 95       	swap	r24
    1abe:	92 95       	swap	r25
    1ac0:	90 7f       	andi	r25, 0xF0	; 240
    1ac2:	98 27       	eor	r25, r24
    1ac4:	80 7f       	andi	r24, 0xF0	; 240
    1ac6:	98 27       	eor	r25, r24
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1ac8:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
							((current_patch.byte_5 >> VCO1_TRI) & 1) << VCO1_TRI_SW |
							((current_patch.byte_5 >> VCO1_PULSE) & 1) << VCO1_PULSE_SW |
							((current_patch.byte_5 >> VCO2_SAW) & 1) << VCO2_SAW_SW |
							((current_patch.byte_5 >> VCO2_TRI) & 1) << VCO2_TRI_SW |
							((current_patch.byte_5 >> VCO2_PULSE) & 1) << VCO2_PULSE_SW;
    1aca:	81 2f       	mov	r24, r17
    1acc:	82 95       	swap	r24
    1ace:	86 95       	lsr	r24
    1ad0:	86 95       	lsr	r24
    1ad2:	83 70       	andi	r24, 0x03	; 3
    1ad4:	90 e0       	ldi	r25, 0x00	; 0
    1ad6:	81 70       	andi	r24, 0x01	; 1
    1ad8:	90 70       	andi	r25, 0x00	; 0
    1ada:	00 24       	eor	r0, r0
    1adc:	96 95       	lsr	r25
    1ade:	87 95       	ror	r24
    1ae0:	07 94       	ror	r0
    1ae2:	96 95       	lsr	r25
    1ae4:	87 95       	ror	r24
    1ae6:	07 94       	ror	r0
    1ae8:	98 2f       	mov	r25, r24
    1aea:	80 2d       	mov	r24, r0
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1aec:	82 2b       	or	r24, r18
    1aee:	80 93 82 03 	sts	0x0382, r24
							((current_patch.byte_5 >> VCO2_PULSE) & 1) << VCO2_PULSE_SW;
							
	switch_states.byte2 &= 0b11110011; //preserve PROG switches states, clear BMOD and EG2 states
	
	switch_states.byte2 |=	((current_patch.byte_5 >> BMOD) & 1) << BMOD_SW |
							((current_patch.byte_1 >> EG2_INV) & 1) << EG2_INV_SW;	
    1af2:	87 2f       	mov	r24, r23
    1af4:	90 e0       	ldi	r25, 0x00	; 0
    1af6:	81 70       	andi	r24, 0x01	; 1
    1af8:	90 70       	andi	r25, 0x00	; 0
    1afa:	88 0f       	add	r24, r24
    1afc:	99 1f       	adc	r25, r25
    1afe:	88 0f       	add	r24, r24
    1b00:	99 1f       	adc	r25, r25
    1b02:	88 0f       	add	r24, r24
    1b04:	99 1f       	adc	r25, r25
							((current_patch.byte_5 >> VCO1_PULSE) & 1) << VCO1_PULSE_SW |
							((current_patch.byte_5 >> VCO2_SAW) & 1) << VCO2_SAW_SW |
							((current_patch.byte_5 >> VCO2_TRI) & 1) << VCO2_TRI_SW |
							((current_patch.byte_5 >> VCO2_PULSE) & 1) << VCO2_PULSE_SW;
							
	switch_states.byte2 &= 0b11110011; //preserve PROG switches states, clear BMOD and EG2 states
    1b06:	90 91 84 03 	lds	r25, 0x0384
    1b0a:	93 7f       	andi	r25, 0xF3	; 243
	
	switch_states.byte2 |=	((current_patch.byte_5 >> BMOD) & 1) << BMOD_SW |
    1b0c:	89 2b       	or	r24, r25
    1b0e:	11 1f       	adc	r17, r17
    1b10:	11 27       	eor	r17, r17
    1b12:	11 1f       	adc	r17, r17
    1b14:	11 0f       	add	r17, r17
    1b16:	11 0f       	add	r17, r17
    1b18:	81 2b       	or	r24, r17
    1b1a:	80 93 84 03 	sts	0x0384, r24
													
	//spi_sw_byte0_current_state = spi_sw_byte0_previous_state = switch_states.byte0;
	//
	//spi_sw_byte1_current_state = spi_sw_byte1_previous_state = switch_states.byte1;						
			
	lock_pots();
    1b1e:	0e 94 a5 08 	call	0x114a	; 0x114a <lock_pots>
	
	//if (current_patch.mode == MANUAL) switch_states.byte2 &= ~(1<< PROG_MANUAL_SW); //if in MANUAL mode, turn off MANUAL LED
	switch_states.byte2 &= ~(1<<PROG_MANUAL_SW);
    1b22:	80 91 84 03 	lds	r24, 0x0384
    1b26:	8f 77       	andi	r24, 0x7F	; 127
    1b28:	80 93 84 03 	sts	0x0384, r24
	
	current_patch.mode = MEMORY;
    1b2c:	10 92 0b 03 	sts	0x030B, r1
	
}
    1b30:	cd 5b       	subi	r28, 0xBD	; 189
    1b32:	df 4f       	sbci	r29, 0xFF	; 255
    1b34:	0f b6       	in	r0, 0x3f	; 63
    1b36:	f8 94       	cli
    1b38:	de bf       	out	0x3e, r29	; 62
    1b3a:	0f be       	out	0x3f, r0	; 63
    1b3c:	cd bf       	out	0x3d, r28	; 61
    1b3e:	df 91       	pop	r29
    1b40:	cf 91       	pop	r28
    1b42:	1f 91       	pop	r17
    1b44:	08 95       	ret

00001b46 <transpose_note>:

uint8_t transpose_note (uint8_t note, uint8_t vco) {
	
	uint8_t n = 0;
	
	n = octave_index.vco1;
    1b46:	90 91 0c 03 	lds	r25, 0x030C
	if (vco == VCO2) n = octave_index.vco2;
    1b4a:	60 3f       	cpi	r22, 0xF0	; 240
    1b4c:	11 f4       	brne	.+4      	; 0x1b52 <transpose_note+0xc>
    1b4e:	90 91 0d 03 	lds	r25, 0x030D

	note = (n*12) + note; //calculate MIDI note after octave addition
    1b52:	29 2f       	mov	r18, r25
    1b54:	22 0f       	add	r18, r18
    1b56:	92 0f       	add	r25, r18
    1b58:	99 0f       	add	r25, r25
    1b5a:	99 0f       	add	r25, r25
    1b5c:	89 0f       	add	r24, r25
			
		note = 136;
			
	}
		
	return note;	
    1b5e:	89 38       	cpi	r24, 0x89	; 137
    1b60:	08 f0       	brcs	.+2      	; 0x1b64 <transpose_note+0x1e>
    1b62:	88 e8       	ldi	r24, 0x88	; 136
	
}
    1b64:	08 95       	ret

00001b66 <update_octave_range>:

void update_octave_range(void) {
	
	if ((switch_states.byte0 >> VCO1_OCTAVE_UP_SW) & 1) {
    1b66:	80 91 82 03 	lds	r24, 0x0382
    1b6a:	98 2f       	mov	r25, r24
    1b6c:	96 95       	lsr	r25
    1b6e:	96 95       	lsr	r25
    1b70:	96 95       	lsr	r25
    1b72:	90 ff       	sbrs	r25, 0
    1b74:	0e c0       	rjmp	.+28     	; 0x1b92 <update_octave_range+0x2c>
		
		if (++octave_index.vco1 == 5) octave_index.vco1 = 4;
    1b76:	90 91 0c 03 	lds	r25, 0x030C
    1b7a:	9f 5f       	subi	r25, 0xFF	; 255
    1b7c:	90 93 0c 03 	sts	0x030C, r25
    1b80:	95 30       	cpi	r25, 0x05	; 5
    1b82:	19 f4       	brne	.+6      	; 0x1b8a <update_octave_range+0x24>
    1b84:	94 e0       	ldi	r25, 0x04	; 4
    1b86:	90 93 0c 03 	sts	0x030C, r25
		switch_states.byte0 ^= (1<<VCO1_OCTAVE_UP_SW); //toggle switch state bit
    1b8a:	98 e0       	ldi	r25, 0x08	; 8
    1b8c:	89 27       	eor	r24, r25
    1b8e:	80 93 82 03 	sts	0x0382, r24
		
	}
	
	if ((switch_states.byte1 >> VCO1_OCTAVE_DOWN_SW) & 1) { //this didn't work initially because VCO1_OCTAVE_DOWN_SW pull down resistor wasn't installed on PCB!!!
    1b92:	80 91 83 03 	lds	r24, 0x0383
    1b96:	98 2f       	mov	r25, r24
    1b98:	96 95       	lsr	r25
    1b9a:	96 95       	lsr	r25
    1b9c:	96 95       	lsr	r25
    1b9e:	90 ff       	sbrs	r25, 0
    1ba0:	0b c0       	rjmp	.+22     	; 0x1bb8 <update_octave_range+0x52>
	
		if (octave_index.vco1 == 0) {} else {octave_index.vco1--;}
    1ba2:	90 91 0c 03 	lds	r25, 0x030C
    1ba6:	99 23       	and	r25, r25
    1ba8:	19 f0       	breq	.+6      	; 0x1bb0 <update_octave_range+0x4a>
    1baa:	91 50       	subi	r25, 0x01	; 1
    1bac:	90 93 0c 03 	sts	0x030C, r25
		switch_states.byte1 ^= (1<<VCO1_OCTAVE_DOWN_SW);
    1bb0:	98 e0       	ldi	r25, 0x08	; 8
    1bb2:	89 27       	eor	r24, r25
    1bb4:	80 93 83 03 	sts	0x0383, r24

	}
	
	current_patch.byte_4 = 0; //clear the whole damn byte as all bits are set below
	current_patch.byte_4 |= (1<<vco1_octave[octave_index.vco1]); //set octave	
    1bb8:	80 91 0c 03 	lds	r24, 0x030C
    1bbc:	e1 e2       	ldi	r30, 0x21	; 33
    1bbe:	f2 e0       	ldi	r31, 0x02	; 2
    1bc0:	e8 0f       	add	r30, r24
    1bc2:	f1 1d       	adc	r31, r1
    1bc4:	81 e0       	ldi	r24, 0x01	; 1
    1bc6:	90 e0       	ldi	r25, 0x00	; 0
    1bc8:	00 80       	ld	r0, Z
    1bca:	02 c0       	rjmp	.+4      	; 0x1bd0 <update_octave_range+0x6a>
    1bcc:	88 0f       	add	r24, r24
    1bce:	99 1f       	adc	r25, r25
    1bd0:	0a 94       	dec	r0
    1bd2:	e2 f7       	brpl	.-8      	; 0x1bcc <update_octave_range+0x66>
    1bd4:	58 2f       	mov	r21, r24
    1bd6:	80 93 05 03 	sts	0x0305, r24
	
	if ((switch_states.byte1 >> VCO2_OCTAVE_UP_SW) & 1) {
    1bda:	90 91 83 03 	lds	r25, 0x0383
    1bde:	29 2f       	mov	r18, r25
    1be0:	26 95       	lsr	r18
    1be2:	26 95       	lsr	r18
    1be4:	20 ff       	sbrs	r18, 0
    1be6:	0e c0       	rjmp	.+28     	; 0x1c04 <update_octave_range+0x9e>
		
		if (++octave_index.vco2 == 5) octave_index.vco2 = 4;
    1be8:	80 91 0d 03 	lds	r24, 0x030D
    1bec:	8f 5f       	subi	r24, 0xFF	; 255
    1bee:	80 93 0d 03 	sts	0x030D, r24
    1bf2:	85 30       	cpi	r24, 0x05	; 5
    1bf4:	19 f4       	brne	.+6      	; 0x1bfc <update_octave_range+0x96>
    1bf6:	84 e0       	ldi	r24, 0x04	; 4
    1bf8:	80 93 0d 03 	sts	0x030D, r24
		switch_states.byte1 ^= (1<<VCO2_OCTAVE_UP_SW); //toggle switch state bit		
    1bfc:	84 e0       	ldi	r24, 0x04	; 4
    1bfe:	98 27       	eor	r25, r24
    1c00:	90 93 83 03 	sts	0x0383, r25
	}	
	
	if ((switch_states.byte1 >> VCO2_OCTAVE_DOWN_SW) & 1) {
    1c04:	90 91 83 03 	lds	r25, 0x0383
    1c08:	29 2f       	mov	r18, r25
    1c0a:	26 95       	lsr	r18
    1c0c:	20 ff       	sbrs	r18, 0
    1c0e:	0b c0       	rjmp	.+22     	; 0x1c26 <update_octave_range+0xc0>
		
		if (octave_index.vco2 == 0) {} else {octave_index.vco2--;}
    1c10:	80 91 0d 03 	lds	r24, 0x030D
    1c14:	88 23       	and	r24, r24
    1c16:	19 f0       	breq	.+6      	; 0x1c1e <update_octave_range+0xb8>
    1c18:	81 50       	subi	r24, 0x01	; 1
    1c1a:	80 93 0d 03 	sts	0x030D, r24
		switch_states.byte1 ^= (1<<VCO2_OCTAVE_DOWN_SW);
    1c1e:	82 e0       	ldi	r24, 0x02	; 2
    1c20:	98 27       	eor	r25, r24
    1c22:	90 93 83 03 	sts	0x0383, r25
		
	}
			
	current_patch.byte_3 &= 0b11111100; //clear bottom 2 bits for patch byte_3, which are for VCO2 2' and 4'
    1c26:	40 91 04 03 	lds	r20, 0x0304
    1c2a:	4c 7f       	andi	r20, 0xFC	; 252
    1c2c:	40 93 04 03 	sts	0x0304, r20
	
	if (octave_index.vco2 > 2) { //VCO2 2' and 4' LEDs are on LED latch 3
    1c30:	90 91 0d 03 	lds	r25, 0x030D
    1c34:	93 30       	cpi	r25, 0x03	; 3
    1c36:	88 f0       	brcs	.+34     	; 0x1c5a <update_octave_range+0xf4>

						
		current_patch.byte_3 |= (1<<vco2_octave[octave_index.vco2]);	
    1c38:	ec e1       	ldi	r30, 0x1C	; 28
    1c3a:	f2 e0       	ldi	r31, 0x02	; 2
    1c3c:	e9 0f       	add	r30, r25
    1c3e:	f1 1d       	adc	r31, r1
    1c40:	21 e0       	ldi	r18, 0x01	; 1
    1c42:	30 e0       	ldi	r19, 0x00	; 0
    1c44:	c9 01       	movw	r24, r18
    1c46:	00 80       	ld	r0, Z
    1c48:	02 c0       	rjmp	.+4      	; 0x1c4e <update_octave_range+0xe8>
    1c4a:	88 0f       	add	r24, r24
    1c4c:	99 1f       	adc	r25, r25
    1c4e:	0a 94       	dec	r0
    1c50:	e2 f7       	brpl	.-8      	; 0x1c4a <update_octave_range+0xe4>
    1c52:	84 2b       	or	r24, r20
    1c54:	80 93 04 03 	sts	0x0304, r24
    1c58:	08 95       	ret
				
	} else { //VCO2 8', 16' and 32' are on LED latch 4
		
		current_patch.byte_4 |= (1<<vco2_octave[octave_index.vco2]); //set octave
    1c5a:	ec e1       	ldi	r30, 0x1C	; 28
    1c5c:	f2 e0       	ldi	r31, 0x02	; 2
    1c5e:	e9 0f       	add	r30, r25
    1c60:	f1 1d       	adc	r31, r1
    1c62:	21 e0       	ldi	r18, 0x01	; 1
    1c64:	30 e0       	ldi	r19, 0x00	; 0
    1c66:	c9 01       	movw	r24, r18
    1c68:	00 80       	ld	r0, Z
    1c6a:	02 c0       	rjmp	.+4      	; 0x1c70 <update_octave_range+0x10a>
    1c6c:	88 0f       	add	r24, r24
    1c6e:	99 1f       	adc	r25, r25
    1c70:	0a 94       	dec	r0
    1c72:	e2 f7       	brpl	.-8      	; 0x1c6c <update_octave_range+0x106>
    1c74:	85 2b       	or	r24, r21
    1c76:	80 93 05 03 	sts	0x0305, r24
    1c7a:	08 95       	ret

00001c7c <update_lfo_shape>:
	
}	
	
void update_lfo_shape(void) {

	if ((switch_states.byte1 >> LFO_SHAPE_SW) & 1) {
    1c7c:	80 91 83 03 	lds	r24, 0x0383
    1c80:	88 23       	and	r24, r24
    1c82:	64 f4       	brge	.+24     	; 0x1c9c <update_lfo_shape+0x20>
	
		switch_states.byte1 ^= (1<<LFO_SHAPE_SW); //toggle switch state
    1c84:	80 58       	subi	r24, 0x80	; 128
    1c86:	80 93 83 03 	sts	0x0383, r24
		if (++lfo_shape_index == 5) lfo_shape_index = 0;
    1c8a:	80 91 0e 03 	lds	r24, 0x030E
    1c8e:	8f 5f       	subi	r24, 0xFF	; 255
    1c90:	80 93 0e 03 	sts	0x030E, r24
    1c94:	85 30       	cpi	r24, 0x05	; 5
    1c96:	11 f4       	brne	.+4      	; 0x1c9c <update_lfo_shape+0x20>
    1c98:	10 92 0e 03 	sts	0x030E, r1
	}
	
	current_patch.byte_2 &= 0b00001111; //clear top 4 bits
	current_patch.byte_2 |= 1 << lfo[lfo_shape_index].led_addr;
    1c9c:	e0 91 0e 03 	lds	r30, 0x030E
    1ca0:	f0 e0       	ldi	r31, 0x00	; 0
    1ca2:	ee 0f       	add	r30, r30
    1ca4:	ff 1f       	adc	r31, r31
    1ca6:	ea 5d       	subi	r30, 0xDA	; 218
    1ca8:	fd 4f       	sbci	r31, 0xFD	; 253
    1caa:	81 e0       	ldi	r24, 0x01	; 1
    1cac:	90 e0       	ldi	r25, 0x00	; 0
    1cae:	01 80       	ldd	r0, Z+1	; 0x01
    1cb0:	02 c0       	rjmp	.+4      	; 0x1cb6 <update_lfo_shape+0x3a>
    1cb2:	88 0f       	add	r24, r24
    1cb4:	99 1f       	adc	r25, r25
    1cb6:	0a 94       	dec	r0
    1cb8:	e2 f7       	brpl	.-8      	; 0x1cb2 <update_lfo_shape+0x36>
	
		switch_states.byte1 ^= (1<<LFO_SHAPE_SW); //toggle switch state
		if (++lfo_shape_index == 5) lfo_shape_index = 0;
	}
	
	current_patch.byte_2 &= 0b00001111; //clear top 4 bits
    1cba:	90 91 03 03 	lds	r25, 0x0303
    1cbe:	9f 70       	andi	r25, 0x0F	; 15
	current_patch.byte_2 |= 1 << lfo[lfo_shape_index].led_addr;
    1cc0:	89 2b       	or	r24, r25
    1cc2:	80 93 03 03 	sts	0x0303, r24
	DATA_BUS = lfo[lfo_shape_index].waveform_addr;
    1cc6:	80 81       	ld	r24, Z
    1cc8:	82 b9       	out	0x02, r24	; 2
	LFO_LATCH_PORT |= (1<<LFO_SW_LATCH);
    1cca:	ed ed       	ldi	r30, 0xDD	; 221
    1ccc:	f0 e0       	ldi	r31, 0x00	; 0
    1cce:	80 81       	ld	r24, Z
    1cd0:	80 62       	ori	r24, 0x20	; 32
    1cd2:	80 83       	st	Z, r24
	LFO_LATCH_PORT &= ~(1<<LFO_SW_LATCH);
    1cd4:	80 81       	ld	r24, Z
    1cd6:	8f 7d       	andi	r24, 0xDF	; 223
    1cd8:	80 83       	st	Z, r24
	
}		
    1cda:	08 95       	ret

00001cdc <update_lfo_sync>:
	
void update_lfo_sync(void) {
	
	static uint8_t lfo_sync_mode = 0;
	
	if ((switch_states.byte1 >> LFO_SYNC_SW) & 1) {
    1cdc:	80 91 83 03 	lds	r24, 0x0383
    1ce0:	80 ff       	sbrs	r24, 0
    1ce2:	0f c0       	rjmp	.+30     	; 0x1d02 <update_lfo_sync+0x26>
			
		switch_states.byte1 ^= (1<<LFO_SYNC_SW); //toggle switch state
    1ce4:	91 e0       	ldi	r25, 0x01	; 1
    1ce6:	89 27       	eor	r24, r25
    1ce8:	80 93 83 03 	sts	0x0383, r24
		if (++lfo_sync_mode == 5) lfo_sync_mode = 0;
    1cec:	80 91 0f 03 	lds	r24, 0x030F
    1cf0:	8f 5f       	subi	r24, 0xFF	; 255
    1cf2:	80 93 0f 03 	sts	0x030F, r24
    1cf6:	85 30       	cpi	r24, 0x05	; 5
    1cf8:	11 f4       	brne	.+4      	; 0x1cfe <update_lfo_sync+0x22>
    1cfa:	10 92 0f 03 	sts	0x030F, r1
		midi_clock.ppqn_counter = 0; //reset counter
    1cfe:	10 92 da 03 	sts	0x03DA, r1
	}
	
	current_patch.byte_2 &= 0b11110000; //clear bottom 4 bits
    1d02:	60 91 03 03 	lds	r22, 0x0303
    1d06:	60 7f       	andi	r22, 0xF0	; 240
    1d08:	60 93 03 03 	sts	0x0303, r22
	if (lfo_sync_mode) current_patch.byte_2 |= (1<<(lfo_sync_mode -1)); //this allows an off state when lfo_sync_mode = 0;
    1d0c:	20 91 0f 03 	lds	r18, 0x030F
    1d10:	22 23       	and	r18, r18
    1d12:	71 f0       	breq	.+28     	; 0x1d30 <update_lfo_sync+0x54>
    1d14:	30 e0       	ldi	r19, 0x00	; 0
    1d16:	21 50       	subi	r18, 0x01	; 1
    1d18:	30 40       	sbci	r19, 0x00	; 0
    1d1a:	41 e0       	ldi	r20, 0x01	; 1
    1d1c:	50 e0       	ldi	r21, 0x00	; 0
    1d1e:	ca 01       	movw	r24, r20
    1d20:	02 c0       	rjmp	.+4      	; 0x1d26 <update_lfo_sync+0x4a>
    1d22:	88 0f       	add	r24, r24
    1d24:	99 1f       	adc	r25, r25
    1d26:	2a 95       	dec	r18
    1d28:	e2 f7       	brpl	.-8      	; 0x1d22 <update_lfo_sync+0x46>
    1d2a:	86 2b       	or	r24, r22
    1d2c:	80 93 03 03 	sts	0x0303, r24
	
	//now parse out clock divide from patch byte_2
	switch (current_patch.byte_2 & 0b00001111) {
    1d30:	80 91 03 03 	lds	r24, 0x0303
    1d34:	90 e0       	ldi	r25, 0x00	; 0
    1d36:	8f 70       	andi	r24, 0x0F	; 15
    1d38:	90 70       	andi	r25, 0x00	; 0
    1d3a:	82 30       	cpi	r24, 0x02	; 2
    1d3c:	91 05       	cpc	r25, r1
    1d3e:	89 f0       	breq	.+34     	; 0x1d62 <update_lfo_sync+0x86>
    1d40:	83 30       	cpi	r24, 0x03	; 3
    1d42:	91 05       	cpc	r25, r1
    1d44:	24 f4       	brge	.+8      	; 0x1d4e <update_lfo_sync+0x72>
    1d46:	81 30       	cpi	r24, 0x01	; 1
    1d48:	91 05       	cpc	r25, r1
    1d4a:	b9 f4       	brne	.+46     	; 0x1d7a <update_lfo_sync+0x9e>
    1d4c:	07 c0       	rjmp	.+14     	; 0x1d5c <update_lfo_sync+0x80>
    1d4e:	84 30       	cpi	r24, 0x04	; 4
    1d50:	91 05       	cpc	r25, r1
    1d52:	59 f0       	breq	.+22     	; 0x1d6a <update_lfo_sync+0x8e>
    1d54:	88 30       	cpi	r24, 0x08	; 8
    1d56:	91 05       	cpc	r25, r1
    1d58:	81 f4       	brne	.+32     	; 0x1d7a <update_lfo_sync+0x9e>
    1d5a:	0b c0       	rjmp	.+22     	; 0x1d72 <update_lfo_sync+0x96>
		
		case 0b0001:
			midi_clock.divider = 0; //key sync mode - need to turn midi sync off here. How?
    1d5c:	10 92 d9 03 	sts	0x03D9, r1
			
			break;
    1d60:	08 95       	ret
			
		case 0b0010: //turn these case conditions into constants. #define 0b0010 DIV_24
			midi_clock.divider = 24; //1:4
    1d62:	88 e1       	ldi	r24, 0x18	; 24
    1d64:	80 93 d9 03 	sts	0x03D9, r24
			break;
    1d68:	08 95       	ret
			
		case 0b0100:
			midi_clock.divider = 12; //1:8
    1d6a:	8c e0       	ldi	r24, 0x0C	; 12
    1d6c:	80 93 d9 03 	sts	0x03D9, r24
			break;
    1d70:	08 95       	ret
			
		case 0b1000:
			midi_clock.divider = 6; //1:16	 		
    1d72:	86 e0       	ldi	r24, 0x06	; 6
    1d74:	80 93 d9 03 	sts	0x03D9, r24
			break;
    1d78:	08 95       	ret
		
		default:
			midi_clock.divider = 0; //need to turn midi sync off here. How?
    1d7a:	10 92 d9 03 	sts	0x03D9, r1
    1d7e:	08 95       	ret

00001d80 <update_arp_sync>:

void update_arp_sync(void) {
	
	static uint8_t arp_sync_mode = 0;
	
	if ((switch_states.byte1 >> ARP_SYNC_SW) & 1) {
    1d80:	80 91 83 03 	lds	r24, 0x0383
    1d84:	98 2f       	mov	r25, r24
    1d86:	92 95       	swap	r25
    1d88:	96 95       	lsr	r25
    1d8a:	96 95       	lsr	r25
    1d8c:	93 70       	andi	r25, 0x03	; 3
    1d8e:	90 ff       	sbrs	r25, 0
    1d90:	16 c0       	rjmp	.+44     	; 0x1dbe <update_arp_sync+0x3e>
		
		switch_states.byte1 ^= (1<<ARP_SYNC_SW); //toggle switch state
    1d92:	90 e4       	ldi	r25, 0x40	; 64
    1d94:	89 27       	eor	r24, r25
    1d96:	80 93 83 03 	sts	0x0383, r24
		if (++arp_sync_mode == 5) arp_sync_mode = 0;
    1d9a:	80 91 10 03 	lds	r24, 0x0310
    1d9e:	8f 5f       	subi	r24, 0xFF	; 255
    1da0:	80 93 10 03 	sts	0x0310, r24
    1da4:	85 30       	cpi	r24, 0x05	; 5
    1da6:	11 f4       	brne	.+4      	; 0x1dac <update_arp_sync+0x2c>
    1da8:	10 92 10 03 	sts	0x0310, r1
		if (arp.clock_source == MIDI_CLOCK) arp.ppqn_counter = 1; //this will need to be handled elsewhere to take into account current ppqn count and and new divider value 
    1dac:	80 91 91 03 	lds	r24, 0x0391
    1db0:	88 23       	and	r24, r24
    1db2:	19 f4       	brne	.+6      	; 0x1dba <update_arp_sync+0x3a>
    1db4:	81 e0       	ldi	r24, 0x01	; 1
    1db6:	80 93 8e 03 	sts	0x038E, r24
		system_clock.ppqn_counter = 0;	//same applies to system clock ppqn counter
    1dba:	10 92 d4 03 	sts	0x03D4, r1
		
	}
	
	current_patch.byte_3 &= 0b11000011; //clear middle 4 bits
    1dbe:	60 91 04 03 	lds	r22, 0x0304
    1dc2:	63 7c       	andi	r22, 0xC3	; 195
    1dc4:	60 93 04 03 	sts	0x0304, r22
	if (arp_sync_mode) current_patch.byte_3 |= 1<<(arp_sync_mode + 1); //this allows an off state when arp_sync_mode = 0. Is that what's really needed?
    1dc8:	20 91 10 03 	lds	r18, 0x0310
    1dcc:	22 23       	and	r18, r18
    1dce:	71 f0       	breq	.+28     	; 0x1dec <update_arp_sync+0x6c>
    1dd0:	30 e0       	ldi	r19, 0x00	; 0
    1dd2:	2f 5f       	subi	r18, 0xFF	; 255
    1dd4:	3f 4f       	sbci	r19, 0xFF	; 255
    1dd6:	41 e0       	ldi	r20, 0x01	; 1
    1dd8:	50 e0       	ldi	r21, 0x00	; 0
    1dda:	ca 01       	movw	r24, r20
    1ddc:	02 c0       	rjmp	.+4      	; 0x1de2 <update_arp_sync+0x62>
    1dde:	88 0f       	add	r24, r24
    1de0:	99 1f       	adc	r25, r25
    1de2:	2a 95       	dec	r18
    1de4:	e2 f7       	brpl	.-8      	; 0x1dde <update_arp_sync+0x5e>
    1de6:	86 2b       	or	r24, r22
    1de8:	80 93 04 03 	sts	0x0304, r24
	
	switch (current_patch.byte_3 & 0b00111100) {
    1dec:	80 91 04 03 	lds	r24, 0x0304
    1df0:	90 e0       	ldi	r25, 0x00	; 0
    1df2:	8c 73       	andi	r24, 0x3C	; 60
    1df4:	90 70       	andi	r25, 0x00	; 0
    1df6:	88 30       	cpi	r24, 0x08	; 8
    1df8:	91 05       	cpc	r25, r1
    1dfa:	a1 f0       	breq	.+40     	; 0x1e24 <update_arp_sync+0xa4>
    1dfc:	89 30       	cpi	r24, 0x09	; 9
    1dfe:	91 05       	cpc	r25, r1
    1e00:	24 f4       	brge	.+8      	; 0x1e0a <update_arp_sync+0x8a>
    1e02:	84 30       	cpi	r24, 0x04	; 4
    1e04:	91 05       	cpc	r25, r1
    1e06:	01 f5       	brne	.+64     	; 0x1e48 <update_arp_sync+0xc8>
    1e08:	07 c0       	rjmp	.+14     	; 0x1e18 <update_arp_sync+0x98>
    1e0a:	80 31       	cpi	r24, 0x10	; 16
    1e0c:	91 05       	cpc	r25, r1
    1e0e:	81 f0       	breq	.+32     	; 0x1e30 <update_arp_sync+0xb0>
    1e10:	80 32       	cpi	r24, 0x20	; 32
    1e12:	91 05       	cpc	r25, r1
    1e14:	c9 f4       	brne	.+50     	; 0x1e48 <update_arp_sync+0xc8>
    1e16:	12 c0       	rjmp	.+36     	; 0x1e3c <update_arp_sync+0xbc>
			
		case 0b00000100:
			system_clock.divider = arp.divider = 48; //1:2
    1e18:	80 e3       	ldi	r24, 0x30	; 48
    1e1a:	80 93 8f 03 	sts	0x038F, r24
    1e1e:	80 93 d3 03 	sts	0x03D3, r24
			break;
    1e22:	08 95       	ret
			
		case 0b00001000:
			system_clock.divider = arp.divider = 24; //1:4
    1e24:	88 e1       	ldi	r24, 0x18	; 24
    1e26:	80 93 8f 03 	sts	0x038F, r24
    1e2a:	80 93 d3 03 	sts	0x03D3, r24
			break;
    1e2e:	08 95       	ret
			
		case 0b00010000:		
			system_clock.divider = arp.divider = 12; //1:8
    1e30:	8c e0       	ldi	r24, 0x0C	; 12
    1e32:	80 93 8f 03 	sts	0x038F, r24
    1e36:	80 93 d3 03 	sts	0x03D3, r24
			break;
    1e3a:	08 95       	ret
			
		case 0b00100000:
			system_clock.divider = arp.divider = 6; //1:16	
    1e3c:	86 e0       	ldi	r24, 0x06	; 6
    1e3e:	80 93 8f 03 	sts	0x038F, r24
    1e42:	80 93 d3 03 	sts	0x03D3, r24
			break;
    1e46:	08 95       	ret
			
		default:
			system_clock.divider = arp.divider = 4; //should be 1 but this never turns arp_sync_led off - need to fix this	
    1e48:	84 e0       	ldi	r24, 0x04	; 4
    1e4a:	80 93 8f 03 	sts	0x038F, r24
    1e4e:	80 93 d3 03 	sts	0x03D3, r24
    1e52:	08 95       	ret

00001e54 <update_arp_range>:

void update_arp_range(void) {
	
	static uint8_t arp_range = 0;
	
	if ((switch_states.byte1 == (1<<ARP_RANGE_SW)) & 1) {
    1e54:	80 91 83 03 	lds	r24, 0x0383
    1e58:	80 31       	cpi	r24, 0x10	; 16
    1e5a:	69 f4       	brne	.+26     	; 0x1e76 <update_arp_range+0x22>
		
		switch_states.byte1 ^= (1<<ARP_RANGE_SW); //toggle switch bit
    1e5c:	10 92 83 03 	sts	0x0383, r1
		
		if (++arp_range == 4) arp_range = 0;
    1e60:	80 91 11 03 	lds	r24, 0x0311
    1e64:	8f 5f       	subi	r24, 0xFF	; 255
    1e66:	80 93 11 03 	sts	0x0311, r24
    1e6a:	84 30       	cpi	r24, 0x04	; 4
    1e6c:	11 f4       	brne	.+4      	; 0x1e72 <update_arp_range+0x1e>
    1e6e:	10 92 11 03 	sts	0x0311, r1
		arp.step_position = 0; //reset step position if range changes
    1e72:	10 92 8a 03 	sts	0x038A, r1
						
	}
	
	//arp range LEDs 3 and 2 are in byte_3, bits 7 and 6, respectively. arp range LED 1 is bit 1 of byte_1
	
	current_patch.byte_1 &= ~(1<<ARP_RANGE_1); //clear arp range 1 LED
    1e76:	80 91 02 03 	lds	r24, 0x0302
    1e7a:	8d 7f       	andi	r24, 0xFD	; 253
    1e7c:	80 93 02 03 	sts	0x0302, r24
	current_patch.byte_3 &= 0b00111111; //clear bits 6 and7, arp range 3 and 2
    1e80:	80 91 04 03 	lds	r24, 0x0304
    1e84:	8f 73       	andi	r24, 0x3F	; 63
    1e86:	80 93 04 03 	sts	0x0304, r24
	
	arp.range = arp_range;
    1e8a:	80 91 11 03 	lds	r24, 0x0311
    1e8e:	80 93 88 03 	sts	0x0388, r24
	
	update_arp_sequence(); //update sequence with new settings
    1e92:	0e 94 a3 00 	call	0x146	; 0x146 <update_arp_sequence>
	
	switch (arp_range) { //this just updates LEDs. no struct to handle arp range yet
    1e96:	80 91 11 03 	lds	r24, 0x0311
    1e9a:	82 30       	cpi	r24, 0x02	; 2
    1e9c:	51 f0       	breq	.+20     	; 0x1eb2 <update_arp_range+0x5e>
    1e9e:	83 30       	cpi	r24, 0x03	; 3
    1ea0:	71 f0       	breq	.+28     	; 0x1ebe <update_arp_range+0x6a>
    1ea2:	81 30       	cpi	r24, 0x01	; 1
    1ea4:	89 f4       	brne	.+34     	; 0x1ec8 <update_arp_range+0x74>
			
			break;
			
		case 1:
		
			current_patch.byte_1 |= (1<<ARP_RANGE_1); //set range 1 LED. LED was in the wrong way!
    1ea6:	80 91 02 03 	lds	r24, 0x0302
    1eaa:	82 60       	ori	r24, 0x02	; 2
    1eac:	80 93 02 03 	sts	0x0302, r24
			break;
    1eb0:	08 95       	ret
			
		case 2:
		
			current_patch.byte_3 |= (1<<ARP_RANGE_2);		
    1eb2:	80 91 04 03 	lds	r24, 0x0304
    1eb6:	80 64       	ori	r24, 0x40	; 64
    1eb8:	80 93 04 03 	sts	0x0304, r24
			break;
    1ebc:	08 95       	ret
			
			
		case 3: 
			
			current_patch.byte_3 |= (1<<ARP_RANGE_3);
    1ebe:	80 91 04 03 	lds	r24, 0x0304
    1ec2:	80 68       	ori	r24, 0x80	; 128
    1ec4:	80 93 04 03 	sts	0x0304, r24
    1ec8:	08 95       	ret

00001eca <update_arp_mode>:

void update_arp_mode(void) {

	static uint8_t arp_mode = 0;
	
	if ((switch_states.byte1 >> ARP_MODE_SW) & 1) {
    1eca:	80 91 83 03 	lds	r24, 0x0383
    1ece:	98 2f       	mov	r25, r24
    1ed0:	92 95       	swap	r25
    1ed2:	96 95       	lsr	r25
    1ed4:	97 70       	andi	r25, 0x07	; 7
    1ed6:	90 ff       	sbrs	r25, 0
    1ed8:	0f c0       	rjmp	.+30     	; 0x1ef8 <update_arp_mode+0x2e>
		
		switch_states.byte1 ^= (1<<ARP_MODE_SW); //toggle switch state
    1eda:	90 e2       	ldi	r25, 0x20	; 32
    1edc:	89 27       	eor	r24, r25
    1ede:	80 93 83 03 	sts	0x0383, r24
		if (++arp_mode == 5) arp_mode = 0;
    1ee2:	80 91 12 03 	lds	r24, 0x0312
    1ee6:	8f 5f       	subi	r24, 0xFF	; 255
    1ee8:	80 93 12 03 	sts	0x0312, r24
    1eec:	85 30       	cpi	r24, 0x05	; 5
    1eee:	11 f4       	brne	.+4      	; 0x1ef4 <update_arp_mode+0x2a>
    1ef0:	10 92 12 03 	sts	0x0312, r1
		arp.step_position = 0; //reset step position if mode changes
    1ef4:	10 92 8a 03 	sts	0x038A, r1
		
	}

	//if (arp.clock_source != MIDI_CLOCK) arp.clock_source = INTERNAL_CLOCK;	

	current_patch.byte_1 &= 0b11000011; //clear middle 4 bits UP, DOWN, RANDOM, MODE correspond to bits 6>>2
    1ef8:	90 91 02 03 	lds	r25, 0x0302
    1efc:	93 7c       	andi	r25, 0xC3	; 195
    1efe:	90 93 02 03 	sts	0x0302, r25
	
	switch(arp_mode) {
    1f02:	80 91 12 03 	lds	r24, 0x0312
    1f06:	81 30       	cpi	r24, 0x01	; 1
    1f08:	79 f0       	breq	.+30     	; 0x1f28 <update_arp_mode+0x5e>
    1f0a:	81 30       	cpi	r24, 0x01	; 1
    1f0c:	28 f0       	brcs	.+10     	; 0x1f18 <update_arp_mode+0x4e>
    1f0e:	82 30       	cpi	r24, 0x02	; 2
    1f10:	91 f0       	breq	.+36     	; 0x1f36 <update_arp_mode+0x6c>
    1f12:	83 30       	cpi	r24, 0x03	; 3
    1f14:	f1 f4       	brne	.+60     	; 0x1f52 <update_arp_mode+0x88>
    1f16:	16 c0       	rjmp	.+44     	; 0x1f44 <update_arp_mode+0x7a>
		
		case 0:
		
			//turn arp off
			arp.mode = OFF;
    1f18:	10 92 92 03 	sts	0x0392, r1
			if (gate_buffer == 0) PORTF &= ~(1<<GATE); //turn gate off.
    1f1c:	80 91 b4 02 	lds	r24, 0x02B4
    1f20:	88 23       	and	r24, r24
    1f22:	e9 f4       	brne	.+58     	; 0x1f5e <update_arp_mode+0x94>
    1f24:	89 98       	cbi	0x11, 1	; 17
    1f26:	1b c0       	rjmp	.+54     	; 0x1f5e <update_arp_mode+0x94>
			break;
			
		case 1:
		
			current_patch.byte_1 |= (1<<ARP_MODE_UP) | (1<<ARP_ON);
    1f28:	94 62       	ori	r25, 0x24	; 36
    1f2a:	90 93 02 03 	sts	0x0302, r25
			arp.mode = UP;
    1f2e:	81 e0       	ldi	r24, 0x01	; 1
    1f30:	80 93 92 03 	sts	0x0392, r24
			break;	
    1f34:	14 c0       	rjmp	.+40     	; 0x1f5e <update_arp_mode+0x94>
		
		case 2:
			current_patch.byte_1 |= (1<<ARP_MODE_DN) | (1<<ARP_ON);
    1f36:	94 61       	ori	r25, 0x14	; 20
    1f38:	90 93 02 03 	sts	0x0302, r25
			arp.mode = DOWN;
    1f3c:	82 e0       	ldi	r24, 0x02	; 2
    1f3e:	80 93 92 03 	sts	0x0392, r24
			break;
    1f42:	0d c0       	rjmp	.+26     	; 0x1f5e <update_arp_mode+0x94>
			
		case 3:
			current_patch.byte_1 |= (1<<ARP_MODE_UP) | (1<<ARP_MODE_DN) | (1<<ARP_ON);
    1f44:	94 63       	ori	r25, 0x34	; 52
    1f46:	90 93 02 03 	sts	0x0302, r25
			arp.mode = UP_DOWN;
    1f4a:	83 e0       	ldi	r24, 0x03	; 3
    1f4c:	80 93 92 03 	sts	0x0392, r24
			break;
    1f50:	06 c0       	rjmp	.+12     	; 0x1f5e <update_arp_mode+0x94>
			
		default:
			current_patch.byte_1 |= (1<<ARP_MODE_RD) | (1<<ARP_ON);
    1f52:	9c 60       	ori	r25, 0x0C	; 12
    1f54:	90 93 02 03 	sts	0x0302, r25
			arp.mode = RANDOM;
    1f58:	84 e0       	ldi	r24, 0x04	; 4
    1f5a:	80 93 92 03 	sts	0x0392, r24
			
					
		
	}
	
	update_arp_sequence(); //update arp sequence with new mode
    1f5e:	0e 94 a3 00 	call	0x146	; 0x146 <update_arp_sequence>
	



}
    1f62:	08 95       	ret

00001f64 <update_patch>:
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    1f64:	90 91 82 03 	lds	r25, 0x0382
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
							((switch_states.byte0 >> VCO1_PULSE_SW) & 1) << VCO1_PULSE |
							((switch_states.byte0 >> VCO2_SAW_SW) & 1) << VCO2_SAW |
							((switch_states.byte0 >> VCO2_TRI_SW) & 1) << VCO2_TRI |
							((switch_states.byte0 >> VCO2_PULSE_SW) & 1) << VCO2_PULSE |
							((switch_states.byte2 >> BMOD_SW) & 1) << BMOD;
    1f68:	80 91 84 03 	lds	r24, 0x0384
    1f6c:	86 95       	lsr	r24
    1f6e:	86 95       	lsr	r24
    1f70:	68 2f       	mov	r22, r24
    1f72:	67 95       	ror	r22
    1f74:	66 27       	eor	r22, r22
    1f76:	67 95       	ror	r22
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    1f78:	29 2f       	mov	r18, r25
    1f7a:	21 70       	andi	r18, 0x01	; 1
    1f7c:	26 2b       	or	r18, r22
    1f7e:	69 2f       	mov	r22, r25
    1f80:	66 1f       	adc	r22, r22
    1f82:	66 27       	eor	r22, r22
    1f84:	66 1f       	adc	r22, r22
    1f86:	66 0f       	add	r22, r22
    1f88:	62 2b       	or	r22, r18
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
    1f8a:	29 2f       	mov	r18, r25
    1f8c:	26 95       	lsr	r18
    1f8e:	26 95       	lsr	r18
    1f90:	30 e0       	ldi	r19, 0x00	; 0
    1f92:	21 70       	andi	r18, 0x01	; 1
    1f94:	30 70       	andi	r19, 0x00	; 0
    1f96:	d9 01       	movw	r26, r18
    1f98:	aa 0f       	add	r26, r26
    1f9a:	bb 1f       	adc	r27, r27
    1f9c:	aa 0f       	add	r26, r26
    1f9e:	bb 1f       	adc	r27, r27
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    1fa0:	6a 2b       	or	r22, r26
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
    1fa2:	a9 2f       	mov	r26, r25
    1fa4:	a6 95       	lsr	r26
    1fa6:	b0 e0       	ldi	r27, 0x00	; 0
    1fa8:	a1 70       	andi	r26, 0x01	; 1
    1faa:	b0 70       	andi	r27, 0x00	; 0
    1fac:	fd 01       	movw	r30, r26
    1fae:	ee 0f       	add	r30, r30
    1fb0:	ff 1f       	adc	r31, r31
    1fb2:	ee 0f       	add	r30, r30
    1fb4:	ff 1f       	adc	r31, r31
    1fb6:	ee 0f       	add	r30, r30
    1fb8:	ff 1f       	adc	r31, r31
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    1fba:	a6 2f       	mov	r26, r22
    1fbc:	ae 2b       	or	r26, r30
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
							((switch_states.byte0 >> VCO1_PULSE_SW) & 1) << VCO1_PULSE |
							((switch_states.byte0 >> VCO2_SAW_SW) & 1) << VCO2_SAW |
    1fbe:	e9 2f       	mov	r30, r25
    1fc0:	e2 95       	swap	r30
    1fc2:	ef 70       	andi	r30, 0x0F	; 15
    1fc4:	f0 e0       	ldi	r31, 0x00	; 0
    1fc6:	e1 70       	andi	r30, 0x01	; 1
    1fc8:	f0 70       	andi	r31, 0x00	; 0
    1fca:	bf 01       	movw	r22, r30
    1fcc:	62 95       	swap	r22
    1fce:	72 95       	swap	r23
    1fd0:	70 7f       	andi	r23, 0xF0	; 240
    1fd2:	76 27       	eor	r23, r22
    1fd4:	60 7f       	andi	r22, 0xF0	; 240
    1fd6:	76 27       	eor	r23, r22
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    1fd8:	ea 2f       	mov	r30, r26
    1fda:	e6 2b       	or	r30, r22
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
							((switch_states.byte0 >> VCO1_PULSE_SW) & 1) << VCO1_PULSE |
							((switch_states.byte0 >> VCO2_SAW_SW) & 1) << VCO2_SAW |
							((switch_states.byte0 >> VCO2_TRI_SW) & 1) << VCO2_TRI |
    1fdc:	69 2f       	mov	r22, r25
    1fde:	62 95       	swap	r22
    1fe0:	66 95       	lsr	r22
    1fe2:	67 70       	andi	r22, 0x07	; 7
    1fe4:	70 e0       	ldi	r23, 0x00	; 0
    1fe6:	61 70       	andi	r22, 0x01	; 1
    1fe8:	70 70       	andi	r23, 0x00	; 0
    1fea:	ab 01       	movw	r20, r22
    1fec:	44 0f       	add	r20, r20
    1fee:	55 1f       	adc	r21, r21
    1ff0:	42 95       	swap	r20
    1ff2:	52 95       	swap	r21
    1ff4:	50 7f       	andi	r21, 0xF0	; 240
    1ff6:	54 27       	eor	r21, r20
    1ff8:	40 7f       	andi	r20, 0xF0	; 240
    1ffa:	54 27       	eor	r21, r20
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    1ffc:	6e 2f       	mov	r22, r30
    1ffe:	64 2b       	or	r22, r20
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
							((switch_states.byte0 >> VCO1_PULSE_SW) & 1) << VCO1_PULSE |
							((switch_states.byte0 >> VCO2_SAW_SW) & 1) << VCO2_SAW |
							((switch_states.byte0 >> VCO2_TRI_SW) & 1) << VCO2_TRI |
							((switch_states.byte0 >> VCO2_PULSE_SW) & 1) << VCO2_PULSE |
    2000:	49 2f       	mov	r20, r25
    2002:	42 95       	swap	r20
    2004:	46 95       	lsr	r20
    2006:	46 95       	lsr	r20
    2008:	43 70       	andi	r20, 0x03	; 3
    200a:	50 e0       	ldi	r21, 0x00	; 0
    200c:	41 70       	andi	r20, 0x01	; 1
    200e:	50 70       	andi	r21, 0x00	; 0
    2010:	9a 01       	movw	r18, r20
    2012:	00 24       	eor	r0, r0
    2014:	36 95       	lsr	r19
    2016:	27 95       	ror	r18
    2018:	07 94       	ror	r0
    201a:	36 95       	lsr	r19
    201c:	27 95       	ror	r18
    201e:	07 94       	ror	r0
    2020:	32 2f       	mov	r19, r18
    2022:	20 2d       	mov	r18, r0
			
	
void update_patch(void) {
	
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    2024:	26 2b       	or	r18, r22
    2026:	20 93 06 03 	sts	0x0306, r18
			
	//update analog switch latch:
	//need to incorporate BMOD_LATCH_BIT switch state into data byte sent to analog switch latch
	//3rd switch bit is VCO1_OCTAVE_UP_SW state, which isn't used by analog switch latch
	uint8_t analog_sw_byte = switch_states.byte0;
	uint8_t BMOD_SW_ON = (switch_states.byte2 >> BMOD_SW) & 1;
    202a:	81 70       	andi	r24, 0x01	; 1
	analog_sw_byte ^= (-BMOD_SW_ON ^ analog_sw_byte) & (1<<3);//set third bit dependent on BMOD switch state
    202c:	81 95       	neg	r24
    202e:	89 27       	eor	r24, r25
    2030:	88 70       	andi	r24, 0x08	; 8
	update_analog_switch_latch(analog_sw_byte);
    2032:	89 27       	eor	r24, r25
    2034:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <update_analog_switch_latch>
					
	//set EG2 INV bit. This changes the nth bit to x from: http://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit-in-c-c
	//need to make sure this doesn't interfere with anything else on this port
	uint8_t EG2_INV_ON = (switch_states.byte2 >> EG2_INV_SW) & 1;	
	EG2_POL_PORT ^= (-EG2_INV_ON ^ EG2_POL_PORT) & (1<<EG2_POL);
    2038:	ed ed       	ldi	r30, 0xDD	; 221
    203a:	f0 e0       	ldi	r31, 0x00	; 0
    203c:	20 81       	ld	r18, Z
	analog_sw_byte ^= (-BMOD_SW_ON ^ analog_sw_byte) & (1<<3);//set third bit dependent on BMOD switch state
	update_analog_switch_latch(analog_sw_byte);
					
	//set EG2 INV bit. This changes the nth bit to x from: http://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit-in-c-c
	//need to make sure this doesn't interfere with anything else on this port
	uint8_t EG2_INV_ON = (switch_states.byte2 >> EG2_INV_SW) & 1;	
    203e:	90 91 84 03 	lds	r25, 0x0384
    2042:	96 95       	lsr	r25
    2044:	96 95       	lsr	r25
    2046:	96 95       	lsr	r25
    2048:	91 70       	andi	r25, 0x01	; 1
	EG2_POL_PORT ^= (-EG2_INV_ON ^ EG2_POL_PORT) & (1<<EG2_POL);
    204a:	91 95       	neg	r25
    204c:	80 81       	ld	r24, Z
    204e:	89 27       	eor	r24, r25
    2050:	80 71       	andi	r24, 0x10	; 16
    2052:	82 27       	eor	r24, r18
    2054:	80 83       	st	Z, r24
	current_patch.byte_1 ^= (-EG2_INV_ON ^ current_patch.byte_1) & (1 << EG2_INV); //don't forget to set it in patch or it won't be saved!
    2056:	e2 e0       	ldi	r30, 0x02	; 2
    2058:	f3 e0       	ldi	r31, 0x03	; 3
    205a:	80 81       	ld	r24, Z
    205c:	98 27       	eor	r25, r24
    205e:	91 70       	andi	r25, 0x01	; 1
    2060:	89 27       	eor	r24, r25
    2062:	80 83       	st	Z, r24
	
	//parse octave switch data
	update_octave_range();
    2064:	0e 94 b3 0d 	call	0x1b66	; 0x1b66 <update_octave_range>
	
	//parse LFO data
	update_lfo_shape();
    2068:	0e 94 3e 0e 	call	0x1c7c	; 0x1c7c <update_lfo_shape>
	
	//parse LFO sync data
	update_lfo_sync();
    206c:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <update_lfo_sync>

	//update arp settings
	update_arp_sync();
    2070:	0e 94 c0 0e 	call	0x1d80	; 0x1d80 <update_arp_sync>
	update_arp_range();
    2074:	0e 94 2a 0f 	call	0x1e54	; 0x1e54 <update_arp_range>
	update_arp_mode();
    2078:	0e 94 65 0f 	call	0x1eca	; 0x1eca <update_arp_mode>
	//update_patch_programmer();		
				

		
	
}
    207c:	08 95       	ret

0000207e <update_patch_programmer>:





void update_patch_programmer(void) { //maybe best to use a switch/case statement here instead of a series of if/elses?
    207e:	cf 93       	push	r28
    2080:	df 93       	push	r29
	
	if (current_patch.mode == CAL) //temporary tune button hack by pressing and holding PROG DOWN switch
    2082:	90 91 0b 03 	lds	r25, 0x030B
    2086:	95 30       	cpi	r25, 0x05	; 5
    2088:	01 f5       	brne	.+64     	; 0x20ca <update_patch_programmer+0x4c>
	{
		
		
		//TURN OFF LFO OUTPUT
		DATA_BUS = 0b00000111; //turn off LFO waveform
    208a:	87 e0       	ldi	r24, 0x07	; 7
    208c:	82 b9       	out	0x02, r24	; 2
		LFO_LATCH_PORT |= (1<<LFO_SW_LATCH);
    208e:	cd ed       	ldi	r28, 0xDD	; 221
    2090:	d0 e0       	ldi	r29, 0x00	; 0
    2092:	88 81       	ld	r24, Y
    2094:	80 62       	ori	r24, 0x20	; 32
    2096:	88 83       	st	Y, r24
		LFO_LATCH_PORT &= ~(1<<LFO_SW_LATCH);
    2098:	88 81       	ld	r24, Y
    209a:	8f 7d       	andi	r24, 0xDF	; 223
    209c:	88 83       	st	Y, r24
		DATA_BUS = 0;
    209e:	12 b8       	out	0x02, r1	; 2
		
		tune();
    20a0:	0e 94 be 16 	call	0x2d7c	; 0x2d7c <tune>
		
		DATA_BUS = LFO_TRI_ADDR;
    20a4:	12 b8       	out	0x02, r1	; 2
		LFO_LATCH_PORT |= (1<<LFO_SW_LATCH);
    20a6:	88 81       	ld	r24, Y
    20a8:	80 62       	ori	r24, 0x20	; 32
    20aa:	88 83       	st	Y, r24
		LFO_LATCH_PORT &= ~(1<<LFO_SW_LATCH);
    20ac:	88 81       	ld	r24, Y
    20ae:	8f 7d       	andi	r24, 0xDF	; 223
    20b0:	88 83       	st	Y, r24
		DATA_BUS = 0;
    20b2:	12 b8       	out	0x02, r1	; 2
		current_patch.byte_2 &= 0b00001111; //clear top 4 bits
    20b4:	80 91 03 03 	lds	r24, 0x0303
    20b8:	8f 70       	andi	r24, 0x0F	; 15
		current_patch.byte_2 |= (1<<LFO_TRI);
    20ba:	80 68       	ori	r24, 0x80	; 128
    20bc:	80 93 03 03 	sts	0x0303, r24
		
		setup_system_clock(); //restore system clock settings
    20c0:	0e 94 ec 01 	call	0x3d8	; 0x3d8 <setup_system_clock>

		current_patch.mode = MEMORY;
    20c4:	10 92 0b 03 	sts	0x030B, r1
		
		return;
    20c8:	63 c0       	rjmp	.+198    	; 0x2190 <update_patch_programmer+0x112>
		
	}
	

	
	if ((switch_states.byte2>> PROG_UP_SW) & 1) {
    20ca:	80 91 84 03 	lds	r24, 0x0384
    20ce:	28 2f       	mov	r18, r24
    20d0:	22 95       	swap	r18
    20d2:	26 95       	lsr	r18
    20d4:	26 95       	lsr	r18
    20d6:	23 70       	andi	r18, 0x03	; 3
    20d8:	20 ff       	sbrs	r18, 0
    20da:	15 c0       	rjmp	.+42     	; 0x2106 <update_patch_programmer+0x88>
		
		switch_states.byte2 ^= (1<<PROG_UP_SW); //toggle switch state bit
    20dc:	20 e4       	ldi	r18, 0x40	; 64
    20de:	82 27       	eor	r24, r18
    20e0:	80 93 84 03 	sts	0x0384, r24
		
		if (++current_patch.number == NUM_PATCHES + 1) {			
    20e4:	80 91 07 03 	lds	r24, 0x0307
    20e8:	8f 5f       	subi	r24, 0xFF	; 255
    20ea:	80 93 07 03 	sts	0x0307, r24
    20ee:	85 32       	cpi	r24, 0x25	; 37
    20f0:	21 f4       	brne	.+8      	; 0x20fa <update_patch_programmer+0x7c>
			
			current_patch.number = NUM_PATCHES; //max patch number
    20f2:	84 e2       	ldi	r24, 0x24	; 36
    20f4:	80 93 07 03 	sts	0x0307, r24
    20f8:	06 c0       	rjmp	.+12     	; 0x2106 <update_patch_programmer+0x88>
		
					
		} else if (current_patch.mode != WRITE) { //load next patch if not in WRITE mode
    20fa:	93 30       	cpi	r25, 0x03	; 3
    20fc:	21 f0       	breq	.+8      	; 0x2106 <update_patch_programmer+0x88>
			
			load_patch(current_patch.number);
    20fe:	0e 94 c3 0a 	call	0x1586	; 0x1586 <load_patch>
			update_patch();
    2102:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <update_patch>
			
		}		
		
	}
	
	if ((switch_states.byte2 >> PROG_DOWN_SW) & 1) {
    2106:	80 91 84 03 	lds	r24, 0x0384
    210a:	98 2f       	mov	r25, r24
    210c:	92 95       	swap	r25
    210e:	96 95       	lsr	r25
    2110:	97 70       	andi	r25, 0x07	; 7
    2112:	90 ff       	sbrs	r25, 0
    2114:	15 c0       	rjmp	.+42     	; 0x2140 <update_patch_programmer+0xc2>
	
		switch_states.byte2 ^= (1<<PROG_DOWN_SW); //toggle switch state bit
    2116:	90 e2       	ldi	r25, 0x20	; 32
    2118:	89 27       	eor	r24, r25
    211a:	80 93 84 03 	sts	0x0384, r24

		if (current_patch.number == 1) {} else {current_patch.number--;}
    211e:	80 91 07 03 	lds	r24, 0x0307
    2122:	81 30       	cpi	r24, 0x01	; 1
    2124:	19 f0       	breq	.+6      	; 0x212c <update_patch_programmer+0xae>
    2126:	81 50       	subi	r24, 0x01	; 1
    2128:	80 93 07 03 	sts	0x0307, r24
		
		if (current_patch.mode != WRITE) {
    212c:	80 91 0b 03 	lds	r24, 0x030B
    2130:	83 30       	cpi	r24, 0x03	; 3
    2132:	31 f0       	breq	.+12     	; 0x2140 <update_patch_programmer+0xc2>
			
			load_patch(current_patch.number); 
    2134:	80 91 07 03 	lds	r24, 0x0307
    2138:	0e 94 c3 0a 	call	0x1586	; 0x1586 <load_patch>
			update_patch();
    213c:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <update_patch>
		}			
	}
	
	
	if ((switch_states.byte2 >> PROG_WRITE_SW) & 1) {
    2140:	80 91 84 03 	lds	r24, 0x0384
    2144:	98 2f       	mov	r25, r24
    2146:	92 95       	swap	r25
    2148:	9f 70       	andi	r25, 0x0F	; 15
    214a:	90 ff       	sbrs	r25, 0
    214c:	15 c0       	rjmp	.+42     	; 0x2178 <update_patch_programmer+0xfa>
		
		switch_states.byte2 ^= (1<<PROG_WRITE_SW);
    214e:	90 e1       	ldi	r25, 0x10	; 16
    2150:	89 27       	eor	r24, r25
    2152:	80 93 84 03 	sts	0x0384, r24
		if (current_patch.mode != WRITE) {
    2156:	90 91 0b 03 	lds	r25, 0x030B
    215a:	93 30       	cpi	r25, 0x03	; 3
    215c:	49 f0       	breq	.+18     	; 0x2170 <update_patch_programmer+0xf2>
			switch_states.byte2 &= ~(1<< PROG_MANUAL_SW); //turn off manual mode
    215e:	8f 77       	andi	r24, 0x7F	; 127
    2160:	80 93 84 03 	sts	0x0384, r24
			current_patch.mode = WRITE;
    2164:	83 e0       	ldi	r24, 0x03	; 3
    2166:	80 93 0b 03 	sts	0x030B, r24
			lock_pots();
    216a:	0e 94 a5 08 	call	0x114a	; 0x114a <lock_pots>
    216e:	04 c0       	rjmp	.+8      	; 0x2178 <update_patch_programmer+0xfa>
			
			
		} else {
			
			save_patch(current_patch.number); //write the patch
    2170:	80 91 07 03 	lds	r24, 0x0307
    2174:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <save_patch>
		//save_patch(current_patch.number);
		
		
	}
	
	if (((switch_states.byte2 >> PROG_MANUAL_SW) & 1)) {
    2178:	80 91 84 03 	lds	r24, 0x0384
    217c:	88 23       	and	r24, r24
    217e:	44 f4       	brge	.+16     	; 0x2190 <update_patch_programmer+0x112>
			
		switch_states.byte2 |= (1<< PROG_MANUAL_SW);
    2180:	80 68       	ori	r24, 0x80	; 128
    2182:	80 93 84 03 	sts	0x0384, r24
		current_patch.mode = MANUAL;
    2186:	81 e0       	ldi	r24, 0x01	; 1
    2188:	80 93 0b 03 	sts	0x030B, r24
		unlock_pots();
    218c:	0e 94 bf 08 	call	0x117e	; 0x117e <unlock_pots>
	}
	//value_to_display = current_patch.number;	
	//value_to_display = vco1_init_cv>>1;
	
	
}	
    2190:	df 91       	pop	r29
    2192:	cf 91       	pop	r28
    2194:	08 95       	ret

00002196 <initialize_voice_for_tuning>:
	

void initialize_voice_for_tuning(void) { //this function sets all CVs required for oscillator tuning
	

	set_control_voltage(&volume_cv, MIN); //turn volume all the way down
    2196:	88 ed       	ldi	r24, 0xD8	; 216
    2198:	91 e0       	ldi	r25, 0x01	; 1
    219a:	60 e0       	ldi	r22, 0x00	; 0
    219c:	70 e0       	ldi	r23, 0x00	; 0
    219e:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off all pitch modulation
	set_control_voltage(&pitch_lfo_cv, MIN);
    21a2:	81 ee       	ldi	r24, 0xE1	; 225
    21a4:	91 e0       	ldi	r25, 0x01	; 1
    21a6:	60 e0       	ldi	r22, 0x00	; 0
    21a8:	70 e0       	ldi	r23, 0x00	; 0
    21aa:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pitch_eg2_cv, MIN);
    21ae:	82 ee       	ldi	r24, 0xE2	; 226
    21b0:	91 e0       	ldi	r25, 0x01	; 1
    21b2:	60 e0       	ldi	r22, 0x00	; 0
    21b4:	70 e0       	ldi	r23, 0x00	; 0
    21b6:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pitch_vco2_cv, MIN);
    21ba:	87 eb       	ldi	r24, 0xB7	; 183
    21bc:	92 e0       	ldi	r25, 0x02	; 2
    21be:	60 e0       	ldi	r22, 0x00	; 0
    21c0:	70 e0       	ldi	r23, 0x00	; 0
    21c2:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off glide
	set_control_voltage(&glide_cv, MIN);
    21c6:	8a ed       	ldi	r24, 0xDA	; 218
    21c8:	91 e0       	ldi	r25, 0x01	; 1
    21ca:	60 e0       	ldi	r22, 0x00	; 0
    21cc:	70 e0       	ldi	r23, 0x00	; 0
    21ce:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off all pulse width modulation
	set_control_voltage(&pwm_eg2_cv, MIN);
    21d2:	8f ed       	ldi	r24, 0xDF	; 223
    21d4:	91 e0       	ldi	r25, 0x01	; 1
    21d6:	60 e0       	ldi	r22, 0x00	; 0
    21d8:	70 e0       	ldi	r23, 0x00	; 0
    21da:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pwm_lfo_cv, MIN);
    21de:	80 ee       	ldi	r24, 0xE0	; 224
    21e0:	91 e0       	ldi	r25, 0x01	; 1
    21e2:	60 e0       	ldi	r22, 0x00	; 0
    21e4:	70 e0       	ldi	r23, 0x00	; 0
    21e6:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off all filter modulation
	set_control_voltage(&fil_lfo_cv, MIN);
    21ea:	81 ed       	ldi	r24, 0xD1	; 209
    21ec:	91 e0       	ldi	r25, 0x01	; 1
    21ee:	60 e0       	ldi	r22, 0x00	; 0
    21f0:	70 e0       	ldi	r23, 0x00	; 0
    21f2:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&fil_eg2_cv, MIN);
    21f6:	86 ed       	ldi	r24, 0xD6	; 214
    21f8:	91 e0       	ldi	r25, 0x01	; 1
    21fa:	60 e0       	ldi	r22, 0x00	; 0
    21fc:	70 e0       	ldi	r23, 0x00	; 0
    21fe:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&fil_vco2_cv, MIN);
    2202:	82 ed       	ldi	r24, 0xD2	; 210
    2204:	91 e0       	ldi	r25, 0x01	; 1
    2206:	60 e0       	ldi	r22, 0x00	; 0
    2208:	70 e0       	ldi	r23, 0x00	; 0
    220a:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&key_track_cv, MIN);
    220e:	83 ed       	ldi	r24, 0xD3	; 211
    2210:	91 e0       	ldi	r25, 0x01	; 1
    2212:	60 e0       	ldi	r22, 0x00	; 0
    2214:	70 e0       	ldi	r23, 0x00	; 0
    2216:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//open filter with no resonance
	set_control_voltage(&cutoff_cv, MAX);
    221a:	84 ed       	ldi	r24, 0xD4	; 212
    221c:	91 e0       	ldi	r25, 0x01	; 1
    221e:	6f ef       	ldi	r22, 0xFF	; 255
    2220:	7f e3       	ldi	r23, 0x3F	; 63
    2222:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&res_cv, MIN);
    2226:	85 ed       	ldi	r24, 0xD5	; 213
    2228:	91 e0       	ldi	r25, 0x01	; 1
    222a:	60 e0       	ldi	r22, 0x00	; 0
    222c:	70 e0       	ldi	r23, 0x00	; 0
    222e:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off VCA LFO modulation
	set_control_voltage(&amp_lfo_cv, MIN);
    2232:	89 ed       	ldi	r24, 0xD9	; 217
    2234:	91 e0       	ldi	r25, 0x01	; 1
    2236:	60 e0       	ldi	r22, 0x00	; 0
    2238:	70 e0       	ldi	r23, 0x00	; 0
    223a:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//initialize VCA envelope
	set_control_voltage(&attack_1_cv, MIN);
    223e:	8e ec       	ldi	r24, 0xCE	; 206
    2240:	91 e0       	ldi	r25, 0x01	; 1
    2242:	60 e0       	ldi	r22, 0x00	; 0
    2244:	70 e0       	ldi	r23, 0x00	; 0
    2246:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&decay_1_cv, MIN);
    224a:	8c ec       	ldi	r24, 0xCC	; 204
    224c:	91 e0       	ldi	r25, 0x01	; 1
    224e:	60 e0       	ldi	r22, 0x00	; 0
    2250:	70 e0       	ldi	r23, 0x00	; 0
    2252:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&sustain_1_cv, MAX);
    2256:	8a ec       	ldi	r24, 0xCA	; 202
    2258:	91 e0       	ldi	r25, 0x01	; 1
    225a:	6f ef       	ldi	r22, 0xFF	; 255
    225c:	7f e3       	ldi	r23, 0x3F	; 63
    225e:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&release_1_cv, MIN);
    2262:	88 ec       	ldi	r24, 0xC8	; 200
    2264:	91 e0       	ldi	r25, 0x01	; 1
    2266:	60 e0       	ldi	r22, 0x00	; 0
    2268:	70 e0       	ldi	r23, 0x00	; 0
    226a:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off noise
	set_control_voltage(&noise_mix_cv, MIN);
    226e:	80 ed       	ldi	r24, 0xD0	; 208
    2270:	91 e0       	ldi	r25, 0x01	; 1
    2272:	60 e0       	ldi	r22, 0x00	; 0
    2274:	70 e0       	ldi	r23, 0x00	; 0
    2276:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&vco1_mix_cv, MIN);
    227a:	83 ee       	ldi	r24, 0xE3	; 227
    227c:	91 e0       	ldi	r25, 0x01	; 1
    227e:	60 e0       	ldi	r22, 0x00	; 0
    2280:	70 e0       	ldi	r23, 0x00	; 0
    2282:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&vco2_mix_cv, MIN);
    2286:	84 ee       	ldi	r24, 0xE4	; 228
    2288:	91 e0       	ldi	r25, 0x01	; 1
    228a:	60 e0       	ldi	r22, 0x00	; 0
    228c:	70 e0       	ldi	r23, 0x00	; 0
    228e:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
}	
    2292:	08 95       	ret

00002294 <set_vco_init_cv>:
	
uint16_t set_vco_init_cv(uint8_t vco, uint16_t base_reference) { 
    2294:	2f 92       	push	r2
    2296:	3f 92       	push	r3
    2298:	4f 92       	push	r4
    229a:	5f 92       	push	r5
    229c:	6f 92       	push	r6
    229e:	7f 92       	push	r7
    22a0:	8f 92       	push	r8
    22a2:	9f 92       	push	r9
    22a4:	af 92       	push	r10
    22a6:	bf 92       	push	r11
    22a8:	cf 92       	push	r12
    22aa:	df 92       	push	r13
    22ac:	ef 92       	push	r14
    22ae:	ff 92       	push	r15
    22b0:	0f 93       	push	r16
    22b2:	1f 93       	push	r17
    22b4:	cf 93       	push	r28
    22b6:	df 93       	push	r29
    22b8:	cd b7       	in	r28, 0x3d	; 61
    22ba:	de b7       	in	r29, 0x3e	; 62
    22bc:	2c 97       	sbiw	r28, 0x0c	; 12
    22be:	0f b6       	in	r0, 0x3f	; 63
    22c0:	f8 94       	cli
    22c2:	de bf       	out	0x3e, r29	; 62
    22c4:	0f be       	out	0x3f, r0	; 63
    22c6:	cd bf       	out	0x3d, r28	; 61
    22c8:	08 2f       	mov	r16, r24
    22ca:	78 87       	std	Y+8, r23	; 0x08
    22cc:	6f 83       	std	Y+7, r22	; 0x07

	uint16_t init_cv = 0;
	timer1_clock |= (1<<CS11) | (1<<CS10);
    22ce:	80 91 7f 03 	lds	r24, 0x037F
    22d2:	83 60       	ori	r24, 0x03	; 3
    22d4:	80 93 7f 03 	sts	0x037F, r24
	 
	//TO DO: disable UART so MIDI data doesn't interrupt tuning
	
	//setup control voltages	
	initialize_voice_for_tuning();
    22d8:	0e 94 cb 10 	call	0x2196	; 0x2196 <initialize_voice_for_tuning>
	struct control_voltage *vco_init_cv;
	struct control_voltage *vco_mix_cv;
	struct control_voltage *vco_pw_cv;
	struct control_voltage *vco_pitch_cv;

	count_finished = FALSE;
    22dc:	10 92 7e 03 	sts	0x037E, r1
	
	if (vco == VCO1) { //turn on VCO1 pulse
    22e0:	0f 30       	cpi	r16, 0x0F	; 15
    22e2:	e1 f4       	brne	.+56     	; 0x231c <set_vco_init_cv+0x88>
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
		vco_mix_cv = &vco1_mix_cv;
		vco_pw_cv = &vco1_pw_cv;
		vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
    22e4:	0f 2e       	mov	r0, r31
    22e6:	f6 ee       	ldi	r31, 0xE6	; 230
    22e8:	4f 2e       	mov	r4, r31
    22ea:	f1 e0       	ldi	r31, 0x01	; 1
    22ec:	5f 2e       	mov	r5, r31
    22ee:	f0 2d       	mov	r31, r0
	if (vco == VCO1) { //turn on VCO1 pulse
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
		vco_mix_cv = &vco1_mix_cv;
		vco_pw_cv = &vco1_pw_cv;
    22f0:	0f 2e       	mov	r0, r31
    22f2:	fe ed       	ldi	r31, 0xDE	; 222
    22f4:	2f 2e       	mov	r2, r31
    22f6:	f1 e0       	ldi	r31, 0x01	; 1
    22f8:	3f 2e       	mov	r3, r31
    22fa:	f0 2d       	mov	r31, r0
	
	if (vco == VCO1) { //turn on VCO1 pulse
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
		vco_mix_cv = &vco1_mix_cv;
    22fc:	23 ee       	ldi	r18, 0xE3	; 227
    22fe:	31 e0       	ldi	r19, 0x01	; 1
    2300:	3a 83       	std	Y+2, r19	; 0x02
    2302:	29 83       	std	Y+1, r18	; 0x01
	count_finished = FALSE;
	
	if (vco == VCO1) { //turn on VCO1 pulse
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
    2304:	0f 2e       	mov	r0, r31
    2306:	fc ed       	ldi	r31, 0xDC	; 220
    2308:	8f 2e       	mov	r8, r31
    230a:	f1 e0       	ldi	r31, 0x01	; 1
    230c:	9f 2e       	mov	r9, r31
    230e:	f0 2d       	mov	r31, r0
		vco_mix_cv = &vco1_mix_cv;
		vco_pw_cv = &vco1_pw_cv;
		vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
		reference_count = base_reference;//38222; //make this an argument passed to function
		eeprom_addr = &vco1_init_cv_eeprom;
    2310:	82 e7       	ldi	r24, 0x72	; 114
    2312:	96 e0       	ldi	r25, 0x06	; 6
    2314:	9a 87       	std	Y+10, r25	; 0x0a
    2316:	89 87       	std	Y+9, r24	; 0x09

	count_finished = FALSE;
	
	if (vco == VCO1) { //turn on VCO1 pulse
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
    2318:	81 e0       	ldi	r24, 0x01	; 1
    231a:	1b c0       	rjmp	.+54     	; 0x2352 <set_vco_init_cv+0xbe>
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
		vco_mix_cv = &vco2_mix_cv;
		vco_pw_cv = &vco2_pw_cv;
		vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
    231c:	0f 2e       	mov	r0, r31
    231e:	f5 ee       	ldi	r31, 0xE5	; 229
    2320:	4f 2e       	mov	r4, r31
    2322:	f1 e0       	ldi	r31, 0x01	; 1
    2324:	5f 2e       	mov	r5, r31
    2326:	f0 2d       	mov	r31, r0
	} else { //turn on VCO2 pulse	
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
		vco_mix_cv = &vco2_mix_cv;
		vco_pw_cv = &vco2_pw_cv;
    2328:	0f 2e       	mov	r0, r31
    232a:	f7 ed       	ldi	r31, 0xD7	; 215
    232c:	2f 2e       	mov	r2, r31
    232e:	f1 e0       	ldi	r31, 0x01	; 1
    2330:	3f 2e       	mov	r3, r31
    2332:	f0 2d       	mov	r31, r0
		
	} else { //turn on VCO2 pulse	
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
		vco_mix_cv = &vco2_mix_cv;
    2334:	e4 ee       	ldi	r30, 0xE4	; 228
    2336:	f1 e0       	ldi	r31, 0x01	; 1
    2338:	fa 83       	std	Y+2, r31	; 0x02
    233a:	e9 83       	std	Y+1, r30	; 0x01
		eeprom_addr = &vco1_init_cv_eeprom;
		
	} else { //turn on VCO2 pulse	
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
    233c:	0f 2e       	mov	r0, r31
    233e:	fd ed       	ldi	r31, 0xDD	; 221
    2340:	8f 2e       	mov	r8, r31
    2342:	f1 e0       	ldi	r31, 0x01	; 1
    2344:	9f 2e       	mov	r9, r31
    2346:	f0 2d       	mov	r31, r0
		vco_mix_cv = &vco2_mix_cv;
		vco_pw_cv = &vco2_pw_cv;
		vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
		reference_count = base_reference;
		eeprom_addr = &vco2_init_cv_eeprom;
    2348:	20 e7       	ldi	r18, 0x70	; 112
    234a:	36 e0       	ldi	r19, 0x06	; 6
    234c:	3a 87       	std	Y+10, r19	; 0x0a
    234e:	29 87       	std	Y+9, r18	; 0x09
		reference_count = base_reference;//38222; //make this an argument passed to function
		eeprom_addr = &vco1_init_cv_eeprom;
		
	} else { //turn on VCO2 pulse	
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
    2350:	80 e4       	ldi	r24, 0x40	; 64
		reference_count = base_reference;
		eeprom_addr = &vco2_init_cv_eeprom;
	}
	
	//latch switch data
	DATA_BUS = switch_byte;
    2352:	82 b9       	out	0x02, r24	; 2
	VCO_SW_LATCH_PORT |= (1<<VCO_SW_LATCH);
    2354:	ed ed       	ldi	r30, 0xDD	; 221
    2356:	f0 e0       	ldi	r31, 0x00	; 0
    2358:	80 81       	ld	r24, Z
    235a:	80 64       	ori	r24, 0x40	; 64
    235c:	80 83       	st	Z, r24
	//_delay_us(1); //why is this delay here????
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    235e:	80 81       	ld	r24, Z
    2360:	8f 7b       	andi	r24, 0xBF	; 191
    2362:	80 83       	st	Z, r24
	DATA_BUS = 0;
    2364:	12 b8       	out	0x02, r1	; 2

	PORTF |= (1<<GATE); //turn gate on
    2366:	89 9a       	sbi	0x11, 1	; 17
	
	//set up timer/counter0 to be clocked by T0 input
	
	TCCR0A |= (1<<CS02) | (1<<CS01) | (1<<CS00) | (1<<WGM01); //clocked by external T0 pin, rising edge + clear timer on compare match
    2368:	84 b5       	in	r24, 0x24	; 36
    236a:	8f 60       	ori	r24, 0x0F	; 15
    236c:	84 bd       	out	0x24, r24	; 36
	OCR0A = 1; //output compare register - set to number of periods to be counted. OCR0A needs to be set to (periods_to_be_counted - 1)
    236e:	81 e0       	ldi	r24, 0x01	; 1
    2370:	87 bd       	out	0x27, r24	; 39
	//set OCR0A to 1 here means first ISR interrupt will occur after 2 periods, it is then set to 0 to count only single periods
	//for reasons I don't understand yet, starting with OCR0A set to 0 results in a multi-second delay before first compare match ISR is called ***ACTUALLY, THIS MAY BE RELATED TO LEAVING Timer0 RUNNING. COULD TRY TO SET OCR0A TO 0 NOW and SEE IF IT WORKS
	TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt	
    2372:	ee e6       	ldi	r30, 0x6E	; 110
    2374:	f0 e0       	ldi	r31, 0x00	; 0
    2376:	90 81       	ld	r25, Z
    2378:	92 60       	ori	r25, 0x02	; 2
    237a:	90 83       	st	Z, r25
	period = 1; //only counting 1 period 
    237c:	80 93 80 03 	sts	0x0380, r24
	for (int dac_bit = 13; dac_bit >= 0; dac_bit--) {
    2380:	8d e0       	ldi	r24, 0x0D	; 13
    2382:	90 e0       	ldi	r25, 0x00	; 0
    2384:	9c 83       	std	Y+4, r25	; 0x04
    2386:	8b 83       	std	Y+3, r24	; 0x03
		//enable watchdog timer
		//WDTCR |= (1<<WDP2) | (1<<WDP1) | (1<<WDP0) | (1<<WDE)| (1<<WDCE);
		wdt_enable(WDTO_2S);
		while (count_finished == FALSE) { //need to have a watchdog timer here to escape while loop if it takes too long
			
			update_display(vco + 1, DEC);
    2388:	80 2f       	mov	r24, r16
    238a:	90 e0       	ldi	r25, 0x00	; 0
    238c:	8c 01       	movw	r16, r24
    238e:	0f 5f       	subi	r16, 0xFF	; 255
    2390:	1f 4f       	sbci	r17, 0xFF	; 255
		
			set_control_voltage(vco_init_cv, init_cv);
			set_control_voltage(vco_pw_cv, MAX);
			set_control_voltage(&volume_cv, MIN);
    2392:	0f 2e       	mov	r0, r31
    2394:	f8 ed       	ldi	r31, 0xD8	; 216
    2396:	ef 2e       	mov	r14, r31
    2398:	f1 e0       	ldi	r31, 0x01	; 1
    239a:	ff 2e       	mov	r15, r31
    239c:	f0 2d       	mov	r31, r0
			set_control_voltage(&cutoff_cv, MAX);
    239e:	0f 2e       	mov	r0, r31
    23a0:	f4 ed       	ldi	r31, 0xD4	; 212
    23a2:	cf 2e       	mov	r12, r31
    23a4:	f1 e0       	ldi	r31, 0x01	; 1
    23a6:	df 2e       	mov	r13, r31
    23a8:	f0 2d       	mov	r31, r0
			set_control_voltage(&sustain_1_cv, MAX);
    23aa:	0f 2e       	mov	r0, r31
    23ac:	fa ec       	ldi	r31, 0xCA	; 202
    23ae:	af 2e       	mov	r10, r31
    23b0:	f1 e0       	ldi	r31, 0x01	; 1
    23b2:	bf 2e       	mov	r11, r31
    23b4:	f0 2d       	mov	r31, r0
			set_control_voltage(&sustain_2_cv, MAX); //can't remember is EG1 for VCA or EG2????
    23b6:	0f 2e       	mov	r0, r31
    23b8:	fb ec       	ldi	r31, 0xCB	; 203
    23ba:	6f 2e       	mov	r6, r31
    23bc:	f1 e0       	ldi	r31, 0x01	; 1
    23be:	7f 2e       	mov	r7, r31
    23c0:	f0 2d       	mov	r31, r0
    23c2:	e0 e0       	ldi	r30, 0x00	; 0
    23c4:	f0 e0       	ldi	r31, 0x00	; 0
    23c6:	fc 87       	std	Y+12, r31	; 0x0c
    23c8:	eb 87       	std	Y+11, r30	; 0x0b
	//for reasons I don't understand yet, starting with OCR0A set to 0 results in a multi-second delay before first compare match ISR is called ***ACTUALLY, THIS MAY BE RELATED TO LEAVING Timer0 RUNNING. COULD TRY TO SET OCR0A TO 0 NOW and SEE IF IT WORKS
	TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt	
	period = 1; //only counting 1 period 
	for (int dac_bit = 13; dac_bit >= 0; dac_bit--) {
	
		init_cv |= (1<<dac_bit);
    23ca:	21 e0       	ldi	r18, 0x01	; 1
    23cc:	30 e0       	ldi	r19, 0x00	; 0
    23ce:	0b 80       	ldd	r0, Y+3	; 0x03
    23d0:	02 c0       	rjmp	.+4      	; 0x23d6 <set_vco_init_cv+0x142>
    23d2:	22 0f       	add	r18, r18
    23d4:	33 1f       	adc	r19, r19
    23d6:	0a 94       	dec	r0
    23d8:	e2 f7       	brpl	.-8      	; 0x23d2 <set_vco_init_cv+0x13e>
    23da:	3e 83       	std	Y+6, r19	; 0x06
    23dc:	2d 83       	std	Y+5, r18	; 0x05
    23de:	8b 85       	ldd	r24, Y+11	; 0x0b
    23e0:	9c 85       	ldd	r25, Y+12	; 0x0c
    23e2:	82 2b       	or	r24, r18
    23e4:	93 2b       	or	r25, r19
    23e6:	9c 87       	std	Y+12, r25	; 0x0c
    23e8:	8b 87       	std	Y+11, r24	; 0x0b
		
		set_control_voltage(vco_init_cv, init_cv);
    23ea:	c4 01       	movw	r24, r8
    23ec:	6b 85       	ldd	r22, Y+11	; 0x0b
    23ee:	7c 85       	ldd	r23, Y+12	; 0x0c
    23f0:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
		
		
		count_finished = FALSE;
    23f4:	10 92 7e 03 	sts	0x037E, r1
		period_counter = 0;
    23f8:	10 92 81 03 	sts	0x0381, r1
		//TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
		//enable watchdog timer
		//WDTCR |= (1<<WDP2) | (1<<WDP1) | (1<<WDP0) | (1<<WDE)| (1<<WDCE);
		wdt_enable(WDTO_2S);
    23fc:	8f e0       	ldi	r24, 0x0F	; 15
    23fe:	e8 e1       	ldi	r30, 0x18	; 24
    2400:	f0 e0       	ldi	r31, 0x00	; 0
    2402:	0f b6       	in	r0, 0x3f	; 63
    2404:	f8 94       	cli
    2406:	a8 95       	wdr
    2408:	e0 93 60 00 	sts	0x0060, r30
    240c:	0f be       	out	0x3f, r0	; 63
    240e:	80 93 60 00 	sts	0x0060, r24
		while (count_finished == FALSE) { //need to have a watchdog timer here to escape while loop if it takes too long
    2412:	80 91 7e 03 	lds	r24, 0x037E
    2416:	88 23       	and	r24, r24
    2418:	89 f5       	brne	.+98     	; 0x247c <set_vco_init_cv+0x1e8>
			
			update_display(vco + 1, DEC);
    241a:	c8 01       	movw	r24, r16
    241c:	60 e0       	ldi	r22, 0x00	; 0
    241e:	0e 94 38 03 	call	0x670	; 0x670 <update_display>
		
			set_control_voltage(vco_init_cv, init_cv);
    2422:	c4 01       	movw	r24, r8
    2424:	6b 85       	ldd	r22, Y+11	; 0x0b
    2426:	7c 85       	ldd	r23, Y+12	; 0x0c
    2428:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
			set_control_voltage(vco_pw_cv, MAX);
    242c:	c1 01       	movw	r24, r2
    242e:	6f ef       	ldi	r22, 0xFF	; 255
    2430:	7f e3       	ldi	r23, 0x3F	; 63
    2432:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
			set_control_voltage(&volume_cv, MIN);
    2436:	c7 01       	movw	r24, r14
    2438:	60 e0       	ldi	r22, 0x00	; 0
    243a:	70 e0       	ldi	r23, 0x00	; 0
    243c:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
			set_control_voltage(&cutoff_cv, MAX);
    2440:	c6 01       	movw	r24, r12
    2442:	6f ef       	ldi	r22, 0xFF	; 255
    2444:	7f e3       	ldi	r23, 0x3F	; 63
    2446:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
			set_control_voltage(&sustain_1_cv, MAX);
    244a:	c5 01       	movw	r24, r10
    244c:	6f ef       	ldi	r22, 0xFF	; 255
    244e:	7f e3       	ldi	r23, 0x3F	; 63
    2450:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
			set_control_voltage(&sustain_2_cv, MAX); //can't remember is EG1 for VCA or EG2????
    2454:	c3 01       	movw	r24, r6
    2456:	6f ef       	ldi	r22, 0xFF	; 255
    2458:	7f e3       	ldi	r23, 0x3F	; 63
    245a:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
			set_control_voltage(vco_mix_cv, MAX);
    245e:	89 81       	ldd	r24, Y+1	; 0x01
    2460:	9a 81       	ldd	r25, Y+2	; 0x02
    2462:	6f ef       	ldi	r22, 0xFF	; 255
    2464:	7f e3       	ldi	r23, 0x3F	; 63
    2466:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
			set_control_voltage(vco_pitch_cv, 0);	
    246a:	c2 01       	movw	r24, r4
    246c:	60 e0       	ldi	r22, 0x00	; 0
    246e:	70 e0       	ldi	r23, 0x00	; 0
    2470:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
		period_counter = 0;
		//TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
		//enable watchdog timer
		//WDTCR |= (1<<WDP2) | (1<<WDP1) | (1<<WDP0) | (1<<WDE)| (1<<WDCE);
		wdt_enable(WDTO_2S);
		while (count_finished == FALSE) { //need to have a watchdog timer here to escape while loop if it takes too long
    2474:	80 91 7e 03 	lds	r24, 0x037E
    2478:	88 23       	and	r24, r24
    247a:	79 f2       	breq	.-98     	; 0x241a <set_vco_init_cv+0x186>
			
		}
		//turn off watchdog timer
		//WDTCR |= (1<<WDCE) | (1<<WDE);
		//WDTCR = 0x00;
		wdt_disable();
    247c:	88 e1       	ldi	r24, 0x18	; 24
    247e:	0f b6       	in	r0, 0x3f	; 63
    2480:	f8 94       	cli
    2482:	80 93 60 00 	sts	0x0060, r24
    2486:	10 92 60 00 	sts	0x0060, r1
    248a:	0f be       	out	0x3f, r0	; 63
		//remember that as INIT_CV goes up, pitch goes down, so looking for osc_count >= reference_count instead of <= as is the case for normal oscillator tuning
		//similarily, OR no_overflow == FALSE *not* AND no_overflow == FALSE to clear bits that make initial pitch too low
		if ((osc_count > reference_count)  || (no_overflow == FALSE)) init_cv &= ~(1 << dac_bit);
    248c:	80 91 7c 03 	lds	r24, 0x037C
    2490:	90 91 7d 03 	lds	r25, 0x037D
    2494:	ef 81       	ldd	r30, Y+7	; 0x07
    2496:	f8 85       	ldd	r31, Y+8	; 0x08
    2498:	e8 17       	cp	r30, r24
    249a:	f9 07       	cpc	r31, r25
    249c:	20 f0       	brcs	.+8      	; 0x24a6 <set_vco_init_cv+0x212>
    249e:	80 91 af 02 	lds	r24, 0x02AF
    24a2:	88 23       	and	r24, r24
    24a4:	51 f4       	brne	.+20     	; 0x24ba <set_vco_init_cv+0x226>
    24a6:	8d 81       	ldd	r24, Y+5	; 0x05
    24a8:	9e 81       	ldd	r25, Y+6	; 0x06
    24aa:	80 95       	com	r24
    24ac:	90 95       	com	r25
    24ae:	2b 85       	ldd	r18, Y+11	; 0x0b
    24b0:	3c 85       	ldd	r19, Y+12	; 0x0c
    24b2:	28 23       	and	r18, r24
    24b4:	39 23       	and	r19, r25
    24b6:	3c 87       	std	Y+12, r19	; 0x0c
    24b8:	2b 87       	std	Y+11, r18	; 0x0b
		no_overflow = TRUE;
    24ba:	81 e0       	ldi	r24, 0x01	; 1
    24bc:	80 93 af 02 	sts	0x02AF, r24
	OCR0A = 1; //output compare register - set to number of periods to be counted. OCR0A needs to be set to (periods_to_be_counted - 1)
	//set OCR0A to 1 here means first ISR interrupt will occur after 2 periods, it is then set to 0 to count only single periods
	//for reasons I don't understand yet, starting with OCR0A set to 0 results in a multi-second delay before first compare match ISR is called ***ACTUALLY, THIS MAY BE RELATED TO LEAVING Timer0 RUNNING. COULD TRY TO SET OCR0A TO 0 NOW and SEE IF IT WORKS
	TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt	
	period = 1; //only counting 1 period 
	for (int dac_bit = 13; dac_bit >= 0; dac_bit--) {
    24c0:	8b 81       	ldd	r24, Y+3	; 0x03
    24c2:	9c 81       	ldd	r25, Y+4	; 0x04
    24c4:	01 97       	sbiw	r24, 0x01	; 1
    24c6:	9c 83       	std	Y+4, r25	; 0x04
    24c8:	8b 83       	std	Y+3, r24	; 0x03
    24ca:	ef ef       	ldi	r30, 0xFF	; 255
    24cc:	8f 3f       	cpi	r24, 0xFF	; 255
    24ce:	9e 07       	cpc	r25, r30
    24d0:	09 f0       	breq	.+2      	; 0x24d4 <set_vco_init_cv+0x240>
    24d2:	7b cf       	rjmp	.-266    	; 0x23ca <set_vco_init_cv+0x136>
    24d4:	2b 85       	ldd	r18, Y+11	; 0x0b
    24d6:	3c 85       	ldd	r19, Y+12	; 0x0c
    24d8:	3e 83       	std	Y+6, r19	; 0x06
    24da:	2d 83       	std	Y+5, r18	; 0x05
		no_overflow = TRUE;
		
	}		
	
	//none of these help with clicking when returning from this function and starting to read pots	
	set_control_voltage(&release_1_cv, MIN); //this will hopefully reduce popping after returning from initializing pitch CV
    24dc:	88 ec       	ldi	r24, 0xC8	; 200
    24de:	91 e0       	ldi	r25, 0x01	; 1
    24e0:	60 e0       	ldi	r22, 0x00	; 0
    24e2:	70 e0       	ldi	r23, 0x00	; 0
    24e4:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&release_2_cv, MIN);
    24e8:	89 ec       	ldi	r24, 0xC9	; 201
    24ea:	91 e0       	ldi	r25, 0x01	; 1
    24ec:	60 e0       	ldi	r22, 0x00	; 0
    24ee:	70 e0       	ldi	r23, 0x00	; 0
    24f0:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&cutoff_cv, MIN);
    24f4:	84 ed       	ldi	r24, 0xD4	; 212
    24f6:	91 e0       	ldi	r25, 0x01	; 1
    24f8:	60 e0       	ldi	r22, 0x00	; 0
    24fa:	70 e0       	ldi	r23, 0x00	; 0
    24fc:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&volume_cv, MIN);
    2500:	88 ed       	ldi	r24, 0xD8	; 216
    2502:	91 e0       	ldi	r25, 0x01	; 1
    2504:	60 e0       	ldi	r22, 0x00	; 0
    2506:	70 e0       	ldi	r23, 0x00	; 0
    2508:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
		
	PORTF &= ~(1<<GATE); //turn gate off
    250c:	89 98       	cbi	0x11, 1	; 17
	
	TIMSK0 &= ~(1<<OCIE0A); //turn off compare match A interrupt
    250e:	ee e6       	ldi	r30, 0x6E	; 110
    2510:	f0 e0       	ldi	r31, 0x00	; 0
    2512:	80 81       	ld	r24, Z
    2514:	8d 7f       	andi	r24, 0xFD	; 253
    2516:	80 83       	st	Z, r24
	TCCR0A = 0; //turn off timer0 period timer
    2518:	14 bc       	out	0x24, r1	; 36
	//} else {
		//
		//eeprom_update_word(&vco2_init_cv_eeprom, init_cv);
	//}				
		
	eeprom_update_word(eeprom_addr, init_cv);
    251a:	89 85       	ldd	r24, Y+9	; 0x09
    251c:	9a 85       	ldd	r25, Y+10	; 0x0a
    251e:	6d 81       	ldd	r22, Y+5	; 0x05
    2520:	7e 81       	ldd	r23, Y+6	; 0x06
    2522:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <__eeupd_word_m6450a>
	//value_to_display = eeprom_read_word(&vco1_init_cv_eeprom);	

	
	return init_cv;
	
}
    2526:	8d 81       	ldd	r24, Y+5	; 0x05
    2528:	9e 81       	ldd	r25, Y+6	; 0x06
    252a:	2c 96       	adiw	r28, 0x0c	; 12
    252c:	0f b6       	in	r0, 0x3f	; 63
    252e:	f8 94       	cli
    2530:	de bf       	out	0x3e, r29	; 62
    2532:	0f be       	out	0x3f, r0	; 63
    2534:	cd bf       	out	0x3d, r28	; 61
    2536:	df 91       	pop	r29
    2538:	cf 91       	pop	r28
    253a:	1f 91       	pop	r17
    253c:	0f 91       	pop	r16
    253e:	ff 90       	pop	r15
    2540:	ef 90       	pop	r14
    2542:	df 90       	pop	r13
    2544:	cf 90       	pop	r12
    2546:	bf 90       	pop	r11
    2548:	af 90       	pop	r10
    254a:	9f 90       	pop	r9
    254c:	8f 90       	pop	r8
    254e:	7f 90       	pop	r7
    2550:	6f 90       	pop	r6
    2552:	5f 90       	pop	r5
    2554:	4f 90       	pop	r4
    2556:	3f 90       	pop	r3
    2558:	2f 90       	pop	r2
    255a:	08 95       	ret

0000255c <tune_8ths>:



void tune_8ths(uint8_t vco) {
    255c:	2f 92       	push	r2
    255e:	3f 92       	push	r3
    2560:	4f 92       	push	r4
    2562:	5f 92       	push	r5
    2564:	6f 92       	push	r6
    2566:	7f 92       	push	r7
    2568:	8f 92       	push	r8
    256a:	9f 92       	push	r9
    256c:	af 92       	push	r10
    256e:	bf 92       	push	r11
    2570:	cf 92       	push	r12
    2572:	df 92       	push	r13
    2574:	ef 92       	push	r14
    2576:	ff 92       	push	r15
    2578:	0f 93       	push	r16
    257a:	1f 93       	push	r17
    257c:	cf 93       	push	r28
    257e:	df 93       	push	r29
    2580:	cd b7       	in	r28, 0x3d	; 61
    2582:	de b7       	in	r29, 0x3e	; 62
    2584:	c0 54       	subi	r28, 0x40	; 64
    2586:	d0 40       	sbci	r29, 0x00	; 0
    2588:	0f b6       	in	r0, 0x3f	; 63
    258a:	f8 94       	cli
    258c:	de bf       	out	0x3e, r29	; 62
    258e:	0f be       	out	0x3f, r0	; 63
    2590:	cd bf       	out	0x3d, r28	; 61
    2592:	08 2f       	mov	r16, r24
		uint8_t period;
		uint16_t count;
	
		};

	struct pitch_reference reference[16] = 
    2594:	de 01       	movw	r26, r28
    2596:	11 96       	adiw	r26, 0x01	; 1
    2598:	e0 e3       	ldi	r30, 0x30	; 48
    259a:	f2 e0       	ldi	r31, 0x02	; 2
    259c:	80 e3       	ldi	r24, 0x30	; 48
    259e:	01 90       	ld	r0, Z+
    25a0:	0d 92       	st	X+, r0
    25a2:	81 50       	subi	r24, 0x01	; 1
    25a4:	e1 f7       	brne	.-8      	; 0x259e <tune_8ths+0x42>
	
		//to do:
		//disable UART so MIDI data doesn't interrupt tuning
	
		//setup control voltages	
		initialize_voice_for_tuning();
    25a6:	0e 94 cb 10 	call	0x2196	; 0x2196 <initialize_voice_for_tuning>
		struct control_voltage *vco_init_cv;
		struct control_voltage *vco_mix_cv;
		struct control_voltage *vco_pw_cv;
		struct control_voltage *vco_pitch_cv;	

		if (vco == VCO1) { //set up parameters for VCO1 tuning
    25aa:	0f 30       	cpi	r16, 0x0F	; 15
    25ac:	11 f5       	brne	.+68     	; 0x25f2 <tune_8ths+0x96>
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
			vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 1; //allows second digit to display VCO being tuned
			init_cv = vco1_init_cv;
    25ae:	40 90 79 03 	lds	r4, 0x0379
    25b2:	50 90 7a 03 	lds	r5, 0x037A
			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
			vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
    25b6:	0f 2e       	mov	r0, r31
    25b8:	f6 ee       	ldi	r31, 0xE6	; 230
    25ba:	8f 2e       	mov	r8, r31
    25bc:	f1 e0       	ldi	r31, 0x01	; 1
    25be:	9f 2e       	mov	r9, r31
    25c0:	f0 2d       	mov	r31, r0

			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
    25c2:	0f 2e       	mov	r0, r31
    25c4:	fe ed       	ldi	r31, 0xDE	; 222
    25c6:	2f 2e       	mov	r2, r31
    25c8:	f1 e0       	ldi	r31, 0x01	; 1
    25ca:	3f 2e       	mov	r3, r31
    25cc:	f0 2d       	mov	r31, r0
		if (vco == VCO1) { //set up parameters for VCO1 tuning

			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
    25ce:	23 ee       	ldi	r18, 0xE3	; 227
    25d0:	31 e0       	ldi	r19, 0x01	; 1
    25d2:	3a ab       	sts	0x5a, r19
    25d4:	29 ab       	sts	0x59, r18

		if (vco == VCO1) { //set up parameters for VCO1 tuning

			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
    25d6:	0f 2e       	mov	r0, r31
    25d8:	fc ed       	ldi	r31, 0xDC	; 220
    25da:	6f 2e       	mov	r6, r31
    25dc:	f1 e0       	ldi	r31, 0x01	; 1
    25de:	7f 2e       	mov	r7, r31
    25e0:	f0 2d       	mov	r31, r0
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
			vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 1; //allows second digit to display VCO being tuned
			init_cv = vco1_init_cv;
			vco_pitch_table = vco1_pitch_table;
    25e2:	05 e5       	ldi	r16, 0x55	; 85
    25e4:	13 e0       	ldi	r17, 0x03	; 3
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
			vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 1; //allows second digit to display VCO being tuned
    25e6:	cc 24       	eor	r12, r12
    25e8:	c3 94       	inc	r12
		struct control_voltage *vco_pitch_cv;	

		if (vco == VCO1) { //set up parameters for VCO1 tuning

			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
    25ea:	ee 24       	eor	r14, r14
    25ec:	68 94       	set
    25ee:	e1 f8       	bld	r14, 1
    25f0:	22 c0       	rjmp	.+68     	; 0x2636 <tune_8ths+0xda>
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
			vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 2; //allows second digit to display VCO being tuned
			init_cv = vco2_init_cv;
    25f2:	40 90 77 03 	lds	r4, 0x0377
    25f6:	50 90 78 03 	lds	r5, 0x0378
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
			vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
    25fa:	0f 2e       	mov	r0, r31
    25fc:	f5 ee       	ldi	r31, 0xE5	; 229
    25fe:	8f 2e       	mov	r8, r31
    2600:	f1 e0       	ldi	r31, 0x01	; 1
    2602:	9f 2e       	mov	r9, r31
    2604:	f0 2d       	mov	r31, r0
		
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
    2606:	0f 2e       	mov	r0, r31
    2608:	f7 ed       	ldi	r31, 0xD7	; 215
    260a:	2f 2e       	mov	r2, r31
    260c:	f1 e0       	ldi	r31, 0x01	; 1
    260e:	3f 2e       	mov	r3, r31
    2610:	f0 2d       	mov	r31, r0
		} else { //set up parameters for VCO2 tuning
		
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
    2612:	44 ee       	ldi	r20, 0xE4	; 228
    2614:	51 e0       	ldi	r21, 0x01	; 1
    2616:	5a ab       	sts	0x5a, r21
    2618:	49 ab       	sts	0x59, r20
		
		} else { //set up parameters for VCO2 tuning
		
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
    261a:	0f 2e       	mov	r0, r31
    261c:	fd ed       	ldi	r31, 0xDD	; 221
    261e:	6f 2e       	mov	r6, r31
    2620:	f1 e0       	ldi	r31, 0x01	; 1
    2622:	7f 2e       	mov	r7, r31
    2624:	f0 2d       	mov	r31, r0
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
			vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 2; //allows second digit to display VCO being tuned
			init_cv = vco2_init_cv;
			vco_pitch_table = vco2_pitch_table;
    2626:	03 e3       	ldi	r16, 0x33	; 51
    2628:	13 e0       	ldi	r17, 0x03	; 3
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
			vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 2; //allows second digit to display VCO being tuned
    262a:	cc 24       	eor	r12, r12
    262c:	68 94       	set
    262e:	c1 f8       	bld	r12, 1
		
		
		} else { //set up parameters for VCO2 tuning
		
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
    2630:	ee 24       	eor	r14, r14
    2632:	68 94       	set
    2634:	e5 f8       	bld	r14, 5
		}
	


		//set VCO init offset CV
		set_control_voltage(vco_init_cv, init_cv);
    2636:	c3 01       	movw	r24, r6
    2638:	b2 01       	movw	r22, r4
    263a:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
		
	
		//latch switch data
		DATA_BUS = switch_byte;
    263e:	e2 b8       	out	0x02, r14	; 2
		VCO_SW_LATCH_PORT |= (1<<VCO_SW_LATCH);
    2640:	ed ed       	ldi	r30, 0xDD	; 221
    2642:	f0 e0       	ldi	r31, 0x00	; 0
    2644:	80 81       	ld	r24, Z
    2646:	80 64       	ori	r24, 0x40	; 64
    2648:	80 83       	st	Z, r24
		//_delay_us(1); //why is this delay here????
		VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    264a:	80 81       	ld	r24, Z
    264c:	8f 7b       	andi	r24, 0xBF	; 191
    264e:	80 83       	st	Z, r24
		DATA_BUS = 0;
    2650:	12 b8       	out	0x02, r1	; 2

		PORTF |= (1<<GATE); //turn gate on
    2652:	89 9a       	sbi	0x11, 1	; 17
			
		period = 1; //need to initialize to minimum period number here
    2654:	81 e0       	ldi	r24, 0x01	; 1
    2656:	80 93 80 03 	sts	0x0380, r24
		
		compare_match_counter = 0;	
    265a:	10 92 7b 03 	sts	0x037B, r1
			
				//enable watchdog timer
				wdt_enable(WDTO_2S);
				while (count_finished == FALSE) {
					//update_display(vco_number + period + (compare_match_counter>>4)*100, DEC);
					update_display(vco_number*100 + period, DEC);//
    265e:	8c 2d       	mov	r24, r12
    2660:	90 e0       	ldi	r25, 0x00	; 0
    2662:	24 e6       	ldi	r18, 0x64	; 100
    2664:	30 e0       	ldi	r19, 0x00	; 0
    2666:	82 9f       	mul	r24, r18
    2668:	d0 01       	movw	r26, r0
    266a:	83 9f       	mul	r24, r19
    266c:	b0 0d       	add	r27, r0
    266e:	92 9f       	mul	r25, r18
    2670:	b0 0d       	add	r27, r0
    2672:	11 24       	eor	r1, r1
    2674:	bc ab       	sts	0x5c, r27
    2676:	ab ab       	sts	0x5b, r26
    2678:	fe 01       	movw	r30, r28
    267a:	31 96       	adiw	r30, 0x01	; 1
    267c:	fc af       	sts	0x7c, r31
    267e:	eb af       	sts	0x7b, r30
	
}



void tune_8ths(uint8_t vco) {
    2680:	98 01       	movw	r18, r16
    2682:	2e 5f       	subi	r18, 0xFE	; 254
    2684:	3f 4f       	sbci	r19, 0xFF	; 255
    2686:	21 96       	adiw	r28, 0x01	; 1
    2688:	3f af       	sts	0x7f, r19
    268a:	2e af       	sts	0x7e, r18
    268c:	21 97       	sbiw	r28, 0x01	; 1
		PORTF |= (1<<GATE); //turn gate on
			
		period = 1; //need to initialize to minimum period number here
		
		compare_match_counter = 0;	
		for (int note_number = 0; note_number <= 15; note_number++) 
    268e:	1e ae       	sts	0xbe, r17
    2690:	1d ae       	sts	0xbd, r17
					//not sure what's really necessary here - definitely pitch and init_cv, but what else?
					set_control_voltage(vco_init_cv, init_cv);
					set_control_voltage(vco_pitch_cv, osc_pitch_cv);
					//set_control_voltage(&pitch_lfo_cv, MIN);
					//set_control_voltage(vco_pw_cv, MAX); //not necessary as SAW is being used to clock comparator
					set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
    2692:	0f 2e       	mov	r0, r31
    2694:	f8 ed       	ldi	r31, 0xD8	; 216
    2696:	ef 2e       	mov	r14, r31
    2698:	f1 e0       	ldi	r31, 0x01	; 1
    269a:	ff 2e       	mov	r15, r31
    269c:	f0 2d       	mov	r31, r0
					set_control_voltage(&cutoff_cv, MAX);
    269e:	0f 2e       	mov	r0, r31
    26a0:	f4 ed       	ldi	r31, 0xD4	; 212
    26a2:	cf 2e       	mov	r12, r31
    26a4:	f1 e0       	ldi	r31, 0x01	; 1
    26a6:	df 2e       	mov	r13, r31
    26a8:	f0 2d       	mov	r31, r0
					//set_control_voltage(&res_cv, MIN);
					set_control_voltage(&sustain_1_cv, MAX);
    26aa:	0f 2e       	mov	r0, r31
    26ac:	fa ec       	ldi	r31, 0xCA	; 202
    26ae:	af 2e       	mov	r10, r31
    26b0:	f1 e0       	ldi	r31, 0x01	; 1
    26b2:	bf 2e       	mov	r11, r31
    26b4:	f0 2d       	mov	r31, r0
	
}



void tune_8ths(uint8_t vco) {
    26b6:	eb ad       	sts	0x6b, r30
    26b8:	fc ad       	sts	0x6c, r31
		period = 1; //need to initialize to minimum period number here
		
		compare_match_counter = 0;	
		for (int note_number = 0; note_number <= 15; note_number++) 
			{
			period = reference[note_number].period;
    26ba:	80 81       	ld	r24, Z
    26bc:	80 93 80 03 	sts	0x0380, r24
			//period timer needs to be initialized here and turned off after each note's SAR to prevent glitching caused by leaving timer0 running
			TCCR0A |= (1<<CS02) | (1<<CS01) | (1<<CS00) | (1<<WGM01); //clocked by external T0 pin, rising edge + clear timer on compare match
    26c0:	84 b5       	in	r24, 0x24	; 36
    26c2:	8f 60       	ori	r24, 0x0F	; 15
    26c4:	84 bd       	out	0x24, r24	; 36
			OCR0A = 1; //output compare register - set to number of periods to be counted. OCR0A needs to be set to (periods_to_be_counted - 1) ***COULD PROBABLY CHANGE THIS TO 0 NOW*** - NOPE. NEEDS TO BE 1!!!
    26c6:	81 e0       	ldi	r24, 0x01	; 1
    26c8:	87 bd       	out	0x27, r24	; 39
			//TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
			TCNT0 = 0; //make sure timer/counter0 is actually 0. 
    26ca:	16 bc       	out	0x26, r1	; 38
			
			if (note_number <= 2) {
    26cc:	4d ad       	sts	0x6d, r20
    26ce:	5e ad       	sts	0x6e, r21
    26d0:	43 30       	cpi	r20, 0x03	; 3
    26d2:	51 05       	cpc	r21, r1
    26d4:	24 f4       	brge	.+8      	; 0x26de <tune_8ths+0x182>
	
				//set timer/counter1 to /64 0.3125 MHz
				timer1_clock = (1<<CS11) | (1<<CS10);
    26d6:	83 e0       	ldi	r24, 0x03	; 3
    26d8:	80 93 7f 03 	sts	0x037F, r24
    26dc:	03 c0       	rjmp	.+6      	; 0x26e4 <tune_8ths+0x188>
	
			} else {
	
				//set timer/counter1 to /8 2.5 MHz
				timer1_clock = (1<<CS11);
    26de:	82 e0       	ldi	r24, 0x02	; 2
    26e0:	80 93 7f 03 	sts	0x037F, r24
	
			}
			//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
			uint16_t reference_count = reference[note_number].count;
    26e4:	81 81       	ldd	r24, Z+1	; 0x01
    26e6:	92 81       	ldd	r25, Z+2	; 0x02
    26e8:	9a af       	sts	0x7a, r25
    26ea:	89 af       	sts	0x79, r24
			uint16_t osc_pitch_cv = 0;
			for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
    26ec:	ad e0       	ldi	r26, 0x0D	; 13
    26ee:	b0 e0       	ldi	r27, 0x00	; 0
    26f0:	be ab       	sts	0x5e, r27
    26f2:	ad ab       	sts	0x5d, r26
				timer1_clock = (1<<CS11);
	
			}
			//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
			uint16_t reference_count = reference[note_number].count;
			uint16_t osc_pitch_cv = 0;
    26f4:	00 e0       	ldi	r16, 0x00	; 0
    26f6:	10 e0       	ldi	r17, 0x00	; 0
			for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
				
				osc_pitch_cv |= (1<<dac_bit);
    26f8:	e1 e0       	ldi	r30, 0x01	; 1
    26fa:	f0 e0       	ldi	r31, 0x00	; 0
    26fc:	0d a8       	sts	0x8d, r16
    26fe:	02 c0       	rjmp	.+4      	; 0x2704 <tune_8ths+0x1a8>
    2700:	ee 0f       	add	r30, r30
    2702:	ff 1f       	adc	r31, r31
    2704:	0a 94       	dec	r0
    2706:	e2 f7       	brpl	.-8      	; 0x2700 <tune_8ths+0x1a4>
    2708:	f8 af       	sts	0x78, r31
    270a:	ef ab       	sts	0x5f, r30
    270c:	0e 2b       	or	r16, r30
    270e:	1f 2b       	or	r17, r31
				TIMSK0 &= ~(1<<OCIE0A); //turn off output compare match A interrupt
    2710:	ae e6       	ldi	r26, 0x6E	; 110
    2712:	b0 e0       	ldi	r27, 0x00	; 0
    2714:	8c 91       	ld	r24, X
    2716:	8d 7f       	andi	r24, 0xFD	; 253
    2718:	8c 93       	st	X, r24
				set_control_voltage(vco_pitch_cv, osc_pitch_cv);
    271a:	c4 01       	movw	r24, r8
    271c:	b8 01       	movw	r22, r16
    271e:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2722:	e3 ef       	ldi	r30, 0xF3	; 243
    2724:	f1 e0       	ldi	r31, 0x01	; 1
    2726:	31 97       	sbiw	r30, 0x01	; 1
    2728:	f1 f7       	brne	.-4      	; 0x2726 <tune_8ths+0x1ca>
    272a:	00 c0       	rjmp	.+0      	; 0x272c <tune_8ths+0x1d0>
    272c:	00 00       	nop
				_delay_ms(2); //add delay here to allow pitch to slew to its final value
				TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
    272e:	ae e6       	ldi	r26, 0x6E	; 110
    2730:	b0 e0       	ldi	r27, 0x00	; 0
    2732:	8c 91       	ld	r24, X
    2734:	82 60       	ori	r24, 0x02	; 2
    2736:	8c 93       	st	X, r24
				//TCNT0 = 0;
				
				count_finished = FALSE;
    2738:	10 92 7e 03 	sts	0x037E, r1
				period_counter = 0;
    273c:	10 92 81 03 	sts	0x0381, r1
			
				//enable watchdog timer
				wdt_enable(WDTO_2S);
    2740:	e8 e1       	ldi	r30, 0x18	; 24
    2742:	f0 e0       	ldi	r31, 0x00	; 0
    2744:	2f e0       	ldi	r18, 0x0F	; 15
    2746:	0f b6       	in	r0, 0x3f	; 63
    2748:	f8 94       	cli
    274a:	a8 95       	wdr
    274c:	e0 93 60 00 	sts	0x0060, r30
    2750:	0f be       	out	0x3f, r0	; 63
    2752:	20 93 60 00 	sts	0x0060, r18
				while (count_finished == FALSE) {
    2756:	80 91 7e 03 	lds	r24, 0x037E
    275a:	88 23       	and	r24, r24
    275c:	81 f5       	brne	.+96     	; 0x27be <tune_8ths+0x262>
					//update_display(vco_number + period + (compare_match_counter>>4)*100, DEC);
					update_display(vco_number*100 + period, DEC);//
    275e:	80 91 80 03 	lds	r24, 0x0380
    2762:	4b a9       	sts	0x4b, r20
    2764:	5c a9       	sts	0x4c, r21
    2766:	48 0f       	add	r20, r24
    2768:	51 1d       	adc	r21, r1
    276a:	ca 01       	movw	r24, r20
    276c:	60 e0       	ldi	r22, 0x00	; 0
    276e:	0e 94 38 03 	call	0x670	; 0x670 <update_display>
					//update_display(value_to_display, DEC);	
					//need to have a watchdog timer here to escape while loop if it takes too long
				
					//not sure what's really necessary here - definitely pitch and init_cv, but what else?
					set_control_voltage(vco_init_cv, init_cv);
    2772:	c3 01       	movw	r24, r6
    2774:	b2 01       	movw	r22, r4
    2776:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
					set_control_voltage(vco_pitch_cv, osc_pitch_cv);
    277a:	c4 01       	movw	r24, r8
    277c:	b8 01       	movw	r22, r16
    277e:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
					//set_control_voltage(&pitch_lfo_cv, MIN);
					//set_control_voltage(vco_pw_cv, MAX); //not necessary as SAW is being used to clock comparator
					set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
    2782:	c7 01       	movw	r24, r14
    2784:	60 e0       	ldi	r22, 0x00	; 0
    2786:	70 e0       	ldi	r23, 0x00	; 0
    2788:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
					set_control_voltage(&cutoff_cv, MAX);
    278c:	c6 01       	movw	r24, r12
    278e:	6f ef       	ldi	r22, 0xFF	; 255
    2790:	7f e3       	ldi	r23, 0x3F	; 63
    2792:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
					//set_control_voltage(&res_cv, MIN);
					set_control_voltage(&sustain_1_cv, MAX);
    2796:	c5 01       	movw	r24, r10
    2798:	6f ef       	ldi	r22, 0xFF	; 255
    279a:	7f e3       	ldi	r23, 0x3F	; 63
    279c:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
					//set_control_voltage(&attack_1_cv, MIN); //keep attack at minimum
					set_control_voltage(vco_pw_cv, 8192);
    27a0:	c1 01       	movw	r24, r2
    27a2:	60 e0       	ldi	r22, 0x00	; 0
    27a4:	70 e2       	ldi	r23, 0x20	; 32
    27a6:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
					set_control_voltage(vco_mix_cv, MAX);
    27aa:	89 a9       	sts	0x49, r24
    27ac:	9a a9       	sts	0x4a, r25
    27ae:	6f ef       	ldi	r22, 0xFF	; 255
    27b0:	7f e3       	ldi	r23, 0x3F	; 63
    27b2:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
				count_finished = FALSE;
				period_counter = 0;
			
				//enable watchdog timer
				wdt_enable(WDTO_2S);
				while (count_finished == FALSE) {
    27b6:	80 91 7e 03 	lds	r24, 0x037E
    27ba:	88 23       	and	r24, r24
    27bc:	81 f2       	breq	.-96     	; 0x275e <tune_8ths+0x202>

			
			
				}							
				//turn off watchdog timer
				wdt_disable();
    27be:	58 e1       	ldi	r21, 0x18	; 24
    27c0:	0f b6       	in	r0, 0x3f	; 63
    27c2:	f8 94       	cli
    27c4:	50 93 60 00 	sts	0x0060, r21
    27c8:	10 92 60 00 	sts	0x0060, r1
    27cc:	0f be       	out	0x3f, r0	; 63
				//Omar changed this from <= to < which makes sense. <= was an error because if it's equal you don't want to clear the bit
				if ((osc_count <= reference_count) && (no_overflow == TRUE)) osc_pitch_cv &= ~(1<<dac_bit);
    27ce:	80 91 7c 03 	lds	r24, 0x037C
    27d2:	90 91 7d 03 	lds	r25, 0x037D
    27d6:	a9 ad       	sts	0x69, r26
    27d8:	ba ad       	sts	0x6a, r27
    27da:	a8 17       	cp	r26, r24
    27dc:	b9 07       	cpc	r27, r25
    27de:	50 f0       	brcs	.+20     	; 0x27f4 <tune_8ths+0x298>
    27e0:	80 91 af 02 	lds	r24, 0x02AF
    27e4:	81 30       	cpi	r24, 0x01	; 1
    27e6:	31 f4       	brne	.+12     	; 0x27f4 <tune_8ths+0x298>
    27e8:	8f a9       	sts	0x4f, r24
    27ea:	98 ad       	sts	0x68, r25
    27ec:	80 95       	com	r24
    27ee:	90 95       	com	r25
    27f0:	08 23       	and	r16, r24
    27f2:	19 23       	and	r17, r25
				
				if (osc_count == reference_count && no_overflow == TRUE) {
    27f4:	80 91 7c 03 	lds	r24, 0x037C
    27f8:	90 91 7d 03 	lds	r25, 0x037D
    27fc:	e9 ad       	sts	0x69, r30
    27fe:	fa ad       	sts	0x6a, r31
    2800:	8e 17       	cp	r24, r30
    2802:	9f 07       	cpc	r25, r31
    2804:	21 f4       	brne	.+8      	; 0x280e <tune_8ths+0x2b2>
    2806:	80 91 af 02 	lds	r24, 0x02AF
    280a:	81 30       	cpi	r24, 0x01	; 1
    280c:	71 f0       	breq	.+28     	; 0x282a <tune_8ths+0x2ce>
					break;	//if you hit the reference count then get out of here		
				}				
				no_overflow = TRUE;
    280e:	f1 e0       	ldi	r31, 0x01	; 1
    2810:	f0 93 af 02 	sts	0x02AF, r31
	
			}
			//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
			uint16_t reference_count = reference[note_number].count;
			uint16_t osc_pitch_cv = 0;
			for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
    2814:	2d a9       	sts	0x4d, r18
    2816:	3e a9       	sts	0x4e, r19
    2818:	21 50       	subi	r18, 0x01	; 1
    281a:	30 40       	sbci	r19, 0x00	; 0
    281c:	3e ab       	sts	0x5e, r19
    281e:	2d ab       	sts	0x5d, r18
    2820:	4f ef       	ldi	r20, 0xFF	; 255
    2822:	2f 3f       	cpi	r18, 0xFF	; 255
    2824:	34 07       	cpc	r19, r20
    2826:	09 f0       	breq	.+2      	; 0x282a <tune_8ths+0x2ce>
    2828:	67 cf       	rjmp	.-306    	; 0x26f8 <tune_8ths+0x19c>
			
			
			}
		
			//vco_pitch_table[octave*12 + note_number] = osc_pitch_cv; //store the note control voltage in the pitch table
			*(vco_pitch_table + (note_number+1)) = osc_pitch_cv;		
    282a:	21 96       	adiw	r28, 0x01	; 1
    282c:	ae ad       	sts	0x6e, r26
    282e:	bf ad       	sts	0x6f, r27
    2830:	21 97       	sbiw	r28, 0x01	; 1
    2832:	0d 93       	st	X+, r16
    2834:	1d 93       	st	X+, r17
    2836:	21 96       	adiw	r28, 0x01	; 1
    2838:	bf af       	sts	0x7f, r27
    283a:	ae af       	sts	0x7e, r26
    283c:	21 97       	sbiw	r28, 0x01	; 1
			
			//need to turn timer off here. This seems to have stopped periodic glitching of first note of first VCO tuned.
			TIMSK0 &= ~(1<<OCIE0A); //turn off timer0 compare match A interrupt
    283e:	ee e6       	ldi	r30, 0x6E	; 110
    2840:	f0 e0       	ldi	r31, 0x00	; 0
    2842:	80 81       	ld	r24, Z
    2844:	8d 7f       	andi	r24, 0xFD	; 253
    2846:	80 83       	st	Z, r24
			TCCR0A = 0; //turn off timer0
    2848:	14 bc       	out	0x24, r1	; 36
		PORTF |= (1<<GATE); //turn gate on
			
		period = 1; //need to initialize to minimum period number here
		
		compare_match_counter = 0;	
		for (int note_number = 0; note_number <= 15; note_number++) 
    284a:	2d ad       	sts	0x6d, r18
    284c:	3e ad       	sts	0x6e, r19
    284e:	2f 5f       	subi	r18, 0xFF	; 255
    2850:	3f 4f       	sbci	r19, 0xFF	; 255
    2852:	3e af       	sts	0x7e, r19
    2854:	2d af       	sts	0x7d, r18
    2856:	4b ad       	sts	0x6b, r20
    2858:	5c ad       	sts	0x6c, r21
    285a:	4d 5f       	subi	r20, 0xFD	; 253
    285c:	5f 4f       	sbci	r21, 0xFF	; 255
    285e:	5c af       	sts	0x7c, r21
    2860:	4b af       	sts	0x7b, r20
    2862:	20 31       	cpi	r18, 0x10	; 16
    2864:	31 05       	cpc	r19, r1
    2866:	09 f0       	breq	.+2      	; 0x286a <tune_8ths+0x30e>
    2868:	26 cf       	rjmp	.-436    	; 0x26b6 <tune_8ths+0x15a>
		}
	
		
		//eeprom_update_block((const void*)vco_pitch_table, (void*)vco_pitch_table_eeprom, sizeof(vco_pitch_table));
		//vco_pitch_table[0] = 0;
		PORTF &= ~(1<<GATE); //turn gate off
    286a:	89 98       	cbi	0x11, 1	; 17
		
		
	
	
	}
    286c:	c0 5c       	subi	r28, 0xC0	; 192
    286e:	df 4f       	sbci	r29, 0xFF	; 255
    2870:	0f b6       	in	r0, 0x3f	; 63
    2872:	f8 94       	cli
    2874:	de bf       	out	0x3e, r29	; 62
    2876:	0f be       	out	0x3f, r0	; 63
    2878:	cd bf       	out	0x3d, r28	; 61
    287a:	df 91       	pop	r29
    287c:	cf 91       	pop	r28
    287e:	1f 91       	pop	r17
    2880:	0f 91       	pop	r16
    2882:	ff 90       	pop	r15
    2884:	ef 90       	pop	r14
    2886:	df 90       	pop	r13
    2888:	cf 90       	pop	r12
    288a:	bf 90       	pop	r11
    288c:	af 90       	pop	r10
    288e:	9f 90       	pop	r9
    2890:	8f 90       	pop	r8
    2892:	7f 90       	pop	r7
    2894:	6f 90       	pop	r6
    2896:	5f 90       	pop	r5
    2898:	4f 90       	pop	r4
    289a:	3f 90       	pop	r3
    289c:	2f 90       	pop	r2
    289e:	08 95       	ret

000028a0 <tune_filter>:
	
void tune_filter(void) {
    28a0:	2f 92       	push	r2
    28a2:	3f 92       	push	r3
    28a4:	4f 92       	push	r4
    28a6:	5f 92       	push	r5
    28a8:	6f 92       	push	r6
    28aa:	7f 92       	push	r7
    28ac:	8f 92       	push	r8
    28ae:	9f 92       	push	r9
    28b0:	af 92       	push	r10
    28b2:	bf 92       	push	r11
    28b4:	cf 92       	push	r12
    28b6:	df 92       	push	r13
    28b8:	ef 92       	push	r14
    28ba:	ff 92       	push	r15
    28bc:	0f 93       	push	r16
    28be:	1f 93       	push	r17
    28c0:	cf 93       	push	r28
    28c2:	df 93       	push	r29
    28c4:	cd b7       	in	r28, 0x3d	; 61
    28c6:	de b7       	in	r29, 0x3e	; 62
    28c8:	e9 97       	sbiw	r28, 0x39	; 57
    28ca:	0f b6       	in	r0, 0x3f	; 63
    28cc:	f8 94       	cli
    28ce:	de bf       	out	0x3e, r29	; 62
    28d0:	0f be       	out	0x3f, r0	; 63
    28d2:	cd bf       	out	0x3d, r28	; 61
		uint8_t period;
		uint16_t count;
		
	};

	struct pitch_reference reference[15] =
    28d4:	de 01       	movw	r26, r28
    28d6:	11 96       	adiw	r26, 0x01	; 1
    28d8:	e0 e6       	ldi	r30, 0x60	; 96
    28da:	f2 e0       	ldi	r31, 0x02	; 2
    28dc:	8d e2       	ldi	r24, 0x2D	; 45
    28de:	01 90       	ld	r0, Z+
    28e0:	0d 92       	st	X+, r0
    28e2:	81 50       	subi	r24, 0x01	; 1
    28e4:	e1 f7       	brne	.-8      	; 0x28de <tune_filter+0x3e>
		
	};

	
	//initialize CVs for filter tuning
	set_control_voltage(&volume_cv, MIN); //turn volume all the way down
    28e6:	88 ed       	ldi	r24, 0xD8	; 216
    28e8:	91 e0       	ldi	r25, 0x01	; 1
    28ea:	60 e0       	ldi	r22, 0x00	; 0
    28ec:	70 e0       	ldi	r23, 0x00	; 0
    28ee:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off all pitch modulation
	set_control_voltage(&pitch_lfo_cv, MIN);
    28f2:	81 ee       	ldi	r24, 0xE1	; 225
    28f4:	91 e0       	ldi	r25, 0x01	; 1
    28f6:	60 e0       	ldi	r22, 0x00	; 0
    28f8:	70 e0       	ldi	r23, 0x00	; 0
    28fa:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pitch_eg2_cv, MIN);
    28fe:	82 ee       	ldi	r24, 0xE2	; 226
    2900:	91 e0       	ldi	r25, 0x01	; 1
    2902:	60 e0       	ldi	r22, 0x00	; 0
    2904:	70 e0       	ldi	r23, 0x00	; 0
    2906:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pitch_vco2_cv, MIN);
    290a:	87 eb       	ldi	r24, 0xB7	; 183
    290c:	92 e0       	ldi	r25, 0x02	; 2
    290e:	60 e0       	ldi	r22, 0x00	; 0
    2910:	70 e0       	ldi	r23, 0x00	; 0
    2912:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off glide
	set_control_voltage(&glide_cv, MIN);
    2916:	8a ed       	ldi	r24, 0xDA	; 218
    2918:	91 e0       	ldi	r25, 0x01	; 1
    291a:	60 e0       	ldi	r22, 0x00	; 0
    291c:	70 e0       	ldi	r23, 0x00	; 0
    291e:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off all pulse width modulation
	set_control_voltage(&pwm_eg2_cv, MIN);
    2922:	8f ed       	ldi	r24, 0xDF	; 223
    2924:	91 e0       	ldi	r25, 0x01	; 1
    2926:	60 e0       	ldi	r22, 0x00	; 0
    2928:	70 e0       	ldi	r23, 0x00	; 0
    292a:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&pwm_lfo_cv, MIN);
    292e:	80 ee       	ldi	r24, 0xE0	; 224
    2930:	91 e0       	ldi	r25, 0x01	; 1
    2932:	60 e0       	ldi	r22, 0x00	; 0
    2934:	70 e0       	ldi	r23, 0x00	; 0
    2936:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off all filter modulation
	set_control_voltage(&fil_lfo_cv, MIN);
    293a:	81 ed       	ldi	r24, 0xD1	; 209
    293c:	91 e0       	ldi	r25, 0x01	; 1
    293e:	60 e0       	ldi	r22, 0x00	; 0
    2940:	70 e0       	ldi	r23, 0x00	; 0
    2942:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&fil_eg2_cv, MIN);
    2946:	86 ed       	ldi	r24, 0xD6	; 214
    2948:	91 e0       	ldi	r25, 0x01	; 1
    294a:	60 e0       	ldi	r22, 0x00	; 0
    294c:	70 e0       	ldi	r23, 0x00	; 0
    294e:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&fil_vco2_cv, MIN);
    2952:	82 ed       	ldi	r24, 0xD2	; 210
    2954:	91 e0       	ldi	r25, 0x01	; 1
    2956:	60 e0       	ldi	r22, 0x00	; 0
    2958:	70 e0       	ldi	r23, 0x00	; 0
    295a:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&key_track_cv, MIN);
    295e:	83 ed       	ldi	r24, 0xD3	; 211
    2960:	91 e0       	ldi	r25, 0x01	; 1
    2962:	60 e0       	ldi	r22, 0x00	; 0
    2964:	70 e0       	ldi	r23, 0x00	; 0
    2966:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//open filter with max resonance
	set_control_voltage(&cutoff_cv, MAX); //need to start with MAX to get filter oscillating
    296a:	84 ed       	ldi	r24, 0xD4	; 212
    296c:	91 e0       	ldi	r25, 0x01	; 1
    296e:	6f ef       	ldi	r22, 0xFF	; 255
    2970:	7f e3       	ldi	r23, 0x3F	; 63
    2972:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&res_cv, MAX);
    2976:	85 ed       	ldi	r24, 0xD5	; 213
    2978:	91 e0       	ldi	r25, 0x01	; 1
    297a:	6f ef       	ldi	r22, 0xFF	; 255
    297c:	7f e3       	ldi	r23, 0x3F	; 63
    297e:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off VCA LFO modulation
	set_control_voltage(&amp_lfo_cv, MIN);
    2982:	89 ed       	ldi	r24, 0xD9	; 217
    2984:	91 e0       	ldi	r25, 0x01	; 1
    2986:	60 e0       	ldi	r22, 0x00	; 0
    2988:	70 e0       	ldi	r23, 0x00	; 0
    298a:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//initialize VCA envelope
	set_control_voltage(&attack_1_cv, MIN);
    298e:	8e ec       	ldi	r24, 0xCE	; 206
    2990:	91 e0       	ldi	r25, 0x01	; 1
    2992:	60 e0       	ldi	r22, 0x00	; 0
    2994:	70 e0       	ldi	r23, 0x00	; 0
    2996:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&decay_1_cv, MIN);
    299a:	8c ec       	ldi	r24, 0xCC	; 204
    299c:	91 e0       	ldi	r25, 0x01	; 1
    299e:	60 e0       	ldi	r22, 0x00	; 0
    29a0:	70 e0       	ldi	r23, 0x00	; 0
    29a2:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&sustain_1_cv, MAX);
    29a6:	8a ec       	ldi	r24, 0xCA	; 202
    29a8:	91 e0       	ldi	r25, 0x01	; 1
    29aa:	6f ef       	ldi	r22, 0xFF	; 255
    29ac:	7f e3       	ldi	r23, 0x3F	; 63
    29ae:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&release_1_cv, MIN);
    29b2:	88 ec       	ldi	r24, 0xC8	; 200
    29b4:	91 e0       	ldi	r25, 0x01	; 1
    29b6:	60 e0       	ldi	r22, 0x00	; 0
    29b8:	70 e0       	ldi	r23, 0x00	; 0
    29ba:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	//turn off noise, VCO1 and VCO2
	set_control_voltage(&noise_mix_cv, MIN);
    29be:	80 ed       	ldi	r24, 0xD0	; 208
    29c0:	91 e0       	ldi	r25, 0x01	; 1
    29c2:	60 e0       	ldi	r22, 0x00	; 0
    29c4:	70 e0       	ldi	r23, 0x00	; 0
    29c6:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&vco1_mix_cv, MIN);
    29ca:	83 ee       	ldi	r24, 0xE3	; 227
    29cc:	91 e0       	ldi	r25, 0x01	; 1
    29ce:	60 e0       	ldi	r22, 0x00	; 0
    29d0:	70 e0       	ldi	r23, 0x00	; 0
    29d2:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
	set_control_voltage(&vco2_mix_cv, MIN);
    29d6:	84 ee       	ldi	r24, 0xE4	; 228
    29d8:	91 e0       	ldi	r25, 0x01	; 1
    29da:	60 e0       	ldi	r22, 0x00	; 0
    29dc:	70 e0       	ldi	r23, 0x00	; 0
    29de:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>


	//latch switch data
	DATA_BUS = 0; //turn off all VCO waveforms
    29e2:	12 b8       	out	0x02, r1	; 2
	VCO_SW_LATCH_PORT |= (1<<VCO_SW_LATCH);
    29e4:	ed ed       	ldi	r30, 0xDD	; 221
    29e6:	f0 e0       	ldi	r31, 0x00	; 0
    29e8:	80 81       	ld	r24, Z
    29ea:	80 64       	ori	r24, 0x40	; 64
    29ec:	80 83       	st	Z, r24
	//_delay_us(1); //why is this delay here????
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    29ee:	80 81       	ld	r24, Z
    29f0:	8f 7b       	andi	r24, 0xBF	; 191
    29f2:	80 83       	st	Z, r24
	//DATA_BUS = 0;


	period = 1; //need to initialize to minimum period number here
    29f4:	81 e0       	ldi	r24, 0x01	; 1
    29f6:	80 93 80 03 	sts	0x0380, r24
	PORTF |= (1<<GATE); //turn gate on
    29fa:	89 9a       	sbi	0x11, 1	; 17
    29fc:	9e 01       	movw	r18, r28
    29fe:	2f 5f       	subi	r18, 0xFF	; 255
    2a00:	3f 4f       	sbci	r19, 0xFF	; 255
    2a02:	3d ab       	sts	0x5d, r19
    2a04:	2c ab       	sts	0x5c, r18
    2a06:	85 e1       	ldi	r24, 0x15	; 21
    2a08:	93 e0       	ldi	r25, 0x03	; 3
    2a0a:	99 af       	sts	0x79, r25
    2a0c:	88 af       	sts	0x78, r24
	
	
	
	for (int note_number = 0; note_number <= 14; note_number++)
    2a0e:	1f aa       	sts	0x9f, r17
    2a10:	1e aa       	sts	0x9e, r17
		uint16_t pitch_cv = 0;
		for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
		
			pitch_cv |= (1<<dac_bit);

			set_control_voltage(&cutoff_cv, pitch_cv);
    2a12:	0f 2e       	mov	r0, r31
    2a14:	f4 ed       	ldi	r31, 0xD4	; 212
    2a16:	af 2e       	mov	r10, r31
    2a18:	f1 e0       	ldi	r31, 0x01	; 1
    2a1a:	bf 2e       	mov	r11, r31
    2a1c:	f0 2d       	mov	r31, r0
				//value_to_display = TCNT0;
				//update_display(value_to_display, DEC);
				
		
				set_control_voltage(&cutoff_cv, pitch_cv);
				set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
    2a1e:	0f 2e       	mov	r0, r31
    2a20:	f8 ed       	ldi	r31, 0xD8	; 216
    2a22:	6f 2e       	mov	r6, r31
    2a24:	f1 e0       	ldi	r31, 0x01	; 1
    2a26:	7f 2e       	mov	r7, r31
    2a28:	f0 2d       	mov	r31, r0
				set_control_voltage(&res_cv, MAX);
    2a2a:	0f 2e       	mov	r0, r31
    2a2c:	f5 ed       	ldi	r31, 0xD5	; 213
    2a2e:	4f 2e       	mov	r4, r31
    2a30:	f1 e0       	ldi	r31, 0x01	; 1
    2a32:	5f 2e       	mov	r5, r31
    2a34:	f0 2d       	mov	r31, r0
				set_control_voltage(&sustain_1_cv, MAX);
    2a36:	0f 2e       	mov	r0, r31
    2a38:	fa ec       	ldi	r31, 0xCA	; 202
    2a3a:	2f 2e       	mov	r2, r31
    2a3c:	f1 e0       	ldi	r31, 0x01	; 1
    2a3e:	3f 2e       	mov	r3, r31
    2a40:	f0 2d       	mov	r31, r0
		
	
	
	}
	
void tune_filter(void) {
    2a42:	ac a9       	sts	0x4c, r26
    2a44:	bd a9       	sts	0x4d, r27
	
	
	
	for (int note_number = 0; note_number <= 14; note_number++)
	{
		period = reference[note_number].period;
    2a46:	8c 91       	ld	r24, X
    2a48:	80 93 80 03 	sts	0x0380, r24
		//period timer needs to be initialized here and turned off after each note's SAR to prevent glitching caused by leaving timer0 running
		TCCR0A |= (1<<CS02) | (1<<CS01) | (1<<CS00) | (1<<WGM01); //clocked by external T0 pin, rising edge + clear timer on compare match
    2a4c:	84 b5       	in	r24, 0x24	; 36
    2a4e:	8f 60       	ori	r24, 0x0F	; 15
    2a50:	84 bd       	out	0x24, r24	; 36
		OCR0A = 1; //output compare register - set to number of periods to be counted. OCR0A needs to be set to (periods_to_be_counted - 1) ***COULD PROBABLY CHANGE THIS TO 0 NOW*** - NOPE. NEEDS TO BE 1!!!
    2a52:	81 e0       	ldi	r24, 0x01	; 1
    2a54:	87 bd       	out	0x27, r24	; 39
		TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
    2a56:	ee e6       	ldi	r30, 0x6E	; 110
    2a58:	f0 e0       	ldi	r31, 0x00	; 0
    2a5a:	80 81       	ld	r24, Z
    2a5c:	82 60       	ori	r24, 0x02	; 2
    2a5e:	80 83       	st	Z, r24
		TCNT0 = 0; //make sure timer/counter0 is actually 0.
    2a60:	16 bc       	out	0x26, r1	; 38
		
		if (note_number <= 1) {
    2a62:	ee a9       	sts	0x4e, r30
    2a64:	ff a9       	sts	0x4f, r31
    2a66:	e2 30       	cpi	r30, 0x02	; 2
    2a68:	f1 05       	cpc	r31, r1
    2a6a:	24 f4       	brge	.+8      	; 0x2a74 <tune_filter+0x1d4>
			
			//set timer/counter1 to /64 0.3125 MHz
			timer1_clock = (1<<CS11) | (1<<CS10);
    2a6c:	83 e0       	ldi	r24, 0x03	; 3
    2a6e:	80 93 7f 03 	sts	0x037F, r24
    2a72:	03 c0       	rjmp	.+6      	; 0x2a7a <tune_filter+0x1da>
			
		} else {
			
			//set timer/counter1 to /8 2.5 MHz
			timer1_clock = (1<<CS11);
    2a74:	82 e0       	ldi	r24, 0x02	; 2
    2a76:	80 93 7f 03 	sts	0x037F, r24
			
		}
		//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
		uint16_t reference_count = reference[note_number].count;
    2a7a:	11 96       	adiw	r26, 0x01	; 1
    2a7c:	2d 91       	ld	r18, X+
    2a7e:	3c 91       	ld	r19, X
    2a80:	12 97       	sbiw	r26, 0x02	; 2
    2a82:	3b ab       	sts	0x5b, r19
    2a84:	2a ab       	sts	0x5a, r18
		uint16_t pitch_cv = 0;
		for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
    2a86:	8d e0       	ldi	r24, 0x0D	; 13
    2a88:	90 e0       	ldi	r25, 0x00	; 0
    2a8a:	9f a7       	lds	r25, 0x7f
    2a8c:	8e a7       	lds	r24, 0x7e
			timer1_clock = (1<<CS11);
			
		}
		//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
		uint16_t reference_count = reference[note_number].count;
		uint16_t pitch_cv = 0;
    2a8e:	ee 24       	eor	r14, r14
    2a90:	ff 24       	eor	r15, r15
				set_control_voltage(&cutoff_cv, pitch_cv);
				set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
				set_control_voltage(&res_cv, MAX);
				set_control_voltage(&sustain_1_cv, MAX);
				set_control_voltage(&attack_1_cv, MIN); //keep attack at minimum
				set_control_voltage(&fil_lfo_cv, MIN);	//keep all filter modulation at a minimum
    2a92:	0f 2e       	mov	r0, r31
    2a94:	f1 ed       	ldi	r31, 0xD1	; 209
    2a96:	cf 2e       	mov	r12, r31
    2a98:	f1 e0       	ldi	r31, 0x01	; 1
    2a9a:	df 2e       	mov	r13, r31
    2a9c:	f0 2d       	mov	r31, r0
				set_control_voltage(&fil_eg2_cv, MIN);
    2a9e:	0f 2e       	mov	r0, r31
    2aa0:	f6 ed       	ldi	r31, 0xD6	; 214
    2aa2:	8f 2e       	mov	r8, r31
    2aa4:	f1 e0       	ldi	r31, 0x01	; 1
    2aa6:	9f 2e       	mov	r9, r31
    2aa8:	f0 2d       	mov	r31, r0
		//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
		uint16_t reference_count = reference[note_number].count;
		uint16_t pitch_cv = 0;
		for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
		
			pitch_cv |= (1<<dac_bit);
    2aaa:	81 e0       	ldi	r24, 0x01	; 1
    2aac:	90 e0       	ldi	r25, 0x00	; 0
    2aae:	fc 01       	movw	r30, r24
    2ab0:	0e a4       	lds	r16, 0xae
    2ab2:	02 c0       	rjmp	.+4      	; 0x2ab8 <tune_filter+0x218>
    2ab4:	ee 0f       	add	r30, r30
    2ab6:	ff 1f       	adc	r31, r31
    2ab8:	0a 94       	dec	r0
    2aba:	e2 f7       	brpl	.-8      	; 0x2ab4 <tune_filter+0x214>
    2abc:	f9 ab       	sts	0x59, r31
    2abe:	e8 ab       	sts	0x58, r30
    2ac0:	ee 2a       	or	r14, r30
    2ac2:	ff 2a       	or	r15, r31

			set_control_voltage(&cutoff_cv, pitch_cv);
    2ac4:	c5 01       	movw	r24, r10
    2ac6:	b7 01       	movw	r22, r14
    2ac8:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
			count_finished = FALSE;
    2acc:	10 92 7e 03 	sts	0x037E, r1
			period_counter = 0;
    2ad0:	10 92 81 03 	sts	0x0381, r1
		
			//enable watchdog timer
			wdt_enable(WDTO_2S);
    2ad4:	8f e0       	ldi	r24, 0x0F	; 15
    2ad6:	28 e1       	ldi	r18, 0x18	; 24
    2ad8:	30 e0       	ldi	r19, 0x00	; 0
    2ada:	0f b6       	in	r0, 0x3f	; 63
    2adc:	f8 94       	cli
    2ade:	a8 95       	wdr
    2ae0:	20 93 60 00 	sts	0x0060, r18
    2ae4:	0f be       	out	0x3f, r0	; 63
    2ae6:	80 93 60 00 	sts	0x0060, r24
			while (count_finished == FALSE) {
    2aea:	80 91 7e 03 	lds	r24, 0x037E
    2aee:	88 23       	and	r24, r24
    2af0:	b1 f5       	brne	.+108    	; 0x2b5e <tune_filter+0x2be>
				set_control_voltage(&res_cv, MAX);
				set_control_voltage(&sustain_1_cv, MAX);
				set_control_voltage(&attack_1_cv, MIN); //keep attack at minimum
				set_control_voltage(&fil_lfo_cv, MIN);	//keep all filter modulation at a minimum
				set_control_voltage(&fil_eg2_cv, MIN);
				set_control_voltage(&fil_vco2_cv, MIN);
    2af2:	02 ed       	ldi	r16, 0xD2	; 210
    2af4:	11 e0       	ldi	r17, 0x01	; 1
		
			//enable watchdog timer
			wdt_enable(WDTO_2S);
			while (count_finished == FALSE) {
				//update_display(vco_number + period + (compare_match_counter>>4)*100, DEC);
				update_display(300 + period, DEC);//
    2af6:	80 91 80 03 	lds	r24, 0x0380
    2afa:	90 e0       	ldi	r25, 0x00	; 0
    2afc:	84 5d       	subi	r24, 0xD4	; 212
    2afe:	9e 4f       	sbci	r25, 0xFE	; 254
    2b00:	60 e0       	ldi	r22, 0x00	; 0
    2b02:	0e 94 38 03 	call	0x670	; 0x670 <update_display>
				//value_to_display = TCNT0;
				//update_display(value_to_display, DEC);
				
		
				set_control_voltage(&cutoff_cv, pitch_cv);
    2b06:	c5 01       	movw	r24, r10
    2b08:	b7 01       	movw	r22, r14
    2b0a:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
				set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
    2b0e:	c3 01       	movw	r24, r6
    2b10:	60 e0       	ldi	r22, 0x00	; 0
    2b12:	70 e0       	ldi	r23, 0x00	; 0
    2b14:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
				set_control_voltage(&res_cv, MAX);
    2b18:	c2 01       	movw	r24, r4
    2b1a:	6f ef       	ldi	r22, 0xFF	; 255
    2b1c:	7f e3       	ldi	r23, 0x3F	; 63
    2b1e:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
				set_control_voltage(&sustain_1_cv, MAX);
    2b22:	c1 01       	movw	r24, r2
    2b24:	6f ef       	ldi	r22, 0xFF	; 255
    2b26:	7f e3       	ldi	r23, 0x3F	; 63
    2b28:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
				set_control_voltage(&attack_1_cv, MIN); //keep attack at minimum
    2b2c:	8e ec       	ldi	r24, 0xCE	; 206
    2b2e:	91 e0       	ldi	r25, 0x01	; 1
    2b30:	60 e0       	ldi	r22, 0x00	; 0
    2b32:	70 e0       	ldi	r23, 0x00	; 0
    2b34:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
				set_control_voltage(&fil_lfo_cv, MIN);	//keep all filter modulation at a minimum
    2b38:	c6 01       	movw	r24, r12
    2b3a:	60 e0       	ldi	r22, 0x00	; 0
    2b3c:	70 e0       	ldi	r23, 0x00	; 0
    2b3e:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
				set_control_voltage(&fil_eg2_cv, MIN);
    2b42:	c4 01       	movw	r24, r8
    2b44:	60 e0       	ldi	r22, 0x00	; 0
    2b46:	70 e0       	ldi	r23, 0x00	; 0
    2b48:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
				set_control_voltage(&fil_vco2_cv, MIN);
    2b4c:	c8 01       	movw	r24, r16
    2b4e:	60 e0       	ldi	r22, 0x00	; 0
    2b50:	70 e0       	ldi	r23, 0x00	; 0
    2b52:	0e 94 04 02 	call	0x408	; 0x408 <set_control_voltage>
			count_finished = FALSE;
			period_counter = 0;
		
			//enable watchdog timer
			wdt_enable(WDTO_2S);
			while (count_finished == FALSE) {
    2b56:	80 91 7e 03 	lds	r24, 0x037E
    2b5a:	88 23       	and	r24, r24
    2b5c:	61 f2       	breq	.-104    	; 0x2af6 <tune_filter+0x256>
				set_control_voltage(&fil_eg2_cv, MIN);
				set_control_voltage(&fil_vco2_cv, MIN);
						
			}
			//turn off watchdog timer
			wdt_disable();
    2b5e:	88 e1       	ldi	r24, 0x18	; 24
    2b60:	0f b6       	in	r0, 0x3f	; 63
    2b62:	f8 94       	cli
    2b64:	80 93 60 00 	sts	0x0060, r24
    2b68:	10 92 60 00 	sts	0x0060, r1
    2b6c:	0f be       	out	0x3f, r0	; 63
			//Omar changed this from <= to < which makes sense. <= was an error because if it's equal you don't want to clear the bit
			if ((osc_count <= reference_count) && (no_overflow == TRUE))pitch_cv &= ~(1<<dac_bit);
    2b6e:	80 91 7c 03 	lds	r24, 0x037C
    2b72:	90 91 7d 03 	lds	r25, 0x037D
    2b76:	2a a9       	sts	0x4a, r18
    2b78:	3b a9       	sts	0x4b, r19
    2b7a:	28 17       	cp	r18, r24
    2b7c:	39 07       	cpc	r19, r25
    2b7e:	50 f0       	brcs	.+20     	; 0x2b94 <tune_filter+0x2f4>
    2b80:	80 91 af 02 	lds	r24, 0x02AF
    2b84:	81 30       	cpi	r24, 0x01	; 1
    2b86:	31 f4       	brne	.+12     	; 0x2b94 <tune_filter+0x2f4>
    2b88:	88 a9       	sts	0x48, r24
    2b8a:	99 a9       	sts	0x49, r25
    2b8c:	80 95       	com	r24
    2b8e:	90 95       	com	r25
    2b90:	e8 22       	and	r14, r24
    2b92:	f9 22       	and	r15, r25
		
			if (osc_count == reference_count && no_overflow == TRUE) {
    2b94:	80 91 7c 03 	lds	r24, 0x037C
    2b98:	90 91 7d 03 	lds	r25, 0x037D
    2b9c:	ea a9       	sts	0x4a, r30
    2b9e:	fb a9       	sts	0x4b, r31
    2ba0:	8e 17       	cp	r24, r30
    2ba2:	9f 07       	cpc	r25, r31
    2ba4:	21 f4       	brne	.+8      	; 0x2bae <tune_filter+0x30e>
    2ba6:	80 91 af 02 	lds	r24, 0x02AF
    2baa:	81 30       	cpi	r24, 0x01	; 1
    2bac:	71 f0       	breq	.+28     	; 0x2bca <tune_filter+0x32a>
				break;	//if you hit the reference count then get out of here
			}
			no_overflow = TRUE;
    2bae:	81 e0       	ldi	r24, 0x01	; 1
    2bb0:	80 93 af 02 	sts	0x02AF, r24
			
		}
		//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
		uint16_t reference_count = reference[note_number].count;
		uint16_t pitch_cv = 0;
		for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
    2bb4:	2e a5       	lds	r18, 0x6e
    2bb6:	3f a5       	lds	r19, 0x6f
    2bb8:	21 50       	subi	r18, 0x01	; 1
    2bba:	30 40       	sbci	r19, 0x00	; 0
    2bbc:	3f a7       	lds	r19, 0x7f
    2bbe:	2e a7       	lds	r18, 0x7e
    2bc0:	8f ef       	ldi	r24, 0xFF	; 255
    2bc2:	2f 3f       	cpi	r18, 0xFF	; 255
    2bc4:	38 07       	cpc	r19, r24
    2bc6:	09 f0       	breq	.+2      	; 0x2bca <tune_filter+0x32a>
    2bc8:	70 cf       	rjmp	.-288    	; 0x2aaa <tune_filter+0x20a>
		
		
	}
	
	
	filter_pitch_table[note_number+1] = pitch_cv + 32; //32 is an offset that is trying to fix a bug somewhere else. This fix seems to work, but why 2^5 shift is required doesn't make sense to me yet. Need to look into this further
    2bca:	ee a9       	sts	0x4e, r30
    2bcc:	ff a9       	sts	0x4f, r31
    2bce:	31 96       	adiw	r30, 0x01	; 1
    2bd0:	ff ab       	sts	0x5f, r31
    2bd2:	ee ab       	sts	0x5e, r30
    2bd4:	c7 01       	movw	r24, r14
    2bd6:	80 96       	adiw	r24, 0x20	; 32
    2bd8:	e8 ad       	sts	0x68, r30
    2bda:	f9 ad       	sts	0x69, r31
    2bdc:	81 93       	st	Z+, r24
    2bde:	91 93       	st	Z+, r25
    2be0:	f9 af       	sts	0x79, r31
    2be2:	e8 af       	sts	0x78, r30
	
	//need to turn timer off here. This seems to have stopped periodic glitching of first note of first VCO tuned.
	TIMSK0 &= ~(1<<OCIE0A); //turn off timer0 compare match A interrupt
    2be4:	ee e6       	ldi	r30, 0x6E	; 110
    2be6:	f0 e0       	ldi	r31, 0x00	; 0
    2be8:	80 81       	ld	r24, Z
    2bea:	8d 7f       	andi	r24, 0xFD	; 253
    2bec:	80 83       	st	Z, r24
	TCCR0A = 0; //turn off timer0
    2bee:	14 bc       	out	0x24, r1	; 36
    2bf0:	2c a9       	sts	0x4c, r18
    2bf2:	3d a9       	sts	0x4d, r19
    2bf4:	2d 5f       	subi	r18, 0xFD	; 253
    2bf6:	3f 4f       	sbci	r19, 0xFF	; 255
    2bf8:	3d ab       	sts	0x5d, r19
    2bfa:	2c ab       	sts	0x5c, r18
	period = 1; //need to initialize to minimum period number here
	PORTF |= (1<<GATE); //turn gate on
	
	
	
	for (int note_number = 0; note_number <= 14; note_number++)
    2bfc:	8e a9       	sts	0x4e, r24
    2bfe:	9f a9       	sts	0x4f, r25
    2c00:	8f 30       	cpi	r24, 0x0F	; 15
    2c02:	91 05       	cpc	r25, r1
    2c04:	09 f0       	breq	.+2      	; 0x2c08 <tune_filter+0x368>
    2c06:	1d cf       	rjmp	.-454    	; 0x2a42 <tune_filter+0x1a2>
}


//eeprom_update_block((const void*)filter_pitch_table, (void*)filter_pitch_table_eeprom, sizeof(filter_pitch_table));

PORTF &= ~(1<<GATE); //turn gate off
    2c08:	89 98       	cbi	0x11, 1	; 17
	
	
}	
    2c0a:	e9 96       	adiw	r28, 0x39	; 57
    2c0c:	0f b6       	in	r0, 0x3f	; 63
    2c0e:	f8 94       	cli
    2c10:	de bf       	out	0x3e, r29	; 62
    2c12:	0f be       	out	0x3f, r0	; 63
    2c14:	cd bf       	out	0x3d, r28	; 61
    2c16:	df 91       	pop	r29
    2c18:	cf 91       	pop	r28
    2c1a:	1f 91       	pop	r17
    2c1c:	0f 91       	pop	r16
    2c1e:	ff 90       	pop	r15
    2c20:	ef 90       	pop	r14
    2c22:	df 90       	pop	r13
    2c24:	cf 90       	pop	r12
    2c26:	bf 90       	pop	r11
    2c28:	af 90       	pop	r10
    2c2a:	9f 90       	pop	r9
    2c2c:	8f 90       	pop	r8
    2c2e:	7f 90       	pop	r7
    2c30:	6f 90       	pop	r6
    2c32:	5f 90       	pop	r5
    2c34:	4f 90       	pop	r4
    2c36:	3f 90       	pop	r3
    2c38:	2f 90       	pop	r2
    2c3a:	08 95       	ret

00002c3c <save_tuning_tables>:


void save_tuning_tables(void) { //write tuning tables to memory
	
	eeprom_update_block((const void*)filter_pitch_table, (void*)filter_pitch_table_eeprom, sizeof(filter_pitch_table));
    2c3c:	83 e1       	ldi	r24, 0x13	; 19
    2c3e:	93 e0       	ldi	r25, 0x03	; 3
    2c40:	6c e0       	ldi	r22, 0x0C	; 12
    2c42:	76 e0       	ldi	r23, 0x06	; 6
    2c44:	40 e2       	ldi	r20, 0x20	; 32
    2c46:	50 e0       	ldi	r21, 0x00	; 0
    2c48:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <__eeupd_block_m6450a>
	eeprom_update_block((const void*)vco1_pitch_table, (void*)vco1_pitch_table_eeprom, sizeof(vco1_pitch_table));
    2c4c:	85 e5       	ldi	r24, 0x55	; 85
    2c4e:	93 e0       	ldi	r25, 0x03	; 3
    2c50:	6e e4       	ldi	r22, 0x4E	; 78
    2c52:	76 e0       	ldi	r23, 0x06	; 6
    2c54:	42 e2       	ldi	r20, 0x22	; 34
    2c56:	50 e0       	ldi	r21, 0x00	; 0
    2c58:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <__eeupd_block_m6450a>
	eeprom_update_block((const void*)vco2_pitch_table, (void*)vco2_pitch_table_eeprom, sizeof(vco2_pitch_table));
    2c5c:	83 e3       	ldi	r24, 0x33	; 51
    2c5e:	93 e0       	ldi	r25, 0x03	; 3
    2c60:	6c e2       	ldi	r22, 0x2C	; 44
    2c62:	76 e0       	ldi	r23, 0x06	; 6
    2c64:	42 e2       	ldi	r20, 0x22	; 34
    2c66:	50 e0       	ldi	r21, 0x00	; 0
    2c68:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <__eeupd_block_m6450a>
	
	
}
    2c6c:	08 95       	ret

00002c6e <load_tuning_tables>:

void load_tuning_tables(void) { //retrieve tuning tables from memory
	
	
	vco1_init_cv = eeprom_read_word(&vco1_init_cv_eeprom);
    2c6e:	82 e7       	ldi	r24, 0x72	; 114
    2c70:	96 e0       	ldi	r25, 0x06	; 6
    2c72:	0e 94 0d 1f 	call	0x3e1a	; 0x3e1a <__eerd_word_m6450a>
    2c76:	90 93 7a 03 	sts	0x037A, r25
    2c7a:	80 93 79 03 	sts	0x0379, r24
	vco2_init_cv = eeprom_read_word(&vco2_init_cv_eeprom);
    2c7e:	80 e7       	ldi	r24, 0x70	; 112
    2c80:	96 e0       	ldi	r25, 0x06	; 6
    2c82:	0e 94 0d 1f 	call	0x3e1a	; 0x3e1a <__eerd_word_m6450a>
    2c86:	90 93 78 03 	sts	0x0378, r25
    2c8a:	80 93 77 03 	sts	0x0377, r24
	//uint16_t eeprom_addr = 0;
	//vco1_init_cv = eeprom_read_word((uint16_t*)eeprom_addr);
	//eeprom_addr += sizeof(vco2_init_cv);
	//vco2_init_cv = eeprom_read_word((uint16_t*)eeprom_addr);
	eeprom_read_block((void*)vco1_pitch_table, (const void*)vco1_pitch_table_eeprom, sizeof(vco1_pitch_table));
    2c8e:	85 e5       	ldi	r24, 0x55	; 85
    2c90:	93 e0       	ldi	r25, 0x03	; 3
    2c92:	6e e4       	ldi	r22, 0x4E	; 78
    2c94:	76 e0       	ldi	r23, 0x06	; 6
    2c96:	42 e2       	ldi	r20, 0x22	; 34
    2c98:	50 e0       	ldi	r21, 0x00	; 0
    2c9a:	0e 94 fd 1e 	call	0x3dfa	; 0x3dfa <__eerd_block_m6450a>
	eeprom_read_block((void*)vco2_pitch_table, (const void*)vco2_pitch_table_eeprom, sizeof(vco2_pitch_table));
    2c9e:	83 e3       	ldi	r24, 0x33	; 51
    2ca0:	93 e0       	ldi	r25, 0x03	; 3
    2ca2:	6c e2       	ldi	r22, 0x2C	; 44
    2ca4:	76 e0       	ldi	r23, 0x06	; 6
    2ca6:	42 e2       	ldi	r20, 0x22	; 34
    2ca8:	50 e0       	ldi	r21, 0x00	; 0
    2caa:	0e 94 fd 1e 	call	0x3dfa	; 0x3dfa <__eerd_block_m6450a>
	eeprom_read_block((void*)filter_pitch_table, (const void*)filter_pitch_table_eeprom, sizeof(filter_pitch_table));
    2cae:	83 e1       	ldi	r24, 0x13	; 19
    2cb0:	93 e0       	ldi	r25, 0x03	; 3
    2cb2:	6c e0       	ldi	r22, 0x0C	; 12
    2cb4:	76 e0       	ldi	r23, 0x06	; 6
    2cb6:	40 e2       	ldi	r20, 0x20	; 32
    2cb8:	50 e0       	ldi	r21, 0x00	; 0
    2cba:	0e 94 fd 1e 	call	0x3dfa	; 0x3dfa <__eerd_block_m6450a>
	
	//value_to_display = vco1_init_cv_eeprom;
	
}			
    2cbe:	08 95       	ret

00002cc0 <interpolate_pitch_cv>:
	
uint16_t interpolate_pitch_cv(uint8_t note, uint16_t *pitch_table) {
	
	uint8_t pitch_index = note>>3;
    2cc0:	98 2f       	mov	r25, r24
    2cc2:	96 95       	lsr	r25
    2cc4:	96 95       	lsr	r25
    2cc6:	96 95       	lsr	r25
	uint8_t delta_note = note - pitch_index*8; //will range from 0 to 7
		
	uint16_t y0 = pitch_table[pitch_index -1];
    2cc8:	29 2f       	mov	r18, r25
    2cca:	30 e0       	ldi	r19, 0x00	; 0
    2ccc:	f9 01       	movw	r30, r18
    2cce:	31 97       	sbiw	r30, 0x01	; 1
    2cd0:	ee 0f       	add	r30, r30
    2cd2:	ff 1f       	adc	r31, r31
    2cd4:	e6 0f       	add	r30, r22
    2cd6:	f7 1f       	adc	r31, r23
    2cd8:	01 90       	ld	r0, Z+
    2cda:	f0 81       	ld	r31, Z
    2cdc:	e0 2d       	mov	r30, r0
	uint16_t y1 = pitch_table[pitch_index];
    2cde:	22 0f       	add	r18, r18
    2ce0:	33 1f       	adc	r19, r19
    2ce2:	26 0f       	add	r18, r22
    2ce4:	37 1f       	adc	r19, r23
	
	uint16_t interpolated_pitch_cv = y0 + (((y1 - y0)*delta_note)>>3); //mind order of operations here: + is evaluated before >>	also, might be possible to optimize this with 16MUL8SHIFT8 from Anushri ASM util
    2ce6:	d9 01       	movw	r26, r18
    2ce8:	4d 91       	ld	r20, X+
    2cea:	5c 91       	ld	r21, X
    2cec:	11 97       	sbiw	r26, 0x01	; 1
    2cee:	4e 1b       	sub	r20, r30
    2cf0:	5f 0b       	sbc	r21, r31
}			
	
uint16_t interpolate_pitch_cv(uint8_t note, uint16_t *pitch_table) {
	
	uint8_t pitch_index = note>>3;
	uint8_t delta_note = note - pitch_index*8; //will range from 0 to 7
    2cf2:	99 0f       	add	r25, r25
    2cf4:	99 0f       	add	r25, r25
    2cf6:	99 0f       	add	r25, r25
    2cf8:	89 1b       	sub	r24, r25
		
	uint16_t y0 = pitch_table[pitch_index -1];
	uint16_t y1 = pitch_table[pitch_index];
	
	uint16_t interpolated_pitch_cv = y0 + (((y1 - y0)*delta_note)>>3); //mind order of operations here: + is evaluated before >>	also, might be possible to optimize this with 16MUL8SHIFT8 from Anushri ASM util
    2cfa:	90 e0       	ldi	r25, 0x00	; 0
    2cfc:	48 9f       	mul	r20, r24
    2cfe:	90 01       	movw	r18, r0
    2d00:	49 9f       	mul	r20, r25
    2d02:	30 0d       	add	r19, r0
    2d04:	58 9f       	mul	r21, r24
    2d06:	30 0d       	add	r19, r0
    2d08:	11 24       	eor	r1, r1
    2d0a:	36 95       	lsr	r19
    2d0c:	27 95       	ror	r18
    2d0e:	36 95       	lsr	r19
    2d10:	27 95       	ror	r18
    2d12:	36 95       	lsr	r19
    2d14:	27 95       	ror	r18
    2d16:	e2 0f       	add	r30, r18
    2d18:	f3 1f       	adc	r31, r19
	
	
	
	return interpolated_pitch_cv;
	
}
    2d1a:	8e 2f       	mov	r24, r30
    2d1c:	9f 2f       	mov	r25, r31
    2d1e:	08 95       	ret

00002d20 <set_one_volt_per_octave>:

void set_one_volt_per_octave(void) { //does this get stored in RAM? Should it go in progmem instead?
    2d20:	cf 93       	push	r28
    2d22:	df 93       	push	r29
    2d24:	cd b7       	in	r28, 0x3d	; 61
    2d26:	de b7       	in	r29, 0x3e	; 62
    2d28:	a2 97       	sbiw	r28, 0x22	; 34
    2d2a:	0f b6       	in	r0, 0x3f	; 63
    2d2c:	f8 94       	cli
    2d2e:	de bf       	out	0x3e, r29	; 62
    2d30:	0f be       	out	0x3f, r0	; 63
    2d32:	cd bf       	out	0x3d, r28	; 61
	
	uint16_t vpo_pitch_table[17] = {
    2d34:	de 01       	movw	r26, r28
    2d36:	11 96       	adiw	r26, 0x01	; 1
    2d38:	ed e8       	ldi	r30, 0x8D	; 141
    2d3a:	f2 e0       	ldi	r31, 0x02	; 2
    2d3c:	82 e2       	ldi	r24, 0x22	; 34
    2d3e:	01 90       	ld	r0, Z+
    2d40:	0d 92       	st	X+, r0
    2d42:	81 50       	subi	r24, 0x01	; 1
    2d44:	e1 f7       	brne	.-8      	; 0x2d3e <set_one_volt_per_octave+0x1e>
		16384
		
	};
	
	
	memcpy((void*)vco1_pitch_table, (const void*)vpo_pitch_table, (size_t)sizeof(vpo_pitch_table));
    2d46:	a5 e5       	ldi	r26, 0x55	; 85
    2d48:	b3 e0       	ldi	r27, 0x03	; 3
    2d4a:	fe 01       	movw	r30, r28
    2d4c:	31 96       	adiw	r30, 0x01	; 1
    2d4e:	82 e2       	ldi	r24, 0x22	; 34
    2d50:	01 90       	ld	r0, Z+
    2d52:	0d 92       	st	X+, r0
    2d54:	81 50       	subi	r24, 0x01	; 1
    2d56:	e1 f7       	brne	.-8      	; 0x2d50 <set_one_volt_per_octave+0x30>
	memcpy((void*)vco2_pitch_table, (const void*)vpo_pitch_table, (size_t)sizeof(vpo_pitch_table));
    2d58:	a3 e3       	ldi	r26, 0x33	; 51
    2d5a:	b3 e0       	ldi	r27, 0x03	; 3
    2d5c:	fe 01       	movw	r30, r28
    2d5e:	31 96       	adiw	r30, 0x01	; 1
    2d60:	82 e2       	ldi	r24, 0x22	; 34
    2d62:	01 90       	ld	r0, Z+
    2d64:	0d 92       	st	X+, r0
    2d66:	81 50       	subi	r24, 0x01	; 1
    2d68:	e1 f7       	brne	.-8      	; 0x2d62 <set_one_volt_per_octave+0x42>
	
	
}
    2d6a:	a2 96       	adiw	r28, 0x22	; 34
    2d6c:	0f b6       	in	r0, 0x3f	; 63
    2d6e:	f8 94       	cli
    2d70:	de bf       	out	0x3e, r29	; 62
    2d72:	0f be       	out	0x3f, r0	; 63
    2d74:	cd bf       	out	0x3d, r28	; 61
    2d76:	df 91       	pop	r29
    2d78:	cf 91       	pop	r28
    2d7a:	08 95       	ret

00002d7c <tune>:
void tune(void) {
	

			
			//turn off Timer1 output compare match now, it is used by the system clock
			TIMSK1 &= (1<<OCIE1A);
    2d7c:	ef e6       	ldi	r30, 0x6F	; 111
    2d7e:	f0 e0       	ldi	r31, 0x00	; 0
    2d80:	80 81       	ld	r24, Z
    2d82:	82 70       	andi	r24, 0x02	; 2
    2d84:	80 83       	st	Z, r24
			//get rid of CTC here for Timer1 too
			TCCR1B &= ~(1<<WGM12); //turn off CTC
    2d86:	e1 e8       	ldi	r30, 0x81	; 129
    2d88:	f0 e0       	ldi	r31, 0x00	; 0
    2d8a:	80 81       	ld	r24, Z
    2d8c:	87 7f       	andi	r24, 0xF7	; 247
    2d8e:	80 83       	st	Z, r24
			
			vco1_init_cv = set_vco_init_cv(VCO1, 24079);
    2d90:	8f e0       	ldi	r24, 0x0F	; 15
    2d92:	6f e0       	ldi	r22, 0x0F	; 15
    2d94:	7e e5       	ldi	r23, 0x5E	; 94
    2d96:	0e 94 4a 11 	call	0x2294	; 0x2294 <set_vco_init_cv>
    2d9a:	90 93 7a 03 	sts	0x037A, r25
    2d9e:	80 93 79 03 	sts	0x0379, r24
			vco2_init_cv = set_vco_init_cv(VCO2, 24079);
    2da2:	80 ef       	ldi	r24, 0xF0	; 240
    2da4:	6f e0       	ldi	r22, 0x0F	; 15
    2da6:	7e e5       	ldi	r23, 0x5E	; 94
    2da8:	0e 94 4a 11 	call	0x2294	; 0x2294 <set_vco_init_cv>
    2dac:	90 93 78 03 	sts	0x0378, r25
    2db0:	80 93 77 03 	sts	0x0377, r24
			//vco1_init_cv = vco2_init_cv;
			tune_8ths(VCO1);
    2db4:	8f e0       	ldi	r24, 0x0F	; 15
    2db6:	0e 94 ae 12 	call	0x255c	; 0x255c <tune_8ths>
			tune_8ths(VCO2);
    2dba:	80 ef       	ldi	r24, 0xF0	; 240
    2dbc:	0e 94 ae 12 	call	0x255c	; 0x255c <tune_8ths>
			tune_filter();
    2dc0:	0e 94 50 14 	call	0x28a0	; 0x28a0 <tune_filter>
			save_tuning_tables();
    2dc4:	0e 94 1e 16 	call	0x2c3c	; 0x2c3c <save_tuning_tables>
    2dc8:	8f e4       	ldi	r24, 0x4F	; 79
    2dca:	93 ec       	ldi	r25, 0xC3	; 195
    2dcc:	01 97       	sbiw	r24, 0x01	; 1
    2dce:	f1 f7       	brne	.-4      	; 0x2dcc <tune+0x50>
    2dd0:	00 c0       	rjmp	.+0      	; 0x2dd2 <tune+0x56>
    2dd2:	00 00       	nop
			_delay_ms(200);	//give some time for release to decay to avoid pops
			
			//need to restore Timer1 settings. This currently happens after the function is called, but should really be included here
	
    2dd4:	08 95       	ret

00002dd6 <read_switch_port>:
uint8_t read_switch_port(void) {
	
	static uint8_t previous_port_state = 0;
	static uint16_t prog_hold_counter = 0;
	
	uint8_t current_port_state = SWITCH_PORT; //read switch state byte
    2dd6:	8f b1       	in	r24, 0x0f	; 15
	switch_press |= current_port_state & 0b00001100; //mask for four PROG buttons 
    2dd8:	98 2f       	mov	r25, r24
    2dda:	9c 70       	andi	r25, 0x0C	; 12
    2ddc:	20 91 c5 02 	lds	r18, 0x02C5
    2de0:	92 2b       	or	r25, r18
    2de2:	90 93 c5 02 	sts	0x02C5, r25
	
	if ((current_port_state >> PROG_DOWN_SW) & 1) { //press and hold handler for PROG DOWN switch. Should have a general framework for handling switch presses and holds
    2de6:	98 2f       	mov	r25, r24
    2de8:	92 95       	swap	r25
    2dea:	96 95       	lsr	r25
    2dec:	97 70       	andi	r25, 0x07	; 7
    2dee:	90 ff       	sbrs	r25, 0
    2df0:	16 c0       	rjmp	.+44     	; 0x2e1e <read_switch_port+0x48>
		
		if (++prog_hold_counter == 600) { //problem here is that the hold time is dependent on main loop execution speed. Could maybe somehow link this to Timer1, which is running at constant /1024
    2df2:	20 91 85 03 	lds	r18, 0x0385
    2df6:	30 91 86 03 	lds	r19, 0x0386
    2dfa:	2f 5f       	subi	r18, 0xFF	; 255
    2dfc:	3f 4f       	sbci	r19, 0xFF	; 255
    2dfe:	30 93 86 03 	sts	0x0386, r19
    2e02:	20 93 85 03 	sts	0x0385, r18
    2e06:	92 e0       	ldi	r25, 0x02	; 2
    2e08:	28 35       	cpi	r18, 0x58	; 88
    2e0a:	39 07       	cpc	r19, r25
    2e0c:	61 f4       	brne	.+24     	; 0x2e26 <read_switch_port+0x50>
			
			prog_hold_counter = 0; //shouldn't need this as prog_hold_counter will overflow to 0 on next press
    2e0e:	10 92 86 03 	sts	0x0386, r1
    2e12:	10 92 85 03 	sts	0x0385, r1
			current_patch.mode = CAL;
    2e16:	95 e0       	ldi	r25, 0x05	; 5
    2e18:	90 93 0b 03 	sts	0x030B, r25
    2e1c:	04 c0       	rjmp	.+8      	; 0x2e26 <read_switch_port+0x50>
			
		}
		
	} else { prog_hold_counter = 0;} //reset counter to 0
    2e1e:	10 92 86 03 	sts	0x0386, r1
    2e22:	10 92 85 03 	sts	0x0385, r1
		
	//this toggle code works, but I haven't figured out how it works
	//source: http://forum.allaboutcircuits.com/threads/help-with-programming-uc-toggle-led-using-one-switch.51602/	
	current_port_state ^= previous_port_state;
    2e26:	90 91 87 03 	lds	r25, 0x0387
    2e2a:	89 27       	eor	r24, r25
	previous_port_state ^= current_port_state;
    2e2c:	98 27       	eor	r25, r24
    2e2e:	90 93 87 03 	sts	0x0387, r25
	current_port_state &= previous_port_state;
	
	return current_port_state;
	
}
    2e32:	89 23       	and	r24, r25
    2e34:	08 95       	ret

00002e36 <update_analog_switch_latch>:

void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    2e36:	ed ed       	ldi	r30, 0xDD	; 221
    2e38:	f0 e0       	ldi	r31, 0x00	; 0
    2e3a:	90 81       	ld	r25, Z
    2e3c:	9f 7b       	andi	r25, 0xBF	; 191
    2e3e:	90 83       	st	Z, r25
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
	((switch_state_byte >> VCO_SYNC_SW) & 1) << VCO_SYNC_LATCH_BIT |
	((switch_state_byte >> VCO1_SAW_SW) & 1) << VCO1_SAW_LATCH_BIT |
	((switch_state_byte >> VCO1_TRI_SW) & 1) << VCO1_TRI_LATCH_BIT |
	((switch_state_byte >> VCO1_PULSE_SW) & 1) << VCO1_PULSE_LATCH_BIT |
    2e40:	28 2f       	mov	r18, r24
    2e42:	30 e0       	ldi	r19, 0x00	; 0
    2e44:	21 70       	andi	r18, 0x01	; 1
    2e46:	30 70       	andi	r19, 0x00	; 0
    2e48:	22 0f       	add	r18, r18
    2e4a:	33 1f       	adc	r19, r19
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
	((switch_state_byte >> VCO2_TRI_SW) & 1) << VCO2_TRI_LATCH_BIT |
    2e4c:	68 2f       	mov	r22, r24
    2e4e:	62 95       	swap	r22
    2e50:	66 95       	lsr	r22
    2e52:	67 70       	andi	r22, 0x07	; 7
    2e54:	67 95       	ror	r22
    2e56:	66 27       	eor	r22, r22
    2e58:	67 95       	ror	r22
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2e5a:	26 2b       	or	r18, r22
    2e5c:	98 2f       	mov	r25, r24
    2e5e:	96 95       	lsr	r25
    2e60:	96 95       	lsr	r25
    2e62:	91 70       	andi	r25, 0x01	; 1
    2e64:	29 2b       	or	r18, r25
	((switch_state_byte >> VCO_SYNC_SW) & 1) << VCO_SYNC_LATCH_BIT |
    2e66:	68 2f       	mov	r22, r24
    2e68:	66 1f       	adc	r22, r22
    2e6a:	66 27       	eor	r22, r22
    2e6c:	66 1f       	adc	r22, r22
    2e6e:	66 0f       	add	r22, r22
    2e70:	66 0f       	add	r22, r22
    2e72:	66 0f       	add	r22, r22
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2e74:	26 2b       	or	r18, r22
	((switch_state_byte >> VCO_SYNC_SW) & 1) << VCO_SYNC_LATCH_BIT |
	((switch_state_byte >> VCO1_SAW_SW) & 1) << VCO1_SAW_LATCH_BIT |
	((switch_state_byte >> VCO1_TRI_SW) & 1) << VCO1_TRI_LATCH_BIT |
    2e76:	a8 2f       	mov	r26, r24
    2e78:	a6 95       	lsr	r26
    2e7a:	b0 e0       	ldi	r27, 0x00	; 0
    2e7c:	a1 70       	andi	r26, 0x01	; 1
    2e7e:	b0 70       	andi	r27, 0x00	; 0
    2e80:	bd 01       	movw	r22, r26
    2e82:	66 0f       	add	r22, r22
    2e84:	77 1f       	adc	r23, r23
    2e86:	66 0f       	add	r22, r22
    2e88:	77 1f       	adc	r23, r23
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2e8a:	26 2b       	or	r18, r22
	((switch_state_byte >> VCO_SYNC_SW) & 1) << VCO_SYNC_LATCH_BIT |
	((switch_state_byte >> VCO1_SAW_SW) & 1) << VCO1_SAW_LATCH_BIT |
	((switch_state_byte >> VCO1_TRI_SW) & 1) << VCO1_TRI_LATCH_BIT |
	((switch_state_byte >> VCO1_PULSE_SW) & 1) << VCO1_PULSE_LATCH_BIT |
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
    2e8c:	68 2f       	mov	r22, r24
    2e8e:	62 95       	swap	r22
    2e90:	6f 70       	andi	r22, 0x0F	; 15
    2e92:	70 e0       	ldi	r23, 0x00	; 0
    2e94:	61 70       	andi	r22, 0x01	; 1
    2e96:	70 70       	andi	r23, 0x00	; 0
    2e98:	ab 01       	movw	r20, r22
    2e9a:	00 24       	eor	r0, r0
    2e9c:	56 95       	lsr	r21
    2e9e:	47 95       	ror	r20
    2ea0:	07 94       	ror	r0
    2ea2:	56 95       	lsr	r21
    2ea4:	47 95       	ror	r20
    2ea6:	07 94       	ror	r0
    2ea8:	54 2f       	mov	r21, r20
    2eaa:	40 2d       	mov	r20, r0
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2eac:	62 2f       	mov	r22, r18
    2eae:	64 2b       	or	r22, r20
	((switch_state_byte >> VCO1_SAW_SW) & 1) << VCO1_SAW_LATCH_BIT |
	((switch_state_byte >> VCO1_TRI_SW) & 1) << VCO1_TRI_LATCH_BIT |
	((switch_state_byte >> VCO1_PULSE_SW) & 1) << VCO1_PULSE_LATCH_BIT |
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
	((switch_state_byte >> VCO2_TRI_SW) & 1) << VCO2_TRI_LATCH_BIT |
	((switch_state_byte >> VCO2_PULSE_SW) & 1) << VCO2_PULSE_LATCH_BIT |
    2eb0:	48 2f       	mov	r20, r24
    2eb2:	42 95       	swap	r20
    2eb4:	46 95       	lsr	r20
    2eb6:	46 95       	lsr	r20
    2eb8:	43 70       	andi	r20, 0x03	; 3
    2eba:	50 e0       	ldi	r21, 0x00	; 0
    2ebc:	41 70       	andi	r20, 0x01	; 1
    2ebe:	50 70       	andi	r21, 0x00	; 0
    2ec0:	9a 01       	movw	r18, r20
    2ec2:	22 0f       	add	r18, r18
    2ec4:	33 1f       	adc	r19, r19
    2ec6:	22 95       	swap	r18
    2ec8:	32 95       	swap	r19
    2eca:	30 7f       	andi	r19, 0xF0	; 240
    2ecc:	32 27       	eor	r19, r18
    2ece:	20 7f       	andi	r18, 0xF0	; 240
    2ed0:	32 27       	eor	r19, r18
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2ed2:	46 2f       	mov	r20, r22
    2ed4:	42 2b       	or	r20, r18
	((switch_state_byte >> VCO1_PULSE_SW) & 1) << VCO1_PULSE_LATCH_BIT |
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
	((switch_state_byte >> VCO2_TRI_SW) & 1) << VCO2_TRI_LATCH_BIT |
	((switch_state_byte >> VCO2_PULSE_SW) & 1) << VCO2_PULSE_LATCH_BIT |
	//BMOD_SW_ON << BMOD_LATCH_BIT;
	((switch_state_byte >> 3) & 1) << BMOD_LATCH_BIT;
    2ed6:	86 95       	lsr	r24
    2ed8:	86 95       	lsr	r24
    2eda:	86 95       	lsr	r24
    2edc:	28 2f       	mov	r18, r24
    2ede:	30 e0       	ldi	r19, 0x00	; 0
    2ee0:	21 70       	andi	r18, 0x01	; 1
    2ee2:	30 70       	andi	r19, 0x00	; 0
    2ee4:	c9 01       	movw	r24, r18
    2ee6:	82 95       	swap	r24
    2ee8:	92 95       	swap	r25
    2eea:	90 7f       	andi	r25, 0xF0	; 240
    2eec:	98 27       	eor	r25, r24
    2eee:	80 7f       	andi	r24, 0xF0	; 240
    2ef0:	98 27       	eor	r25, r24
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2ef2:	84 2b       	or	r24, r20
    2ef4:	82 b9       	out	0x02, r24	; 2
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
	((switch_state_byte >> VCO2_TRI_SW) & 1) << VCO2_TRI_LATCH_BIT |
	((switch_state_byte >> VCO2_PULSE_SW) & 1) << VCO2_PULSE_LATCH_BIT |
	//BMOD_SW_ON << BMOD_LATCH_BIT;
	((switch_state_byte >> 3) & 1) << BMOD_LATCH_BIT;
	VCO_SW_LATCH_PORT |= (1<<VCO_SW_LATCH);
    2ef6:	80 81       	ld	r24, Z
    2ef8:	80 64       	ori	r24, 0x40	; 64
    2efa:	80 83       	st	Z, r24
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    2efc:	80 81       	ld	r24, Z
    2efe:	8f 7b       	andi	r24, 0xBF	; 191
    2f00:	80 83       	st	Z, r24
	DATA_BUS = 0;
    2f02:	12 b8       	out	0x02, r1	; 2
	
	
    2f04:	08 95       	ret

00002f06 <bytequeue_init>:
//along with avr-bytequeue.  If not, see <http://www.gnu.org/licenses/>.

#include "bytequeue.h"
#include "interrupt_setting.h"

void bytequeue_init(byteQueue_t * queue, uint8_t * dataArray, byteQueueIndex_t arrayLen){
    2f06:	fc 01       	movw	r30, r24
   queue->length = arrayLen;
    2f08:	42 83       	std	Z+2, r20	; 0x02
   queue->data = dataArray;
    2f0a:	74 83       	std	Z+4, r23	; 0x04
    2f0c:	63 83       	std	Z+3, r22	; 0x03
   queue->start = queue->end = 0;
    2f0e:	11 82       	std	Z+1, r1	; 0x01
    2f10:	10 82       	st	Z, r1
}
    2f12:	08 95       	ret

00002f14 <bytequeue_enqueue>:

bool bytequeue_enqueue(byteQueue_t * queue, uint8_t item){
    2f14:	1f 93       	push	r17
    2f16:	cf 93       	push	r28
    2f18:	df 93       	push	r29
    2f1a:	ec 01       	movw	r28, r24
    2f1c:	16 2f       	mov	r17, r22
   interrupt_setting_t setting = store_and_clear_interrupt();
    2f1e:	0e 94 f9 17 	call	0x2ff2	; 0x2ff2 <store_and_clear_interrupt>
    2f22:	28 2f       	mov	r18, r24
   //full
   if(((queue->end + 1) % queue->length) == queue->start){
    2f24:	39 81       	ldd	r19, Y+1	; 0x01
    2f26:	83 2f       	mov	r24, r19
    2f28:	90 e0       	ldi	r25, 0x00	; 0
    2f2a:	01 96       	adiw	r24, 0x01	; 1
    2f2c:	6a 81       	ldd	r22, Y+2	; 0x02
    2f2e:	70 e0       	ldi	r23, 0x00	; 0
    2f30:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <__divmodhi4>
    2f34:	48 81       	ld	r20, Y
    2f36:	50 e0       	ldi	r21, 0x00	; 0
    2f38:	84 17       	cp	r24, r20
    2f3a:	95 07       	cpc	r25, r21
    2f3c:	29 f4       	brne	.+10     	; 0x2f48 <bytequeue_enqueue+0x34>
      restore_interrupt_setting(setting);
    2f3e:	82 2f       	mov	r24, r18
    2f40:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <restore_interrupt_setting>
      return false;
    2f44:	80 e0       	ldi	r24, 0x00	; 0
    2f46:	11 c0       	rjmp	.+34     	; 0x2f6a <bytequeue_enqueue+0x56>
   } else {
      queue->data[queue->end] = item;
    2f48:	eb 81       	ldd	r30, Y+3	; 0x03
    2f4a:	fc 81       	ldd	r31, Y+4	; 0x04
    2f4c:	e3 0f       	add	r30, r19
    2f4e:	f1 1d       	adc	r31, r1
    2f50:	10 83       	st	Z, r17
      queue->end = (queue->end + 1) % queue->length;
    2f52:	89 81       	ldd	r24, Y+1	; 0x01
    2f54:	90 e0       	ldi	r25, 0x00	; 0
    2f56:	01 96       	adiw	r24, 0x01	; 1
    2f58:	6a 81       	ldd	r22, Y+2	; 0x02
    2f5a:	70 e0       	ldi	r23, 0x00	; 0
    2f5c:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <__divmodhi4>
    2f60:	89 83       	std	Y+1, r24	; 0x01
      restore_interrupt_setting(setting);
    2f62:	82 2f       	mov	r24, r18
    2f64:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <restore_interrupt_setting>
      return true;
    2f68:	81 e0       	ldi	r24, 0x01	; 1
   }
}
    2f6a:	df 91       	pop	r29
    2f6c:	cf 91       	pop	r28
    2f6e:	1f 91       	pop	r17
    2f70:	08 95       	ret

00002f72 <bytequeue_length>:

byteQueueIndex_t bytequeue_length(byteQueue_t * queue){
    2f72:	cf 93       	push	r28
    2f74:	df 93       	push	r29
    2f76:	ec 01       	movw	r28, r24
   byteQueueIndex_t len;
   interrupt_setting_t setting = store_and_clear_interrupt();
    2f78:	0e 94 f9 17 	call	0x2ff2	; 0x2ff2 <store_and_clear_interrupt>
   if(queue->end >= queue->start)
    2f7c:	29 81       	ldd	r18, Y+1	; 0x01
    2f7e:	98 81       	ld	r25, Y
    2f80:	29 17       	cp	r18, r25
    2f82:	18 f0       	brcs	.+6      	; 0x2f8a <bytequeue_length+0x18>
      len = queue->end - queue->start;
    2f84:	c2 2f       	mov	r28, r18
    2f86:	c9 1b       	sub	r28, r25
    2f88:	03 c0       	rjmp	.+6      	; 0x2f90 <bytequeue_length+0x1e>
   else
      len = (queue->length - queue->start) + queue->end;
    2f8a:	ca 81       	ldd	r28, Y+2	; 0x02
    2f8c:	c2 0f       	add	r28, r18
    2f8e:	c9 1b       	sub	r28, r25
   restore_interrupt_setting(setting);
    2f90:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <restore_interrupt_setting>
   return len;
}
    2f94:	8c 2f       	mov	r24, r28
    2f96:	df 91       	pop	r29
    2f98:	cf 91       	pop	r28
    2f9a:	08 95       	ret

00002f9c <bytequeue_get>:

//we don't need to avoid interrupts if there is only one reader
uint8_t bytequeue_get(byteQueue_t * queue, byteQueueIndex_t index){
    2f9c:	fc 01       	movw	r30, r24
   return queue->data[(queue->start + index) % queue->length];
    2f9e:	20 81       	ld	r18, Z
    2fa0:	86 2f       	mov	r24, r22
    2fa2:	90 e0       	ldi	r25, 0x00	; 0
    2fa4:	82 0f       	add	r24, r18
    2fa6:	91 1d       	adc	r25, r1
    2fa8:	62 81       	ldd	r22, Z+2	; 0x02
    2faa:	70 e0       	ldi	r23, 0x00	; 0
    2fac:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <__divmodhi4>
    2fb0:	03 80       	ldd	r0, Z+3	; 0x03
    2fb2:	f4 81       	ldd	r31, Z+4	; 0x04
    2fb4:	e0 2d       	mov	r30, r0
    2fb6:	e8 0f       	add	r30, r24
    2fb8:	f9 1f       	adc	r31, r25
}
    2fba:	80 81       	ld	r24, Z
    2fbc:	08 95       	ret

00002fbe <bytequeue_remove>:

//we just update the start index to remove elements
void bytequeue_remove(byteQueue_t * queue, byteQueueIndex_t numToRemove){
    2fbe:	1f 93       	push	r17
    2fc0:	cf 93       	push	r28
    2fc2:	df 93       	push	r29
    2fc4:	ec 01       	movw	r28, r24
    2fc6:	16 2f       	mov	r17, r22
   interrupt_setting_t setting = store_and_clear_interrupt();
    2fc8:	0e 94 f9 17 	call	0x2ff2	; 0x2ff2 <store_and_clear_interrupt>
    2fcc:	48 2f       	mov	r20, r24
   queue->start = (queue->start + numToRemove) % queue->length;
    2fce:	88 81       	ld	r24, Y
    2fd0:	21 2f       	mov	r18, r17
    2fd2:	30 e0       	ldi	r19, 0x00	; 0
    2fd4:	28 0f       	add	r18, r24
    2fd6:	31 1d       	adc	r19, r1
    2fd8:	6a 81       	ldd	r22, Y+2	; 0x02
    2fda:	c9 01       	movw	r24, r18
    2fdc:	70 e0       	ldi	r23, 0x00	; 0
    2fde:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <__divmodhi4>
    2fe2:	88 83       	st	Y, r24
   restore_interrupt_setting(setting);
    2fe4:	84 2f       	mov	r24, r20
    2fe6:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <restore_interrupt_setting>
}
    2fea:	df 91       	pop	r29
    2fec:	cf 91       	pop	r28
    2fee:	1f 91       	pop	r17
    2ff0:	08 95       	ret

00002ff2 <store_and_clear_interrupt>:

#include "interrupt_setting.h"
#include <avr/interrupt.h>

interrupt_setting_t store_and_clear_interrupt(void) {
   uint8_t sreg = SREG;
    2ff2:	8f b7       	in	r24, 0x3f	; 63
   cli();
    2ff4:	f8 94       	cli
   return sreg;
}
    2ff6:	08 95       	ret

00002ff8 <restore_interrupt_setting>:

void restore_interrupt_setting(interrupt_setting_t setting) {
   SREG = setting;
    2ff8:	8f bf       	out	0x3f, r24	; 63
}
    2ffa:	08 95       	ret

00002ffc <midi_is_statusbyte>:
#define NULL 0
#endif

bool midi_is_statusbyte(uint8_t theByte){
   return (bool)(theByte & MIDI_STATUSMASK);
}
    2ffc:	88 1f       	adc	r24, r24
    2ffe:	88 27       	eor	r24, r24
    3000:	88 1f       	adc	r24, r24
    3002:	08 95       	ret

00003004 <midi_is_realtime>:

bool midi_is_realtime(uint8_t theByte){
   return (theByte >= MIDI_CLOCK);
    3004:	91 e0       	ldi	r25, 0x01	; 1
    3006:	88 3f       	cpi	r24, 0xF8	; 248
    3008:	08 f4       	brcc	.+2      	; 0x300c <midi_is_realtime+0x8>
    300a:	90 e0       	ldi	r25, 0x00	; 0
}
    300c:	89 2f       	mov	r24, r25
    300e:	08 95       	ret

00003010 <midi_packet_length>:

midi_packet_length_t midi_packet_length(uint8_t status){
   switch(status & 0xF0){
    3010:	28 2f       	mov	r18, r24
    3012:	30 e0       	ldi	r19, 0x00	; 0
    3014:	20 7f       	andi	r18, 0xF0	; 240
    3016:	30 70       	andi	r19, 0x00	; 0
    3018:	20 3c       	cpi	r18, 0xC0	; 192
    301a:	31 05       	cpc	r19, r1
    301c:	e9 f1       	breq	.+122    	; 0x3098 <midi_packet_length+0x88>
    301e:	21 3c       	cpi	r18, 0xC1	; 193
    3020:	31 05       	cpc	r19, r1
    3022:	8c f4       	brge	.+34     	; 0x3046 <midi_packet_length+0x36>
    3024:	20 39       	cpi	r18, 0x90	; 144
    3026:	31 05       	cpc	r19, r1
    3028:	e1 f0       	breq	.+56     	; 0x3062 <midi_packet_length+0x52>
    302a:	21 39       	cpi	r18, 0x91	; 145
    302c:	31 05       	cpc	r19, r1
    302e:	24 f4       	brge	.+8      	; 0x3038 <midi_packet_length+0x28>
    3030:	20 38       	cpi	r18, 0x80	; 128
    3032:	31 05       	cpc	r19, r1
    3034:	79 f5       	brne	.+94     	; 0x3094 <midi_packet_length+0x84>
    3036:	15 c0       	rjmp	.+42     	; 0x3062 <midi_packet_length+0x52>
    3038:	20 3a       	cpi	r18, 0xA0	; 160
    303a:	31 05       	cpc	r19, r1
    303c:	91 f0       	breq	.+36     	; 0x3062 <midi_packet_length+0x52>
    303e:	20 3b       	cpi	r18, 0xB0	; 176
    3040:	31 05       	cpc	r19, r1
    3042:	41 f5       	brne	.+80     	; 0x3094 <midi_packet_length+0x84>
    3044:	0e c0       	rjmp	.+28     	; 0x3062 <midi_packet_length+0x52>
    3046:	20 3e       	cpi	r18, 0xE0	; 224
    3048:	31 05       	cpc	r19, r1
    304a:	59 f0       	breq	.+22     	; 0x3062 <midi_packet_length+0x52>
    304c:	21 3e       	cpi	r18, 0xE1	; 225
    304e:	31 05       	cpc	r19, r1
    3050:	24 f4       	brge	.+8      	; 0x305a <midi_packet_length+0x4a>
    3052:	20 3d       	cpi	r18, 0xD0	; 208
    3054:	31 05       	cpc	r19, r1
    3056:	f1 f4       	brne	.+60     	; 0x3094 <midi_packet_length+0x84>
    3058:	1f c0       	rjmp	.+62     	; 0x3098 <midi_packet_length+0x88>
    305a:	20 3f       	cpi	r18, 0xF0	; 240
    305c:	31 05       	cpc	r19, r1
    305e:	d1 f4       	brne	.+52     	; 0x3094 <midi_packet_length+0x84>
    3060:	02 c0       	rjmp	.+4      	; 0x3066 <midi_packet_length+0x56>
      case MIDI_CC:
      case MIDI_NOTEON:
      case MIDI_NOTEOFF:
      case MIDI_AFTERTOUCH:
      case MIDI_PITCHBEND:
         return THREE3;
    3062:	83 e0       	ldi	r24, 0x03	; 3
    3064:	08 95       	ret
      case MIDI_PROGCHANGE:
      case MIDI_CHANPRESSURE:
      case MIDI_SONGSELECT:
         return TWO2;
      case 0xF0:
         switch(status) {
    3066:	86 3f       	cpi	r24, 0xF6	; 246
    3068:	79 f0       	breq	.+30     	; 0x3088 <midi_packet_length+0x78>
    306a:	87 3f       	cpi	r24, 0xF7	; 247
    306c:	38 f4       	brcc	.+14     	; 0x307c <midi_packet_length+0x6c>
    306e:	82 3f       	cpi	r24, 0xF2	; 242
    3070:	a9 f0       	breq	.+42     	; 0x309c <midi_packet_length+0x8c>
    3072:	83 3f       	cpi	r24, 0xF3	; 243
    3074:	59 f0       	breq	.+22     	; 0x308c <midi_packet_length+0x7c>
    3076:	81 3f       	cpi	r24, 0xF1	; 241
    3078:	59 f4       	brne	.+22     	; 0x3090 <midi_packet_length+0x80>
    307a:	08 c0       	rjmp	.+16     	; 0x308c <midi_packet_length+0x7c>
    307c:	88 3f       	cpi	r24, 0xF8	; 248
    307e:	40 f0       	brcs	.+16     	; 0x3090 <midi_packet_length+0x80>
    3080:	8d 3f       	cpi	r24, 0xFD	; 253
    3082:	10 f0       	brcs	.+4      	; 0x3088 <midi_packet_length+0x78>
    3084:	8e 3f       	cpi	r24, 0xFE	; 254
    3086:	20 f0       	brcs	.+8      	; 0x3090 <midi_packet_length+0x80>
            case MIDI_CONTINUE:
            case MIDI_STOP:
            case MIDI_ACTIVESENSE:
            case MIDI_RESET:
            case MIDI_TUNEREQUEST:
               return ONE1;
    3088:	81 e0       	ldi	r24, 0x01	; 1
    308a:	08 95       	ret
            case MIDI_SONGPOSITION:
               return THREE3;
            case MIDI_TC_QUARTERFRAME:
            case MIDI_SONGSELECT:
               return TWO2;
    308c:	82 e0       	ldi	r24, 0x02	; 2
    308e:	08 95       	ret
            case SYSEX_END:
            case SYSEX_BEGIN:
            default:
               return UNDEFINED;
    3090:	80 e0       	ldi	r24, 0x00	; 0
    3092:	08 95       	ret
         }
      default:
         return UNDEFINED;
    3094:	80 e0       	ldi	r24, 0x00	; 0
    3096:	08 95       	ret
      case MIDI_PITCHBEND:
         return THREE3;
      case MIDI_PROGCHANGE:
      case MIDI_CHANPRESSURE:
      case MIDI_SONGSELECT:
         return TWO2;
    3098:	82 e0       	ldi	r24, 0x02	; 2
    309a:	08 95       	ret
            case MIDI_ACTIVESENSE:
            case MIDI_RESET:
            case MIDI_TUNEREQUEST:
               return ONE1;
            case MIDI_SONGPOSITION:
               return THREE3;
    309c:	83 e0       	ldi	r24, 0x03	; 3
               return UNDEFINED;
         }
      default:
         return UNDEFINED;
   }
}
    309e:	08 95       	ret

000030a0 <midi_send_cc>:

void midi_send_cc(MidiDevice * device, uint8_t chan, uint8_t num, uint8_t val){
    30a0:	0f 93       	push	r16
    30a2:	34 2f       	mov	r19, r20
    30a4:	02 2f       	mov	r16, r18
   //CC Status: 0xB0 to 0xBF where the low nibble is the MIDI channel.
   //CC Data: Controller Num, Controller Val
   device->send_func(device, 3,
    30a6:	46 2f       	mov	r20, r22
    30a8:	4f 70       	andi	r20, 0x0F	; 15
    30aa:	40 6b       	ori	r20, 0xB0	; 176
    30ac:	23 2f       	mov	r18, r19
    30ae:	2f 77       	andi	r18, 0x7F	; 127
    30b0:	0f 77       	andi	r16, 0x7F	; 127
    30b2:	dc 01       	movw	r26, r24
    30b4:	ed 91       	ld	r30, X+
    30b6:	fc 91       	ld	r31, X
    30b8:	63 e0       	ldi	r22, 0x03	; 3
    30ba:	70 e0       	ldi	r23, 0x00	; 0
    30bc:	09 95       	icall
         MIDI_CC | (chan & MIDI_CHANMASK),
         num & 0x7F,
         val & 0x7F);
}
    30be:	0f 91       	pop	r16
    30c0:	08 95       	ret

000030c2 <midi_send_noteon>:

void midi_send_noteon(MidiDevice * device, uint8_t chan, uint8_t num, uint8_t vel){
    30c2:	0f 93       	push	r16
    30c4:	34 2f       	mov	r19, r20
    30c6:	02 2f       	mov	r16, r18
   //Note Data: Note Num, Note Velocity
   device->send_func(device, 3,
    30c8:	46 2f       	mov	r20, r22
    30ca:	4f 70       	andi	r20, 0x0F	; 15
    30cc:	40 69       	ori	r20, 0x90	; 144
    30ce:	23 2f       	mov	r18, r19
    30d0:	2f 77       	andi	r18, 0x7F	; 127
    30d2:	0f 77       	andi	r16, 0x7F	; 127
    30d4:	dc 01       	movw	r26, r24
    30d6:	ed 91       	ld	r30, X+
    30d8:	fc 91       	ld	r31, X
    30da:	63 e0       	ldi	r22, 0x03	; 3
    30dc:	70 e0       	ldi	r23, 0x00	; 0
    30de:	09 95       	icall
         MIDI_NOTEON | (chan & MIDI_CHANMASK),
         num & 0x7F,
         vel & 0x7F);
}
    30e0:	0f 91       	pop	r16
    30e2:	08 95       	ret

000030e4 <midi_send_noteoff>:

void midi_send_noteoff(MidiDevice * device, uint8_t chan, uint8_t num, uint8_t vel){
    30e4:	0f 93       	push	r16
    30e6:	34 2f       	mov	r19, r20
    30e8:	02 2f       	mov	r16, r18
   //Note Data: Note Num, Note Velocity
   device->send_func(device, 3,
    30ea:	46 2f       	mov	r20, r22
    30ec:	4f 70       	andi	r20, 0x0F	; 15
    30ee:	40 68       	ori	r20, 0x80	; 128
    30f0:	23 2f       	mov	r18, r19
    30f2:	2f 77       	andi	r18, 0x7F	; 127
    30f4:	0f 77       	andi	r16, 0x7F	; 127
    30f6:	dc 01       	movw	r26, r24
    30f8:	ed 91       	ld	r30, X+
    30fa:	fc 91       	ld	r31, X
    30fc:	63 e0       	ldi	r22, 0x03	; 3
    30fe:	70 e0       	ldi	r23, 0x00	; 0
    3100:	09 95       	icall
         MIDI_NOTEOFF | (chan & MIDI_CHANMASK),
         num & 0x7F,
         vel & 0x7F);
}
    3102:	0f 91       	pop	r16
    3104:	08 95       	ret

00003106 <midi_send_aftertouch>:

void midi_send_aftertouch(MidiDevice * device, uint8_t chan, uint8_t note_num, uint8_t amt){
    3106:	0f 93       	push	r16
    3108:	34 2f       	mov	r19, r20
    310a:	02 2f       	mov	r16, r18
   device->send_func(device, 3,
    310c:	46 2f       	mov	r20, r22
    310e:	4f 70       	andi	r20, 0x0F	; 15
    3110:	40 6a       	ori	r20, 0xA0	; 160
    3112:	23 2f       	mov	r18, r19
    3114:	2f 77       	andi	r18, 0x7F	; 127
    3116:	0f 77       	andi	r16, 0x7F	; 127
    3118:	dc 01       	movw	r26, r24
    311a:	ed 91       	ld	r30, X+
    311c:	fc 91       	ld	r31, X
    311e:	63 e0       	ldi	r22, 0x03	; 3
    3120:	70 e0       	ldi	r23, 0x00	; 0
    3122:	09 95       	icall
         MIDI_AFTERTOUCH | (chan & MIDI_CHANMASK),
         note_num & 0x7F,
         amt & 0x7F);
}
    3124:	0f 91       	pop	r16
    3126:	08 95       	ret

00003128 <midi_send_pitchbend>:

//XXX does this work right?
//amt in range -0x2000, 0x1fff
//uAmt should be in range..
//0x0000 to 0x3FFF
void midi_send_pitchbend(MidiDevice * device, uint8_t chan, int16_t amt){
    3128:	0f 93       	push	r16
    312a:	1f 93       	push	r17
   uint16_t uAmt;
   //check range
   if(amt > 0x1fff){
    312c:	20 e2       	ldi	r18, 0x20	; 32
    312e:	40 30       	cpi	r20, 0x00	; 0
    3130:	52 07       	cpc	r21, r18
    3132:	44 f4       	brge	.+16     	; 0x3144 <midi_send_pitchbend+0x1c>
      uAmt = 0x3FFF;
   } else if(amt < -0x2000){
    3134:	a0 ee       	ldi	r26, 0xE0	; 224
    3136:	40 30       	cpi	r20, 0x00	; 0
    3138:	5a 07       	cpc	r21, r26
    313a:	3c f0       	brlt	.+14     	; 0x314a <midi_send_pitchbend+0x22>
      uAmt = 0;
   } else {
      uAmt = amt + 0x2000;
    313c:	8a 01       	movw	r16, r20
    313e:	00 50       	subi	r16, 0x00	; 0
    3140:	10 4e       	sbci	r17, 0xE0	; 224
    3142:	05 c0       	rjmp	.+10     	; 0x314e <midi_send_pitchbend+0x26>
//0x0000 to 0x3FFF
void midi_send_pitchbend(MidiDevice * device, uint8_t chan, int16_t amt){
   uint16_t uAmt;
   //check range
   if(amt > 0x1fff){
      uAmt = 0x3FFF;
    3144:	0f ef       	ldi	r16, 0xFF	; 255
    3146:	1f e3       	ldi	r17, 0x3F	; 63
    3148:	02 c0       	rjmp	.+4      	; 0x314e <midi_send_pitchbend+0x26>
   } else if(amt < -0x2000){
      uAmt = 0;
    314a:	00 e0       	ldi	r16, 0x00	; 0
    314c:	10 e0       	ldi	r17, 0x00	; 0
   } else {
      uAmt = amt + 0x2000;
   }
   device->send_func(device, 3,
    314e:	46 2f       	mov	r20, r22
    3150:	4f 70       	andi	r20, 0x0F	; 15
    3152:	40 6e       	ori	r20, 0xE0	; 224
    3154:	20 2f       	mov	r18, r16
    3156:	2f 77       	andi	r18, 0x7F	; 127
         MIDI_PITCHBEND | (chan & MIDI_CHANMASK),
         uAmt & 0x7F,
         (uAmt >> 7) & 0x7F);
    3158:	00 0f       	add	r16, r16
    315a:	01 2f       	mov	r16, r17
    315c:	00 1f       	adc	r16, r16
    315e:	11 0b       	sbc	r17, r17
    3160:	11 95       	neg	r17
   } else if(amt < -0x2000){
      uAmt = 0;
   } else {
      uAmt = amt + 0x2000;
   }
   device->send_func(device, 3,
    3162:	0f 77       	andi	r16, 0x7F	; 127
    3164:	dc 01       	movw	r26, r24
    3166:	ed 91       	ld	r30, X+
    3168:	fc 91       	ld	r31, X
    316a:	63 e0       	ldi	r22, 0x03	; 3
    316c:	70 e0       	ldi	r23, 0x00	; 0
    316e:	09 95       	icall
         MIDI_PITCHBEND | (chan & MIDI_CHANMASK),
         uAmt & 0x7F,
         (uAmt >> 7) & 0x7F);
}
    3170:	1f 91       	pop	r17
    3172:	0f 91       	pop	r16
    3174:	08 95       	ret

00003176 <midi_send_programchange>:

void midi_send_programchange(MidiDevice * device, uint8_t chan, uint8_t num){
    3176:	0f 93       	push	r16
    3178:	24 2f       	mov	r18, r20
   device->send_func(device, 2,
    317a:	46 2f       	mov	r20, r22
    317c:	4f 70       	andi	r20, 0x0F	; 15
    317e:	40 6c       	ori	r20, 0xC0	; 192
    3180:	2f 77       	andi	r18, 0x7F	; 127
    3182:	dc 01       	movw	r26, r24
    3184:	ed 91       	ld	r30, X+
    3186:	fc 91       	ld	r31, X
    3188:	62 e0       	ldi	r22, 0x02	; 2
    318a:	70 e0       	ldi	r23, 0x00	; 0
    318c:	00 e0       	ldi	r16, 0x00	; 0
    318e:	09 95       	icall
         MIDI_PROGCHANGE | (chan & MIDI_CHANMASK),
         num & 0x7F,
         0);
}
    3190:	0f 91       	pop	r16
    3192:	08 95       	ret

00003194 <midi_send_channelpressure>:

void midi_send_channelpressure(MidiDevice * device, uint8_t chan, uint8_t amt){
    3194:	0f 93       	push	r16
    3196:	24 2f       	mov	r18, r20
   device->send_func(device, 2,
    3198:	46 2f       	mov	r20, r22
    319a:	4f 70       	andi	r20, 0x0F	; 15
    319c:	40 6d       	ori	r20, 0xD0	; 208
    319e:	2f 77       	andi	r18, 0x7F	; 127
    31a0:	dc 01       	movw	r26, r24
    31a2:	ed 91       	ld	r30, X+
    31a4:	fc 91       	ld	r31, X
    31a6:	62 e0       	ldi	r22, 0x02	; 2
    31a8:	70 e0       	ldi	r23, 0x00	; 0
    31aa:	00 e0       	ldi	r16, 0x00	; 0
    31ac:	09 95       	icall
         MIDI_CHANPRESSURE | (chan & MIDI_CHANMASK),
         amt & 0x7F,
         0);
}
    31ae:	0f 91       	pop	r16
    31b0:	08 95       	ret

000031b2 <midi_send_clock>:

void midi_send_clock(MidiDevice * device){
    31b2:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_CLOCK, 0, 0);
    31b4:	dc 01       	movw	r26, r24
    31b6:	ed 91       	ld	r30, X+
    31b8:	fc 91       	ld	r31, X
    31ba:	61 e0       	ldi	r22, 0x01	; 1
    31bc:	70 e0       	ldi	r23, 0x00	; 0
    31be:	48 ef       	ldi	r20, 0xF8	; 248
    31c0:	20 e0       	ldi	r18, 0x00	; 0
    31c2:	00 e0       	ldi	r16, 0x00	; 0
    31c4:	09 95       	icall
}
    31c6:	0f 91       	pop	r16
    31c8:	08 95       	ret

000031ca <midi_send_tick>:

void midi_send_tick(MidiDevice * device){
    31ca:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_TICK, 0, 0);
    31cc:	dc 01       	movw	r26, r24
    31ce:	ed 91       	ld	r30, X+
    31d0:	fc 91       	ld	r31, X
    31d2:	61 e0       	ldi	r22, 0x01	; 1
    31d4:	70 e0       	ldi	r23, 0x00	; 0
    31d6:	49 ef       	ldi	r20, 0xF9	; 249
    31d8:	20 e0       	ldi	r18, 0x00	; 0
    31da:	00 e0       	ldi	r16, 0x00	; 0
    31dc:	09 95       	icall
}
    31de:	0f 91       	pop	r16
    31e0:	08 95       	ret

000031e2 <midi_send_start>:

void midi_send_start(MidiDevice * device){
    31e2:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_START, 0, 0);
    31e4:	dc 01       	movw	r26, r24
    31e6:	ed 91       	ld	r30, X+
    31e8:	fc 91       	ld	r31, X
    31ea:	61 e0       	ldi	r22, 0x01	; 1
    31ec:	70 e0       	ldi	r23, 0x00	; 0
    31ee:	4a ef       	ldi	r20, 0xFA	; 250
    31f0:	20 e0       	ldi	r18, 0x00	; 0
    31f2:	00 e0       	ldi	r16, 0x00	; 0
    31f4:	09 95       	icall
}
    31f6:	0f 91       	pop	r16
    31f8:	08 95       	ret

000031fa <midi_send_continue>:

void midi_send_continue(MidiDevice * device){
    31fa:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_CONTINUE, 0, 0);
    31fc:	dc 01       	movw	r26, r24
    31fe:	ed 91       	ld	r30, X+
    3200:	fc 91       	ld	r31, X
    3202:	61 e0       	ldi	r22, 0x01	; 1
    3204:	70 e0       	ldi	r23, 0x00	; 0
    3206:	4b ef       	ldi	r20, 0xFB	; 251
    3208:	20 e0       	ldi	r18, 0x00	; 0
    320a:	00 e0       	ldi	r16, 0x00	; 0
    320c:	09 95       	icall
}
    320e:	0f 91       	pop	r16
    3210:	08 95       	ret

00003212 <midi_send_stop>:

void midi_send_stop(MidiDevice * device){
    3212:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_STOP, 0, 0);
    3214:	dc 01       	movw	r26, r24
    3216:	ed 91       	ld	r30, X+
    3218:	fc 91       	ld	r31, X
    321a:	61 e0       	ldi	r22, 0x01	; 1
    321c:	70 e0       	ldi	r23, 0x00	; 0
    321e:	4c ef       	ldi	r20, 0xFC	; 252
    3220:	20 e0       	ldi	r18, 0x00	; 0
    3222:	00 e0       	ldi	r16, 0x00	; 0
    3224:	09 95       	icall
}
    3226:	0f 91       	pop	r16
    3228:	08 95       	ret

0000322a <midi_send_activesense>:

void midi_send_activesense(MidiDevice * device){
    322a:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_ACTIVESENSE, 0, 0);
    322c:	dc 01       	movw	r26, r24
    322e:	ed 91       	ld	r30, X+
    3230:	fc 91       	ld	r31, X
    3232:	61 e0       	ldi	r22, 0x01	; 1
    3234:	70 e0       	ldi	r23, 0x00	; 0
    3236:	4e ef       	ldi	r20, 0xFE	; 254
    3238:	20 e0       	ldi	r18, 0x00	; 0
    323a:	00 e0       	ldi	r16, 0x00	; 0
    323c:	09 95       	icall
}
    323e:	0f 91       	pop	r16
    3240:	08 95       	ret

00003242 <midi_send_reset>:

void midi_send_reset(MidiDevice * device){
    3242:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_RESET, 0, 0);
    3244:	dc 01       	movw	r26, r24
    3246:	ed 91       	ld	r30, X+
    3248:	fc 91       	ld	r31, X
    324a:	61 e0       	ldi	r22, 0x01	; 1
    324c:	70 e0       	ldi	r23, 0x00	; 0
    324e:	4f ef       	ldi	r20, 0xFF	; 255
    3250:	20 e0       	ldi	r18, 0x00	; 0
    3252:	00 e0       	ldi	r16, 0x00	; 0
    3254:	09 95       	icall
}
    3256:	0f 91       	pop	r16
    3258:	08 95       	ret

0000325a <midi_send_tcquarterframe>:

void midi_send_tcquarterframe(MidiDevice * device, uint8_t time){
    325a:	0f 93       	push	r16
   device->send_func(device, 2,
    325c:	26 2f       	mov	r18, r22
    325e:	2f 77       	andi	r18, 0x7F	; 127
    3260:	dc 01       	movw	r26, r24
    3262:	ed 91       	ld	r30, X+
    3264:	fc 91       	ld	r31, X
    3266:	62 e0       	ldi	r22, 0x02	; 2
    3268:	70 e0       	ldi	r23, 0x00	; 0
    326a:	41 ef       	ldi	r20, 0xF1	; 241
    326c:	00 e0       	ldi	r16, 0x00	; 0
    326e:	09 95       	icall
         MIDI_TC_QUARTERFRAME,
         time & 0x7F,
         0);
}
    3270:	0f 91       	pop	r16
    3272:	08 95       	ret

00003274 <midi_send_songposition>:

//XXX is this right?
void midi_send_songposition(MidiDevice * device, uint16_t pos){
    3274:	0f 93       	push	r16
    3276:	1f 93       	push	r17
   device->send_func(device, 3,
    3278:	26 2f       	mov	r18, r22
    327a:	2f 77       	andi	r18, 0x7F	; 127
         MIDI_SONGPOSITION,
         pos & 0x7F,
         (pos >> 7) & 0x7F);
    327c:	8b 01       	movw	r16, r22
    327e:	00 0f       	add	r16, r16
    3280:	01 2f       	mov	r16, r17
    3282:	00 1f       	adc	r16, r16
    3284:	11 0b       	sbc	r17, r17
    3286:	11 95       	neg	r17
         0);
}

//XXX is this right?
void midi_send_songposition(MidiDevice * device, uint16_t pos){
   device->send_func(device, 3,
    3288:	0f 77       	andi	r16, 0x7F	; 127
    328a:	dc 01       	movw	r26, r24
    328c:	ed 91       	ld	r30, X+
    328e:	fc 91       	ld	r31, X
    3290:	63 e0       	ldi	r22, 0x03	; 3
    3292:	70 e0       	ldi	r23, 0x00	; 0
    3294:	42 ef       	ldi	r20, 0xF2	; 242
    3296:	09 95       	icall
         MIDI_SONGPOSITION,
         pos & 0x7F,
         (pos >> 7) & 0x7F);
}
    3298:	1f 91       	pop	r17
    329a:	0f 91       	pop	r16
    329c:	08 95       	ret

0000329e <midi_send_songselect>:

void midi_send_songselect(MidiDevice * device, uint8_t song){
    329e:	0f 93       	push	r16
   device->send_func(device, 2,
    32a0:	26 2f       	mov	r18, r22
    32a2:	2f 77       	andi	r18, 0x7F	; 127
    32a4:	dc 01       	movw	r26, r24
    32a6:	ed 91       	ld	r30, X+
    32a8:	fc 91       	ld	r31, X
    32aa:	62 e0       	ldi	r22, 0x02	; 2
    32ac:	70 e0       	ldi	r23, 0x00	; 0
    32ae:	43 ef       	ldi	r20, 0xF3	; 243
    32b0:	00 e0       	ldi	r16, 0x00	; 0
    32b2:	09 95       	icall
         MIDI_SONGSELECT,
         song & 0x7F,
         0);
}
    32b4:	0f 91       	pop	r16
    32b6:	08 95       	ret

000032b8 <midi_send_tunerequest>:

void midi_send_tunerequest(MidiDevice * device){
    32b8:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_TUNEREQUEST, 0, 0);
    32ba:	dc 01       	movw	r26, r24
    32bc:	ed 91       	ld	r30, X+
    32be:	fc 91       	ld	r31, X
    32c0:	61 e0       	ldi	r22, 0x01	; 1
    32c2:	70 e0       	ldi	r23, 0x00	; 0
    32c4:	46 ef       	ldi	r20, 0xF6	; 246
    32c6:	20 e0       	ldi	r18, 0x00	; 0
    32c8:	00 e0       	ldi	r16, 0x00	; 0
    32ca:	09 95       	icall
}
    32cc:	0f 91       	pop	r16
    32ce:	08 95       	ret

000032d0 <midi_send_byte>:

void midi_send_byte(MidiDevice * device, uint8_t b){
    32d0:	0f 93       	push	r16
    32d2:	46 2f       	mov	r20, r22
   device->send_func(device, 1, b, 0, 0);
    32d4:	dc 01       	movw	r26, r24
    32d6:	ed 91       	ld	r30, X+
    32d8:	fc 91       	ld	r31, X
    32da:	61 e0       	ldi	r22, 0x01	; 1
    32dc:	70 e0       	ldi	r23, 0x00	; 0
    32de:	20 e0       	ldi	r18, 0x00	; 0
    32e0:	00 e0       	ldi	r16, 0x00	; 0
    32e2:	09 95       	icall
}
    32e4:	0f 91       	pop	r16
    32e6:	08 95       	ret

000032e8 <midi_send_data>:

void midi_send_data(MidiDevice * device, uint16_t count, uint8_t byte0, uint8_t byte1, uint8_t byte2){
    32e8:	0f 93       	push	r16
   //ensure that the count passed along is always 3 or lower
   if (count > 3) {
      //TODO how to do this correctly?
   }
   device->send_func(device, count, byte0, byte1, byte2);
    32ea:	dc 01       	movw	r26, r24
    32ec:	ed 91       	ld	r30, X+
    32ee:	fc 91       	ld	r31, X
    32f0:	09 95       	icall
}
    32f2:	0f 91       	pop	r16
    32f4:	08 95       	ret

000032f6 <midi_send_array>:

void midi_send_array(MidiDevice * device, uint16_t count, uint8_t * array) {
    32f6:	6f 92       	push	r6
    32f8:	7f 92       	push	r7
    32fa:	8f 92       	push	r8
    32fc:	9f 92       	push	r9
    32fe:	af 92       	push	r10
    3300:	bf 92       	push	r11
    3302:	cf 92       	push	r12
    3304:	df 92       	push	r13
    3306:	ef 92       	push	r14
    3308:	ff 92       	push	r15
    330a:	0f 93       	push	r16
    330c:	1f 93       	push	r17
    330e:	cf 93       	push	r28
    3310:	df 93       	push	r29
    3312:	00 d0       	rcall	.+0      	; 0x3314 <midi_send_array+0x1e>
    3314:	0f 92       	push	r0
    3316:	cd b7       	in	r28, 0x3d	; 61
    3318:	de b7       	in	r29, 0x3e	; 62
    331a:	4c 01       	movw	r8, r24
    331c:	6b 01       	movw	r12, r22
    331e:	5a 01       	movw	r10, r20
  uint16_t i;
  for (i = 0; i < count; i += 3) {
    3320:	61 15       	cp	r22, r1
    3322:	71 05       	cpc	r23, r1
    3324:	41 f1       	breq	.+80     	; 0x3376 <midi_send_array+0x80>
    3326:	ee 24       	eor	r14, r14
    3328:	ff 24       	eor	r15, r15
    uint8_t b[3] = { 0, 0, 0 };
    uint16_t to_send = count - i;
    to_send = (to_send > 3) ? 3 : to_send;
    332a:	0f 2e       	mov	r0, r31
    332c:	f3 e0       	ldi	r31, 0x03	; 3
    332e:	6f 2e       	mov	r6, r31
    3330:	77 24       	eor	r7, r7
    3332:	f0 2d       	mov	r31, r0
}

void midi_send_array(MidiDevice * device, uint16_t count, uint8_t * array) {
  uint16_t i;
  for (i = 0; i < count; i += 3) {
    uint8_t b[3] = { 0, 0, 0 };
    3334:	19 82       	std	Y+1, r1	; 0x01
    3336:	1a 82       	std	Y+2, r1	; 0x02
    3338:	1b 82       	std	Y+3, r1	; 0x03
    uint16_t to_send = count - i;
    333a:	86 01       	movw	r16, r12
    333c:	0e 19       	sub	r16, r14
    333e:	1f 09       	sbc	r17, r15
    to_send = (to_send > 3) ? 3 : to_send;
    3340:	04 30       	cpi	r16, 0x04	; 4
    3342:	11 05       	cpc	r17, r1
    3344:	08 f0       	brcs	.+2      	; 0x3348 <midi_send_array+0x52>
    3346:	83 01       	movw	r16, r6
      //TODO how to do this correctly?
   }
   device->send_func(device, count, byte0, byte1, byte2);
}

void midi_send_array(MidiDevice * device, uint16_t count, uint8_t * array) {
    3348:	b5 01       	movw	r22, r10
    334a:	6e 0d       	add	r22, r14
    334c:	7f 1d       	adc	r23, r15
  uint16_t i;
  for (i = 0; i < count; i += 3) {
    uint8_t b[3] = { 0, 0, 0 };
    uint16_t to_send = count - i;
    to_send = (to_send > 3) ? 3 : to_send;
    memcpy(b, array + i, to_send);
    334e:	ce 01       	movw	r24, r28
    3350:	01 96       	adiw	r24, 0x01	; 1
    3352:	40 2f       	mov	r20, r16
    3354:	51 2f       	mov	r21, r17
    3356:	0e 94 e2 1e 	call	0x3dc4	; 0x3dc4 <memcpy>
    midi_send_data(device, to_send, b[0], b[1], b[2]);
    335a:	c4 01       	movw	r24, r8
    335c:	b8 01       	movw	r22, r16
    335e:	49 81       	ldd	r20, Y+1	; 0x01
    3360:	2a 81       	ldd	r18, Y+2	; 0x02
    3362:	0b 81       	ldd	r16, Y+3	; 0x03
    3364:	0e 94 74 19 	call	0x32e8	; 0x32e8 <midi_send_data>
   device->send_func(device, count, byte0, byte1, byte2);
}

void midi_send_array(MidiDevice * device, uint16_t count, uint8_t * array) {
  uint16_t i;
  for (i = 0; i < count; i += 3) {
    3368:	83 e0       	ldi	r24, 0x03	; 3
    336a:	90 e0       	ldi	r25, 0x00	; 0
    336c:	e8 0e       	add	r14, r24
    336e:	f9 1e       	adc	r15, r25
    3370:	ec 14       	cp	r14, r12
    3372:	fd 04       	cpc	r15, r13
    3374:	f8 f2       	brcs	.-66     	; 0x3334 <midi_send_array+0x3e>
    uint16_t to_send = count - i;
    to_send = (to_send > 3) ? 3 : to_send;
    memcpy(b, array + i, to_send);
    midi_send_data(device, to_send, b[0], b[1], b[2]);
  }
}
    3376:	0f 90       	pop	r0
    3378:	0f 90       	pop	r0
    337a:	0f 90       	pop	r0
    337c:	df 91       	pop	r29
    337e:	cf 91       	pop	r28
    3380:	1f 91       	pop	r17
    3382:	0f 91       	pop	r16
    3384:	ff 90       	pop	r15
    3386:	ef 90       	pop	r14
    3388:	df 90       	pop	r13
    338a:	cf 90       	pop	r12
    338c:	bf 90       	pop	r11
    338e:	af 90       	pop	r10
    3390:	9f 90       	pop	r9
    3392:	8f 90       	pop	r8
    3394:	7f 90       	pop	r7
    3396:	6f 90       	pop	r6
    3398:	08 95       	ret

0000339a <midi_register_cc_callback>:


void midi_register_cc_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_cc_callback = func;
    339a:	fc 01       	movw	r30, r24
    339c:	73 83       	std	Z+3, r23	; 0x03
    339e:	62 83       	std	Z+2, r22	; 0x02
}
    33a0:	08 95       	ret

000033a2 <midi_register_noteon_callback>:

void midi_register_noteon_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_noteon_callback = func;
    33a2:	fc 01       	movw	r30, r24
    33a4:	75 83       	std	Z+5, r23	; 0x05
    33a6:	64 83       	std	Z+4, r22	; 0x04
}
    33a8:	08 95       	ret

000033aa <midi_register_noteoff_callback>:

void midi_register_noteoff_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_noteoff_callback = func;
    33aa:	fc 01       	movw	r30, r24
    33ac:	77 83       	std	Z+7, r23	; 0x07
    33ae:	66 83       	std	Z+6, r22	; 0x06
}
    33b0:	08 95       	ret

000033b2 <midi_register_aftertouch_callback>:

void midi_register_aftertouch_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_aftertouch_callback = func;
    33b2:	fc 01       	movw	r30, r24
    33b4:	71 87       	std	Z+9, r23	; 0x09
    33b6:	60 87       	std	Z+8, r22	; 0x08
}
    33b8:	08 95       	ret

000033ba <midi_register_pitchbend_callback>:

void midi_register_pitchbend_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_pitchbend_callback = func;
    33ba:	fc 01       	movw	r30, r24
    33bc:	73 87       	std	Z+11, r23	; 0x0b
    33be:	62 87       	std	Z+10, r22	; 0x0a
}
    33c0:	08 95       	ret

000033c2 <midi_register_songposition_callback>:

void midi_register_songposition_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_songposition_callback = func;
    33c2:	fc 01       	movw	r30, r24
    33c4:	75 87       	std	Z+13, r23	; 0x0d
    33c6:	64 87       	std	Z+12, r22	; 0x0c
}
    33c8:	08 95       	ret

000033ca <midi_register_progchange_callback>:

void midi_register_progchange_callback(MidiDevice * device, midi_two_byte_func_t func) {
   device->input_progchange_callback = func;
    33ca:	fc 01       	movw	r30, r24
    33cc:	77 87       	std	Z+15, r23	; 0x0f
    33ce:	66 87       	std	Z+14, r22	; 0x0e
}
    33d0:	08 95       	ret

000033d2 <midi_register_chanpressure_callback>:

void midi_register_chanpressure_callback(MidiDevice * device, midi_two_byte_func_t func) {
   device->input_chanpressure_callback = func;
    33d2:	fc 01       	movw	r30, r24
    33d4:	71 8b       	std	Z+17, r23	; 0x11
    33d6:	60 8b       	std	Z+16, r22	; 0x10
}
    33d8:	08 95       	ret

000033da <midi_register_songselect_callback>:

void midi_register_songselect_callback(MidiDevice * device, midi_two_byte_func_t func) {
   device->input_songselect_callback = func;
    33da:	fc 01       	movw	r30, r24
    33dc:	73 8b       	std	Z+19, r23	; 0x13
    33de:	62 8b       	std	Z+18, r22	; 0x12
}
    33e0:	08 95       	ret

000033e2 <midi_register_tc_quarterframe_callback>:

void midi_register_tc_quarterframe_callback(MidiDevice * device, midi_two_byte_func_t func) {
   device->input_tc_quarterframe_callback = func;
    33e2:	fc 01       	movw	r30, r24
    33e4:	75 8b       	std	Z+21, r23	; 0x15
    33e6:	64 8b       	std	Z+20, r22	; 0x14
}
    33e8:	08 95       	ret

000033ea <midi_register_realtime_callback>:

void midi_register_realtime_callback(MidiDevice * device, midi_one_byte_func_t func){
   device->input_realtime_callback = func;
    33ea:	fc 01       	movw	r30, r24
    33ec:	77 8b       	std	Z+23, r23	; 0x17
    33ee:	66 8b       	std	Z+22, r22	; 0x16
}
    33f0:	08 95       	ret

000033f2 <midi_register_tunerequest_callback>:

void midi_register_tunerequest_callback(MidiDevice * device, midi_one_byte_func_t func){
   device->input_tunerequest_callback = func;
    33f2:	fc 01       	movw	r30, r24
    33f4:	71 8f       	std	Z+25, r23	; 0x19
    33f6:	60 8f       	std	Z+24, r22	; 0x18
}
    33f8:	08 95       	ret

000033fa <midi_register_sysex_callback>:

void midi_register_sysex_callback(MidiDevice * device, midi_sysex_func_t func) {
   device->input_sysex_callback = func;
    33fa:	fc 01       	movw	r30, r24
    33fc:	73 8f       	std	Z+27, r23	; 0x1b
    33fe:	62 8f       	std	Z+26, r22	; 0x1a
}
    3400:	08 95       	ret

00003402 <midi_register_fallthrough_callback>:

void midi_register_fallthrough_callback(MidiDevice * device, midi_var_byte_func_t func){
   device->input_fallthrough_callback = func;
    3402:	fc 01       	movw	r30, r24
    3404:	75 8f       	std	Z+29, r23	; 0x1d
    3406:	64 8f       	std	Z+28, r22	; 0x1c
}
    3408:	08 95       	ret

0000340a <midi_register_catchall_callback>:

void midi_register_catchall_callback(MidiDevice * device, midi_var_byte_func_t func){
   device->input_catchall_callback = func;
    340a:	fc 01       	movw	r30, r24
    340c:	77 8f       	std	Z+31, r23	; 0x1f
    340e:	66 8f       	std	Z+30, r22	; 0x1e
}
    3410:	08 95       	ret

00003412 <midi_device_init>:

//forward declarations, internally used to call the callbacks
void midi_input_callbacks(MidiDevice * device, uint16_t cnt, uint8_t byte0, uint8_t byte1, uint8_t byte2);
void midi_process_byte(MidiDevice * device, uint8_t input);

void midi_device_init(MidiDevice * device){
    3412:	cf 93       	push	r28
    3414:	df 93       	push	r29
    3416:	ec 01       	movw	r28, r24
  device->input_state = IDLE;
    3418:	1d a2       	lds	r17, 0x9d
  device->input_count = 0;
    341a:	1f a2       	lds	r17, 0x9f
    341c:	1e a2       	lds	r17, 0x9e
  bytequeue_init(&device->input_queue, device->input_queue_data, MIDI_INPUT_QUEUE_LENGTH);
    341e:	bc 01       	movw	r22, r24
    3420:	68 5d       	subi	r22, 0xD8	; 216
    3422:	7f 4f       	sbci	r23, 0xFF	; 255
    3424:	88 51       	subi	r24, 0x18	; 24
    3426:	9f 4f       	sbci	r25, 0xFF	; 255
    3428:	40 ec       	ldi	r20, 0xC0	; 192
    342a:	0e 94 83 17 	call	0x2f06	; 0x2f06 <bytequeue_init>

  //three byte funcs
  device->input_cc_callback = NULL;
    342e:	1b 82       	std	Y+3, r1	; 0x03
    3430:	1a 82       	std	Y+2, r1	; 0x02
  device->input_noteon_callback = NULL;
    3432:	1d 82       	std	Y+5, r1	; 0x05
    3434:	1c 82       	std	Y+4, r1	; 0x04
  device->input_noteoff_callback = NULL;
    3436:	1f 82       	std	Y+7, r1	; 0x07
    3438:	1e 82       	std	Y+6, r1	; 0x06
  device->input_aftertouch_callback = NULL;
    343a:	19 86       	std	Y+9, r1	; 0x09
    343c:	18 86       	std	Y+8, r1	; 0x08
  device->input_pitchbend_callback = NULL;
    343e:	1b 86       	std	Y+11, r1	; 0x0b
    3440:	1a 86       	std	Y+10, r1	; 0x0a
  device->input_songposition_callback = NULL;
    3442:	1d 86       	std	Y+13, r1	; 0x0d
    3444:	1c 86       	std	Y+12, r1	; 0x0c

  //two byte funcs
  device->input_progchange_callback = NULL;
    3446:	1f 86       	std	Y+15, r1	; 0x0f
    3448:	1e 86       	std	Y+14, r1	; 0x0e
  device->input_chanpressure_callback = NULL;
    344a:	19 8a       	std	Y+17, r1	; 0x11
    344c:	18 8a       	std	Y+16, r1	; 0x10
  device->input_songselect_callback = NULL;
    344e:	1b 8a       	std	Y+19, r1	; 0x13
    3450:	1a 8a       	std	Y+18, r1	; 0x12
  device->input_tc_quarterframe_callback = NULL;
    3452:	1d 8a       	std	Y+21, r1	; 0x15
    3454:	1c 8a       	std	Y+20, r1	; 0x14

  //one byte funcs
  device->input_realtime_callback = NULL;
    3456:	1f 8a       	std	Y+23, r1	; 0x17
    3458:	1e 8a       	std	Y+22, r1	; 0x16
  device->input_tunerequest_callback = NULL;
    345a:	19 8e       	std	Y+25, r1	; 0x19
    345c:	18 8e       	std	Y+24, r1	; 0x18

  //var byte functions
  device->input_sysex_callback = NULL;
    345e:	1b 8e       	std	Y+27, r1	; 0x1b
    3460:	1a 8e       	std	Y+26, r1	; 0x1a
  device->input_fallthrough_callback = NULL;
    3462:	1d 8e       	std	Y+29, r1	; 0x1d
    3464:	1c 8e       	std	Y+28, r1	; 0x1c
  device->input_catchall_callback = NULL;
    3466:	1f 8e       	std	Y+31, r1	; 0x1f
    3468:	1e 8e       	std	Y+30, r1	; 0x1e

  device->pre_input_process_callback = NULL;
    346a:	19 a2       	lds	r17, 0x99
    346c:	18 a2       	lds	r17, 0x98
}
    346e:	df 91       	pop	r29
    3470:	cf 91       	pop	r28
    3472:	08 95       	ret

00003474 <midi_device_input>:

void midi_device_input(MidiDevice * device, uint8_t cnt, uint8_t * input) {
    3474:	ef 92       	push	r14
    3476:	ff 92       	push	r15
    3478:	0f 93       	push	r16
    347a:	1f 93       	push	r17
    347c:	cf 93       	push	r28
    347e:	df 93       	push	r29
    3480:	d6 2f       	mov	r29, r22
  uint8_t i;
  for (i = 0; i < cnt; i++)
    3482:	66 23       	and	r22, r22
    3484:	99 f0       	breq	.+38     	; 0x34ac <midi_device_input+0x38>
    3486:	04 2f       	mov	r16, r20
    3488:	15 2f       	mov	r17, r21
    348a:	c0 e0       	ldi	r28, 0x00	; 0
    bytequeue_enqueue(&device->input_queue, input[i]);
    348c:	0f 2e       	mov	r0, r31
    348e:	f8 ee       	ldi	r31, 0xE8	; 232
    3490:	ef 2e       	mov	r14, r31
    3492:	ff 24       	eor	r15, r15
    3494:	f0 2d       	mov	r31, r0
    3496:	e8 0e       	add	r14, r24
    3498:	f9 1e       	adc	r15, r25
    349a:	f8 01       	movw	r30, r16
    349c:	61 91       	ld	r22, Z+
    349e:	8f 01       	movw	r16, r30
    34a0:	c7 01       	movw	r24, r14
    34a2:	0e 94 8a 17 	call	0x2f14	; 0x2f14 <bytequeue_enqueue>
  device->pre_input_process_callback = NULL;
}

void midi_device_input(MidiDevice * device, uint8_t cnt, uint8_t * input) {
  uint8_t i;
  for (i = 0; i < cnt; i++)
    34a6:	cf 5f       	subi	r28, 0xFF	; 255
    34a8:	cd 17       	cp	r28, r29
    34aa:	b9 f7       	brne	.-18     	; 0x349a <midi_device_input+0x26>
    bytequeue_enqueue(&device->input_queue, input[i]);
}
    34ac:	df 91       	pop	r29
    34ae:	cf 91       	pop	r28
    34b0:	1f 91       	pop	r17
    34b2:	0f 91       	pop	r16
    34b4:	ff 90       	pop	r15
    34b6:	ef 90       	pop	r14
    34b8:	08 95       	ret

000034ba <midi_device_set_send_func>:

void midi_device_set_send_func(MidiDevice * device, midi_var_byte_func_t send_func){
  device->send_func = send_func;
    34ba:	fc 01       	movw	r30, r24
    34bc:	71 83       	std	Z+1, r23	; 0x01
    34be:	60 83       	st	Z, r22
}
    34c0:	08 95       	ret

000034c2 <midi_device_set_pre_input_process_func>:

void midi_device_set_pre_input_process_func(MidiDevice * device, midi_no_byte_func_t pre_process_func){
  device->pre_input_process_callback = pre_process_func;
    34c2:	fc 01       	movw	r30, r24
    34c4:	71 a3       	lds	r23, 0x51
    34c6:	60 a3       	lds	r22, 0x50
}
    34c8:	08 95       	ret

000034ca <midi_input_callbacks>:
      }
    }
  }
}

void midi_input_callbacks(MidiDevice * device, uint16_t cnt, uint8_t byte0, uint8_t byte1, uint8_t byte2) {
    34ca:	af 92       	push	r10
    34cc:	bf 92       	push	r11
    34ce:	cf 92       	push	r12
    34d0:	df 92       	push	r13
    34d2:	ef 92       	push	r14
    34d4:	ff 92       	push	r15
    34d6:	0f 93       	push	r16
    34d8:	1f 93       	push	r17
    34da:	cf 93       	push	r28
    34dc:	df 93       	push	r29
    34de:	00 d0       	rcall	.+0      	; 0x34e0 <midi_input_callbacks+0x16>
    34e0:	0f 92       	push	r0
    34e2:	cd b7       	in	r28, 0x3d	; 61
    34e4:	de b7       	in	r29, 0x3e	; 62
    34e6:	6c 01       	movw	r12, r24
    34e8:	5b 01       	movw	r10, r22
    34ea:	f4 2e       	mov	r15, r20
    34ec:	e2 2e       	mov	r14, r18
    34ee:	10 2f       	mov	r17, r16
  //did we end up calling a callback?
  bool called = false;
  if (device->input_state == SYSEX_MESSAGE) {
    34f0:	dc 01       	movw	r26, r24
    34f2:	95 96       	adiw	r26, 0x25	; 37
    34f4:	8c 91       	ld	r24, X
    34f6:	95 97       	sbiw	r26, 0x25	; 37
    34f8:	84 30       	cpi	r24, 0x04	; 4
    34fa:	e9 f4       	brne	.+58     	; 0x3536 <midi_input_callbacks+0x6c>
    if (device->input_sysex_callback) {
    34fc:	5a 96       	adiw	r26, 0x1a	; 26
    34fe:	ed 91       	ld	r30, X+
    3500:	fc 91       	ld	r31, X
    3502:	5b 97       	sbiw	r26, 0x1b	; 27
    3504:	30 97       	sbiw	r30, 0x00	; 0
    3506:	09 f4       	brne	.+2      	; 0x350a <midi_input_callbacks+0x40>
    3508:	ee c0       	rjmp	.+476    	; 0x36e6 <midi_input_callbacks+0x21c>
      const uint16_t start = ((cnt - 1) / 3) * 3;
    350a:	cb 01       	movw	r24, r22
    350c:	01 97       	sbiw	r24, 0x01	; 1
    350e:	63 e0       	ldi	r22, 0x03	; 3
    3510:	70 e0       	ldi	r23, 0x00	; 0
    3512:	0e 94 5d 1e 	call	0x3cba	; 0x3cba <__udivmodhi4>
    3516:	cb 01       	movw	r24, r22
    3518:	88 0f       	add	r24, r24
    351a:	99 1f       	adc	r25, r25
    351c:	68 0f       	add	r22, r24
    351e:	79 1f       	adc	r23, r25
      const uint8_t length = (cnt - start);
      uint8_t data[3];
      data[0] = byte0;
    3520:	49 83       	std	Y+1, r20	; 0x01
      data[1] = byte1;
    3522:	2a 83       	std	Y+2, r18	; 0x02
      data[2] = byte2;
    3524:	0b 83       	std	Y+3, r16	; 0x03
  //did we end up calling a callback?
  bool called = false;
  if (device->input_state == SYSEX_MESSAGE) {
    if (device->input_sysex_callback) {
      const uint16_t start = ((cnt - 1) / 3) * 3;
      const uint8_t length = (cnt - start);
    3526:	4a 2d       	mov	r20, r10
    3528:	46 1b       	sub	r20, r22
      uint8_t data[3];
      data[0] = byte0;
      data[1] = byte1;
      data[2] = byte2;
      device->input_sysex_callback(device, start, length, data);
    352a:	c6 01       	movw	r24, r12
    352c:	9e 01       	movw	r18, r28
    352e:	2f 5f       	subi	r18, 0xFF	; 255
    3530:	3f 4f       	sbci	r19, 0xFF	; 255
    3532:	09 95       	icall
    3534:	c8 c0       	rjmp	.+400    	; 0x36c6 <midi_input_callbacks+0x1fc>
      called = true;
    }
  } else {
    switch (cnt) {
    3536:	62 30       	cpi	r22, 0x02	; 2
    3538:	71 05       	cpc	r23, r1
    353a:	09 f4       	brne	.+2      	; 0x353e <midi_input_callbacks+0x74>
    353c:	5f c0       	rjmp	.+190    	; 0x35fc <midi_input_callbacks+0x132>
    353e:	63 30       	cpi	r22, 0x03	; 3
    3540:	71 05       	cpc	r23, r1
    3542:	29 f0       	breq	.+10     	; 0x354e <midi_input_callbacks+0x84>
    3544:	61 30       	cpi	r22, 0x01	; 1
    3546:	71 05       	cpc	r23, r1
    3548:	09 f0       	breq	.+2      	; 0x354c <midi_input_callbacks+0x82>
    354a:	b3 c0       	rjmp	.+358    	; 0x36b2 <midi_input_callbacks+0x1e8>
    354c:	99 c0       	rjmp	.+306    	; 0x3680 <midi_input_callbacks+0x1b6>
      case 3:
        {
          midi_three_byte_func_t func = NULL;
          switch (byte0 & 0xF0) {
    354e:	84 2f       	mov	r24, r20
    3550:	90 e0       	ldi	r25, 0x00	; 0
    3552:	80 7f       	andi	r24, 0xF0	; 240
    3554:	90 70       	andi	r25, 0x00	; 0
    3556:	80 3a       	cpi	r24, 0xA0	; 160
    3558:	91 05       	cpc	r25, r1
    355a:	29 f1       	breq	.+74     	; 0x35a6 <midi_input_callbacks+0xdc>
    355c:	81 3a       	cpi	r24, 0xA1	; 161
    355e:	91 05       	cpc	r25, r1
    3560:	3c f4       	brge	.+14     	; 0x3570 <midi_input_callbacks+0xa6>
    3562:	80 38       	cpi	r24, 0x80	; 128
    3564:	91 05       	cpc	r25, r1
    3566:	c9 f0       	breq	.+50     	; 0x359a <midi_input_callbacks+0xd0>
    3568:	80 39       	cpi	r24, 0x90	; 144
    356a:	91 05       	cpc	r25, r1
    356c:	91 f5       	brne	.+100    	; 0x35d2 <midi_input_callbacks+0x108>
    356e:	0f c0       	rjmp	.+30     	; 0x358e <midi_input_callbacks+0xc4>
    3570:	80 3e       	cpi	r24, 0xE0	; 224
    3572:	91 05       	cpc	r25, r1
    3574:	f1 f0       	breq	.+60     	; 0x35b2 <midi_input_callbacks+0xe8>
    3576:	80 3f       	cpi	r24, 0xF0	; 240
    3578:	91 05       	cpc	r25, r1
    357a:	09 f1       	breq	.+66     	; 0x35be <midi_input_callbacks+0xf4>
    357c:	80 3b       	cpi	r24, 0xB0	; 176
    357e:	91 05       	cpc	r25, r1
    3580:	41 f5       	brne	.+80     	; 0x35d2 <midi_input_callbacks+0x108>
            case MIDI_CC:
              func = device->input_cc_callback;
    3582:	d6 01       	movw	r26, r12
    3584:	12 96       	adiw	r26, 0x02	; 2
    3586:	ed 91       	ld	r30, X+
    3588:	fc 91       	ld	r31, X
    358a:	13 97       	sbiw	r26, 0x03	; 3
              break;
    358c:	24 c0       	rjmp	.+72     	; 0x35d6 <midi_input_callbacks+0x10c>
            case MIDI_NOTEON:
              func = device->input_noteon_callback;
    358e:	d6 01       	movw	r26, r12
    3590:	14 96       	adiw	r26, 0x04	; 4
    3592:	ed 91       	ld	r30, X+
    3594:	fc 91       	ld	r31, X
    3596:	15 97       	sbiw	r26, 0x05	; 5
              break;
    3598:	1e c0       	rjmp	.+60     	; 0x35d6 <midi_input_callbacks+0x10c>
            case MIDI_NOTEOFF:
              func = device->input_noteoff_callback;
    359a:	d6 01       	movw	r26, r12
    359c:	16 96       	adiw	r26, 0x06	; 6
    359e:	ed 91       	ld	r30, X+
    35a0:	fc 91       	ld	r31, X
    35a2:	17 97       	sbiw	r26, 0x07	; 7
              break;
    35a4:	18 c0       	rjmp	.+48     	; 0x35d6 <midi_input_callbacks+0x10c>
            case MIDI_AFTERTOUCH:
              func = device->input_aftertouch_callback;
    35a6:	d6 01       	movw	r26, r12
    35a8:	18 96       	adiw	r26, 0x08	; 8
    35aa:	ed 91       	ld	r30, X+
    35ac:	fc 91       	ld	r31, X
    35ae:	19 97       	sbiw	r26, 0x09	; 9
              break;
    35b0:	12 c0       	rjmp	.+36     	; 0x35d6 <midi_input_callbacks+0x10c>
            case MIDI_PITCHBEND:
              func = device->input_pitchbend_callback;
    35b2:	d6 01       	movw	r26, r12
    35b4:	1a 96       	adiw	r26, 0x0a	; 10
    35b6:	ed 91       	ld	r30, X+
    35b8:	fc 91       	ld	r31, X
    35ba:	1b 97       	sbiw	r26, 0x0b	; 11
              break;
    35bc:	0c c0       	rjmp	.+24     	; 0x35d6 <midi_input_callbacks+0x10c>
            case 0xF0:
              if (byte0 == MIDI_SONGPOSITION)
    35be:	b2 ef       	ldi	r27, 0xF2	; 242
    35c0:	4b 17       	cp	r20, r27
    35c2:	09 f0       	breq	.+2      	; 0x35c6 <midi_input_callbacks+0xfc>
    35c4:	90 c0       	rjmp	.+288    	; 0x36e6 <midi_input_callbacks+0x21c>
                func = device->input_songposition_callback;
    35c6:	d6 01       	movw	r26, r12
    35c8:	1c 96       	adiw	r26, 0x0c	; 12
    35ca:	ed 91       	ld	r30, X+
    35cc:	fc 91       	ld	r31, X
    35ce:	1d 97       	sbiw	r26, 0x0d	; 13
    35d0:	02 c0       	rjmp	.+4      	; 0x35d6 <midi_input_callbacks+0x10c>
    }
  } else {
    switch (cnt) {
      case 3:
        {
          midi_three_byte_func_t func = NULL;
    35d2:	e0 e0       	ldi	r30, 0x00	; 0
    35d4:	f0 e0       	ldi	r31, 0x00	; 0
                func = device->input_songposition_callback;
              break;
            default:
              break;
          }
          if(func) {
    35d6:	30 97       	sbiw	r30, 0x00	; 0
    35d8:	09 f4       	brne	.+2      	; 0x35dc <midi_input_callbacks+0x112>
    35da:	85 c0       	rjmp	.+266    	; 0x36e6 <midi_input_callbacks+0x21c>
            //mask off the channel for non song position functions
            if (byte0 == MIDI_SONGPOSITION)
    35dc:	b2 ef       	ldi	r27, 0xF2	; 242
    35de:	fb 16       	cp	r15, r27
    35e0:	31 f4       	brne	.+12     	; 0x35ee <midi_input_callbacks+0x124>
              func(device, byte0, byte1, byte2);
    35e2:	c6 01       	movw	r24, r12
    35e4:	62 ef       	ldi	r22, 0xF2	; 242
    35e6:	4e 2d       	mov	r20, r14
    35e8:	21 2f       	mov	r18, r17
    35ea:	09 95       	icall
    35ec:	6c c0       	rjmp	.+216    	; 0x36c6 <midi_input_callbacks+0x1fc>
            else
              func(device, byte0 & 0x0F, byte1, byte2);
    35ee:	6f 2d       	mov	r22, r15
    35f0:	6f 70       	andi	r22, 0x0F	; 15
    35f2:	c6 01       	movw	r24, r12
    35f4:	4e 2d       	mov	r20, r14
    35f6:	21 2f       	mov	r18, r17
    35f8:	09 95       	icall
    35fa:	65 c0       	rjmp	.+202    	; 0x36c6 <midi_input_callbacks+0x1fc>
        }
        break;
      case 2:
        {
          midi_two_byte_func_t func = NULL;
          switch (byte0 & 0xF0) {
    35fc:	84 2f       	mov	r24, r20
    35fe:	90 e0       	ldi	r25, 0x00	; 0
    3600:	80 7f       	andi	r24, 0xF0	; 240
    3602:	90 70       	andi	r25, 0x00	; 0
    3604:	80 3d       	cpi	r24, 0xD0	; 208
    3606:	91 05       	cpc	r25, r1
    3608:	61 f0       	breq	.+24     	; 0x3622 <midi_input_callbacks+0x158>
    360a:	80 3f       	cpi	r24, 0xF0	; 240
    360c:	91 05       	cpc	r25, r1
    360e:	79 f0       	breq	.+30     	; 0x362e <midi_input_callbacks+0x164>
    3610:	80 3c       	cpi	r24, 0xC0	; 192
    3612:	91 05       	cpc	r25, r1
    3614:	f9 f4       	brne	.+62     	; 0x3654 <midi_input_callbacks+0x18a>
            case MIDI_PROGCHANGE:
              func = device->input_progchange_callback;
    3616:	d6 01       	movw	r26, r12
    3618:	1e 96       	adiw	r26, 0x0e	; 14
    361a:	ed 91       	ld	r30, X+
    361c:	fc 91       	ld	r31, X
    361e:	1f 97       	sbiw	r26, 0x0f	; 15
              break;
    3620:	1b c0       	rjmp	.+54     	; 0x3658 <midi_input_callbacks+0x18e>
            case MIDI_CHANPRESSURE:
              func = device->input_chanpressure_callback;
    3622:	d6 01       	movw	r26, r12
    3624:	50 96       	adiw	r26, 0x10	; 16
    3626:	ed 91       	ld	r30, X+
    3628:	fc 91       	ld	r31, X
    362a:	51 97       	sbiw	r26, 0x11	; 17
              break;
    362c:	15 c0       	rjmp	.+42     	; 0x3658 <midi_input_callbacks+0x18e>
            case 0xF0:
              if (byte0 == MIDI_SONGSELECT)
    362e:	b3 ef       	ldi	r27, 0xF3	; 243
    3630:	4b 17       	cp	r20, r27
    3632:	31 f4       	brne	.+12     	; 0x3640 <midi_input_callbacks+0x176>
                func = device->input_songselect_callback;
    3634:	d6 01       	movw	r26, r12
    3636:	52 96       	adiw	r26, 0x12	; 18
    3638:	ed 91       	ld	r30, X+
    363a:	fc 91       	ld	r31, X
    363c:	53 97       	sbiw	r26, 0x13	; 19
    363e:	0c c0       	rjmp	.+24     	; 0x3658 <midi_input_callbacks+0x18e>
              else if (byte0 == MIDI_TC_QUARTERFRAME)
    3640:	b1 ef       	ldi	r27, 0xF1	; 241
    3642:	4b 17       	cp	r20, r27
    3644:	09 f0       	breq	.+2      	; 0x3648 <midi_input_callbacks+0x17e>
    3646:	4f c0       	rjmp	.+158    	; 0x36e6 <midi_input_callbacks+0x21c>
                func = device->input_tc_quarterframe_callback;
    3648:	d6 01       	movw	r26, r12
    364a:	54 96       	adiw	r26, 0x14	; 20
    364c:	ed 91       	ld	r30, X+
    364e:	fc 91       	ld	r31, X
    3650:	55 97       	sbiw	r26, 0x15	; 21
    3652:	02 c0       	rjmp	.+4      	; 0x3658 <midi_input_callbacks+0x18e>
          }
        }
        break;
      case 2:
        {
          midi_two_byte_func_t func = NULL;
    3654:	e0 e0       	ldi	r30, 0x00	; 0
    3656:	f0 e0       	ldi	r31, 0x00	; 0
                func = device->input_tc_quarterframe_callback;
              break;
            default:
              break;
          }
          if(func) {
    3658:	30 97       	sbiw	r30, 0x00	; 0
    365a:	09 f4       	brne	.+2      	; 0x365e <midi_input_callbacks+0x194>
    365c:	44 c0       	rjmp	.+136    	; 0x36e6 <midi_input_callbacks+0x21c>
            //mask off the channel
            if (byte0 == MIDI_SONGSELECT || byte0 == MIDI_TC_QUARTERFRAME)
    365e:	b3 ef       	ldi	r27, 0xF3	; 243
    3660:	fb 16       	cp	r15, r27
    3662:	19 f0       	breq	.+6      	; 0x366a <midi_input_callbacks+0x1a0>
    3664:	81 ef       	ldi	r24, 0xF1	; 241
    3666:	f8 16       	cp	r15, r24
    3668:	29 f4       	brne	.+10     	; 0x3674 <midi_input_callbacks+0x1aa>
              func(device, byte0, byte1);
    366a:	c6 01       	movw	r24, r12
    366c:	6f 2d       	mov	r22, r15
    366e:	4e 2d       	mov	r20, r14
    3670:	09 95       	icall
    3672:	29 c0       	rjmp	.+82     	; 0x36c6 <midi_input_callbacks+0x1fc>
            else
              func(device, byte0 & 0x0F, byte1);
    3674:	6f 2d       	mov	r22, r15
    3676:	6f 70       	andi	r22, 0x0F	; 15
    3678:	c6 01       	movw	r24, r12
    367a:	4e 2d       	mov	r20, r14
    367c:	09 95       	icall
    367e:	23 c0       	rjmp	.+70     	; 0x36c6 <midi_input_callbacks+0x1fc>
        }
        break;
      case 1:
        {
          midi_one_byte_func_t func = NULL;
          if (midi_is_realtime(byte0))
    3680:	84 2f       	mov	r24, r20
    3682:	0e 94 02 18 	call	0x3004	; 0x3004 <midi_is_realtime>
    3686:	88 23       	and	r24, r24
    3688:	31 f0       	breq	.+12     	; 0x3696 <midi_input_callbacks+0x1cc>
            func = device->input_realtime_callback;
    368a:	d6 01       	movw	r26, r12
    368c:	56 96       	adiw	r26, 0x16	; 22
    368e:	ed 91       	ld	r30, X+
    3690:	fc 91       	ld	r31, X
    3692:	57 97       	sbiw	r26, 0x17	; 23
    3694:	08 c0       	rjmp	.+16     	; 0x36a6 <midi_input_callbacks+0x1dc>
          else if (byte0 == MIDI_TUNEREQUEST)
    3696:	b6 ef       	ldi	r27, 0xF6	; 246
    3698:	fb 16       	cp	r15, r27
    369a:	29 f5       	brne	.+74     	; 0x36e6 <midi_input_callbacks+0x21c>
            func = device->input_tunerequest_callback;
    369c:	d6 01       	movw	r26, r12
    369e:	58 96       	adiw	r26, 0x18	; 24
    36a0:	ed 91       	ld	r30, X+
    36a2:	fc 91       	ld	r31, X
    36a4:	59 97       	sbiw	r26, 0x19	; 25
          if (func) {
    36a6:	30 97       	sbiw	r30, 0x00	; 0
    36a8:	f1 f0       	breq	.+60     	; 0x36e6 <midi_input_callbacks+0x21c>
            func(device, byte0);
    36aa:	c6 01       	movw	r24, r12
    36ac:	6f 2d       	mov	r22, r15
    36ae:	09 95       	icall
    36b0:	0a c0       	rjmp	.+20     	; 0x36c6 <midi_input_callbacks+0x1fc>
          }
        }
        break;
      default:
        //just in case
        if (cnt > 3)
    36b2:	64 30       	cpi	r22, 0x04	; 4
    36b4:	71 05       	cpc	r23, r1
    36b6:	a8 f4       	brcc	.+42     	; 0x36e2 <midi_input_callbacks+0x218>
    36b8:	16 c0       	rjmp	.+44     	; 0x36e6 <midi_input_callbacks+0x21c>
  }

  //if there is fallthrough default callback and we haven't called a more specific one, 
  //call the fallthrough
  if (!called && device->input_fallthrough_callback)
    device->input_fallthrough_callback(device, cnt, byte0, byte1, byte2);
    36ba:	c6 01       	movw	r24, r12
    36bc:	b5 01       	movw	r22, r10
    36be:	4f 2d       	mov	r20, r15
    36c0:	2e 2d       	mov	r18, r14
    36c2:	01 2f       	mov	r16, r17
    36c4:	09 95       	icall
  //always call the catch all if it exists
  if (device->input_catchall_callback)
    36c6:	d6 01       	movw	r26, r12
    36c8:	5e 96       	adiw	r26, 0x1e	; 30
    36ca:	ed 91       	ld	r30, X+
    36cc:	fc 91       	ld	r31, X
    36ce:	5f 97       	sbiw	r26, 0x1f	; 31
    36d0:	30 97       	sbiw	r30, 0x00	; 0
    36d2:	89 f0       	breq	.+34     	; 0x36f6 <midi_input_callbacks+0x22c>
    device->input_catchall_callback(device, cnt, byte0, byte1, byte2);
    36d4:	c6 01       	movw	r24, r12
    36d6:	b5 01       	movw	r22, r10
    36d8:	4f 2d       	mov	r20, r15
    36da:	2e 2d       	mov	r18, r14
    36dc:	01 2f       	mov	r16, r17
    36de:	09 95       	icall
    36e0:	0a c0       	rjmp	.+20     	; 0x36f6 <midi_input_callbacks+0x22c>
        }
        break;
      default:
        //just in case
        if (cnt > 3)
          cnt = 0;
    36e2:	aa 24       	eor	r10, r10
    36e4:	bb 24       	eor	r11, r11
    }
  }

  //if there is fallthrough default callback and we haven't called a more specific one, 
  //call the fallthrough
  if (!called && device->input_fallthrough_callback)
    36e6:	d6 01       	movw	r26, r12
    36e8:	5c 96       	adiw	r26, 0x1c	; 28
    36ea:	ed 91       	ld	r30, X+
    36ec:	fc 91       	ld	r31, X
    36ee:	5d 97       	sbiw	r26, 0x1d	; 29
    36f0:	30 97       	sbiw	r30, 0x00	; 0
    36f2:	19 f7       	brne	.-58     	; 0x36ba <midi_input_callbacks+0x1f0>
    36f4:	e8 cf       	rjmp	.-48     	; 0x36c6 <midi_input_callbacks+0x1fc>
    device->input_fallthrough_callback(device, cnt, byte0, byte1, byte2);
  //always call the catch all if it exists
  if (device->input_catchall_callback)
    device->input_catchall_callback(device, cnt, byte0, byte1, byte2);
}
    36f6:	0f 90       	pop	r0
    36f8:	0f 90       	pop	r0
    36fa:	0f 90       	pop	r0
    36fc:	df 91       	pop	r29
    36fe:	cf 91       	pop	r28
    3700:	1f 91       	pop	r17
    3702:	0f 91       	pop	r16
    3704:	ff 90       	pop	r15
    3706:	ef 90       	pop	r14
    3708:	df 90       	pop	r13
    370a:	cf 90       	pop	r12
    370c:	bf 90       	pop	r11
    370e:	af 90       	pop	r10
    3710:	08 95       	ret

00003712 <midi_process_byte>:
    midi_process_byte(device, val);
    bytequeue_remove(&device->input_queue, 1);
  }
}

void midi_process_byte(MidiDevice * device, uint8_t input) {
    3712:	ef 92       	push	r14
    3714:	ff 92       	push	r15
    3716:	0f 93       	push	r16
    3718:	cf 93       	push	r28
    371a:	df 93       	push	r29
    371c:	7c 01       	movw	r14, r24
    371e:	c6 2f       	mov	r28, r22
  if (midi_is_realtime(input)) {
    3720:	86 2f       	mov	r24, r22
    3722:	0e 94 02 18 	call	0x3004	; 0x3004 <midi_is_realtime>
    3726:	88 23       	and	r24, r24
    3728:	91 f0       	breq	.+36     	; 0x374e <midi_process_byte+0x3c>
    //call callback, store and restore state
    input_state_t state = device->input_state;
    372a:	d7 01       	movw	r26, r14
    372c:	95 96       	adiw	r26, 0x25	; 37
    372e:	dc 91       	ld	r29, X
    3730:	95 97       	sbiw	r26, 0x25	; 37
    device->input_state = ONE_BYTE_MESSAGE;
    3732:	81 e0       	ldi	r24, 0x01	; 1
    3734:	95 96       	adiw	r26, 0x25	; 37
    3736:	8c 93       	st	X, r24
    midi_input_callbacks(device, 1, input, 0, 0);
    3738:	c7 01       	movw	r24, r14
    373a:	61 e0       	ldi	r22, 0x01	; 1
    373c:	70 e0       	ldi	r23, 0x00	; 0
    373e:	4c 2f       	mov	r20, r28
    3740:	20 e0       	ldi	r18, 0x00	; 0
    3742:	00 e0       	ldi	r16, 0x00	; 0
    3744:	0e 94 65 1a 	call	0x34ca	; 0x34ca <midi_input_callbacks>
    device->input_state = state;
    3748:	f7 01       	movw	r30, r14
    374a:	d5 a3       	lds	r29, 0x55
    374c:	b7 c0       	rjmp	.+366    	; 0x38bc <midi_process_byte+0x1aa>
  } else if (midi_is_statusbyte(input)) {
    374e:	8c 2f       	mov	r24, r28
    3750:	0e 94 fe 17 	call	0x2ffc	; 0x2ffc <midi_is_statusbyte>
    3754:	88 23       	and	r24, r24
    3756:	09 f4       	brne	.+2      	; 0x375a <midi_process_byte+0x48>
    3758:	73 c0       	rjmp	.+230    	; 0x3840 <midi_process_byte+0x12e>
    //store the byte
    if (device->input_state != SYSEX_MESSAGE) {
    375a:	d7 01       	movw	r26, r14
    375c:	95 96       	adiw	r26, 0x25	; 37
    375e:	8c 91       	ld	r24, X
    3760:	95 97       	sbiw	r26, 0x25	; 37
    3762:	84 30       	cpi	r24, 0x04	; 4
    3764:	49 f0       	breq	.+18     	; 0x3778 <midi_process_byte+0x66>
      device->input_buffer[0] = input;
    3766:	92 96       	adiw	r26, 0x22	; 34
    3768:	cc 93       	st	X, r28
    376a:	92 97       	sbiw	r26, 0x22	; 34
      device->input_count = 1;
    376c:	81 e0       	ldi	r24, 0x01	; 1
    376e:	90 e0       	ldi	r25, 0x00	; 0
    3770:	97 96       	adiw	r26, 0x27	; 39
    3772:	9c 93       	st	X, r25
    3774:	8e 93       	st	-X, r24
    3776:	96 97       	sbiw	r26, 0x26	; 38
    }
    switch (midi_packet_length(input)) {
    3778:	8c 2f       	mov	r24, r28
    377a:	0e 94 08 18 	call	0x3010	; 0x3010 <midi_packet_length>
    377e:	81 30       	cpi	r24, 0x01	; 1
    3780:	41 f0       	breq	.+16     	; 0x3792 <midi_process_byte+0x80>
    3782:	81 30       	cpi	r24, 0x01	; 1
    3784:	00 f1       	brcs	.+64     	; 0x37c6 <midi_process_byte+0xb4>
    3786:	82 30       	cpi	r24, 0x02	; 2
    3788:	a1 f0       	breq	.+40     	; 0x37b2 <midi_process_byte+0xa0>
    378a:	83 30       	cpi	r24, 0x03	; 3
    378c:	09 f0       	breq	.+2      	; 0x3790 <midi_process_byte+0x7e>
    378e:	4f c0       	rjmp	.+158    	; 0x382e <midi_process_byte+0x11c>
    3790:	14 c0       	rjmp	.+40     	; 0x37ba <midi_process_byte+0xa8>
      case ONE1:
        device->input_state = ONE_BYTE_MESSAGE;;
    3792:	81 e0       	ldi	r24, 0x01	; 1
    3794:	f7 01       	movw	r30, r14
    3796:	85 a3       	lds	r24, 0x55
        midi_input_callbacks(device, 1, input, 0, 0);
    3798:	c7 01       	movw	r24, r14
    379a:	61 e0       	ldi	r22, 0x01	; 1
    379c:	70 e0       	ldi	r23, 0x00	; 0
    379e:	4c 2f       	mov	r20, r28
    37a0:	20 e0       	ldi	r18, 0x00	; 0
    37a2:	00 e0       	ldi	r16, 0x00	; 0
    37a4:	0e 94 65 1a 	call	0x34ca	; 0x34ca <midi_input_callbacks>
        device->input_state = IDLE;
    37a8:	d7 01       	movw	r26, r14
    37aa:	95 96       	adiw	r26, 0x25	; 37
    37ac:	1c 92       	st	X, r1
    37ae:	95 97       	sbiw	r26, 0x25	; 37
        break;
    37b0:	85 c0       	rjmp	.+266    	; 0x38bc <midi_process_byte+0x1aa>
      case TWO2:
        device->input_state = TWO_BYTE_MESSAGE;
    37b2:	82 e0       	ldi	r24, 0x02	; 2
    37b4:	f7 01       	movw	r30, r14
    37b6:	85 a3       	lds	r24, 0x55
        break;
    37b8:	81 c0       	rjmp	.+258    	; 0x38bc <midi_process_byte+0x1aa>
      case THREE3:
        device->input_state = THREE_BYTE_MESSAGE;
    37ba:	83 e0       	ldi	r24, 0x03	; 3
    37bc:	d7 01       	movw	r26, r14
    37be:	95 96       	adiw	r26, 0x25	; 37
    37c0:	8c 93       	st	X, r24
    37c2:	95 97       	sbiw	r26, 0x25	; 37
        break;
    37c4:	7b c0       	rjmp	.+246    	; 0x38bc <midi_process_byte+0x1aa>
      case UNDEFINED:
        switch(input) {
    37c6:	c0 3f       	cpi	r28, 0xF0	; 240
    37c8:	19 f0       	breq	.+6      	; 0x37d0 <midi_process_byte+0xbe>
    37ca:	c7 3f       	cpi	r28, 0xF7	; 247
    37cc:	59 f5       	brne	.+86     	; 0x3824 <midi_process_byte+0x112>
    37ce:	0a c0       	rjmp	.+20     	; 0x37e4 <midi_process_byte+0xd2>
          case SYSEX_BEGIN:
            device->input_state = SYSEX_MESSAGE;
    37d0:	84 e0       	ldi	r24, 0x04	; 4
    37d2:	f7 01       	movw	r30, r14
    37d4:	85 a3       	lds	r24, 0x55
            device->input_buffer[0] = input;
    37d6:	80 ef       	ldi	r24, 0xF0	; 240
    37d8:	82 a3       	lds	r24, 0x52
            device->input_count = 1;
    37da:	81 e0       	ldi	r24, 0x01	; 1
    37dc:	90 e0       	ldi	r25, 0x00	; 0
    37de:	97 a3       	lds	r25, 0x57
    37e0:	86 a3       	lds	r24, 0x56
            break;
    37e2:	6c c0       	rjmp	.+216    	; 0x38bc <midi_process_byte+0x1aa>
          case SYSEX_END:
            //send what is left in the input buffer, set idle
            device->input_buffer[device->input_count % 3] = input;
    37e4:	d7 01       	movw	r26, r14
    37e6:	96 96       	adiw	r26, 0x26	; 38
    37e8:	2d 91       	ld	r18, X+
    37ea:	3c 91       	ld	r19, X
    37ec:	97 97       	sbiw	r26, 0x27	; 39
    37ee:	c9 01       	movw	r24, r18
    37f0:	63 e0       	ldi	r22, 0x03	; 3
    37f2:	70 e0       	ldi	r23, 0x00	; 0
    37f4:	0e 94 5d 1e 	call	0x3cba	; 0x3cba <__udivmodhi4>
    37f8:	f7 01       	movw	r30, r14
    37fa:	e8 0f       	add	r30, r24
    37fc:	f9 1f       	adc	r31, r25
    37fe:	87 ef       	ldi	r24, 0xF7	; 247
    3800:	82 a3       	lds	r24, 0x52
            device->input_count += 1;
    3802:	b9 01       	movw	r22, r18
    3804:	6f 5f       	subi	r22, 0xFF	; 255
    3806:	7f 4f       	sbci	r23, 0xFF	; 255
    3808:	f7 01       	movw	r30, r14
    380a:	77 a3       	lds	r23, 0x57
    380c:	66 a3       	lds	r22, 0x56
            //call the callback
            midi_input_callbacks(device, device->input_count, 
    380e:	c7 01       	movw	r24, r14
    3810:	42 a1       	lds	r20, 0x42
    3812:	23 a1       	lds	r18, 0x43
    3814:	04 a1       	lds	r16, 0x44
    3816:	0e 94 65 1a 	call	0x34ca	; 0x34ca <midi_input_callbacks>
                device->input_buffer[0], device->input_buffer[1], device->input_buffer[2]);
            device->input_state = IDLE;
    381a:	d7 01       	movw	r26, r14
    381c:	95 96       	adiw	r26, 0x25	; 37
    381e:	1c 92       	st	X, r1
    3820:	95 97       	sbiw	r26, 0x25	; 37
            break;
    3822:	4c c0       	rjmp	.+152    	; 0x38bc <midi_process_byte+0x1aa>
          default:
            device->input_state = IDLE;
    3824:	f7 01       	movw	r30, r14
    3826:	15 a2       	lds	r17, 0x95
            device->input_count = 0;
    3828:	17 a2       	lds	r17, 0x97
    382a:	16 a2       	lds	r17, 0x96
    382c:	47 c0       	rjmp	.+142    	; 0x38bc <midi_process_byte+0x1aa>
        }

        break;
      default:
        device->input_state = IDLE;
    382e:	d7 01       	movw	r26, r14
    3830:	95 96       	adiw	r26, 0x25	; 37
    3832:	1c 92       	st	X, r1
    3834:	95 97       	sbiw	r26, 0x25	; 37
        device->input_count = 0;
    3836:	97 96       	adiw	r26, 0x27	; 39
    3838:	1c 92       	st	X, r1
    383a:	1e 92       	st	-X, r1
    383c:	96 97       	sbiw	r26, 0x26	; 38
        break;
    383e:	3e c0       	rjmp	.+124    	; 0x38bc <midi_process_byte+0x1aa>
    }
  } else {
    if (device->input_state != IDLE) {
    3840:	f7 01       	movw	r30, r14
    3842:	25 a1       	lds	r18, 0x45
    3844:	22 23       	and	r18, r18
    3846:	d1 f1       	breq	.+116    	; 0x38bc <midi_process_byte+0x1aa>
      //store the byte
      device->input_buffer[device->input_count % 3] = input;
    3848:	06 a0       	lds	r16, 0x86
    384a:	f7 a1       	lds	r31, 0x47
    384c:	e0 2d       	mov	r30, r0
    384e:	cf 01       	movw	r24, r30
    3850:	63 e0       	ldi	r22, 0x03	; 3
    3852:	70 e0       	ldi	r23, 0x00	; 0
    3854:	0e 94 5d 1e 	call	0x3cba	; 0x3cba <__udivmodhi4>
    3858:	ac 01       	movw	r20, r24
    385a:	8e 0d       	add	r24, r14
    385c:	9f 1d       	adc	r25, r15
    385e:	dc 01       	movw	r26, r24
    3860:	92 96       	adiw	r26, 0x22	; 34
    3862:	cc 93       	st	X, r28
    3864:	92 97       	sbiw	r26, 0x22	; 34
      //increment count
      uint16_t prev = device->input_count;
      device->input_count += 1;
    3866:	bf 01       	movw	r22, r30
    3868:	6f 5f       	subi	r22, 0xFF	; 255
    386a:	7f 4f       	sbci	r23, 0xFF	; 255
    386c:	f7 01       	movw	r30, r14
    386e:	77 a3       	lds	r23, 0x57
    3870:	66 a3       	lds	r22, 0x56

      switch(prev % 3) {
    3872:	41 30       	cpi	r20, 0x01	; 1
    3874:	51 05       	cpc	r21, r1
    3876:	91 f0       	breq	.+36     	; 0x389c <midi_process_byte+0x18a>
    3878:	42 30       	cpi	r20, 0x02	; 2
    387a:	51 05       	cpc	r21, r1
    387c:	f9 f4       	brne	.+62     	; 0x38bc <midi_process_byte+0x1aa>
        case 2:
          //call callback
          midi_input_callbacks(device, device->input_count,
    387e:	c7 01       	movw	r24, r14
    3880:	42 a1       	lds	r20, 0x42
    3882:	23 a1       	lds	r18, 0x43
    3884:	04 a1       	lds	r16, 0x44
    3886:	0e 94 65 1a 	call	0x34ca	; 0x34ca <midi_input_callbacks>
              device->input_buffer[0], device->input_buffer[1], device->input_buffer[2]);
          if (device->input_state != SYSEX_MESSAGE) {
    388a:	f7 01       	movw	r30, r14
    388c:	85 a1       	lds	r24, 0x45
    388e:	84 30       	cpi	r24, 0x04	; 4
    3890:	a9 f0       	breq	.+42     	; 0x38bc <midi_process_byte+0x1aa>
            //set to 1, keeping status byte, allowing for running status
            device->input_count = 1;
    3892:	81 e0       	ldi	r24, 0x01	; 1
    3894:	90 e0       	ldi	r25, 0x00	; 0
    3896:	97 a3       	lds	r25, 0x57
    3898:	86 a3       	lds	r24, 0x56
    389a:	10 c0       	rjmp	.+32     	; 0x38bc <midi_process_byte+0x1aa>
          }
          break;
        case 1:
          if (device->input_state == TWO_BYTE_MESSAGE) {
    389c:	22 30       	cpi	r18, 0x02	; 2
    389e:	71 f4       	brne	.+28     	; 0x38bc <midi_process_byte+0x1aa>
            //call callback
            midi_input_callbacks(device, device->input_count,
    38a0:	c7 01       	movw	r24, r14
    38a2:	42 a1       	lds	r20, 0x42
    38a4:	23 a1       	lds	r18, 0x43
    38a6:	00 e0       	ldi	r16, 0x00	; 0
    38a8:	0e 94 65 1a 	call	0x34ca	; 0x34ca <midi_input_callbacks>
                device->input_buffer[0], device->input_buffer[1], 0);
            if (device->input_state != SYSEX_MESSAGE) {
    38ac:	f7 01       	movw	r30, r14
    38ae:	85 a1       	lds	r24, 0x45
    38b0:	84 30       	cpi	r24, 0x04	; 4
    38b2:	21 f0       	breq	.+8      	; 0x38bc <midi_process_byte+0x1aa>
              //set to 1, keeping status byte, allowing for running status
              device->input_count = 1;
    38b4:	81 e0       	ldi	r24, 0x01	; 1
    38b6:	90 e0       	ldi	r25, 0x00	; 0
    38b8:	97 a3       	lds	r25, 0x57
    38ba:	86 a3       	lds	r24, 0x56
          //one byte messages are dealt with directly
          break;
      }
    }
  }
}
    38bc:	df 91       	pop	r29
    38be:	cf 91       	pop	r28
    38c0:	0f 91       	pop	r16
    38c2:	ff 90       	pop	r15
    38c4:	ef 90       	pop	r14
    38c6:	08 95       	ret

000038c8 <midi_device_process>:

void midi_device_set_pre_input_process_func(MidiDevice * device, midi_no_byte_func_t pre_process_func){
  device->pre_input_process_callback = pre_process_func;
}

void midi_device_process(MidiDevice * device) {
    38c8:	cf 92       	push	r12
    38ca:	df 92       	push	r13
    38cc:	ef 92       	push	r14
    38ce:	ff 92       	push	r15
    38d0:	0f 93       	push	r16
    38d2:	1f 93       	push	r17
    38d4:	cf 93       	push	r28
    38d6:	df 93       	push	r29
    38d8:	6c 01       	movw	r12, r24
  //call the pre_input_process_callback if there is one
  if(device->pre_input_process_callback)
    38da:	dc 01       	movw	r26, r24
    38dc:	90 96       	adiw	r26, 0x20	; 32
    38de:	ed 91       	ld	r30, X+
    38e0:	fc 91       	ld	r31, X
    38e2:	91 97       	sbiw	r26, 0x21	; 33
    38e4:	30 97       	sbiw	r30, 0x00	; 0
    38e6:	09 f0       	breq	.+2      	; 0x38ea <midi_device_process+0x22>
    device->pre_input_process_callback(device);
    38e8:	09 95       	icall

  //pull stuff off the queue and process
  byteQueueIndex_t len = bytequeue_length(&device->input_queue);
    38ea:	0f 2e       	mov	r0, r31
    38ec:	f8 ee       	ldi	r31, 0xE8	; 232
    38ee:	ef 2e       	mov	r14, r31
    38f0:	ff 24       	eor	r15, r15
    38f2:	f0 2d       	mov	r31, r0
    38f4:	ec 0c       	add	r14, r12
    38f6:	fd 1c       	adc	r15, r13
    38f8:	c7 01       	movw	r24, r14
    38fa:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <bytequeue_length>
  uint16_t i;
  //TODO limit number of bytes processed?
  for(i = 0; i < len; i++) {
    38fe:	c8 2f       	mov	r28, r24
    3900:	d0 e0       	ldi	r29, 0x00	; 0
    3902:	20 97       	sbiw	r28, 0x00	; 0
    3904:	99 f0       	breq	.+38     	; 0x392c <midi_device_process+0x64>
    3906:	00 e0       	ldi	r16, 0x00	; 0
    3908:	10 e0       	ldi	r17, 0x00	; 0
    uint8_t val = bytequeue_get(&device->input_queue, 0);
    390a:	c7 01       	movw	r24, r14
    390c:	60 e0       	ldi	r22, 0x00	; 0
    390e:	0e 94 ce 17 	call	0x2f9c	; 0x2f9c <bytequeue_get>
    3912:	68 2f       	mov	r22, r24
    midi_process_byte(device, val);
    3914:	c6 01       	movw	r24, r12
    3916:	0e 94 89 1b 	call	0x3712	; 0x3712 <midi_process_byte>
    bytequeue_remove(&device->input_queue, 1);
    391a:	c7 01       	movw	r24, r14
    391c:	61 e0       	ldi	r22, 0x01	; 1
    391e:	0e 94 df 17 	call	0x2fbe	; 0x2fbe <bytequeue_remove>

  //pull stuff off the queue and process
  byteQueueIndex_t len = bytequeue_length(&device->input_queue);
  uint16_t i;
  //TODO limit number of bytes processed?
  for(i = 0; i < len; i++) {
    3922:	0f 5f       	subi	r16, 0xFF	; 255
    3924:	1f 4f       	sbci	r17, 0xFF	; 255
    3926:	0c 17       	cp	r16, r28
    3928:	1d 07       	cpc	r17, r29
    392a:	78 f3       	brcs	.-34     	; 0x390a <midi_device_process+0x42>
    uint8_t val = bytequeue_get(&device->input_queue, 0);
    midi_process_byte(device, val);
    bytequeue_remove(&device->input_queue, 1);
  }
}
    392c:	df 91       	pop	r29
    392e:	cf 91       	pop	r28
    3930:	1f 91       	pop	r17
    3932:	0f 91       	pop	r16
    3934:	ff 90       	pop	r15
    3936:	ef 90       	pop	r14
    3938:	df 90       	pop	r13
    393a:	cf 90       	pop	r12
    393c:	08 95       	ret

0000393e <sysex_encoded_length>:
//You should have received a copy of the GNU General Public License
//along with avr-midi.  If not, see <http://www.gnu.org/licenses/>.

#include "sysex_tools.h"

uint16_t sysex_encoded_length(uint16_t decoded_length){
    393e:	9c 01       	movw	r18, r24
   uint8_t remainder = decoded_length % 7;
    3940:	67 e0       	ldi	r22, 0x07	; 7
    3942:	70 e0       	ldi	r23, 0x00	; 0
    3944:	0e 94 5d 1e 	call	0x3cba	; 0x3cba <__udivmodhi4>
    3948:	48 2f       	mov	r20, r24
   if (remainder)
    394a:	88 23       	and	r24, r24
    394c:	81 f0       	breq	.+32     	; 0x396e <sysex_encoded_length+0x30>
      return (decoded_length / 7) * 8 + remainder + 1;
    394e:	c9 01       	movw	r24, r18
    3950:	67 e0       	ldi	r22, 0x07	; 7
    3952:	70 e0       	ldi	r23, 0x00	; 0
    3954:	0e 94 5d 1e 	call	0x3cba	; 0x3cba <__udivmodhi4>
    3958:	cb 01       	movw	r24, r22
    395a:	88 0f       	add	r24, r24
    395c:	99 1f       	adc	r25, r25
    395e:	88 0f       	add	r24, r24
    3960:	99 1f       	adc	r25, r25
    3962:	88 0f       	add	r24, r24
    3964:	99 1f       	adc	r25, r25
    3966:	01 96       	adiw	r24, 0x01	; 1
    3968:	84 0f       	add	r24, r20
    396a:	91 1d       	adc	r25, r1
    396c:	08 95       	ret
   else
      return (decoded_length / 7) * 8;
    396e:	c9 01       	movw	r24, r18
    3970:	67 e0       	ldi	r22, 0x07	; 7
    3972:	70 e0       	ldi	r23, 0x00	; 0
    3974:	0e 94 5d 1e 	call	0x3cba	; 0x3cba <__udivmodhi4>
    3978:	cb 01       	movw	r24, r22
    397a:	88 0f       	add	r24, r24
    397c:	99 1f       	adc	r25, r25
    397e:	88 0f       	add	r24, r24
    3980:	99 1f       	adc	r25, r25
    3982:	88 0f       	add	r24, r24
    3984:	99 1f       	adc	r25, r25
}
    3986:	08 95       	ret

00003988 <sysex_decoded_length>:

uint16_t sysex_decoded_length(uint16_t encoded_length){
   uint8_t remainder = encoded_length % 8;
    3988:	48 2f       	mov	r20, r24
    398a:	47 70       	andi	r20, 0x07	; 7
   if (remainder)
    398c:	a1 f0       	breq	.+40     	; 0x39b6 <sysex_decoded_length+0x2e>
      return (encoded_length / 8) * 7 + remainder - 1;
    398e:	9c 01       	movw	r18, r24
    3990:	36 95       	lsr	r19
    3992:	27 95       	ror	r18
    3994:	36 95       	lsr	r19
    3996:	27 95       	ror	r18
    3998:	36 95       	lsr	r19
    399a:	27 95       	ror	r18
    399c:	c9 01       	movw	r24, r18
    399e:	88 0f       	add	r24, r24
    39a0:	99 1f       	adc	r25, r25
    39a2:	88 0f       	add	r24, r24
    39a4:	99 1f       	adc	r25, r25
    39a6:	88 0f       	add	r24, r24
    39a8:	99 1f       	adc	r25, r25
    39aa:	82 1b       	sub	r24, r18
    39ac:	93 0b       	sbc	r25, r19
    39ae:	01 97       	sbiw	r24, 0x01	; 1
    39b0:	84 0f       	add	r24, r20
    39b2:	91 1d       	adc	r25, r1
    39b4:	08 95       	ret
   else
      return (encoded_length / 8) * 7;
    39b6:	9c 01       	movw	r18, r24
    39b8:	36 95       	lsr	r19
    39ba:	27 95       	ror	r18
    39bc:	36 95       	lsr	r19
    39be:	27 95       	ror	r18
    39c0:	36 95       	lsr	r19
    39c2:	27 95       	ror	r18
    39c4:	c9 01       	movw	r24, r18
    39c6:	88 0f       	add	r24, r24
    39c8:	99 1f       	adc	r25, r25
    39ca:	88 0f       	add	r24, r24
    39cc:	99 1f       	adc	r25, r25
    39ce:	88 0f       	add	r24, r24
    39d0:	99 1f       	adc	r25, r25
    39d2:	82 1b       	sub	r24, r18
    39d4:	93 0b       	sbc	r25, r19
}
    39d6:	08 95       	ret

000039d8 <sysex_encode>:

uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
    39d8:	2f 92       	push	r2
    39da:	3f 92       	push	r3
    39dc:	4f 92       	push	r4
    39de:	5f 92       	push	r5
    39e0:	6f 92       	push	r6
    39e2:	7f 92       	push	r7
    39e4:	8f 92       	push	r8
    39e6:	9f 92       	push	r9
    39e8:	af 92       	push	r10
    39ea:	bf 92       	push	r11
    39ec:	cf 92       	push	r12
    39ee:	df 92       	push	r13
    39f0:	ef 92       	push	r14
    39f2:	ff 92       	push	r15
    39f4:	0f 93       	push	r16
    39f6:	1f 93       	push	r17
    39f8:	cf 93       	push	r28
    39fa:	df 93       	push	r29
    39fc:	00 d0       	rcall	.+0      	; 0x39fe <sysex_encode+0x26>
    39fe:	00 d0       	rcall	.+0      	; 0x3a00 <sysex_encode+0x28>
    3a00:	00 d0       	rcall	.+0      	; 0x3a02 <sysex_encode+0x2a>
    3a02:	cd b7       	in	r28, 0x3d	; 61
    3a04:	de b7       	in	r29, 0x3e	; 62
    3a06:	1c 01       	movw	r2, r24
    3a08:	7a 83       	std	Y+2, r23	; 0x02
    3a0a:	69 83       	std	Y+1, r22	; 0x01
    3a0c:	3a 01       	movw	r6, r20
   uint16_t encoded_full = length / 7; //number of full 8 byte sections from 7 bytes of input
    3a0e:	ca 01       	movw	r24, r20
    3a10:	67 e0       	ldi	r22, 0x07	; 7
    3a12:	70 e0       	ldi	r23, 0x00	; 0
    3a14:	0e 94 5d 1e 	call	0x3cba	; 0x3cba <__udivmodhi4>
    3a18:	2b 01       	movw	r4, r22
    3a1a:	5b 01       	movw	r10, r22
   uint16_t i,j;

   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
    3a1c:	61 15       	cp	r22, r1
    3a1e:	71 05       	cpc	r23, r1
    3a20:	b1 f1       	breq	.+108    	; 0x3a8e <sysex_encode+0xb6>
    3a22:	81 01       	movw	r16, r2
    3a24:	e9 80       	ldd	r14, Y+1	; 0x01
    3a26:	fa 80       	ldd	r15, Y+2	; 0x02
    3a28:	cc 24       	eor	r12, r12
    3a2a:	dd 24       	eor	r13, r13
      uint16_t encoded_msb_idx = i * 8;
      uint16_t input_start_idx = i * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < 7; j++){
    3a2c:	88 24       	eor	r8, r8
    3a2e:	99 24       	eor	r9, r9
      return (encoded_length / 8) * 7 + remainder - 1;
   else
      return (encoded_length / 8) * 7;
}

uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
    3a30:	1e 83       	std	Y+6, r17	; 0x06
    3a32:	0d 83       	std	Y+5, r16	; 0x05

   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t input_start_idx = i * 7;
      encoded[encoded_msb_idx] = 0;
    3a34:	f8 01       	movw	r30, r16
    3a36:	11 92       	st	Z+, r1
      return (encoded_length / 8) * 7 + remainder - 1;
   else
      return (encoded_length / 8) * 7;
}

uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
    3a38:	fc 82       	std	Y+4, r15	; 0x04
    3a3a:	eb 82       	std	Y+3, r14	; 0x03
   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t input_start_idx = i * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < 7; j++){
    3a3c:	a4 01       	movw	r20, r8
         uint8_t current = source[input_start_idx + j];
    3a3e:	ab 81       	ldd	r26, Y+3	; 0x03
    3a40:	bc 81       	ldd	r27, Y+4	; 0x04
    3a42:	2d 91       	ld	r18, X+
    3a44:	bc 83       	std	Y+4, r27	; 0x04
    3a46:	ab 83       	std	Y+3, r26	; 0x03
         encoded[encoded_msb_idx] |= (0x80 & current) >> (1 + j);
    3a48:	4f 5f       	subi	r20, 0xFF	; 255
    3a4a:	5f 4f       	sbci	r21, 0xFF	; 255
    3a4c:	82 2f       	mov	r24, r18
    3a4e:	90 e0       	ldi	r25, 0x00	; 0
    3a50:	80 78       	andi	r24, 0x80	; 128
    3a52:	90 70       	andi	r25, 0x00	; 0
    3a54:	bc 01       	movw	r22, r24
    3a56:	04 2e       	mov	r0, r20
    3a58:	02 c0       	rjmp	.+4      	; 0x3a5e <sysex_encode+0x86>
    3a5a:	75 95       	asr	r23
    3a5c:	67 95       	ror	r22
    3a5e:	0a 94       	dec	r0
    3a60:	e2 f7       	brpl	.-8      	; 0x3a5a <sysex_encode+0x82>
    3a62:	ad 81       	ldd	r26, Y+5	; 0x05
    3a64:	be 81       	ldd	r27, Y+6	; 0x06
    3a66:	8c 91       	ld	r24, X
    3a68:	86 2b       	or	r24, r22
    3a6a:	8c 93       	st	X, r24
         encoded[encoded_msb_idx + 1 + j] = 0x7F & current;
    3a6c:	2f 77       	andi	r18, 0x7F	; 127
    3a6e:	21 93       	st	Z+, r18
   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t input_start_idx = i * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < 7; j++){
    3a70:	47 30       	cpi	r20, 0x07	; 7
    3a72:	51 05       	cpc	r21, r1
    3a74:	21 f7       	brne	.-56     	; 0x3a3e <sysex_encode+0x66>
uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
   uint16_t encoded_full = length / 7; //number of full 8 byte sections from 7 bytes of input
   uint16_t i,j;

   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
    3a76:	08 94       	sec
    3a78:	c1 1c       	adc	r12, r1
    3a7a:	d1 1c       	adc	r13, r1
    3a7c:	08 5f       	subi	r16, 0xF8	; 248
    3a7e:	1f 4f       	sbci	r17, 0xFF	; 255
    3a80:	e7 e0       	ldi	r30, 0x07	; 7
    3a82:	f0 e0       	ldi	r31, 0x00	; 0
    3a84:	ee 0e       	add	r14, r30
    3a86:	ff 1e       	adc	r15, r31
    3a88:	ca 14       	cp	r12, r10
    3a8a:	db 04       	cpc	r13, r11
    3a8c:	89 f6       	brne	.-94     	; 0x3a30 <sysex_encode+0x58>
         encoded[encoded_msb_idx + 1 + j] = 0x7F & current;
      }
   }

   //fill out the rest if there is any more
   uint8_t remainder = length % 7;
    3a8e:	c3 01       	movw	r24, r6
    3a90:	67 e0       	ldi	r22, 0x07	; 7
    3a92:	70 e0       	ldi	r23, 0x00	; 0
    3a94:	0e 94 5d 1e 	call	0x3cba	; 0x3cba <__udivmodhi4>
   if (remainder) {
    3a98:	88 23       	and	r24, r24
    3a9a:	d9 f1       	breq	.+118    	; 0x3b12 <sysex_encode+0x13a>
      uint16_t encoded_msb_idx = encoded_full * 8;
    3a9c:	82 01       	movw	r16, r4
    3a9e:	00 0f       	add	r16, r16
    3aa0:	11 1f       	adc	r17, r17
    3aa2:	00 0f       	add	r16, r16
    3aa4:	11 1f       	adc	r17, r17
    3aa6:	00 0f       	add	r16, r16
    3aa8:	11 1f       	adc	r17, r17
      uint16_t input_start_idx = encoded_full * 7;
    3aaa:	78 01       	movw	r14, r16
    3aac:	e4 18       	sub	r14, r4
    3aae:	f5 08       	sbc	r15, r5
      encoded[encoded_msb_idx] = 0;
    3ab0:	d1 01       	movw	r26, r2
    3ab2:	a0 0f       	add	r26, r16
    3ab4:	b1 1f       	adc	r27, r17
    3ab6:	1c 92       	st	X, r1
      for(j = 0; j < remainder; j++){
    3ab8:	68 2f       	mov	r22, r24
    3aba:	70 e0       	ldi	r23, 0x00	; 0
    3abc:	61 15       	cp	r22, r1
    3abe:	71 05       	cpc	r23, r1
    3ac0:	19 f1       	breq	.+70     	; 0x3b08 <sysex_encode+0x130>
      return (encoded_length / 8) * 7 + remainder - 1;
   else
      return (encoded_length / 8) * 7;
}

uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
    3ac2:	e9 81       	ldd	r30, Y+1	; 0x01
    3ac4:	fa 81       	ldd	r31, Y+2	; 0x02
    3ac6:	ee 0e       	add	r14, r30
    3ac8:	ff 1e       	adc	r15, r31
    3aca:	c8 01       	movw	r24, r16
    3acc:	01 96       	adiw	r24, 0x01	; 1
    3ace:	28 0e       	add	r2, r24
    3ad0:	39 1e       	adc	r3, r25
   uint8_t remainder = length % 7;
   if (remainder) {
      uint16_t encoded_msb_idx = encoded_full * 8;
      uint16_t input_start_idx = encoded_full * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < remainder; j++){
    3ad2:	20 e0       	ldi	r18, 0x00	; 0
    3ad4:	30 e0       	ldi	r19, 0x00	; 0
         uint8_t current = source[input_start_idx + j];
    3ad6:	f7 01       	movw	r30, r14
    3ad8:	41 91       	ld	r20, Z+
    3ada:	7f 01       	movw	r14, r30
         encoded[encoded_msb_idx] |= (0x80 & current) >> (1 + j);
    3adc:	2f 5f       	subi	r18, 0xFF	; 255
    3ade:	3f 4f       	sbci	r19, 0xFF	; 255
    3ae0:	84 2f       	mov	r24, r20
    3ae2:	90 e0       	ldi	r25, 0x00	; 0
    3ae4:	80 78       	andi	r24, 0x80	; 128
    3ae6:	90 70       	andi	r25, 0x00	; 0
    3ae8:	02 2e       	mov	r0, r18
    3aea:	02 c0       	rjmp	.+4      	; 0x3af0 <sysex_encode+0x118>
    3aec:	95 95       	asr	r25
    3aee:	87 95       	ror	r24
    3af0:	0a 94       	dec	r0
    3af2:	e2 f7       	brpl	.-8      	; 0x3aec <sysex_encode+0x114>
    3af4:	9c 91       	ld	r25, X
    3af6:	89 2b       	or	r24, r25
    3af8:	8c 93       	st	X, r24
         encoded[encoded_msb_idx + 1 + j] = 0x7F & current;
    3afa:	4f 77       	andi	r20, 0x7F	; 127
    3afc:	f1 01       	movw	r30, r2
    3afe:	41 93       	st	Z+, r20
    3b00:	1f 01       	movw	r2, r30
   uint8_t remainder = length % 7;
   if (remainder) {
      uint16_t encoded_msb_idx = encoded_full * 8;
      uint16_t input_start_idx = encoded_full * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < remainder; j++){
    3b02:	26 17       	cp	r18, r22
    3b04:	37 07       	cpc	r19, r23
    3b06:	38 f3       	brcs	.-50     	; 0x3ad6 <sysex_encode+0xfe>
         uint8_t current = source[input_start_idx + j];
         encoded[encoded_msb_idx] |= (0x80 & current) >> (1 + j);
         encoded[encoded_msb_idx + 1 + j] = 0x7F & current;
      }
      return encoded_msb_idx + remainder + 1;
    3b08:	c8 01       	movw	r24, r16
    3b0a:	01 96       	adiw	r24, 0x01	; 1
    3b0c:	86 0f       	add	r24, r22
    3b0e:	97 1f       	adc	r25, r23
    3b10:	07 c0       	rjmp	.+14     	; 0x3b20 <sysex_encode+0x148>
   } else {
      return encoded_full * 8;
    3b12:	c2 01       	movw	r24, r4
    3b14:	88 0f       	add	r24, r24
    3b16:	99 1f       	adc	r25, r25
    3b18:	88 0f       	add	r24, r24
    3b1a:	99 1f       	adc	r25, r25
    3b1c:	88 0f       	add	r24, r24
    3b1e:	99 1f       	adc	r25, r25
   }
}
    3b20:	26 96       	adiw	r28, 0x06	; 6
    3b22:	0f b6       	in	r0, 0x3f	; 63
    3b24:	f8 94       	cli
    3b26:	de bf       	out	0x3e, r29	; 62
    3b28:	0f be       	out	0x3f, r0	; 63
    3b2a:	cd bf       	out	0x3d, r28	; 61
    3b2c:	df 91       	pop	r29
    3b2e:	cf 91       	pop	r28
    3b30:	1f 91       	pop	r17
    3b32:	0f 91       	pop	r16
    3b34:	ff 90       	pop	r15
    3b36:	ef 90       	pop	r14
    3b38:	df 90       	pop	r13
    3b3a:	cf 90       	pop	r12
    3b3c:	bf 90       	pop	r11
    3b3e:	af 90       	pop	r10
    3b40:	9f 90       	pop	r9
    3b42:	8f 90       	pop	r8
    3b44:	7f 90       	pop	r7
    3b46:	6f 90       	pop	r6
    3b48:	5f 90       	pop	r5
    3b4a:	4f 90       	pop	r4
    3b4c:	3f 90       	pop	r3
    3b4e:	2f 90       	pop	r2
    3b50:	08 95       	ret

00003b52 <sysex_decode>:

uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
    3b52:	6f 92       	push	r6
    3b54:	7f 92       	push	r7
    3b56:	8f 92       	push	r8
    3b58:	9f 92       	push	r9
    3b5a:	af 92       	push	r10
    3b5c:	bf 92       	push	r11
    3b5e:	cf 92       	push	r12
    3b60:	df 92       	push	r13
    3b62:	ef 92       	push	r14
    3b64:	ff 92       	push	r15
    3b66:	0f 93       	push	r16
    3b68:	1f 93       	push	r17
    3b6a:	cf 93       	push	r28
    3b6c:	df 93       	push	r29
    3b6e:	3c 01       	movw	r6, r24
    3b70:	4b 01       	movw	r8, r22
    3b72:	5a 01       	movw	r10, r20
   uint16_t decoded_full = length / 8;
   uint16_t i,j;

   if (length < 2)
    3b74:	42 30       	cpi	r20, 0x02	; 2
    3b76:	51 05       	cpc	r21, r1
    3b78:	08 f4       	brcc	.+2      	; 0x3b7c <sysex_decode+0x2a>
    3b7a:	6f c0       	rjmp	.+222    	; 0x3c5a <sysex_decode+0x108>
      return encoded_full * 8;
   }
}

uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
   uint16_t decoded_full = length / 8;
    3b7c:	7a 01       	movw	r14, r20
    3b7e:	f6 94       	lsr	r15
    3b80:	e7 94       	ror	r14
    3b82:	f6 94       	lsr	r15
    3b84:	e7 94       	ror	r14
    3b86:	f6 94       	lsr	r15
    3b88:	e7 94       	ror	r14

   if (length < 2)
      return 0;

   //fill out the fully encoded sections
   for(i = 0; i < decoded_full; i++) {
    3b8a:	e1 14       	cp	r14, r1
    3b8c:	f1 04       	cpc	r15, r1
    3b8e:	29 f1       	breq	.+74     	; 0x3bda <sysex_decode+0x88>
    3b90:	eb 01       	movw	r28, r22
    3b92:	b3 01       	movw	r22, r6
    3b94:	00 e0       	ldi	r16, 0x00	; 0
    3b96:	10 e0       	ldi	r17, 0x00	; 0
      uint16_t encoded_msb_idx = i * 8;
      uint16_t output_start_index = i * 7;
      for(j = 0; j < 7; j++){
    3b98:	cc 24       	eor	r12, r12
    3b9a:	dd 24       	eor	r13, r13
   } else {
      return encoded_full * 8;
   }
}

uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
    3b9c:	de 01       	movw	r26, r28
    3b9e:	11 96       	adiw	r26, 0x01	; 1
    3ba0:	fb 01       	movw	r30, r22

   //fill out the fully encoded sections
   for(i = 0; i < decoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t output_start_index = i * 7;
      for(j = 0; j < 7; j++){
    3ba2:	a6 01       	movw	r20, r12
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
    3ba4:	2d 91       	ld	r18, X+
    3ba6:	2f 77       	andi	r18, 0x7F	; 127
    3ba8:	20 83       	st	Z, r18
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
    3baa:	4f 5f       	subi	r20, 0xFF	; 255
    3bac:	5f 4f       	sbci	r21, 0xFF	; 255
    3bae:	88 81       	ld	r24, Y
    3bb0:	90 e0       	ldi	r25, 0x00	; 0
    3bb2:	04 2e       	mov	r0, r20
    3bb4:	02 c0       	rjmp	.+4      	; 0x3bba <sysex_decode+0x68>
    3bb6:	88 0f       	add	r24, r24
    3bb8:	99 1f       	adc	r25, r25
    3bba:	0a 94       	dec	r0
    3bbc:	e2 f7       	brpl	.-8      	; 0x3bb6 <sysex_decode+0x64>
    3bbe:	80 78       	andi	r24, 0x80	; 128
    3bc0:	28 2b       	or	r18, r24
    3bc2:	21 93       	st	Z+, r18

   //fill out the fully encoded sections
   for(i = 0; i < decoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t output_start_index = i * 7;
      for(j = 0; j < 7; j++){
    3bc4:	47 30       	cpi	r20, 0x07	; 7
    3bc6:	51 05       	cpc	r21, r1
    3bc8:	69 f7       	brne	.-38     	; 0x3ba4 <sysex_decode+0x52>

   if (length < 2)
      return 0;

   //fill out the fully encoded sections
   for(i = 0; i < decoded_full; i++) {
    3bca:	0f 5f       	subi	r16, 0xFF	; 255
    3bcc:	1f 4f       	sbci	r17, 0xFF	; 255
    3bce:	28 96       	adiw	r28, 0x08	; 8
    3bd0:	69 5f       	subi	r22, 0xF9	; 249
    3bd2:	7f 4f       	sbci	r23, 0xFF	; 255
    3bd4:	0e 15       	cp	r16, r14
    3bd6:	1f 05       	cpc	r17, r15
    3bd8:	09 f7       	brne	.-62     	; 0x3b9c <sysex_decode+0x4a>
      for(j = 0; j < 7; j++){
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
      }
   }
   uint8_t remainder = length % 8;
    3bda:	5a 2d       	mov	r21, r10
    3bdc:	57 70       	andi	r21, 0x07	; 7
   if (remainder) {
    3bde:	99 f1       	breq	.+102    	; 0x3c46 <sysex_decode+0xf4>
      uint16_t encoded_msb_idx = decoded_full * 8;
    3be0:	e7 01       	movw	r28, r14
    3be2:	cc 0f       	add	r28, r28
    3be4:	dd 1f       	adc	r29, r29
    3be6:	cc 0f       	add	r28, r28
    3be8:	dd 1f       	adc	r29, r29
    3bea:	cc 0f       	add	r28, r28
    3bec:	dd 1f       	adc	r29, r29
      uint16_t output_start_index = decoded_full * 7;
    3bee:	8e 01       	movw	r16, r28
    3bf0:	0e 19       	sub	r16, r14
    3bf2:	1f 09       	sbc	r17, r15
      for(j = 0; j < (remainder - 1); j++) {
    3bf4:	65 2f       	mov	r22, r21
    3bf6:	70 e0       	ldi	r23, 0x00	; 0
    3bf8:	61 50       	subi	r22, 0x01	; 1
    3bfa:	70 40       	sbci	r23, 0x00	; 0
    3bfc:	f9 f0       	breq	.+62     	; 0x3c3c <sysex_decode+0xea>
   } else {
      return encoded_full * 8;
   }
}

uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
    3bfe:	ce 01       	movw	r24, r28
    3c00:	01 96       	adiw	r24, 0x01	; 1
    3c02:	d4 01       	movw	r26, r8
    3c04:	a8 0f       	add	r26, r24
    3c06:	b9 1f       	adc	r27, r25
    3c08:	f3 01       	movw	r30, r6
    3c0a:	e0 0f       	add	r30, r16
    3c0c:	f1 1f       	adc	r31, r17
   }
   uint8_t remainder = length % 8;
   if (remainder) {
      uint16_t encoded_msb_idx = decoded_full * 8;
      uint16_t output_start_index = decoded_full * 7;
      for(j = 0; j < (remainder - 1); j++) {
    3c0e:	20 e0       	ldi	r18, 0x00	; 0
    3c10:	30 e0       	ldi	r19, 0x00	; 0
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
    3c12:	c8 0d       	add	r28, r8
    3c14:	d9 1d       	adc	r29, r9
   uint8_t remainder = length % 8;
   if (remainder) {
      uint16_t encoded_msb_idx = decoded_full * 8;
      uint16_t output_start_index = decoded_full * 7;
      for(j = 0; j < (remainder - 1); j++) {
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
    3c16:	4d 91       	ld	r20, X+
    3c18:	4f 77       	andi	r20, 0x7F	; 127
    3c1a:	40 83       	st	Z, r20
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
    3c1c:	2f 5f       	subi	r18, 0xFF	; 255
    3c1e:	3f 4f       	sbci	r19, 0xFF	; 255
    3c20:	88 81       	ld	r24, Y
    3c22:	90 e0       	ldi	r25, 0x00	; 0
    3c24:	02 2e       	mov	r0, r18
    3c26:	02 c0       	rjmp	.+4      	; 0x3c2c <sysex_decode+0xda>
    3c28:	88 0f       	add	r24, r24
    3c2a:	99 1f       	adc	r25, r25
    3c2c:	0a 94       	dec	r0
    3c2e:	e2 f7       	brpl	.-8      	; 0x3c28 <sysex_decode+0xd6>
    3c30:	80 78       	andi	r24, 0x80	; 128
    3c32:	48 2b       	or	r20, r24
    3c34:	41 93       	st	Z+, r20
   }
   uint8_t remainder = length % 8;
   if (remainder) {
      uint16_t encoded_msb_idx = decoded_full * 8;
      uint16_t output_start_index = decoded_full * 7;
      for(j = 0; j < (remainder - 1); j++) {
    3c36:	26 17       	cp	r18, r22
    3c38:	37 07       	cpc	r19, r23
    3c3a:	68 f3       	brcs	.-38     	; 0x3c16 <sysex_decode+0xc4>
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
      }
      return decoded_full * 7 + remainder - 1;
    3c3c:	c8 01       	movw	r24, r16
    3c3e:	01 97       	sbiw	r24, 0x01	; 1
    3c40:	85 0f       	add	r24, r21
    3c42:	91 1d       	adc	r25, r1
    3c44:	0c c0       	rjmp	.+24     	; 0x3c5e <sysex_decode+0x10c>
   } else {
      return decoded_full * 7;
    3c46:	c7 01       	movw	r24, r14
    3c48:	88 0f       	add	r24, r24
    3c4a:	99 1f       	adc	r25, r25
    3c4c:	88 0f       	add	r24, r24
    3c4e:	99 1f       	adc	r25, r25
    3c50:	88 0f       	add	r24, r24
    3c52:	99 1f       	adc	r25, r25
    3c54:	8e 19       	sub	r24, r14
    3c56:	9f 09       	sbc	r25, r15
    3c58:	02 c0       	rjmp	.+4      	; 0x3c5e <sysex_decode+0x10c>
uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
   uint16_t decoded_full = length / 8;
   uint16_t i,j;

   if (length < 2)
      return 0;
    3c5a:	80 e0       	ldi	r24, 0x00	; 0
    3c5c:	90 e0       	ldi	r25, 0x00	; 0
      }
      return decoded_full * 7 + remainder - 1;
   } else {
      return decoded_full * 7;
   }
}
    3c5e:	df 91       	pop	r29
    3c60:	cf 91       	pop	r28
    3c62:	1f 91       	pop	r17
    3c64:	0f 91       	pop	r16
    3c66:	ff 90       	pop	r15
    3c68:	ef 90       	pop	r14
    3c6a:	df 90       	pop	r13
    3c6c:	cf 90       	pop	r12
    3c6e:	bf 90       	pop	r11
    3c70:	af 90       	pop	r10
    3c72:	9f 90       	pop	r9
    3c74:	8f 90       	pop	r8
    3c76:	7f 90       	pop	r7
    3c78:	6f 90       	pop	r6
    3c7a:	08 95       	ret

00003c7c <__mulsi3>:
    3c7c:	62 9f       	mul	r22, r18
    3c7e:	d0 01       	movw	r26, r0
    3c80:	73 9f       	mul	r23, r19
    3c82:	f0 01       	movw	r30, r0
    3c84:	82 9f       	mul	r24, r18
    3c86:	e0 0d       	add	r30, r0
    3c88:	f1 1d       	adc	r31, r1
    3c8a:	64 9f       	mul	r22, r20
    3c8c:	e0 0d       	add	r30, r0
    3c8e:	f1 1d       	adc	r31, r1
    3c90:	92 9f       	mul	r25, r18
    3c92:	f0 0d       	add	r31, r0
    3c94:	83 9f       	mul	r24, r19
    3c96:	f0 0d       	add	r31, r0
    3c98:	74 9f       	mul	r23, r20
    3c9a:	f0 0d       	add	r31, r0
    3c9c:	65 9f       	mul	r22, r21
    3c9e:	f0 0d       	add	r31, r0
    3ca0:	99 27       	eor	r25, r25
    3ca2:	72 9f       	mul	r23, r18
    3ca4:	b0 0d       	add	r27, r0
    3ca6:	e1 1d       	adc	r30, r1
    3ca8:	f9 1f       	adc	r31, r25
    3caa:	63 9f       	mul	r22, r19
    3cac:	b0 0d       	add	r27, r0
    3cae:	e1 1d       	adc	r30, r1
    3cb0:	f9 1f       	adc	r31, r25
    3cb2:	bd 01       	movw	r22, r26
    3cb4:	cf 01       	movw	r24, r30
    3cb6:	11 24       	eor	r1, r1
    3cb8:	08 95       	ret

00003cba <__udivmodhi4>:
    3cba:	aa 1b       	sub	r26, r26
    3cbc:	bb 1b       	sub	r27, r27
    3cbe:	51 e1       	ldi	r21, 0x11	; 17
    3cc0:	07 c0       	rjmp	.+14     	; 0x3cd0 <__udivmodhi4_ep>

00003cc2 <__udivmodhi4_loop>:
    3cc2:	aa 1f       	adc	r26, r26
    3cc4:	bb 1f       	adc	r27, r27
    3cc6:	a6 17       	cp	r26, r22
    3cc8:	b7 07       	cpc	r27, r23
    3cca:	10 f0       	brcs	.+4      	; 0x3cd0 <__udivmodhi4_ep>
    3ccc:	a6 1b       	sub	r26, r22
    3cce:	b7 0b       	sbc	r27, r23

00003cd0 <__udivmodhi4_ep>:
    3cd0:	88 1f       	adc	r24, r24
    3cd2:	99 1f       	adc	r25, r25
    3cd4:	5a 95       	dec	r21
    3cd6:	a9 f7       	brne	.-22     	; 0x3cc2 <__udivmodhi4_loop>
    3cd8:	80 95       	com	r24
    3cda:	90 95       	com	r25
    3cdc:	bc 01       	movw	r22, r24
    3cde:	cd 01       	movw	r24, r26
    3ce0:	08 95       	ret

00003ce2 <__divmodhi4>:
    3ce2:	97 fb       	bst	r25, 7
    3ce4:	09 2e       	mov	r0, r25
    3ce6:	07 26       	eor	r0, r23
    3ce8:	0a d0       	rcall	.+20     	; 0x3cfe <__divmodhi4_neg1>
    3cea:	77 fd       	sbrc	r23, 7
    3cec:	04 d0       	rcall	.+8      	; 0x3cf6 <__divmodhi4_neg2>
    3cee:	e5 df       	rcall	.-54     	; 0x3cba <__udivmodhi4>
    3cf0:	06 d0       	rcall	.+12     	; 0x3cfe <__divmodhi4_neg1>
    3cf2:	00 20       	and	r0, r0
    3cf4:	1a f4       	brpl	.+6      	; 0x3cfc <__divmodhi4_exit>

00003cf6 <__divmodhi4_neg2>:
    3cf6:	70 95       	com	r23
    3cf8:	61 95       	neg	r22
    3cfa:	7f 4f       	sbci	r23, 0xFF	; 255

00003cfc <__divmodhi4_exit>:
    3cfc:	08 95       	ret

00003cfe <__divmodhi4_neg1>:
    3cfe:	f6 f7       	brtc	.-4      	; 0x3cfc <__divmodhi4_exit>
    3d00:	90 95       	com	r25
    3d02:	81 95       	neg	r24
    3d04:	9f 4f       	sbci	r25, 0xFF	; 255
    3d06:	08 95       	ret

00003d08 <do_random>:
    3d08:	a0 e0       	ldi	r26, 0x00	; 0
    3d0a:	b0 e0       	ldi	r27, 0x00	; 0
    3d0c:	ea e8       	ldi	r30, 0x8A	; 138
    3d0e:	fe e1       	ldi	r31, 0x1E	; 30
    3d10:	0c 94 5b 1f 	jmp	0x3eb6	; 0x3eb6 <__prologue_saves__+0xc>
    3d14:	ec 01       	movw	r28, r24
    3d16:	88 81       	ld	r24, Y
    3d18:	99 81       	ldd	r25, Y+1	; 0x01
    3d1a:	aa 81       	ldd	r26, Y+2	; 0x02
    3d1c:	bb 81       	ldd	r27, Y+3	; 0x03
    3d1e:	00 97       	sbiw	r24, 0x00	; 0
    3d20:	a1 05       	cpc	r26, r1
    3d22:	b1 05       	cpc	r27, r1
    3d24:	21 f4       	brne	.+8      	; 0x3d2e <do_random+0x26>
    3d26:	84 e2       	ldi	r24, 0x24	; 36
    3d28:	99 ed       	ldi	r25, 0xD9	; 217
    3d2a:	ab e5       	ldi	r26, 0x5B	; 91
    3d2c:	b7 e0       	ldi	r27, 0x07	; 7
    3d2e:	bc 01       	movw	r22, r24
    3d30:	cd 01       	movw	r24, r26
    3d32:	2d e1       	ldi	r18, 0x1D	; 29
    3d34:	33 ef       	ldi	r19, 0xF3	; 243
    3d36:	41 e0       	ldi	r20, 0x01	; 1
    3d38:	50 e0       	ldi	r21, 0x00	; 0
    3d3a:	0e 94 3a 1f 	call	0x3e74	; 0x3e74 <__divmodsi4>
    3d3e:	49 01       	movw	r8, r18
    3d40:	5a 01       	movw	r10, r20
    3d42:	27 ea       	ldi	r18, 0xA7	; 167
    3d44:	31 e4       	ldi	r19, 0x41	; 65
    3d46:	40 e0       	ldi	r20, 0x00	; 0
    3d48:	50 e0       	ldi	r21, 0x00	; 0
    3d4a:	0e 94 3e 1e 	call	0x3c7c	; 0x3c7c <__mulsi3>
    3d4e:	6b 01       	movw	r12, r22
    3d50:	7c 01       	movw	r14, r24
    3d52:	c5 01       	movw	r24, r10
    3d54:	b4 01       	movw	r22, r8
    3d56:	2c ee       	ldi	r18, 0xEC	; 236
    3d58:	34 ef       	ldi	r19, 0xF4	; 244
    3d5a:	4f ef       	ldi	r20, 0xFF	; 255
    3d5c:	5f ef       	ldi	r21, 0xFF	; 255
    3d5e:	0e 94 3e 1e 	call	0x3c7c	; 0x3c7c <__mulsi3>
    3d62:	dc 01       	movw	r26, r24
    3d64:	cb 01       	movw	r24, r22
    3d66:	c8 0e       	add	r12, r24
    3d68:	d9 1e       	adc	r13, r25
    3d6a:	ea 1e       	adc	r14, r26
    3d6c:	fb 1e       	adc	r15, r27
    3d6e:	f7 fe       	sbrs	r15, 7
    3d70:	08 c0       	rjmp	.+16     	; 0x3d82 <do_random+0x7a>
    3d72:	8f ef       	ldi	r24, 0xFF	; 255
    3d74:	9f ef       	ldi	r25, 0xFF	; 255
    3d76:	af ef       	ldi	r26, 0xFF	; 255
    3d78:	bf e7       	ldi	r27, 0x7F	; 127
    3d7a:	c8 0e       	add	r12, r24
    3d7c:	d9 1e       	adc	r13, r25
    3d7e:	ea 1e       	adc	r14, r26
    3d80:	fb 1e       	adc	r15, r27
    3d82:	c8 82       	st	Y, r12
    3d84:	d9 82       	std	Y+1, r13	; 0x01
    3d86:	ea 82       	std	Y+2, r14	; 0x02
    3d88:	fb 82       	std	Y+3, r15	; 0x03
    3d8a:	97 01       	movw	r18, r14
    3d8c:	86 01       	movw	r16, r12
    3d8e:	3f 77       	andi	r19, 0x7F	; 127
    3d90:	b8 01       	movw	r22, r16
    3d92:	c9 01       	movw	r24, r18
    3d94:	cd b7       	in	r28, 0x3d	; 61
    3d96:	de b7       	in	r29, 0x3e	; 62
    3d98:	ec e0       	ldi	r30, 0x0C	; 12
    3d9a:	0c 94 77 1f 	jmp	0x3eee	; 0x3eee <__epilogue_restores__+0xc>

00003d9e <random_r>:
    3d9e:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <do_random>
    3da2:	08 95       	ret

00003da4 <random>:
    3da4:	80 eb       	ldi	r24, 0xB0	; 176
    3da6:	92 e0       	ldi	r25, 0x02	; 2
    3da8:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <do_random>
    3dac:	08 95       	ret

00003dae <srandom>:
    3dae:	dc 01       	movw	r26, r24
    3db0:	cb 01       	movw	r24, r22
    3db2:	80 93 b0 02 	sts	0x02B0, r24
    3db6:	90 93 b1 02 	sts	0x02B1, r25
    3dba:	a0 93 b2 02 	sts	0x02B2, r26
    3dbe:	b0 93 b3 02 	sts	0x02B3, r27
    3dc2:	08 95       	ret

00003dc4 <memcpy>:
    3dc4:	fb 01       	movw	r30, r22
    3dc6:	dc 01       	movw	r26, r24
    3dc8:	02 c0       	rjmp	.+4      	; 0x3dce <memcpy+0xa>
    3dca:	01 90       	ld	r0, Z+
    3dcc:	0d 92       	st	X+, r0
    3dce:	41 50       	subi	r20, 0x01	; 1
    3dd0:	50 40       	sbci	r21, 0x00	; 0
    3dd2:	d8 f7       	brcc	.-10     	; 0x3dca <memcpy+0x6>
    3dd4:	08 95       	ret

00003dd6 <memmove>:
    3dd6:	68 17       	cp	r22, r24
    3dd8:	79 07       	cpc	r23, r25
    3dda:	68 f4       	brcc	.+26     	; 0x3df6 <memmove+0x20>
    3ddc:	fb 01       	movw	r30, r22
    3dde:	dc 01       	movw	r26, r24
    3de0:	e4 0f       	add	r30, r20
    3de2:	f5 1f       	adc	r31, r21
    3de4:	a4 0f       	add	r26, r20
    3de6:	b5 1f       	adc	r27, r21
    3de8:	02 c0       	rjmp	.+4      	; 0x3dee <memmove+0x18>
    3dea:	02 90       	ld	r0, -Z
    3dec:	0e 92       	st	-X, r0
    3dee:	41 50       	subi	r20, 0x01	; 1
    3df0:	50 40       	sbci	r21, 0x00	; 0
    3df2:	d8 f7       	brcc	.-10     	; 0x3dea <memmove+0x14>
    3df4:	08 95       	ret
    3df6:	0c 94 e2 1e 	jmp	0x3dc4	; 0x3dc4 <memcpy>

00003dfa <__eerd_block_m6450a>:
    3dfa:	dc 01       	movw	r26, r24
    3dfc:	cb 01       	movw	r24, r22

00003dfe <__eerd_blraw_m6450a>:
    3dfe:	fc 01       	movw	r30, r24
    3e00:	f9 99       	sbic	0x1f, 1	; 31
    3e02:	fe cf       	rjmp	.-4      	; 0x3e00 <__eerd_blraw_m6450a+0x2>
    3e04:	06 c0       	rjmp	.+12     	; 0x3e12 <__eerd_blraw_m6450a+0x14>
    3e06:	f2 bd       	out	0x22, r31	; 34
    3e08:	e1 bd       	out	0x21, r30	; 33
    3e0a:	f8 9a       	sbi	0x1f, 0	; 31
    3e0c:	31 96       	adiw	r30, 0x01	; 1
    3e0e:	00 b4       	in	r0, 0x20	; 32
    3e10:	0d 92       	st	X+, r0
    3e12:	41 50       	subi	r20, 0x01	; 1
    3e14:	50 40       	sbci	r21, 0x00	; 0
    3e16:	b8 f7       	brcc	.-18     	; 0x3e06 <__eerd_blraw_m6450a+0x8>
    3e18:	08 95       	ret

00003e1a <__eerd_word_m6450a>:
    3e1a:	a8 e1       	ldi	r26, 0x18	; 24
    3e1c:	b0 e0       	ldi	r27, 0x00	; 0
    3e1e:	42 e0       	ldi	r20, 0x02	; 2
    3e20:	50 e0       	ldi	r21, 0x00	; 0
    3e22:	0c 94 ff 1e 	jmp	0x3dfe	; 0x3dfe <__eerd_blraw_m6450a>

00003e26 <__eeupd_block_m6450a>:
    3e26:	dc 01       	movw	r26, r24
    3e28:	a4 0f       	add	r26, r20
    3e2a:	b5 1f       	adc	r27, r21
    3e2c:	41 50       	subi	r20, 0x01	; 1
    3e2e:	50 40       	sbci	r21, 0x00	; 0
    3e30:	48 f0       	brcs	.+18     	; 0x3e44 <__eeupd_block_m6450a+0x1e>
    3e32:	cb 01       	movw	r24, r22
    3e34:	84 0f       	add	r24, r20
    3e36:	95 1f       	adc	r25, r21
    3e38:	2e 91       	ld	r18, -X
    3e3a:	0e 94 24 1f 	call	0x3e48	; 0x3e48 <__eeupd_r18_m6450a>
    3e3e:	41 50       	subi	r20, 0x01	; 1
    3e40:	50 40       	sbci	r21, 0x00	; 0
    3e42:	d0 f7       	brcc	.-12     	; 0x3e38 <__eeupd_block_m6450a+0x12>
    3e44:	08 95       	ret

00003e46 <__eeupd_byte_m6450a>:
    3e46:	26 2f       	mov	r18, r22

00003e48 <__eeupd_r18_m6450a>:
    3e48:	f9 99       	sbic	0x1f, 1	; 31
    3e4a:	fe cf       	rjmp	.-4      	; 0x3e48 <__eeupd_r18_m6450a>
    3e4c:	92 bd       	out	0x22, r25	; 34
    3e4e:	81 bd       	out	0x21, r24	; 33
    3e50:	f8 9a       	sbi	0x1f, 0	; 31
    3e52:	01 97       	sbiw	r24, 0x01	; 1
    3e54:	00 b4       	in	r0, 0x20	; 32
    3e56:	02 16       	cp	r0, r18
    3e58:	31 f0       	breq	.+12     	; 0x3e66 <__eeupd_r18_m6450a+0x1e>
    3e5a:	20 bd       	out	0x20, r18	; 32
    3e5c:	0f b6       	in	r0, 0x3f	; 63
    3e5e:	f8 94       	cli
    3e60:	fa 9a       	sbi	0x1f, 2	; 31
    3e62:	f9 9a       	sbi	0x1f, 1	; 31
    3e64:	0f be       	out	0x3f, r0	; 63
    3e66:	08 95       	ret

00003e68 <__eeupd_word_m6450a>:
    3e68:	01 96       	adiw	r24, 0x01	; 1
    3e6a:	27 2f       	mov	r18, r23
    3e6c:	0e 94 24 1f 	call	0x3e48	; 0x3e48 <__eeupd_r18_m6450a>
    3e70:	0c 94 23 1f 	jmp	0x3e46	; 0x3e46 <__eeupd_byte_m6450a>

00003e74 <__divmodsi4>:
    3e74:	97 fb       	bst	r25, 7
    3e76:	09 2e       	mov	r0, r25
    3e78:	05 26       	eor	r0, r21
    3e7a:	0e d0       	rcall	.+28     	; 0x3e98 <__divmodsi4_neg1>
    3e7c:	57 fd       	sbrc	r21, 7
    3e7e:	04 d0       	rcall	.+8      	; 0x3e88 <__divmodsi4_neg2>
    3e80:	4b d0       	rcall	.+150    	; 0x3f18 <__udivmodsi4>
    3e82:	0a d0       	rcall	.+20     	; 0x3e98 <__divmodsi4_neg1>
    3e84:	00 1c       	adc	r0, r0
    3e86:	38 f4       	brcc	.+14     	; 0x3e96 <__divmodsi4_exit>

00003e88 <__divmodsi4_neg2>:
    3e88:	50 95       	com	r21
    3e8a:	40 95       	com	r20
    3e8c:	30 95       	com	r19
    3e8e:	21 95       	neg	r18
    3e90:	3f 4f       	sbci	r19, 0xFF	; 255
    3e92:	4f 4f       	sbci	r20, 0xFF	; 255
    3e94:	5f 4f       	sbci	r21, 0xFF	; 255

00003e96 <__divmodsi4_exit>:
    3e96:	08 95       	ret

00003e98 <__divmodsi4_neg1>:
    3e98:	f6 f7       	brtc	.-4      	; 0x3e96 <__divmodsi4_exit>
    3e9a:	90 95       	com	r25
    3e9c:	80 95       	com	r24
    3e9e:	70 95       	com	r23
    3ea0:	61 95       	neg	r22
    3ea2:	7f 4f       	sbci	r23, 0xFF	; 255
    3ea4:	8f 4f       	sbci	r24, 0xFF	; 255
    3ea6:	9f 4f       	sbci	r25, 0xFF	; 255
    3ea8:	08 95       	ret

00003eaa <__prologue_saves__>:
    3eaa:	2f 92       	push	r2
    3eac:	3f 92       	push	r3
    3eae:	4f 92       	push	r4
    3eb0:	5f 92       	push	r5
    3eb2:	6f 92       	push	r6
    3eb4:	7f 92       	push	r7
    3eb6:	8f 92       	push	r8
    3eb8:	9f 92       	push	r9
    3eba:	af 92       	push	r10
    3ebc:	bf 92       	push	r11
    3ebe:	cf 92       	push	r12
    3ec0:	df 92       	push	r13
    3ec2:	ef 92       	push	r14
    3ec4:	ff 92       	push	r15
    3ec6:	0f 93       	push	r16
    3ec8:	1f 93       	push	r17
    3eca:	cf 93       	push	r28
    3ecc:	df 93       	push	r29
    3ece:	cd b7       	in	r28, 0x3d	; 61
    3ed0:	de b7       	in	r29, 0x3e	; 62
    3ed2:	ca 1b       	sub	r28, r26
    3ed4:	db 0b       	sbc	r29, r27
    3ed6:	0f b6       	in	r0, 0x3f	; 63
    3ed8:	f8 94       	cli
    3eda:	de bf       	out	0x3e, r29	; 62
    3edc:	0f be       	out	0x3f, r0	; 63
    3ede:	cd bf       	out	0x3d, r28	; 61
    3ee0:	09 94       	ijmp

00003ee2 <__epilogue_restores__>:
    3ee2:	2a 88       	ldd	r2, Y+18	; 0x12
    3ee4:	39 88       	ldd	r3, Y+17	; 0x11
    3ee6:	48 88       	ldd	r4, Y+16	; 0x10
    3ee8:	5f 84       	ldd	r5, Y+15	; 0x0f
    3eea:	6e 84       	ldd	r6, Y+14	; 0x0e
    3eec:	7d 84       	ldd	r7, Y+13	; 0x0d
    3eee:	8c 84       	ldd	r8, Y+12	; 0x0c
    3ef0:	9b 84       	ldd	r9, Y+11	; 0x0b
    3ef2:	aa 84       	ldd	r10, Y+10	; 0x0a
    3ef4:	b9 84       	ldd	r11, Y+9	; 0x09
    3ef6:	c8 84       	ldd	r12, Y+8	; 0x08
    3ef8:	df 80       	ldd	r13, Y+7	; 0x07
    3efa:	ee 80       	ldd	r14, Y+6	; 0x06
    3efc:	fd 80       	ldd	r15, Y+5	; 0x05
    3efe:	0c 81       	ldd	r16, Y+4	; 0x04
    3f00:	1b 81       	ldd	r17, Y+3	; 0x03
    3f02:	aa 81       	ldd	r26, Y+2	; 0x02
    3f04:	b9 81       	ldd	r27, Y+1	; 0x01
    3f06:	ce 0f       	add	r28, r30
    3f08:	d1 1d       	adc	r29, r1
    3f0a:	0f b6       	in	r0, 0x3f	; 63
    3f0c:	f8 94       	cli
    3f0e:	de bf       	out	0x3e, r29	; 62
    3f10:	0f be       	out	0x3f, r0	; 63
    3f12:	cd bf       	out	0x3d, r28	; 61
    3f14:	ed 01       	movw	r28, r26
    3f16:	08 95       	ret

00003f18 <__udivmodsi4>:
    3f18:	a1 e2       	ldi	r26, 0x21	; 33
    3f1a:	1a 2e       	mov	r1, r26
    3f1c:	aa 1b       	sub	r26, r26
    3f1e:	bb 1b       	sub	r27, r27
    3f20:	fd 01       	movw	r30, r26
    3f22:	0d c0       	rjmp	.+26     	; 0x3f3e <__udivmodsi4_ep>

00003f24 <__udivmodsi4_loop>:
    3f24:	aa 1f       	adc	r26, r26
    3f26:	bb 1f       	adc	r27, r27
    3f28:	ee 1f       	adc	r30, r30
    3f2a:	ff 1f       	adc	r31, r31
    3f2c:	a2 17       	cp	r26, r18
    3f2e:	b3 07       	cpc	r27, r19
    3f30:	e4 07       	cpc	r30, r20
    3f32:	f5 07       	cpc	r31, r21
    3f34:	20 f0       	brcs	.+8      	; 0x3f3e <__udivmodsi4_ep>
    3f36:	a2 1b       	sub	r26, r18
    3f38:	b3 0b       	sbc	r27, r19
    3f3a:	e4 0b       	sbc	r30, r20
    3f3c:	f5 0b       	sbc	r31, r21

00003f3e <__udivmodsi4_ep>:
    3f3e:	66 1f       	adc	r22, r22
    3f40:	77 1f       	adc	r23, r23
    3f42:	88 1f       	adc	r24, r24
    3f44:	99 1f       	adc	r25, r25
    3f46:	1a 94       	dec	r1
    3f48:	69 f7       	brne	.-38     	; 0x3f24 <__udivmodsi4_loop>
    3f4a:	60 95       	com	r22
    3f4c:	70 95       	com	r23
    3f4e:	80 95       	com	r24
    3f50:	90 95       	com	r25
    3f52:	9b 01       	movw	r18, r22
    3f54:	ac 01       	movw	r20, r24
    3f56:	bd 01       	movw	r22, r26
    3f58:	cf 01       	movw	r24, r30
    3f5a:	08 95       	ret

00003f5c <_exit>:
    3f5c:	f8 94       	cli

00003f5e <__stop_program>:
    3f5e:	ff cf       	rjmp	.-2      	; 0x3f5e <__stop_program>
