
monapollo-firmware.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001b0  00800100  000036b8  0000376c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000036b8  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001b9  008002b0  008002b0  0000391c  2**0
                  ALLOC
  3 .eeprom       00000674  00810000  00810000  0000391c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00000bf4  00000000  00000000  00003f90  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      0000033e  00000000  00000000  00004b84  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 000002c0  00000000  00000000  00004ec8  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00005ab2  00000000  00000000  00005188  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000152d  00000000  00000000  0000ac3a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001e20  00000000  00000000  0000c167  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000c20  00000000  00000000  0000df88  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000017d9  00000000  00000000  0000eba8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002bfb  00000000  00000000  00010381  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000000e0  00000000  00000000  00012f7c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 32 00 	jmp	0x64	; 0x64 <__ctors_end>
       4:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
       8:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
       c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      10:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      14:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      18:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      1c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      20:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      24:	0c 94 80 02 	jmp	0x500	; 0x500 <__vector_9>
      28:	0c 94 41 02 	jmp	0x482	; 0x482 <__vector_10>
      2c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      30:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      34:	0c 94 bb 02 	jmp	0x576	; 0x576 <__vector_13>
      38:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      3c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      40:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      44:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      48:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      4c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      50:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      54:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      58:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      5c:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>
      60:	0c 94 4f 00 	jmp	0x9e	; 0x9e <__bad_interrupt>

00000064 <__ctors_end>:
      64:	11 24       	eor	r1, r1
      66:	1f be       	out	0x3f, r1	; 63
      68:	cf ef       	ldi	r28, 0xFF	; 255
      6a:	d0 e1       	ldi	r29, 0x10	; 16
      6c:	de bf       	out	0x3e, r29	; 62
      6e:	cd bf       	out	0x3d, r28	; 61

00000070 <__do_copy_data>:
      70:	12 e0       	ldi	r17, 0x02	; 2
      72:	a0 e0       	ldi	r26, 0x00	; 0
      74:	b1 e0       	ldi	r27, 0x01	; 1
      76:	e8 eb       	ldi	r30, 0xB8	; 184
      78:	f6 e3       	ldi	r31, 0x36	; 54
      7a:	02 c0       	rjmp	.+4      	; 0x80 <__do_copy_data+0x10>
      7c:	05 90       	lpm	r0, Z+
      7e:	0d 92       	st	X+, r0
      80:	a0 3b       	cpi	r26, 0xB0	; 176
      82:	b1 07       	cpc	r27, r17
      84:	d9 f7       	brne	.-10     	; 0x7c <__do_copy_data+0xc>

00000086 <__do_clear_bss>:
      86:	14 e0       	ldi	r17, 0x04	; 4
      88:	a0 eb       	ldi	r26, 0xB0	; 176
      8a:	b2 e0       	ldi	r27, 0x02	; 2
      8c:	01 c0       	rjmp	.+2      	; 0x90 <.do_clear_bss_start>

0000008e <.do_clear_bss_loop>:
      8e:	1d 92       	st	X+, r1

00000090 <.do_clear_bss_start>:
      90:	a9 36       	cpi	r26, 0x69	; 105
      92:	b1 07       	cpc	r27, r17
      94:	e1 f7       	brne	.-8      	; 0x8e <.do_clear_bss_loop>
      96:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <main>
      9a:	0c 94 5a 1b 	jmp	0x36b4	; 0x36b4 <_exit>

0000009e <__bad_interrupt>:
      9e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a2 <setup_adc>:

void setup_adc(void)
{
	//ADCSRA |= (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0); //set ADC clock to 156.25 KHz for 20 MHz clock
	//ADCSRA |= (1<<ADPS2) | (1<<ADPS1); //set ADC clock to 312.5 KHz for 20 MHz clock
	ADCSRA |= (1<<ADPS2);// | (1<<ADPS0); //set ADC clock to 1.25 MHz for 20 MHz clock
      a2:	ea e7       	ldi	r30, 0x7A	; 122
      a4:	f0 e0       	ldi	r31, 0x00	; 0
      a6:	80 81       	ld	r24, Z
      a8:	84 60       	ori	r24, 0x04	; 4
      aa:	80 83       	st	Z, r24
	ADMUX |= (1<<REFS0); //set ADC reference to AVCC (+5V)
      ac:	ac e7       	ldi	r26, 0x7C	; 124
      ae:	b0 e0       	ldi	r27, 0x00	; 0
      b0:	8c 91       	ld	r24, X
      b2:	80 64       	ori	r24, 0x40	; 64
      b4:	8c 93       	st	X, r24
	
	DIDR0 |= 0x01; //disable digital input buffer for ADC0
      b6:	ae e7       	ldi	r26, 0x7E	; 126
      b8:	b0 e0       	ldi	r27, 0x00	; 0
      ba:	8c 91       	ld	r24, X
      bc:	81 60       	ori	r24, 0x01	; 1
      be:	8c 93       	st	X, r24
	
	ADCSRA |= (1<<ADEN); //enable ADC
      c0:	80 81       	ld	r24, Z
      c2:	80 68       	ori	r24, 0x80	; 128
      c4:	80 83       	st	Z, r24
}
      c6:	08 95       	ret

000000c8 <read_pot>:

uint16_t read_pot(struct potentiometer *pot) {
      c8:	fc 01       	movw	r30, r24
	
	DATA_BUS = pot->channel;
      ca:	83 81       	ldd	r24, Z+3	; 0x03
      cc:	8f 70       	andi	r24, 0x0F	; 15
      ce:	82 b9       	out	0x02, r24	; 2
	POT_MUX &= ~(1<<pot->mux_addr);
      d0:	aa ed       	ldi	r26, 0xDA	; 218
      d2:	b0 e0       	ldi	r27, 0x00	; 0
      d4:	4c 91       	ld	r20, X
      d6:	83 81       	ldd	r24, Z+3	; 0x03
      d8:	82 95       	swap	r24
      da:	8f 70       	andi	r24, 0x0F	; 15
      dc:	87 70       	andi	r24, 0x07	; 7
      de:	21 e0       	ldi	r18, 0x01	; 1
      e0:	30 e0       	ldi	r19, 0x00	; 0
      e2:	b9 01       	movw	r22, r18
      e4:	02 c0       	rjmp	.+4      	; 0xea <read_pot+0x22>
      e6:	66 0f       	add	r22, r22
      e8:	77 1f       	adc	r23, r23
      ea:	8a 95       	dec	r24
      ec:	e2 f7       	brpl	.-8      	; 0xe6 <read_pot+0x1e>
      ee:	cb 01       	movw	r24, r22
      f0:	80 95       	com	r24
      f2:	84 23       	and	r24, r20
      f4:	8c 93       	st	X, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
      f6:	7d e0       	ldi	r23, 0x0D	; 13
      f8:	7a 95       	dec	r23
      fa:	f1 f7       	brne	.-4      	; 0xf8 <read_pot+0x30>
      fc:	00 00       	nop
	_delay_us(2); //ADC settling time. Previously used 10 us, testing 2 us now. Now testing 1 us. See how it sounds. Nope. Needs to 2 us minimum to prevent crosstalk between multiplexer channels
	ADCSRA |= (1<<ADSC); //start ADC conversion
      fe:	aa e7       	ldi	r26, 0x7A	; 122
     100:	b0 e0       	ldi	r27, 0x00	; 0
     102:	8c 91       	ld	r24, X
     104:	80 64       	ori	r24, 0x40	; 64
     106:	8c 93       	st	X, r24
	while ((ADCSRA & (1<<ADSC))); //wait for ADC conversion to complete (13 cycles of ADC clock - 10.4 us for 1.25Mhz clock) - need to figure out what to do with this time - would interrupt be more efficient?
     108:	8c 91       	ld	r24, X
     10a:	86 fd       	sbrc	r24, 6
     10c:	fd cf       	rjmp	.-6      	; 0x108 <read_pot+0x40>
	POT_MUX |= (1<<pot->mux_addr); //disable pot multiplexer
     10e:	aa ed       	ldi	r26, 0xDA	; 218
     110:	b0 e0       	ldi	r27, 0x00	; 0
     112:	4c 91       	ld	r20, X
     114:	83 81       	ldd	r24, Z+3	; 0x03
     116:	82 95       	swap	r24
     118:	8f 70       	andi	r24, 0x0F	; 15
     11a:	87 70       	andi	r24, 0x07	; 7
     11c:	21 e0       	ldi	r18, 0x01	; 1
     11e:	30 e0       	ldi	r19, 0x00	; 0
     120:	b9 01       	movw	r22, r18
     122:	02 c0       	rjmp	.+4      	; 0x128 <read_pot+0x60>
     124:	66 0f       	add	r22, r22
     126:	77 1f       	adc	r23, r23
     128:	8a 95       	dec	r24
     12a:	e2 f7       	brpl	.-8      	; 0x124 <read_pot+0x5c>
     12c:	cb 01       	movw	r24, r22
     12e:	84 2b       	or	r24, r20
     130:	8c 93       	st	X, r24
	//note that ADSC reads HIGH as long as conversion is in progress, goes LOW when conversion is complete
			
			
	uint16_t adc_read = ADCL;
     132:	80 91 78 00 	lds	r24, 0x0078
     136:	90 e0       	ldi	r25, 0x00	; 0
	adc_read = adc_read | (ADCH <<8);
     138:	40 91 79 00 	lds	r20, 0x0079
     13c:	34 2f       	mov	r19, r20
     13e:	20 e0       	ldi	r18, 0x00	; 0
     140:	82 2b       	or	r24, r18
     142:	93 2b       	or	r25, r19
			
	return adc_read;
     144:	08 95       	ret

00000146 <get_current_note>:

uint8_t get_current_note() { //this is a kludge. Either make current_note global or force inline this function? Ask Omar. BUT, this could be where interpolation is calculated!
	
	return current_note;
	
}
     146:	80 91 b0 02 	lds	r24, 0x02B0
     14a:	08 95       	ret

0000014c <new_note>:

void new_note(uint8_t note, uint8_t velocity) {
     14c:	0f 93       	push	r16
     14e:	1f 93       	push	r17
     150:	cf 93       	push	r28
     152:	df 93       	push	r29
     154:	18 2f       	mov	r17, r24
     156:	06 2f       	mov	r16, r22
	
	
	//shift contents of note_pool right by one element
	memmove(note_pool + 1, note_pool, sizeof(note_pool) -sizeof(*note_pool)); //last argument: sizeof struct - sizeof one element of struct. See http://www.cplusplus.com/forum/beginner/1936/
     158:	8a eb       	ldi	r24, 0xBA	; 186
     15a:	91 e0       	ldi	r25, 0x01	; 1
     15c:	ec 01       	movw	r28, r24
     15e:	22 97       	sbiw	r28, 0x02	; 2
     160:	be 01       	movw	r22, r28
     162:	4e e0       	ldi	r20, 0x0E	; 14
     164:	50 e0       	ldi	r21, 0x00	; 0
     166:	0e 94 0b 1b 	call	0x3616	; 0x3616 <memmove>
	
	//add new note to pool
	note_pool[0].note = note;
     16a:	18 83       	st	Y, r17
	note_pool[0].velocity = velocity;
     16c:	09 83       	std	Y+1, r16	; 0x01
	
	current_note = note; //set current note
     16e:	10 93 b0 02 	sts	0x02B0, r17
	
} 
     172:	df 91       	pop	r29
     174:	cf 91       	pop	r28
     176:	1f 91       	pop	r17
     178:	0f 91       	pop	r16
     17a:	08 95       	ret

0000017c <remove_note>:
void remove_note(uint8_t note){
     17c:	cf 93       	push	r28
	
	uint8_t free_slot = 0;
	uint8_t temp_note = note_pool[0].note; //holder for current note
     17e:	c0 91 b8 01 	lds	r28, 0x01B8
	for (int i = 0; i <= 7; i++) { //search for note in note stack
		
		if (note_pool[i].note == note) {
     182:	c8 17       	cp	r28, r24
     184:	41 f0       	breq	.+16     	; 0x196 <remove_note+0x1a>
     186:	ea eb       	ldi	r30, 0xBA	; 186
     188:	f1 e0       	ldi	r31, 0x01	; 1
} 
void remove_note(uint8_t note){
	
	uint8_t free_slot = 0;
	uint8_t temp_note = note_pool[0].note; //holder for current note
	for (int i = 0; i <= 7; i++) { //search for note in note stack
     18a:	41 e0       	ldi	r20, 0x01	; 1
     18c:	50 e0       	ldi	r21, 0x00	; 0
		
		if (note_pool[i].note == note) {
     18e:	90 81       	ld	r25, Z
     190:	98 17       	cp	r25, r24
     192:	59 f4       	brne	.+22     	; 0x1aa <remove_note+0x2e>
     194:	02 c0       	rjmp	.+4      	; 0x19a <remove_note+0x1e>
} 
void remove_note(uint8_t note){
	
	uint8_t free_slot = 0;
	uint8_t temp_note = note_pool[0].note; //holder for current note
	for (int i = 0; i <= 7; i++) { //search for note in note stack
     196:	40 e0       	ldi	r20, 0x00	; 0
     198:	50 e0       	ldi	r21, 0x00	; 0
		
		if (note_pool[i].note == note) {
			
			note_pool[i].note = EMPTY;
     19a:	fa 01       	movw	r30, r20
     19c:	ee 0f       	add	r30, r30
     19e:	ff 1f       	adc	r31, r31
     1a0:	e8 54       	subi	r30, 0x48	; 72
     1a2:	fe 4f       	sbci	r31, 0xFE	; 254
     1a4:	8f ef       	ldi	r24, 0xFF	; 255
     1a6:	80 83       	st	Z, r24
			free_slot = i;
			break;
     1a8:	07 c0       	rjmp	.+14     	; 0x1b8 <remove_note+0x3c>
} 
void remove_note(uint8_t note){
	
	uint8_t free_slot = 0;
	uint8_t temp_note = note_pool[0].note; //holder for current note
	for (int i = 0; i <= 7; i++) { //search for note in note stack
     1aa:	4f 5f       	subi	r20, 0xFF	; 255
     1ac:	5f 4f       	sbci	r21, 0xFF	; 255
     1ae:	32 96       	adiw	r30, 0x02	; 2
     1b0:	48 30       	cpi	r20, 0x08	; 8
     1b2:	51 05       	cpc	r21, r1
     1b4:	61 f7       	brne	.-40     	; 0x18e <remove_note+0x12>
	current_note = note; //set current note
	
} 
void remove_note(uint8_t note){
	
	uint8_t free_slot = 0;
     1b6:	40 e0       	ldi	r20, 0x00	; 0
		
	}
	
	
	//now shift elements left	
	memmove(note_pool + free_slot, note_pool + free_slot + 1, sizeof(note_pool) - (sizeof(*note_pool)*(free_slot + 1)));
     1b8:	50 e0       	ldi	r21, 0x00	; 0
     1ba:	ca 01       	movw	r24, r20
     1bc:	88 0f       	add	r24, r24
     1be:	99 1f       	adc	r25, r25
     1c0:	bc 01       	movw	r22, r24
     1c2:	66 54       	subi	r22, 0x46	; 70
     1c4:	7e 4f       	sbci	r23, 0xFE	; 254
     1c6:	40 95       	com	r20
     1c8:	50 95       	com	r21
     1ca:	48 5f       	subi	r20, 0xF8	; 248
     1cc:	5f 4f       	sbci	r21, 0xFF	; 255
     1ce:	44 0f       	add	r20, r20
     1d0:	55 1f       	adc	r21, r21
     1d2:	88 54       	subi	r24, 0x48	; 72
     1d4:	9e 4f       	sbci	r25, 0xFE	; 254
     1d6:	0e 94 0b 1b 	call	0x3616	; 0x3616 <memmove>
	note_pool[7].note = EMPTY;	
     1da:	8f ef       	ldi	r24, 0xFF	; 255
     1dc:	80 93 c6 01 	sts	0x01C6, r24
	
	//check to see if this is the last note released		
	//if it is, this might be a good place to ensure gate_buffer is empty
	if (note_pool[0].note == EMPTY) {
     1e0:	80 91 b8 01 	lds	r24, 0x01B8
     1e4:	8f 3f       	cpi	r24, 0xFF	; 255
     1e6:	19 f4       	brne	.+6      	; 0x1ee <remove_note+0x72>
		
		current_note = temp_note; //store last note released for maintaining pitch during envelope release stage
     1e8:	c0 93 b0 02 	sts	0x02B0, r28
     1ec:	02 c0       	rjmp	.+4      	; 0x1f2 <remove_note+0x76>
		
	} else {		
		
		current_note = note_pool[0].note; //otherwise, the current note is the next one in the note stack
     1ee:	80 93 b0 02 	sts	0x02B0, r24

	}	
	
}
     1f2:	cf 91       	pop	r28
     1f4:	08 95       	ret

000001f6 <set_control_voltage>:
struct control_voltage sustain_2_cv		={SUSTAIN_2,	DAC_MUX_EN3};
struct control_voltage sustain_1_cv		={SUSTAIN_1,	DAC_MUX_EN3};
struct control_voltage release_2_cv		={RELEASE_2,	DAC_MUX_EN3};
struct control_voltage release_1_cv		={RELEASE_1,	DAC_MUX_EN3};		

void set_control_voltage (struct control_voltage * cv, uint16_t value) {
     1f6:	dc 01       	movw	r26, r24

	DAC_BUS_LOW = value & 0b00000011111111; //mask top 6 MSBs to set low byte
     1f8:	6b b9       	out	0x0b, r22	; 11
	
	DAC_BUS_HIGH = value >> 8; //shift away bottom LSBs to set high byte
     1fa:	78 b9       	out	0x08, r23	; 8
	
	DAC_CTRL &= ~(1<<DAC_WR); //write DATA
     1fc:	a0 98       	cbi	0x14, 0	; 20
	DAC_CTRL |= (1<<DAC_WR);	
     1fe:	a0 9a       	sbi	0x14, 0	; 20

	DATA_BUS = cv->channel; //set channel for DG408 multiplexer output
     200:	8c 91       	ld	r24, X
     202:	87 70       	andi	r24, 0x07	; 7
     204:	82 b9       	out	0x02, r24	; 2
     206:	66 e0       	ldi	r22, 0x06	; 6
     208:	6a 95       	dec	r22
     20a:	f1 f7       	brne	.-4      	; 0x208 <set_control_voltage+0x12>
     20c:	00 c0       	rjmp	.+0      	; 0x20e <set_control_voltage+0x18>

	_delay_us(1); //AD5556 DAC has 0.5 us settling time. 1 us wasn't long enough for transitions from 10V to 0V
	DAC_MUX |= (1<<cv->mux_addr); //enable multiplexer
     20e:	ea ed       	ldi	r30, 0xDA	; 218
     210:	f0 e0       	ldi	r31, 0x00	; 0
     212:	40 81       	ld	r20, Z
     214:	8c 91       	ld	r24, X
     216:	86 95       	lsr	r24
     218:	86 95       	lsr	r24
     21a:	86 95       	lsr	r24
     21c:	87 70       	andi	r24, 0x07	; 7
     21e:	21 e0       	ldi	r18, 0x01	; 1
     220:	30 e0       	ldi	r19, 0x00	; 0
     222:	b9 01       	movw	r22, r18
     224:	02 c0       	rjmp	.+4      	; 0x22a <set_control_voltage+0x34>
     226:	66 0f       	add	r22, r22
     228:	77 1f       	adc	r23, r23
     22a:	8a 95       	dec	r24
     22c:	e2 f7       	brpl	.-8      	; 0x226 <set_control_voltage+0x30>
     22e:	cb 01       	movw	r24, r22
     230:	84 2b       	or	r24, r20
     232:	80 83       	st	Z, r24
     234:	76 e0       	ldi	r23, 0x06	; 6
     236:	7a 95       	dec	r23
     238:	f1 f7       	brne	.-4      	; 0x236 <set_control_voltage+0x40>
     23a:	00 c0       	rjmp	.+0      	; 0x23c <set_control_voltage+0x46>
	_delay_us(1); //wait for S&H cap to charge - need to figure out how to do this more time efficiently
	DAC_MUX &= ~(1<<cv->mux_addr); //disable multiplexer
     23c:	80 81       	ld	r24, Z
     23e:	9c 91       	ld	r25, X
     240:	96 95       	lsr	r25
     242:	96 95       	lsr	r25
     244:	96 95       	lsr	r25
     246:	97 70       	andi	r25, 0x07	; 7
     248:	02 c0       	rjmp	.+4      	; 0x24e <set_control_voltage+0x58>
     24a:	22 0f       	add	r18, r18
     24c:	33 1f       	adc	r19, r19
     24e:	9a 95       	dec	r25
     250:	e2 f7       	brpl	.-8      	; 0x24a <set_control_voltage+0x54>
     252:	20 95       	com	r18
     254:	28 23       	and	r18, r24
     256:	20 83       	st	Z, r18
	
}	
     258:	08 95       	ret

0000025a <setup_dac>:

	
void setup_dac(void) //set up DAC
{
	DDRG |= (1<<DAC_WR) | (1<<DAC_RS); //set DAC control bits as outputs
     25a:	83 b3       	in	r24, 0x13	; 19
     25c:	83 60       	ori	r24, 0x03	; 3
     25e:	83 bb       	out	0x13, r24	; 19
	DDRD = 0xFF; //set DAC_BUS_LOW bits to outputs
     260:	8f ef       	ldi	r24, 0xFF	; 255
     262:	8a b9       	out	0x0a, r24	; 10
	DDRC |= 0xFF;//set DAC_BUS_HIGH bits to outputs
     264:	97 b1       	in	r25, 0x07	; 7
     266:	87 b9       	out	0x07, r24	; 7
	DDRH |= (1<<DAC_MUX_EN0) | (1<<DAC_MUX_EN1) | (1<<DAC_MUX_EN2) | (1<<DAC_MUX_EN3); //set DAC_MUX_EN pins as outputs
     268:	e9 ed       	ldi	r30, 0xD9	; 217
     26a:	f0 e0       	ldi	r31, 0x00	; 0
     26c:	80 81       	ld	r24, Z
     26e:	8f 60       	ori	r24, 0x0F	; 15
     270:	80 83       	st	Z, r24
	
	DAC_MUX &= ~((1<<DAC_MUX_EN0) | (1<<DAC_MUX_EN1) | (1<<DAC_MUX_EN2) | (1<<DAC_MUX_EN3)); //disable DG408 VDAC multiplexers
     272:	ea ed       	ldi	r30, 0xDA	; 218
     274:	f0 e0       	ldi	r31, 0x00	; 0
     276:	80 81       	ld	r24, Z
     278:	80 7f       	andi	r24, 0xF0	; 240
     27a:	80 83       	st	Z, r24
	
	DAC_CTRL |= (1<<DAC_RS) | (1<<DAC_WR); //disable DAC
     27c:	84 b3       	in	r24, 0x14	; 20
     27e:	83 60       	ori	r24, 0x03	; 3
     280:	84 bb       	out	0x14, r24	; 20
	
	DAC_CTRL &= ~(1<<DAC_RS); //reset DAC
     282:	a1 98       	cbi	0x14, 1	; 20
	DAC_CTRL |= (1<<DAC_RS);
     284:	a1 9a       	sbi	0x14, 1	; 20
	
	DAC_CTRL &= ~(1<<DAC_WR); //write DATA - falling edge then rising edge to toggle DAC bits to output register
     286:	a0 98       	cbi	0x14, 0	; 20
	DAC_CTRL |= (1<<DAC_WR);
     288:	a0 9a       	sbi	0x14, 0	; 20
}
     28a:	08 95       	ret

0000028c <display_dec>:
#include "synth.h"



void display_dec(uint16_t number, uint8_t place)
{
     28c:	0f 93       	push	r16
     28e:	1f 93       	push	r17
     290:	cf 93       	push	r28
     292:	df 93       	push	r29
     294:	cd b7       	in	r28, 0x3d	; 61
     296:	de b7       	in	r29, 0x3e	; 62
     298:	2e 97       	sbiw	r28, 0x0e	; 14
     29a:	0f b6       	in	r0, 0x3f	; 63
     29c:	f8 94       	cli
     29e:	de bf       	out	0x3e, r29	; 62
     2a0:	0f be       	out	0x3f, r0	; 63
     2a2:	cd bf       	out	0x3d, r28	; 61
	
	uint8_t digit[] = {
     2a4:	28 e0       	ldi	r18, 0x08	; 8
     2a6:	29 83       	std	Y+1, r18	; 0x01
     2a8:	21 e0       	ldi	r18, 0x01	; 1
     2aa:	2a 83       	std	Y+2, r18	; 0x02
     2ac:	22 e0       	ldi	r18, 0x02	; 2
     2ae:	2b 83       	std	Y+3, r18	; 0x03
     2b0:	24 e0       	ldi	r18, 0x04	; 4
     2b2:	2c 83       	std	Y+4, r18	; 0x04
		TENS,
		HUNDS,
		THOUS,
	};
	
	uint8_t dec[] = {
     2b4:	de 01       	movw	r26, r28
     2b6:	15 96       	adiw	r26, 0x05	; 5
     2b8:	e7 ee       	ldi	r30, 0xE7	; 231
     2ba:	f1 e0       	ldi	r31, 0x01	; 1
     2bc:	2a e0       	ldi	r18, 0x0A	; 10
     2be:	01 90       	ld	r0, Z+
     2c0:	0d 92       	st	X+, r0
     2c2:	21 50       	subi	r18, 0x01	; 1
     2c4:	e1 f7       	brne	.-8      	; 0x2be <display_dec+0x32>
		
		
	};
	
	//clear cathode bits
	DATA_BUS = 0xFF; //set bits for cathode (current sinks, active LOW)
     2c6:	2f ef       	ldi	r18, 0xFF	; 255
     2c8:	22 b9       	out	0x02, r18	; 2
	//latch data to cathode lines
	DISPLAY_PORT |= (1<<DISP_CATHODE_LATCH);
     2ca:	ea ed       	ldi	r30, 0xDA	; 218
     2cc:	f0 e0       	ldi	r31, 0x00	; 0
     2ce:	20 81       	ld	r18, Z
     2d0:	20 61       	ori	r18, 0x10	; 16
     2d2:	20 83       	st	Z, r18
	DISPLAY_PORT &= ~(1<<DISP_CATHODE_LATCH);
     2d4:	20 81       	ld	r18, Z
     2d6:	2f 7e       	andi	r18, 0xEF	; 239
     2d8:	20 83       	st	Z, r18
	
	//set anode bit
	DATA_BUS = digit[place];
     2da:	06 2f       	mov	r16, r22
     2dc:	10 e0       	ldi	r17, 0x00	; 0
     2de:	de 01       	movw	r26, r28
     2e0:	a0 0f       	add	r26, r16
     2e2:	b1 1f       	adc	r27, r17
     2e4:	11 96       	adiw	r26, 0x01	; 1
     2e6:	2c 91       	ld	r18, X
     2e8:	11 97       	sbiw	r26, 0x01	; 1
     2ea:	22 b9       	out	0x02, r18	; 2
	//latch data to anode lines
	DISPLAY_PORT |= (1<<DISP_ANODE_LATCH);
     2ec:	20 81       	ld	r18, Z
     2ee:	20 62       	ori	r18, 0x20	; 32
     2f0:	20 83       	st	Z, r18
	DISPLAY_PORT &= ~(1<<DISP_ANODE_LATCH);
     2f2:	20 81       	ld	r18, Z
     2f4:	2f 7d       	andi	r18, 0xDF	; 223
     2f6:	20 83       	st	Z, r18
     2f8:	48 2f       	mov	r20, r24
     2fa:	59 2f       	mov	r21, r25
     2fc:	87 e2       	ldi	r24, 0x27	; 39
     2fe:	40 31       	cpi	r20, 0x10	; 16
     300:	58 07       	cpc	r21, r24
     302:	10 f0       	brcs	.+4      	; 0x308 <display_dec+0x7c>
     304:	4f e0       	ldi	r20, 0x0F	; 15
     306:	57 e2       	ldi	r21, 0x27	; 39
	if (number > 9999) {
		number = 9999;
		}
	
	/* First division by 10 */
	q1 = (number >> 1) + (number >> 2);
     308:	ca 01       	movw	r24, r20
     30a:	96 95       	lsr	r25
     30c:	87 95       	ror	r24
     30e:	96 95       	lsr	r25
     310:	87 95       	ror	r24
     312:	9a 01       	movw	r18, r20
     314:	36 95       	lsr	r19
     316:	27 95       	ror	r18
     318:	28 0f       	add	r18, r24
     31a:	39 1f       	adc	r19, r25
	q1 += q1 >> 4;
     31c:	c9 01       	movw	r24, r18
     31e:	92 95       	swap	r25
     320:	82 95       	swap	r24
     322:	8f 70       	andi	r24, 0x0F	; 15
     324:	89 27       	eor	r24, r25
     326:	9f 70       	andi	r25, 0x0F	; 15
     328:	89 27       	eor	r24, r25
     32a:	82 0f       	add	r24, r18
     32c:	93 1f       	adc	r25, r19
	q1 += q1 >> 8;
     32e:	29 2f       	mov	r18, r25
     330:	33 27       	eor	r19, r19
     332:	82 0f       	add	r24, r18
     334:	93 1f       	adc	r25, r19
	q2 = q1 >> 3;
     336:	96 95       	lsr	r25
     338:	87 95       	ror	r24
     33a:	96 95       	lsr	r25
     33c:	87 95       	ror	r24
     33e:	96 95       	lsr	r25
     340:	87 95       	ror	r24
	r = number - q2 * 10;
     342:	28 2f       	mov	r18, r24
     344:	22 0f       	add	r18, r18
     346:	32 2f       	mov	r19, r18
     348:	33 0f       	add	r19, r19
     34a:	33 0f       	add	r19, r19
     34c:	23 0f       	add	r18, r19
     34e:	e4 2f       	mov	r30, r20
     350:	e2 1b       	sub	r30, r18
	//r = number - (((q2 << 2) + q2) << 1);
	qa = q2 + (r > 9);
     352:	61 e0       	ldi	r22, 0x01	; 1
     354:	70 e0       	ldi	r23, 0x00	; 0
     356:	ea 30       	cpi	r30, 0x0A	; 10
     358:	10 f4       	brcc	.+4      	; 0x35e <display_dec+0xd2>
     35a:	60 e0       	ldi	r22, 0x00	; 0
     35c:	70 e0       	ldi	r23, 0x00	; 0
     35e:	68 0f       	add	r22, r24
     360:	79 1f       	adc	r23, r25
	ones_place = rem[r];

	/* second division by 10 */

	q2 = (qa >> 1) + (qa >> 2);
     362:	9b 01       	movw	r18, r22
     364:	36 95       	lsr	r19
     366:	27 95       	ror	r18
     368:	36 95       	lsr	r19
     36a:	27 95       	ror	r18
     36c:	ab 01       	movw	r20, r22
     36e:	56 95       	lsr	r21
     370:	47 95       	ror	r20
     372:	24 0f       	add	r18, r20
     374:	35 1f       	adc	r19, r21
	q2 += q2 >> 4;
     376:	c9 01       	movw	r24, r18
     378:	92 95       	swap	r25
     37a:	82 95       	swap	r24
     37c:	8f 70       	andi	r24, 0x0F	; 15
     37e:	89 27       	eor	r24, r25
     380:	9f 70       	andi	r25, 0x0F	; 15
     382:	89 27       	eor	r24, r25
     384:	82 0f       	add	r24, r18
     386:	93 1f       	adc	r25, r19
	q2 += q2 >> 8;
     388:	29 2f       	mov	r18, r25
     38a:	33 27       	eor	r19, r19
     38c:	82 0f       	add	r24, r18
     38e:	93 1f       	adc	r25, r19
	q3 = q2 >> 3;
     390:	96 95       	lsr	r25
     392:	87 95       	ror	r24
     394:	96 95       	lsr	r25
     396:	87 95       	ror	r24
     398:	96 95       	lsr	r25
     39a:	87 95       	ror	r24
	r = qa - q3 * 10;
     39c:	98 2f       	mov	r25, r24
     39e:	99 0f       	add	r25, r25
     3a0:	29 2f       	mov	r18, r25
     3a2:	22 0f       	add	r18, r18
     3a4:	22 0f       	add	r18, r18
     3a6:	92 0f       	add	r25, r18
     3a8:	69 1b       	sub	r22, r25
	qb = q3 + (r > 9);
     3aa:	91 e0       	ldi	r25, 0x01	; 1
     3ac:	6a 30       	cpi	r22, 0x0A	; 10
     3ae:	08 f4       	brcc	.+2      	; 0x3b2 <display_dec+0x126>
     3b0:	90 e0       	ldi	r25, 0x00	; 0
     3b2:	89 0f       	add	r24, r25
	tens_place = rem[r];
     3b4:	41 ef       	ldi	r20, 0xF1	; 241
     3b6:	51 e0       	ldi	r21, 0x01	; 1
     3b8:	da 01       	movw	r26, r20
     3ba:	a6 0f       	add	r26, r22
     3bc:	b1 1d       	adc	r27, r1
     3be:	3c 91       	ld	r19, X

	/* third division by 10 */

	q4 = (qb >> 1) + (qb >> 2);
     3c0:	28 2f       	mov	r18, r24
     3c2:	26 95       	lsr	r18
     3c4:	26 95       	lsr	r18
     3c6:	98 2f       	mov	r25, r24
     3c8:	96 95       	lsr	r25
     3ca:	92 0f       	add	r25, r18
	q4 += q4 >> 4;
     3cc:	29 2f       	mov	r18, r25
     3ce:	22 95       	swap	r18
     3d0:	2f 70       	andi	r18, 0x0F	; 15
     3d2:	92 0f       	add	r25, r18
	q4 = q4 >> 3;
     3d4:	96 95       	lsr	r25
     3d6:	96 95       	lsr	r25
     3d8:	96 95       	lsr	r25
	r = qb - q4 * 10;
     3da:	29 2f       	mov	r18, r25
     3dc:	22 0f       	add	r18, r18
     3de:	62 2f       	mov	r22, r18
     3e0:	66 0f       	add	r22, r22
     3e2:	66 0f       	add	r22, r22
     3e4:	26 0f       	add	r18, r22
     3e6:	82 1b       	sub	r24, r18
	thous_place = q4 + (r > 9);
	hunds_place = rem[r];
     3e8:	da 01       	movw	r26, r20
     3ea:	a8 0f       	add	r26, r24
     3ec:	b1 1d       	adc	r27, r1
     3ee:	2c 91       	ld	r18, X
	q1 += q1 >> 8;
	q2 = q1 >> 3;
	r = number - q2 * 10;
	//r = number - (((q2 << 2) + q2) << 1);
	qa = q2 + (r > 9);
	ones_place = rem[r];
     3f0:	4e 0f       	add	r20, r30
     3f2:	51 1d       	adc	r21, r1
	q4 = q4 >> 3;
	r = qb - q4 * 10;
	thous_place = q4 + (r > 9);
	hunds_place = rem[r];

	digit_index[0] = ones_place;
     3f4:	fa 01       	movw	r30, r20
     3f6:	40 81       	ld	r20, Z
     3f8:	40 93 b3 02 	sts	0x02B3, r20
	digit_index[1] = tens_place;
     3fc:	30 93 b4 02 	sts	0x02B4, r19
	digit_index[2] = hunds_place;
     400:	20 93 b5 02 	sts	0x02B5, r18

	q4 = (qb >> 1) + (qb >> 2);
	q4 += q4 >> 4;
	q4 = q4 >> 3;
	r = qb - q4 * 10;
	thous_place = q4 + (r > 9);
     404:	21 e0       	ldi	r18, 0x01	; 1
     406:	8a 30       	cpi	r24, 0x0A	; 10
     408:	08 f4       	brcc	.+2      	; 0x40c <display_dec+0x180>
     40a:	20 e0       	ldi	r18, 0x00	; 0
     40c:	92 0f       	add	r25, r18
	hunds_place = rem[r];

	digit_index[0] = ones_place;
	digit_index[1] = tens_place;
	digit_index[2] = hunds_place;
	digit_index[3] = thous_place;
     40e:	90 93 b6 02 	sts	0x02B6, r25

	cathode_byte = dec[digit_index[place]];
     412:	f8 01       	movw	r30, r16
     414:	ed 54       	subi	r30, 0x4D	; 77
     416:	fd 4f       	sbci	r31, 0xFD	; 253
     418:	80 81       	ld	r24, Z
     41a:	fe 01       	movw	r30, r28
     41c:	e8 0f       	add	r30, r24
     41e:	f1 1d       	adc	r31, r1
     420:	85 81       	ldd	r24, Z+5	; 0x05
	
	if (current_patch.mode == EDIT) cathode_byte |= dp;
     422:	90 91 05 03 	lds	r25, 0x0305
     426:	92 30       	cpi	r25, 0x02	; 2
     428:	11 f4       	brne	.+4      	; 0x42e <display_dec+0x1a2>
     42a:	80 62       	ori	r24, 0x20	; 32
     42c:	03 c0       	rjmp	.+6      	; 0x434 <display_dec+0x1a8>
	if (current_patch.mode == MANUAL) cathode_byte = g; //Roland style dash for MANUAL mode. Could move this to the top as manual mode precludes the need to parse digit
     42e:	91 30       	cpi	r25, 0x01	; 1
     430:	09 f4       	brne	.+2      	; 0x434 <display_dec+0x1a8>
     432:	88 e0       	ldi	r24, 0x08	; 8
	
	
	//set cathode byte
	DATA_BUS = ~(cathode_byte); //set bits for cathode (current sinks, active LOW)
     434:	80 95       	com	r24
     436:	82 b9       	out	0x02, r24	; 2
	//latch data to cathode lines
	DISPLAY_PORT |= (1<<DISP_CATHODE_LATCH);
     438:	ea ed       	ldi	r30, 0xDA	; 218
     43a:	f0 e0       	ldi	r31, 0x00	; 0
     43c:	80 81       	ld	r24, Z
     43e:	80 61       	ori	r24, 0x10	; 16
     440:	80 83       	st	Z, r24
	DISPLAY_PORT &= ~(1<<DISP_CATHODE_LATCH);
     442:	80 81       	ld	r24, Z
     444:	8f 7e       	andi	r24, 0xEF	; 239
     446:	80 83       	st	Z, r24
	
	//DATA_BUS = 0; //clear DATA_BUS before return
}
     448:	2e 96       	adiw	r28, 0x0e	; 14
     44a:	0f b6       	in	r0, 0x3f	; 63
     44c:	f8 94       	cli
     44e:	de bf       	out	0x3e, r29	; 62
     450:	0f be       	out	0x3f, r0	; 63
     452:	cd bf       	out	0x3d, r28	; 61
     454:	df 91       	pop	r29
     456:	cf 91       	pop	r28
     458:	1f 91       	pop	r17
     45a:	0f 91       	pop	r16
     45c:	08 95       	ret

0000045e <update_display>:

void update_display(uint16_t number, uint8_t type) {
     45e:	cf 93       	push	r28
	
	static uint8_t place = 0;
	

	
	if (type == DEC) {
     460:	66 23       	and	r22, r22
     462:	69 f4       	brne	.+26     	; 0x47e <update_display+0x20>

		
			
		display_dec(number, place);
     464:	c0 91 b7 02 	lds	r28, 0x02B7
     468:	6c 2f       	mov	r22, r28
     46a:	0e 94 46 01 	call	0x28c	; 0x28c <display_dec>
		//increment digit display place
		if (place++ == 3) //post increment
     46e:	8c 2f       	mov	r24, r28
     470:	8f 5f       	subi	r24, 0xFF	; 255
     472:	80 93 b7 02 	sts	0x02B7, r24
     476:	c3 30       	cpi	r28, 0x03	; 3
     478:	11 f4       	brne	.+4      	; 0x47e <update_display+0x20>
		{
			place = 0;
     47a:	10 92 b7 02 	sts	0x02B7, r1
		
		
	}
	
	
     47e:	cf 91       	pop	r28
     480:	08 95       	ret

00000482 <__vector_10>:

#include "hardware.h"
#include "tune.h"
#include "display.h"

ISR (TIMER0_COMP_vect) { //timer 0 output compare interrupt for tuning
     482:	1f 92       	push	r1
     484:	0f 92       	push	r0
     486:	0f b6       	in	r0, 0x3f	; 63
     488:	0f 92       	push	r0
     48a:	11 24       	eor	r1, r1
     48c:	8f 93       	push	r24
     48e:	9f 93       	push	r25
     490:	ef 93       	push	r30
     492:	ff 93       	push	r31
	
	OCR0A = period-1; //OCR0A counts n-1 periods - see comment in tune.c about setting OCR0A
     494:	80 91 76 03 	lds	r24, 0x0376
     498:	81 50       	subi	r24, 0x01	; 1
     49a:	87 bd       	out	0x27, r24	; 39
	//PORTB ^= (1<<ARP_SYNC_LED); //toggle arp ARP_SYNC LED
	if (period_counter == 0) {
     49c:	80 91 77 03 	lds	r24, 0x0377
     4a0:	88 23       	and	r24, r24
     4a2:	a1 f4       	brne	.+40     	; 0x4cc <__vector_10+0x4a>
		count_finished = FALSE;
     4a4:	10 92 74 03 	sts	0x0374, r1
		no_overflow = TRUE;
     4a8:	81 e0       	ldi	r24, 0x01	; 1
     4aa:	80 93 af 02 	sts	0x02AF, r24
		period_counter = 1; //set period counter to 1
     4ae:	80 93 77 03 	sts	0x0377, r24
		//set up 16 bit timer/counter1		
		TCCR1B |= timer1_clock; //clock /64 to run at 312.5 KHz or /8 to run at 2.5 MHz, dependent on note frequency being measured
     4b2:	e1 e8       	ldi	r30, 0x81	; 129
     4b4:	f0 e0       	ldi	r31, 0x00	; 0
     4b6:	80 81       	ld	r24, Z
     4b8:	90 91 75 03 	lds	r25, 0x0375
     4bc:	89 2b       	or	r24, r25
     4be:	80 83       	st	Z, r24
		TIMSK1 |= (1<<TOIE1); //enable timer1 overflow interrupt
     4c0:	ef e6       	ldi	r30, 0x6F	; 111
     4c2:	f0 e0       	ldi	r31, 0x00	; 0
     4c4:	80 81       	ld	r24, Z
     4c6:	81 60       	ori	r24, 0x01	; 1
     4c8:	80 83       	st	Z, r24
     4ca:	11 c0       	rjmp	.+34     	; 0x4ee <__vector_10+0x6c>
		
	} else {
		
		osc_count = TCNT1;		
     4cc:	e4 e8       	ldi	r30, 0x84	; 132
     4ce:	f0 e0       	ldi	r31, 0x00	; 0
     4d0:	80 81       	ld	r24, Z
     4d2:	91 81       	ldd	r25, Z+1	; 0x01
     4d4:	90 93 73 03 	sts	0x0373, r25
     4d8:	80 93 72 03 	sts	0x0372, r24
		TCCR1B = 0; //turn off 16 bit timer/counter1
     4dc:	10 92 81 00 	sts	0x0081, r1
		count_finished = TRUE;
     4e0:	81 e0       	ldi	r24, 0x01	; 1
     4e2:	80 93 74 03 	sts	0x0374, r24
		period_counter = 0;
     4e6:	10 92 77 03 	sts	0x0377, r1
		TCNT1 = 0; //reset timer/counter 1
     4ea:	11 82       	std	Z+1, r1	; 0x01
     4ec:	10 82       	st	Z, r1
	}
	
	
	
	
}
     4ee:	ff 91       	pop	r31
     4f0:	ef 91       	pop	r30
     4f2:	9f 91       	pop	r25
     4f4:	8f 91       	pop	r24
     4f6:	0f 90       	pop	r0
     4f8:	0f be       	out	0x3f, r0	; 63
     4fa:	0f 90       	pop	r0
     4fc:	1f 90       	pop	r1
     4fe:	18 95       	reti

00000500 <__vector_9>:



ISR (TIMER1_OVF_vect) {
     500:	1f 92       	push	r1
     502:	0f 92       	push	r0
     504:	0f b6       	in	r0, 0x3f	; 63
     506:	0f 92       	push	r0
     508:	11 24       	eor	r1, r1
	
	//during frequency counting, if timer1 overflow occurs set overflow flag
	no_overflow = FALSE;
     50a:	10 92 af 02 	sts	0x02AF, r1
	//PORTB ^= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED
	
     50e:	0f 90       	pop	r0
     510:	0f be       	out	0x3f, r0	; 63
     512:	0f 90       	pop	r0
     514:	1f 90       	pop	r1
     516:	18 95       	reti

00000518 <note_off_event>:
		//could implement this with timers. Will it really make a difference?
		PORTF |= (1<<GATE);
	}
	
}
void note_off_event(MidiDevice * device, uint8_t status, uint8_t note, uint8_t velocity) {
     518:	84 2f       	mov	r24, r20
	remove_note(note);
     51a:	0e 94 be 00 	call	0x17c	; 0x17c <remove_note>
	gate_buffer--;
     51e:	80 91 b9 02 	lds	r24, 0x02B9
     522:	81 50       	subi	r24, 0x01	; 1
     524:	80 93 b9 02 	sts	0x02B9, r24
	if (gate_buffer == 0) PORTF &= ~(1<<GATE);
     528:	88 23       	and	r24, r24
     52a:	09 f4       	brne	.+2      	; 0x52e <note_off_event+0x16>
     52c:	89 98       	cbi	0x11, 1	; 17
     52e:	08 95       	ret

00000530 <note_on_event>:
static uint8_t gate_buffer = 0;




void note_on_event(MidiDevice * device, uint8_t status, uint8_t note, uint8_t velocity) {
     530:	84 2f       	mov	r24, r20
	
	//value_to_display = note;
	midi_note_number = note;
     532:	40 93 ba 02 	sts	0x02BA, r20
	if (velocity == 0) {
     536:	22 23       	and	r18, r18
     538:	59 f4       	brne	.+22     	; 0x550 <note_on_event+0x20>
		remove_note(note);
     53a:	0e 94 be 00 	call	0x17c	; 0x17c <remove_note>
		gate_buffer--;
     53e:	80 91 b9 02 	lds	r24, 0x02B9
     542:	81 50       	subi	r24, 0x01	; 1
     544:	80 93 b9 02 	sts	0x02B9, r24
		if (gate_buffer == 0) PORTF &= ~(1<<GATE);
     548:	88 23       	and	r24, r24
     54a:	59 f4       	brne	.+22     	; 0x562 <note_on_event+0x32>
     54c:	89 98       	cbi	0x11, 1	; 17
     54e:	08 95       	ret
				
	} else {
		new_note(note, velocity);
     550:	62 2f       	mov	r22, r18
     552:	0e 94 a6 00 	call	0x14c	; 0x14c <new_note>
		gate_buffer++; //increment gate_buffer
     556:	80 91 b9 02 	lds	r24, 0x02B9
     55a:	8f 5f       	subi	r24, 0xFF	; 255
     55c:	80 93 b9 02 	sts	0x02B9, r24
		//PORTF &= ~(1<<GATE); //turn gate off to re-trigger envelopes - this isn't nearly long enough
		//retriggering is a feature offered by Kenton Pro-Solo - maybe want it here, but need to decide how long to turn gate off
		//looking at gate of Pro-Solo on oscilloscope might give an idea of how long the Pro-Solo gate is released between retriggers  - checked: Pro-Solo gate-retrigger is 0.3ms
		//could implement this with timers. Will it really make a difference?
		PORTF |= (1<<GATE);
     560:	89 9a       	sbi	0x11, 1	; 17
     562:	08 95       	ret

00000564 <setup_midi_usart>:

void setup_midi_usart(void)
{
    uint16_t ubbr_value = 39; //20MHz/(16*31250 BAUD) - 1
    //write ubbr_value to H and L UBBR1 registers:
    UBRR0L = (unsigned char) ubbr_value;
     564:	87 e2       	ldi	r24, 0x27	; 39
     566:	80 93 c4 00 	sts	0x00C4, r24
    UBRR0H = (unsigned char) (ubbr_value >> 8);
     56a:	10 92 c5 00 	sts	0x00C5, r1
	
	UCSR0B = (1<<RXEN0)|(1<<TXEN0) | (1<<RXCIE0);
     56e:	88 e9       	ldi	r24, 0x98	; 152
     570:	80 93 c1 00 	sts	0x00C1, r24
	//UCSR0C |= (0<<UMSEL0)|(0<<UMSEL01)|(0<<UPM01)|(0<<UPM00)|(0<<USBS0)|(0<<UCSZ02)|(1<<UCSZ01)|(1<<UCSZ00);  	
}
     574:	08 95       	ret

00000576 <__vector_13>:



ISR (USART_RX_vect) { // USART receive interrupt
     576:	1f 92       	push	r1
     578:	0f 92       	push	r0
     57a:	0f b6       	in	r0, 0x3f	; 63
     57c:	0f 92       	push	r0
     57e:	11 24       	eor	r1, r1
     580:	2f 93       	push	r18
     582:	3f 93       	push	r19
     584:	4f 93       	push	r20
     586:	5f 93       	push	r21
     588:	6f 93       	push	r22
     58a:	7f 93       	push	r23
     58c:	8f 93       	push	r24
     58e:	9f 93       	push	r25
     590:	af 93       	push	r26
     592:	bf 93       	push	r27
     594:	ef 93       	push	r30
     596:	ff 93       	push	r31
     598:	cf 93       	push	r28
     59a:	df 93       	push	r29
     59c:	0f 92       	push	r0
     59e:	cd b7       	in	r28, 0x3d	; 61
     5a0:	de b7       	in	r29, 0x3e	; 62
	//PORTB ^= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED 
	uint8_t inByte = UDR0;
     5a2:	80 91 c6 00 	lds	r24, 0x00C6
     5a6:	89 83       	std	Y+1, r24	; 0x01
	midi_device_input(&midi_device, 1, &inByte); 
     5a8:	8c e7       	ldi	r24, 0x7C	; 124
     5aa:	93 e0       	ldi	r25, 0x03	; 3
     5ac:	61 e0       	ldi	r22, 0x01	; 1
     5ae:	ae 01       	movw	r20, r28
     5b0:	4f 5f       	subi	r20, 0xFF	; 255
     5b2:	5f 4f       	sbci	r21, 0xFF	; 255
     5b4:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <midi_device_input>
	//calling a function in an interrupt is inefficient according to AVR C guidelines
	// so this function should maybe be inlined in main loop if inByte is made volatile	
	//***HOWEVER***, xnor-midi example code has this function being called from USART_RX_vect ISR  	
}
     5b8:	0f 90       	pop	r0
     5ba:	df 91       	pop	r29
     5bc:	cf 91       	pop	r28
     5be:	ff 91       	pop	r31
     5c0:	ef 91       	pop	r30
     5c2:	bf 91       	pop	r27
     5c4:	af 91       	pop	r26
     5c6:	9f 91       	pop	r25
     5c8:	8f 91       	pop	r24
     5ca:	7f 91       	pop	r23
     5cc:	6f 91       	pop	r22
     5ce:	5f 91       	pop	r21
     5d0:	4f 91       	pop	r20
     5d2:	3f 91       	pop	r19
     5d4:	2f 91       	pop	r18
     5d6:	0f 90       	pop	r0
     5d8:	0f be       	out	0x3f, r0	; 63
     5da:	0f 90       	pop	r0
     5dc:	1f 90       	pop	r1
     5de:	18 95       	reti

000005e0 <main>:


int main(void)
{
	//turn off JTAG so all outputs of PORTC can be used
	MCUCR = (1<<JTD);
     5e0:	c0 e8       	ldi	r28, 0x80	; 128
     5e2:	c5 bf       	out	0x35, r28	; 53
	MCUCR = (1<<JTD);
     5e4:	c5 bf       	out	0x35, r28	; 53
		
	//SET PORTB PIN 7 (PB7) as OUTPUT
	DDRB |= (1<<ARP_SYNC_LED);
     5e6:	27 9a       	sbi	0x04, 7	; 4
	
	DDRF |= (1<<GATE); //set gate as output
     5e8:	81 9a       	sbi	0x10, 1	; 16
	//PORTF |= (1<<GATE); //turn gate on for testing
	
	DDRG |= (1<<TUNE_SELECT); //set tune select bit as output on PORTG
     5ea:	9a 9a       	sbi	0x13, 2	; 19
	PORTG &= ~(1<<TUNE_SELECT); //set tune select bit to 0 to select VCF/VCA output for oscillator tuning
     5ec:	a2 98       	cbi	0x14, 2	; 20
	//PORTG |= (1<<TUNE_SELECT);
	
	setup_spi(); 
     5ee:	0e 94 03 06 	call	0xc06	; 0xc06 <setup_spi>
	
	DDRH |= (1<<POTMUX_EN0) | (1<<POTMUX_EN1); //set POTMUX_EN pins as outputs
     5f2:	a9 ed       	ldi	r26, 0xD9	; 217
     5f4:	b0 e0       	ldi	r27, 0x00	; 0
     5f6:	8c 91       	ld	r24, X
     5f8:	80 6c       	ori	r24, 0xC0	; 192
     5fa:	8c 93       	st	X, r24
	POT_MUX |= (1<<POTMUX_EN0) | (1<<POTMUX_EN1); //set POTMUX_EN pins HIGH (active LOW)
     5fc:	ea ed       	ldi	r30, 0xDA	; 218
     5fe:	f0 e0       	ldi	r31, 0x00	; 0
     600:	80 81       	ld	r24, Z
     602:	80 6c       	ori	r24, 0xC0	; 192
     604:	80 83       	st	Z, r24
	//POT_MUX |= (1<<POTMUX_EN1);
	
	//set up LED display
	DDRA |= 0b11111111; //set all lines or DATA_BUS to outputs
     606:	81 b1       	in	r24, 0x01	; 1
     608:	8f ef       	ldi	r24, 0xFF	; 255
     60a:	81 b9       	out	0x01, r24	; 1
	DATA_BUS |= 0b11111111; //set all DATA_BUS lines to HIGH (cathodes OFF)
     60c:	92 b1       	in	r25, 0x02	; 2
     60e:	82 b9       	out	0x02, r24	; 2
	DDRH |= (1<<DISP_CATHODE_LATCH) | (1<<DISP_ANODE_LATCH); //set display latches to outputs
     610:	8c 91       	ld	r24, X
     612:	80 63       	ori	r24, 0x30	; 48
     614:	8c 93       	st	X, r24
	DISPLAY_PORT &= ~(1<<DISP_ANODE_LATCH | 1<< DISP_CATHODE_LATCH); //set DISP latches to LOW (inactive)
     616:	80 81       	ld	r24, Z
     618:	8f 7c       	andi	r24, 0xCF	; 207
     61a:	80 83       	st	Z, r24
	
	//set up switch port
	DDRF &= ~(1<<BMOD_SW); //set BMOD_SW pin as input
     61c:	82 98       	cbi	0x10, 2	; 16
	
	//set up LFO DEMUX LATCH
	DDRJ |= (1<<LFO_SW_LATCH); //set LFO_SW_LATCH pin as output
     61e:	ec ed       	ldi	r30, 0xDC	; 220
     620:	f0 e0       	ldi	r31, 0x00	; 0
     622:	80 81       	ld	r24, Z
     624:	80 62       	ori	r24, 0x20	; 32
     626:	80 83       	st	Z, r24
	DATA_BUS = LFO_TRI_ADDR;
     628:	12 b8       	out	0x02, r1	; 2
	LFO_LATCH_PORT |= (1<<LFO_SW_LATCH);
     62a:	ed ed       	ldi	r30, 0xDD	; 221
     62c:	f0 e0       	ldi	r31, 0x00	; 0
     62e:	80 81       	ld	r24, Z
     630:	80 62       	ori	r24, 0x20	; 32
     632:	80 83       	st	Z, r24
	LFO_LATCH_PORT &= ~(1<<LFO_SW_LATCH);
     634:	80 81       	ld	r24, Z
     636:	8f 7d       	andi	r24, 0xDF	; 223
     638:	80 83       	st	Z, r24
	DATA_BUS = 0;
     63a:	12 b8       	out	0x02, r1	; 2
	current_patch.byte_2 = (1<<LFO_TRI);
     63c:	c0 93 ff 02 	sts	0x02FF, r28
	
	//setup ADC
    setup_adc();		
     640:	0e 94 51 00 	call	0xa2	; 0xa2 <setup_adc>
	//setup DAC
	setup_dac();
     644:	0e 94 2d 01 	call	0x25a	; 0x25a <setup_dac>
	
	//setup MIDI
	//initialize MIDI device
	midi_device_init(&midi_device);
     648:	cc e7       	ldi	r28, 0x7C	; 124
     64a:	d3 e0       	ldi	r29, 0x03	; 3
     64c:	ce 01       	movw	r24, r28
     64e:	0e 94 87 16 	call	0x2d0e	; 0x2d0e <midi_device_init>
	//register callbacks
	midi_register_noteon_callback(&midi_device, note_on_event);
     652:	ce 01       	movw	r24, r28
     654:	68 e9       	ldi	r22, 0x98	; 152
     656:	72 e0       	ldi	r23, 0x02	; 2
     658:	0e 94 4f 16 	call	0x2c9e	; 0x2c9e <midi_register_noteon_callback>
	midi_register_noteoff_callback(&midi_device, note_off_event);
     65c:	ce 01       	movw	r24, r28
     65e:	6c e8       	ldi	r22, 0x8C	; 140
     660:	72 e0       	ldi	r23, 0x02	; 2
     662:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <midi_register_noteoff_callback>
	//setup MIDI USART
	setup_midi_usart();
     666:	0e 94 b2 02 	call	0x564	; 0x564 <setup_midi_usart>
	
	update_spi(); //initial update of SPI - will eventual be useful for picking up special power up switch holds
     66a:	0e 94 28 06 	call	0xc50	; 0xc50 <update_spi>
	
	
	current_patch.number = 1;
     66e:	81 e0       	ldi	r24, 0x01	; 1
     670:	80 93 03 03 	sts	0x0303, r24
		
	sei(); //enable global interrupts
     674:	78 94       	sei

	
	//eeprom_update_word((uint16_t*)109, test_word);
	//value_to_display = eeprom_read_word((uint16_t*)109);
	
	load_tuning_tables();
     676:	0e 94 02 13 	call	0x2604	; 0x2604 <load_tuning_tables>
	//value_to_display = vco1_init_cv;
	//set_one_volt_per_octave(); //overwrite tuning tables with 1V/octave data for calibration purposes
	//set initial switch states
	//switch_states.byte0 = (1<<VCO1_PULSE_SW) | (1<<VCO2_PULSE_SW);
	//current_patch.byte_4 = (1<<VCO1_32F) | (1<<VCO2_32F);
	load_patch(1);
     67a:	81 e0       	ldi	r24, 0x01	; 1
     67c:	0e 94 ab 08 	call	0x1156	; 0x1156 <load_patch>

	while(1)
	{	
		
		
		midi_device_process(&midi_device); //this needs to be called 'frequently' in order for MIDI to work
     680:	8e 01       	movw	r16, r28
		if (switch_timer++ == 5)
		{
			switch_timer = 0;
			switch_press = 0; //reset global switch press flag
			//read switches directly connected to MCU	
			switch_states.byte2 ^= read_switch_port(); //toggle switch states
     682:	0f 2e       	mov	r0, r31
     684:	fa e7       	ldi	r31, 0x7A	; 122
     686:	ef 2e       	mov	r14, r31
     688:	f3 e0       	ldi	r31, 0x03	; 3
     68a:	ff 2e       	mov	r15, r31
     68c:	f0 2d       	mov	r31, r0
			switch_states.byte2 |= (current_patch.mode == MANUAL) << PROG_MANUAL_SW; //if MANUAL then don't toggle switch
     68e:	0f 2e       	mov	r0, r31
     690:	f5 e0       	ldi	r31, 0x05	; 5
     692:	cf 2e       	mov	r12, r31
     694:	f3 e0       	ldi	r31, 0x03	; 3
     696:	df 2e       	mov	r13, r31
     698:	f0 2d       	mov	r31, r0
			//switch_states.byte2 |= (current_patch.mode == WRITE) << PROG_WRITE_SW; //if WRITE then don't toggle switch
			update_spi();
			if (switch_press) { 
				update_patch();
				if (current_patch.mode == MEMORY) current_patch.mode = EDIT; //change mode to EDIT if non-program switch is detected
     69a:	bb 24       	eor	r11, r11
     69c:	68 94       	set
     69e:	b1 f8       	bld	r11, 1
		{
			switch_timer = 0;
			switch_press = 0; //reset global switch press flag
			//read switches directly connected to MCU	
			switch_states.byte2 ^= read_switch_port(); //toggle switch states
			switch_states.byte2 |= (current_patch.mode == MANUAL) << PROG_MANUAL_SW; //if MANUAL then don't toggle switch
     6a0:	d0 e8       	ldi	r29, 0x80	; 128

	while(1)
	{	
		
		
		midi_device_process(&midi_device); //this needs to be called 'frequently' in order for MIDI to work
     6a2:	c8 01       	movw	r24, r16
     6a4:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <midi_device_process>
		//value_to_display = vco1_init_cv;
		//PORTB |= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED
		update_display(value_to_display, DEC); //maybe move this into switch_timer loop. Probably doesn't need to be updated this frequently
     6a8:	80 91 fd 01 	lds	r24, 0x01FD
     6ac:	90 91 fe 01 	lds	r25, 0x01FE
     6b0:	60 e0       	ldi	r22, 0x00	; 0
     6b2:	0e 94 2f 02 	call	0x45e	; 0x45e <update_display>
		//PORTB &= ~(1<<ARP_SYNC_LED);
		 	
		//scan_pots_and_update_control_voltages();
		scan_pots();
     6b6:	0e 94 8a 03 	call	0x714	; 0x714 <scan_pots>
		update_control_voltages();
     6ba:	0e 94 17 04 	call	0x82e	; 0x82e <update_control_voltages>
			
		//do SPI read/write every 5 loops - whole section needs major update
		if (switch_timer++ == 5)
     6be:	80 91 b8 02 	lds	r24, 0x02B8
     6c2:	98 2f       	mov	r25, r24
     6c4:	9f 5f       	subi	r25, 0xFF	; 255
     6c6:	90 93 b8 02 	sts	0x02B8, r25
     6ca:	85 30       	cpi	r24, 0x05	; 5
     6cc:	51 f7       	brne	.-44     	; 0x6a2 <main+0xc2>
		{
			switch_timer = 0;
     6ce:	10 92 b8 02 	sts	0x02B8, r1
			switch_press = 0; //reset global switch press flag
     6d2:	10 92 c1 02 	sts	0x02C1, r1
			//read switches directly connected to MCU	
			switch_states.byte2 ^= read_switch_port(); //toggle switch states
     6d6:	f7 01       	movw	r30, r14
     6d8:	c0 81       	ld	r28, Z
     6da:	0e 94 89 13 	call	0x2712	; 0x2712 <read_switch_port>
     6de:	8c 27       	eor	r24, r28
			switch_states.byte2 |= (current_patch.mode == MANUAL) << PROG_MANUAL_SW; //if MANUAL then don't toggle switch
     6e0:	f6 01       	movw	r30, r12
     6e2:	90 81       	ld	r25, Z
     6e4:	91 30       	cpi	r25, 0x01	; 1
     6e6:	11 f4       	brne	.+4      	; 0x6ec <main+0x10c>
     6e8:	cd 2f       	mov	r28, r29
     6ea:	01 c0       	rjmp	.+2      	; 0x6ee <main+0x10e>
     6ec:	c0 e0       	ldi	r28, 0x00	; 0
     6ee:	c8 2b       	or	r28, r24
     6f0:	f7 01       	movw	r30, r14
     6f2:	c0 83       	st	Z, r28
			//switch_states.byte2 |= (current_patch.mode == WRITE) << PROG_WRITE_SW; //if WRITE then don't toggle switch
			update_spi();
     6f4:	0e 94 28 06 	call	0xc50	; 0xc50 <update_spi>
			if (switch_press) { 
     6f8:	80 91 c1 02 	lds	r24, 0x02C1
     6fc:	88 23       	and	r24, r24
     6fe:	39 f0       	breq	.+14     	; 0x70e <main+0x12e>
				update_patch();
     700:	0e 94 56 0c 	call	0x18ac	; 0x18ac <update_patch>
				if (current_patch.mode == MEMORY) current_patch.mode = EDIT; //change mode to EDIT if non-program switch is detected
     704:	f6 01       	movw	r30, r12
     706:	80 81       	ld	r24, Z
     708:	88 23       	and	r24, r24
     70a:	09 f4       	brne	.+2      	; 0x70e <main+0x12e>
     70c:	b0 82       	st	Z, r11
			}				
			update_patch_programmer();	
     70e:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <update_patch_programmer>
     712:	c7 cf       	rjmp	.-114    	; 0x6a2 <main+0xc2>

00000714 <scan_pots>:

uint8_t midi_note_number = 0; //store incoming MIDI note here for pitch lookup table

volatile uint16_t value_to_display = 79; //global to hold display value
	
void scan_pots(void) { //should probably move this to adc.c
     714:	bf 92       	push	r11
     716:	cf 92       	push	r12
     718:	df 92       	push	r13
     71a:	ef 92       	push	r14
     71c:	ff 92       	push	r15
     71e:	0f 93       	push	r16
     720:	1f 93       	push	r17
     722:	cf 93       	push	r28
     724:	df 93       	push	r29
     726:	c0 e0       	ldi	r28, 0x00	; 0
     728:	d1 e0       	ldi	r29, 0x01	; 1
     72a:	02 ec       	ldi	r16, 0xC2	; 194
     72c:	12 e0       	ldi	r17, 0x02	; 2
     72e:	0f 2e       	mov	r0, r31
     730:	fc e3       	ldi	r31, 0x3C	; 60
     732:	cf 2e       	mov	r12, r31
     734:	dd 24       	eor	r13, r13
     736:	f0 2d       	mov	r31, r0
     738:	cc 0e       	add	r12, r28
     73a:	dd 1e       	adc	r13, r29
		//what happens next depends on mode. if pot is locked, then the value of the pot is not written to the current patch unless it is different from the pot's locked value
		
		uint8_t delta_pot = pot_id[i]->locked_value - ((pot_id[i]->value >> 2)); //quick and dirty subtraction, where unsigned delta pot will overflow if value > locked value. see below
		
		
		if ((current_patch.mode == MANUAL) || (pot_id[i]->locked == 0)) { //if in manual mode or pot is already unlocked
     73c:	0f 2e       	mov	r0, r31
     73e:	f5 e0       	ldi	r31, 0x05	; 5
     740:	ef 2e       	mov	r14, r31
     742:	f3 e0       	ldi	r31, 0x03	; 3
     744:	ff 2e       	mov	r15, r31
     746:	f0 2d       	mov	r31, r0
		//} else if ((((pot_id[i]->value >> 2) != pot_id[i]->locked_value)) && (pot_id[i]->locked == 1)) { //need to figure out delta threshold here. 10 bit to 8 bit resolution should be enough???
			
		} else if (((delta_pot > 2) && (delta_pot < 253)) && (pot_id[i]->locked == 1)) { //set a threshold of +/- 3 for pot change  		  		  	
			*(patch_value + i) = pot_id[i]->value;
			pot_id[i]->locked = 0; //unlock pot
			current_patch.mode = EDIT;
     748:	bb 24       	eor	r11, r11
     74a:	68 94       	set
     74c:	b1 f8       	bld	r11, 1
	
	uint16_t *patch_value = &(current_patch.vco2_mix); //pointer to first element of current_patch struct
	//scan 30 parameter pots
	for (int i = 0; i <= 29; i++) {
		
		adc_value = read_pot(pot_id[i]);
     74e:	88 81       	ld	r24, Y
     750:	99 81       	ldd	r25, Y+1	; 0x01
     752:	0e 94 64 00 	call	0xc8	; 0xc8 <read_pot>
     756:	90 93 bc 02 	sts	0x02BC, r25
     75a:	80 93 bb 02 	sts	0x02BB, r24
		adc_change = adc_value - pot_id[i]->value;
     75e:	e8 81       	ld	r30, Y
     760:	f9 81       	ldd	r31, Y+1	; 0x01
     762:	40 81       	ld	r20, Z
     764:	21 81       	ldd	r18, Z+1	; 0x01
     766:	52 2f       	mov	r21, r18
     768:	53 70       	andi	r21, 0x03	; 3
     76a:	84 1b       	sub	r24, r20
     76c:	95 0b       	sbc	r25, r21
		pot_id[i]->value = pot_id[i]->value + (adc_change >> 2);
     76e:	95 95       	asr	r25
     770:	87 95       	ror	r24
     772:	95 95       	asr	r25
     774:	87 95       	ror	r24
     776:	84 0f       	add	r24, r20
     778:	95 1f       	adc	r25, r21
     77a:	80 83       	st	Z, r24
     77c:	89 2f       	mov	r24, r25
     77e:	83 70       	andi	r24, 0x03	; 3
     780:	2c 7f       	andi	r18, 0xFC	; 252
     782:	28 2b       	or	r18, r24
     784:	21 83       	std	Z+1, r18	; 0x01
		//what happens next depends on mode. if pot is locked, then the value of the pot is not written to the current patch unless it is different from the pot's locked value
		
		uint8_t delta_pot = pot_id[i]->locked_value - ((pot_id[i]->value >> 2)); //quick and dirty subtraction, where unsigned delta pot will overflow if value > locked value. see below
     786:	e9 91       	ld	r30, Y+
     788:	f9 91       	ld	r31, Y+
     78a:	92 81       	ldd	r25, Z+2	; 0x02
     78c:	20 81       	ld	r18, Z
     78e:	81 81       	ldd	r24, Z+1	; 0x01
     790:	38 2f       	mov	r19, r24
     792:	33 70       	andi	r19, 0x03	; 3
		
		
		if ((current_patch.mode == MANUAL) || (pot_id[i]->locked == 0)) { //if in manual mode or pot is already unlocked
     794:	d7 01       	movw	r26, r14
     796:	8c 91       	ld	r24, X
     798:	81 30       	cpi	r24, 0x01	; 1
     79a:	19 f0       	breq	.+6      	; 0x7a2 <scan_pots+0x8e>
     79c:	83 81       	ldd	r24, Z+3	; 0x03
     79e:	88 23       	and	r24, r24
     7a0:	24 f0       	brlt	.+8      	; 0x7aa <scan_pots+0x96>
			
			*(patch_value + i) = pot_id[i]->value; //this is a hacked way of indexing the patch structure. Depends on order of pots in pot array being the same as order of parameters in patch struct
     7a2:	f8 01       	movw	r30, r16
     7a4:	31 83       	std	Z+1, r19	; 0x01
     7a6:	20 83       	st	Z, r18
     7a8:	14 c0       	rjmp	.+40     	; 0x7d2 <scan_pots+0xbe>
		adc_value = read_pot(pot_id[i]);
		adc_change = adc_value - pot_id[i]->value;
		pot_id[i]->value = pot_id[i]->value + (adc_change >> 2);
		//what happens next depends on mode. if pot is locked, then the value of the pot is not written to the current patch unless it is different from the pot's locked value
		
		uint8_t delta_pot = pot_id[i]->locked_value - ((pot_id[i]->value >> 2)); //quick and dirty subtraction, where unsigned delta pot will overflow if value > locked value. see below
     7aa:	49 2f       	mov	r20, r25
     7ac:	43 50       	subi	r20, 0x03	; 3
     7ae:	c9 01       	movw	r24, r18
     7b0:	95 95       	asr	r25
     7b2:	87 95       	ror	r24
     7b4:	95 95       	asr	r25
     7b6:	87 95       	ror	r24
			
			*(patch_value + i) = pot_id[i]->value; //this is a hacked way of indexing the patch structure. Depends on order of pots in pot array being the same as order of parameters in patch struct
			
		//} else if ((((pot_id[i]->value >> 2) != pot_id[i]->locked_value)) && (pot_id[i]->locked == 1)) { //need to figure out delta threshold here. 10 bit to 8 bit resolution should be enough???
			
		} else if (((delta_pot > 2) && (delta_pot < 253)) && (pot_id[i]->locked == 1)) { //set a threshold of +/- 3 for pot change  		  		  	
     7b8:	94 2f       	mov	r25, r20
     7ba:	98 1b       	sub	r25, r24
     7bc:	9a 3f       	cpi	r25, 0xFA	; 250
     7be:	48 f4       	brcc	.+18     	; 0x7d2 <scan_pots+0xbe>
			*(patch_value + i) = pot_id[i]->value;
     7c0:	d8 01       	movw	r26, r16
     7c2:	11 96       	adiw	r26, 0x01	; 1
     7c4:	3c 93       	st	X, r19
     7c6:	2e 93       	st	-X, r18
			pot_id[i]->locked = 0; //unlock pot
     7c8:	83 81       	ldd	r24, Z+3	; 0x03
     7ca:	8f 77       	andi	r24, 0x7F	; 127
     7cc:	83 83       	std	Z+3, r24	; 0x03
			current_patch.mode = EDIT;
     7ce:	f7 01       	movw	r30, r14
     7d0:	b0 82       	st	Z, r11
     7d2:	0e 5f       	subi	r16, 0xFE	; 254
     7d4:	1f 4f       	sbci	r17, 0xFF	; 255

	int adc_change = 0;
	
	uint16_t *patch_value = &(current_patch.vco2_mix); //pointer to first element of current_patch struct
	//scan 30 parameter pots
	for (int i = 0; i <= 29; i++) {
     7d6:	cc 15       	cp	r28, r12
     7d8:	dd 05       	cpc	r29, r13
     7da:	09 f0       	breq	.+2      	; 0x7de <scan_pots+0xca>
     7dc:	b8 cf       	rjmp	.-144    	; 0x74e <scan_pots+0x3a>
		
	}
	
	
	//scan volume pot
	adc_value = read_pot(&volume_pot);
     7de:	8c e7       	ldi	r24, 0x7C	; 124
     7e0:	91 e0       	ldi	r25, 0x01	; 1
     7e2:	0e 94 64 00 	call	0xc8	; 0xc8 <read_pot>
     7e6:	90 93 bc 02 	sts	0x02BC, r25
     7ea:	80 93 bb 02 	sts	0x02BB, r24
	adc_change = adc_value - volume_pot.value;
     7ee:	20 91 7c 01 	lds	r18, 0x017C
     7f2:	40 91 7d 01 	lds	r20, 0x017D
     7f6:	34 2f       	mov	r19, r20
     7f8:	33 70       	andi	r19, 0x03	; 3
     7fa:	82 1b       	sub	r24, r18
     7fc:	93 0b       	sbc	r25, r19
	volume_pot.value = volume_pot.value + (adc_change >> 2);
     7fe:	95 95       	asr	r25
     800:	87 95       	ror	r24
     802:	95 95       	asr	r25
     804:	87 95       	ror	r24
     806:	28 0f       	add	r18, r24
     808:	39 1f       	adc	r19, r25
     80a:	20 93 7c 01 	sts	0x017C, r18
     80e:	83 2f       	mov	r24, r19
     810:	83 70       	andi	r24, 0x03	; 3
     812:	4c 7f       	andi	r20, 0xFC	; 252
     814:	48 2b       	or	r20, r24
     816:	40 93 7d 01 	sts	0x017D, r20
	
}
     81a:	df 91       	pop	r29
     81c:	cf 91       	pop	r28
     81e:	1f 91       	pop	r17
     820:	0f 91       	pop	r16
     822:	ff 90       	pop	r15
     824:	ef 90       	pop	r14
     826:	df 90       	pop	r13
     828:	cf 90       	pop	r12
     82a:	bf 90       	pop	r11
     82c:	08 95       	ret

0000082e <update_control_voltages>:

void update_control_voltages(void) { //keep everything updated in the current order of pots. Probably arbitrary, but try to minimize change from old CV update to new CV update
     82e:	cf 93       	push	r28
     830:	df 93       	push	r29
	
	set_control_voltage(&vco2_mix_cv, (current_patch.vco2_mix << 4));
     832:	60 91 c2 02 	lds	r22, 0x02C2
     836:	70 91 c3 02 	lds	r23, 0x02C3
     83a:	62 95       	swap	r22
     83c:	72 95       	swap	r23
     83e:	70 7f       	andi	r23, 0xF0	; 240
     840:	76 27       	eor	r23, r22
     842:	60 7f       	andi	r22, 0xF0	; 240
     844:	76 27       	eor	r23, r22
     846:	84 ee       	ldi	r24, 0xE4	; 228
     848:	91 e0       	ldi	r25, 0x01	; 1
     84a:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&vco1_mix_cv, (current_patch.vco1_mix << 4));
     84e:	60 91 c4 02 	lds	r22, 0x02C4
     852:	70 91 c5 02 	lds	r23, 0x02C5
     856:	62 95       	swap	r22
     858:	72 95       	swap	r23
     85a:	70 7f       	andi	r23, 0xF0	; 240
     85c:	76 27       	eor	r23, r22
     85e:	60 7f       	andi	r22, 0xF0	; 240
     860:	76 27       	eor	r23, r22
     862:	83 ee       	ldi	r24, 0xE3	; 227
     864:	91 e0       	ldi	r25, 0x01	; 1
     866:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&pitch_eg2_cv, (current_patch.pitch_eg2 << 3)); //1/4 scale
     86a:	60 91 c6 02 	lds	r22, 0x02C6
     86e:	70 91 c7 02 	lds	r23, 0x02C7
     872:	66 0f       	add	r22, r22
     874:	77 1f       	adc	r23, r23
     876:	66 0f       	add	r22, r22
     878:	77 1f       	adc	r23, r23
     87a:	66 0f       	add	r22, r22
     87c:	77 1f       	adc	r23, r23
     87e:	82 ee       	ldi	r24, 0xE2	; 226
     880:	91 e0       	ldi	r25, 0x01	; 1
     882:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&pitch_vco2_cv, (current_patch.pitch_vco2 << 4));
     886:	60 91 c8 02 	lds	r22, 0x02C8
     88a:	70 91 c9 02 	lds	r23, 0x02C9
     88e:	62 95       	swap	r22
     890:	72 95       	swap	r23
     892:	70 7f       	andi	r23, 0xF0	; 240
     894:	76 27       	eor	r23, r22
     896:	60 7f       	andi	r22, 0xF0	; 240
     898:	76 27       	eor	r23, r22
     89a:	82 eb       	ldi	r24, 0xB2	; 178
     89c:	92 e0       	ldi	r25, 0x02	; 2
     89e:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&pitch_lfo_cv, (current_patch.pitch_lfo << 3)); // 1/4 scale
     8a2:	60 91 ca 02 	lds	r22, 0x02CA
     8a6:	70 91 cb 02 	lds	r23, 0x02CB
     8aa:	66 0f       	add	r22, r22
     8ac:	77 1f       	adc	r23, r23
     8ae:	66 0f       	add	r22, r22
     8b0:	77 1f       	adc	r23, r23
     8b2:	66 0f       	add	r22, r22
     8b4:	77 1f       	adc	r23, r23
     8b6:	81 ee       	ldi	r24, 0xE1	; 225
     8b8:	91 e0       	ldi	r25, 0x01	; 1
     8ba:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&pwm_lfo_cv, (current_patch.pwm_lfo) << 4);
     8be:	60 91 cc 02 	lds	r22, 0x02CC
     8c2:	70 91 cd 02 	lds	r23, 0x02CD
     8c6:	62 95       	swap	r22
     8c8:	72 95       	swap	r23
     8ca:	70 7f       	andi	r23, 0xF0	; 240
     8cc:	76 27       	eor	r23, r22
     8ce:	60 7f       	andi	r22, 0xF0	; 240
     8d0:	76 27       	eor	r23, r22
     8d2:	80 ee       	ldi	r24, 0xE0	; 224
     8d4:	91 e0       	ldi	r25, 0x01	; 1
     8d6:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&pwm_eg2_cv, (current_patch.pwm_eg2) << 4);
     8da:	60 91 ce 02 	lds	r22, 0x02CE
     8de:	70 91 cf 02 	lds	r23, 0x02CF
     8e2:	62 95       	swap	r22
     8e4:	72 95       	swap	r23
     8e6:	70 7f       	andi	r23, 0xF0	; 240
     8e8:	76 27       	eor	r23, r22
     8ea:	60 7f       	andi	r22, 0xF0	; 240
     8ec:	76 27       	eor	r23, r22
     8ee:	8f ed       	ldi	r24, 0xDF	; 223
     8f0:	91 e0       	ldi	r25, 0x01	; 1
     8f2:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&vco1_pw_cv, (current_patch.vco1_pw) << 4);
     8f6:	60 91 d0 02 	lds	r22, 0x02D0
     8fa:	70 91 d1 02 	lds	r23, 0x02D1
     8fe:	62 95       	swap	r22
     900:	72 95       	swap	r23
     902:	70 7f       	andi	r23, 0xF0	; 240
     904:	76 27       	eor	r23, r22
     906:	60 7f       	andi	r22, 0xF0	; 240
     908:	76 27       	eor	r23, r22
     90a:	8e ed       	ldi	r24, 0xDE	; 222
     90c:	91 e0       	ldi	r25, 0x01	; 1
     90e:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	
	int tune_offset = 512 - current_patch.tune; //master tune offset
     912:	80 91 d4 02 	lds	r24, 0x02D4
     916:	90 91 d5 02 	lds	r25, 0x02D5
     91a:	c0 e0       	ldi	r28, 0x00	; 0
     91c:	d2 e0       	ldi	r29, 0x02	; 2
     91e:	c8 1b       	sub	r28, r24
     920:	d9 0b       	sbc	r29, r25
	
	int fine_offset = 512 - current_patch.fine; //fine tune offset
     922:	60 91 6d 03 	lds	r22, 0x036D
     926:	70 91 6e 03 	lds	r23, 0x036E
     92a:	60 50       	subi	r22, 0x00	; 0
     92c:	7e 4f       	sbci	r23, 0xFE	; 254
	
	set_control_voltage(&fine_cv, vco2_init_cv + tune_offset + fine_offset);
     92e:	80 91 d2 02 	lds	r24, 0x02D2
     932:	90 91 d3 02 	lds	r25, 0x02D3
     936:	68 1b       	sub	r22, r24
     938:	79 0b       	sbc	r23, r25
     93a:	6c 0f       	add	r22, r28
     93c:	7d 1f       	adc	r23, r29
     93e:	8d ed       	ldi	r24, 0xDD	; 221
     940:	91 e0       	ldi	r25, 0x01	; 1
     942:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&tune_cv, vco1_init_cv + tune_offset);
     946:	60 91 6f 03 	lds	r22, 0x036F
     94a:	70 91 70 03 	lds	r23, 0x0370
     94e:	6c 0f       	add	r22, r28
     950:	7d 1f       	adc	r23, r29
     952:	8c ed       	ldi	r24, 0xDC	; 220
     954:	91 e0       	ldi	r25, 0x01	; 1
     956:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	
	set_control_voltage(&lfo_rate_cv, (current_patch.lfo_rate) << 4);
     95a:	60 91 d6 02 	lds	r22, 0x02D6
     95e:	70 91 d7 02 	lds	r23, 0x02D7
     962:	62 95       	swap	r22
     964:	72 95       	swap	r23
     966:	70 7f       	andi	r23, 0xF0	; 240
     968:	76 27       	eor	r23, r22
     96a:	60 7f       	andi	r22, 0xF0	; 240
     96c:	76 27       	eor	r23, r22
     96e:	8b ed       	ldi	r24, 0xDB	; 219
     970:	91 e0       	ldi	r25, 0x01	; 1
     972:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&glide_cv, (current_patch.glide) << 4);
     976:	60 91 da 02 	lds	r22, 0x02DA
     97a:	70 91 db 02 	lds	r23, 0x02DB
     97e:	62 95       	swap	r22
     980:	72 95       	swap	r23
     982:	70 7f       	andi	r23, 0xF0	; 240
     984:	76 27       	eor	r23, r22
     986:	60 7f       	andi	r22, 0xF0	; 240
     988:	76 27       	eor	r23, r22
     98a:	8a ed       	ldi	r24, 0xDA	; 218
     98c:	91 e0       	ldi	r25, 0x01	; 1
     98e:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&amp_lfo_cv, (current_patch.amp_lfo) << 4);
     992:	60 91 dc 02 	lds	r22, 0x02DC
     996:	70 91 dd 02 	lds	r23, 0x02DD
     99a:	62 95       	swap	r22
     99c:	72 95       	swap	r23
     99e:	70 7f       	andi	r23, 0xF0	; 240
     9a0:	76 27       	eor	r23, r22
     9a2:	60 7f       	andi	r22, 0xF0	; 240
     9a4:	76 27       	eor	r23, r22
     9a6:	89 ed       	ldi	r24, 0xD9	; 217
     9a8:	91 e0       	ldi	r25, 0x01	; 1
     9aa:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&volume_cv, (volume_pot.value << 4)); //volume level not a patch parameter
     9ae:	60 91 7c 01 	lds	r22, 0x017C
     9b2:	80 91 7d 01 	lds	r24, 0x017D
     9b6:	78 2f       	mov	r23, r24
     9b8:	73 70       	andi	r23, 0x03	; 3
     9ba:	62 95       	swap	r22
     9bc:	72 95       	swap	r23
     9be:	70 7f       	andi	r23, 0xF0	; 240
     9c0:	76 27       	eor	r23, r22
     9c2:	60 7f       	andi	r22, 0xF0	; 240
     9c4:	76 27       	eor	r23, r22
     9c6:	88 ed       	ldi	r24, 0xD8	; 216
     9c8:	91 e0       	ldi	r25, 0x01	; 1
     9ca:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&vco2_pw_cv, (current_patch.vco2_pw) << 4);	
     9ce:	60 91 de 02 	lds	r22, 0x02DE
     9d2:	70 91 df 02 	lds	r23, 0x02DF
     9d6:	62 95       	swap	r22
     9d8:	72 95       	swap	r23
     9da:	70 7f       	andi	r23, 0xF0	; 240
     9dc:	76 27       	eor	r23, r22
     9de:	60 7f       	andi	r22, 0xF0	; 240
     9e0:	76 27       	eor	r23, r22
     9e2:	87 ed       	ldi	r24, 0xD7	; 215
     9e4:	91 e0       	ldi	r25, 0x01	; 1
     9e6:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	
	set_control_voltage(&fil_eg2_cv, (current_patch.fil_eg2) << 4);
     9ea:	60 91 e0 02 	lds	r22, 0x02E0
     9ee:	70 91 e1 02 	lds	r23, 0x02E1
     9f2:	62 95       	swap	r22
     9f4:	72 95       	swap	r23
     9f6:	70 7f       	andi	r23, 0xF0	; 240
     9f8:	76 27       	eor	r23, r22
     9fa:	60 7f       	andi	r22, 0xF0	; 240
     9fc:	76 27       	eor	r23, r22
     9fe:	86 ed       	ldi	r24, 0xD6	; 214
     a00:	91 e0       	ldi	r25, 0x01	; 1
     a02:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&res_cv, (current_patch.res) << 4);
     a06:	60 91 e2 02 	lds	r22, 0x02E2
     a0a:	70 91 e3 02 	lds	r23, 0x02E3
     a0e:	62 95       	swap	r22
     a10:	72 95       	swap	r23
     a12:	70 7f       	andi	r23, 0xF0	; 240
     a14:	76 27       	eor	r23, r22
     a16:	60 7f       	andi	r22, 0xF0	; 240
     a18:	76 27       	eor	r23, r22
     a1a:	85 ed       	ldi	r24, 0xD5	; 213
     a1c:	91 e0       	ldi	r25, 0x01	; 1
     a1e:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	
	//this next bit should be separated out, but leave it here for now while testing decoupled adc/dac read/write
	uint8_t note = get_current_note(); //get current note from assigner
     a22:	0e 94 a3 00 	call	0x146	; 0x146 <get_current_note>
     a26:	c8 2f       	mov	r28, r24
	if (note < 8) note = 8; //init_cv gives VCO range from MIDI note 8 to MIDI note 127+. If you don't set notes <8 to 8 then you get array out of bounds problems. Should find a better way to handle this.
     a28:	88 30       	cpi	r24, 0x08	; 8
     a2a:	08 f4       	brcc	.+2      	; 0xa2e <update_control_voltages+0x200>
     a2c:	c8 e0       	ldi	r28, 0x08	; 8
	//value_to_display = note;
		
	uint16_t interpolated_pitch_cv = 0; //holder for interpolated pitch values
	
	interpolated_pitch_cv = interpolate_pitch_cv(note-8, filter_pitch_table); //subtract 8 from note because filter pitch is calibrated so that 0V is E, 20.6 Hz
     a2e:	8c 2f       	mov	r24, r28
     a30:	88 50       	subi	r24, 0x08	; 8
     a32:	69 e0       	ldi	r22, 0x09	; 9
     a34:	73 e0       	ldi	r23, 0x03	; 3
     a36:	0e 94 2b 13 	call	0x2656	; 0x2656 <interpolate_pitch_cv>
	//note that product of key_track and interpolated_pitch_cv needs to be cast as uint32t - otherwise product is evaluated incorrectly
	uint16_t divided_pitch_cv = ((uint32_t)current_patch.key_track*interpolated_pitch_cv) >> 10;
     a3a:	bc 01       	movw	r22, r24
     a3c:	80 e0       	ldi	r24, 0x00	; 0
     a3e:	90 e0       	ldi	r25, 0x00	; 0
     a40:	20 91 e6 02 	lds	r18, 0x02E6
     a44:	30 91 e7 02 	lds	r19, 0x02E7
     a48:	40 e0       	ldi	r20, 0x00	; 0
     a4a:	50 e0       	ldi	r21, 0x00	; 0
     a4c:	0e 94 bc 1a 	call	0x3578	; 0x3578 <__mulsi3>
     a50:	dc 01       	movw	r26, r24
     a52:	cb 01       	movw	r24, r22
     a54:	07 2e       	mov	r0, r23
     a56:	7a e0       	ldi	r23, 0x0A	; 10
     a58:	b6 95       	lsr	r27
     a5a:	a7 95       	ror	r26
     a5c:	97 95       	ror	r25
     a5e:	87 95       	ror	r24
     a60:	7a 95       	dec	r23
     a62:	d1 f7       	brne	.-12     	; 0xa58 <update_control_voltages+0x22a>
     a64:	70 2d       	mov	r23, r0
	uint16_t filter_cutoff_cv = divided_pitch_cv + (current_patch.cutoff << 4); //filter cutoff CV is the sum of filter cutoff pot and key track amount.
     a66:	60 91 e4 02 	lds	r22, 0x02E4
     a6a:	70 91 e5 02 	lds	r23, 0x02E5
     a6e:	62 95       	swap	r22
     a70:	72 95       	swap	r23
     a72:	70 7f       	andi	r23, 0xF0	; 240
     a74:	76 27       	eor	r23, r22
     a76:	60 7f       	andi	r22, 0xF0	; 240
     a78:	76 27       	eor	r23, r22
     a7a:	86 0f       	add	r24, r22
     a7c:	97 1f       	adc	r25, r23
	if (filter_cutoff_cv > MAX) filter_cutoff_cv = MAX; //make sure there is no overflow/wrap by capping max
	set_control_voltage(&cutoff_cv, filter_cutoff_cv);	
     a7e:	bc 01       	movw	r22, r24
     a80:	80 e4       	ldi	r24, 0x40	; 64
     a82:	60 30       	cpi	r22, 0x00	; 0
     a84:	78 07       	cpc	r23, r24
     a86:	10 f0       	brcs	.+4      	; 0xa8c <update_control_voltages+0x25e>
     a88:	6f ef       	ldi	r22, 0xFF	; 255
     a8a:	7f e3       	ldi	r23, 0x3F	; 63
     a8c:	84 ed       	ldi	r24, 0xD4	; 212
     a8e:	91 e0       	ldi	r25, 0x01	; 1
     a90:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	
	set_control_voltage(&fil_vco2_cv, (current_patch.fil_vco2) << 4);
     a94:	60 91 e8 02 	lds	r22, 0x02E8
     a98:	70 91 e9 02 	lds	r23, 0x02E9
     a9c:	62 95       	swap	r22
     a9e:	72 95       	swap	r23
     aa0:	70 7f       	andi	r23, 0xF0	; 240
     aa2:	76 27       	eor	r23, r22
     aa4:	60 7f       	andi	r22, 0xF0	; 240
     aa6:	76 27       	eor	r23, r22
     aa8:	82 ed       	ldi	r24, 0xD2	; 210
     aaa:	91 e0       	ldi	r25, 0x01	; 1
     aac:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&fil_lfo_cv, (current_patch.fil_lfo) << 4);
     ab0:	60 91 ea 02 	lds	r22, 0x02EA
     ab4:	70 91 eb 02 	lds	r23, 0x02EB
     ab8:	62 95       	swap	r22
     aba:	72 95       	swap	r23
     abc:	70 7f       	andi	r23, 0xF0	; 240
     abe:	76 27       	eor	r23, r22
     ac0:	60 7f       	andi	r22, 0xF0	; 240
     ac2:	76 27       	eor	r23, r22
     ac4:	81 ed       	ldi	r24, 0xD1	; 209
     ac6:	91 e0       	ldi	r25, 0x01	; 1
     ac8:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&noise_mix_cv, (current_patch.noise_mix) << 4);
     acc:	60 91 ec 02 	lds	r22, 0x02EC
     ad0:	70 91 ed 02 	lds	r23, 0x02ED
     ad4:	62 95       	swap	r22
     ad6:	72 95       	swap	r23
     ad8:	70 7f       	andi	r23, 0xF0	; 240
     ada:	76 27       	eor	r23, r22
     adc:	60 7f       	andi	r22, 0xF0	; 240
     ade:	76 27       	eor	r23, r22
     ae0:	80 ed       	ldi	r24, 0xD0	; 208
     ae2:	91 e0       	ldi	r25, 0x01	; 1
     ae4:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&attack_2_cv, (current_patch.attack_2) << 4);
     ae8:	60 91 ee 02 	lds	r22, 0x02EE
     aec:	70 91 ef 02 	lds	r23, 0x02EF
     af0:	62 95       	swap	r22
     af2:	72 95       	swap	r23
     af4:	70 7f       	andi	r23, 0xF0	; 240
     af6:	76 27       	eor	r23, r22
     af8:	60 7f       	andi	r22, 0xF0	; 240
     afa:	76 27       	eor	r23, r22
     afc:	8f ec       	ldi	r24, 0xCF	; 207
     afe:	91 e0       	ldi	r25, 0x01	; 1
     b00:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&attack_1_cv, (current_patch.attack_1) << 4);
     b04:	60 91 f0 02 	lds	r22, 0x02F0
     b08:	70 91 f1 02 	lds	r23, 0x02F1
     b0c:	62 95       	swap	r22
     b0e:	72 95       	swap	r23
     b10:	70 7f       	andi	r23, 0xF0	; 240
     b12:	76 27       	eor	r23, r22
     b14:	60 7f       	andi	r22, 0xF0	; 240
     b16:	76 27       	eor	r23, r22
     b18:	8e ec       	ldi	r24, 0xCE	; 206
     b1a:	91 e0       	ldi	r25, 0x01	; 1
     b1c:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&decay_2_cv, (current_patch.decay_2) << 4);
     b20:	60 91 f2 02 	lds	r22, 0x02F2
     b24:	70 91 f3 02 	lds	r23, 0x02F3
     b28:	62 95       	swap	r22
     b2a:	72 95       	swap	r23
     b2c:	70 7f       	andi	r23, 0xF0	; 240
     b2e:	76 27       	eor	r23, r22
     b30:	60 7f       	andi	r22, 0xF0	; 240
     b32:	76 27       	eor	r23, r22
     b34:	8d ec       	ldi	r24, 0xCD	; 205
     b36:	91 e0       	ldi	r25, 0x01	; 1
     b38:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&decay_1_cv, (current_patch.decay_1) << 4);
     b3c:	60 91 f4 02 	lds	r22, 0x02F4
     b40:	70 91 f5 02 	lds	r23, 0x02F5
     b44:	62 95       	swap	r22
     b46:	72 95       	swap	r23
     b48:	70 7f       	andi	r23, 0xF0	; 240
     b4a:	76 27       	eor	r23, r22
     b4c:	60 7f       	andi	r22, 0xF0	; 240
     b4e:	76 27       	eor	r23, r22
     b50:	8c ec       	ldi	r24, 0xCC	; 204
     b52:	91 e0       	ldi	r25, 0x01	; 1
     b54:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&sustain_1_cv, (current_patch.sustain_1) << 4);
     b58:	60 91 f8 02 	lds	r22, 0x02F8
     b5c:	70 91 f9 02 	lds	r23, 0x02F9
     b60:	62 95       	swap	r22
     b62:	72 95       	swap	r23
     b64:	70 7f       	andi	r23, 0xF0	; 240
     b66:	76 27       	eor	r23, r22
     b68:	60 7f       	andi	r22, 0xF0	; 240
     b6a:	76 27       	eor	r23, r22
     b6c:	8a ec       	ldi	r24, 0xCA	; 202
     b6e:	91 e0       	ldi	r25, 0x01	; 1
     b70:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&sustain_2_cv, (current_patch.sustain_2) << 4);
     b74:	60 91 f6 02 	lds	r22, 0x02F6
     b78:	70 91 f7 02 	lds	r23, 0x02F7
     b7c:	62 95       	swap	r22
     b7e:	72 95       	swap	r23
     b80:	70 7f       	andi	r23, 0xF0	; 240
     b82:	76 27       	eor	r23, r22
     b84:	60 7f       	andi	r22, 0xF0	; 240
     b86:	76 27       	eor	r23, r22
     b88:	8b ec       	ldi	r24, 0xCB	; 203
     b8a:	91 e0       	ldi	r25, 0x01	; 1
     b8c:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&release_1_cv, (current_patch.release_1) << 4);
     b90:	60 91 fc 02 	lds	r22, 0x02FC
     b94:	70 91 fd 02 	lds	r23, 0x02FD
     b98:	62 95       	swap	r22
     b9a:	72 95       	swap	r23
     b9c:	70 7f       	andi	r23, 0xF0	; 240
     b9e:	76 27       	eor	r23, r22
     ba0:	60 7f       	andi	r22, 0xF0	; 240
     ba2:	76 27       	eor	r23, r22
     ba4:	88 ec       	ldi	r24, 0xC8	; 200
     ba6:	91 e0       	ldi	r25, 0x01	; 1
     ba8:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&release_2_cv, (current_patch.release_2) << 4);
     bac:	60 91 fa 02 	lds	r22, 0x02FA
     bb0:	70 91 fb 02 	lds	r23, 0x02FB
     bb4:	62 95       	swap	r22
     bb6:	72 95       	swap	r23
     bb8:	70 7f       	andi	r23, 0xF0	; 240
     bba:	76 27       	eor	r23, r22
     bbc:	60 7f       	andi	r22, 0xF0	; 240
     bbe:	76 27       	eor	r23, r22
     bc0:	89 ec       	ldi	r24, 0xC9	; 201
     bc2:	91 e0       	ldi	r25, 0x01	; 1
     bc4:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>

	//set VCO1 and VCO2 pitch control voltages. Remember, set_control_voltage() is expecting a pointer to a control_voltage struct
	//that contains the control_voltage multiplexer channel and the multiplexer address
	

	uint8_t vco1_note = transpose_note(note, VCO1); //transpose
     bc8:	8c 2f       	mov	r24, r28
     bca:	6f e0       	ldi	r22, 0x0F	; 15
     bcc:	0e 94 8b 0b 	call	0x1716	; 0x1716 <transpose_note>

	interpolated_pitch_cv = interpolate_pitch_cv(vco1_note, vco1_pitch_table);
     bd0:	6b e4       	ldi	r22, 0x4B	; 75
     bd2:	73 e0       	ldi	r23, 0x03	; 3
     bd4:	0e 94 2b 13 	call	0x2656	; 0x2656 <interpolate_pitch_cv>
     bd8:	bc 01       	movw	r22, r24
	
	//value_to_display = interpolated_pitch_cv;
	
	set_control_voltage(&vco1_pitch_cv, interpolated_pitch_cv);
     bda:	86 ee       	ldi	r24, 0xE6	; 230
     bdc:	91 e0       	ldi	r25, 0x01	; 1
     bde:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	
	uint8_t vco2_note = transpose_note(note, VCO2);
     be2:	8c 2f       	mov	r24, r28
     be4:	60 ef       	ldi	r22, 0xF0	; 240
     be6:	0e 94 8b 0b 	call	0x1716	; 0x1716 <transpose_note>
	
	interpolated_pitch_cv = interpolate_pitch_cv(vco2_note, vco2_pitch_table);
     bea:	69 e2       	ldi	r22, 0x29	; 41
     bec:	73 e0       	ldi	r23, 0x03	; 3
     bee:	0e 94 2b 13 	call	0x2656	; 0x2656 <interpolate_pitch_cv>
     bf2:	bc 01       	movw	r22, r24
	
	set_control_voltage(&vco2_pitch_cv, interpolated_pitch_cv);
     bf4:	85 ee       	ldi	r24, 0xE5	; 229
     bf6:	91 e0       	ldi	r25, 0x01	; 1
     bf8:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
		
	DAC_CTRL &= ~(1<<DAC_RS); //reset DAC
     bfc:	a1 98       	cbi	0x14, 1	; 20
	DAC_CTRL |= (1<<DAC_RS);
     bfe:	a1 9a       	sbi	0x14, 1	; 20
}			
     c00:	df 91       	pop	r29
     c02:	cf 91       	pop	r28
     c04:	08 95       	ret

00000c06 <setup_spi>:
void setup_spi(void) {
	
		//SET SPI_DATA_OUT and SPI_CLK and SPI_SW_LATCH pins as outputs
		//also set Slave Select (PB0) as output just to ensure it doesn't interfere with SPI communication (currently floating)
		//ACTUALLY, Slave Select ***MUST*** be set as output. Leaving it floating without setting its data direction bit breaks SPI!
		DDRB |= (SPI_DATA_OUT | SPI_CLK | SPI_SW_LATCH |(1<<PB0));
     c06:	84 b1       	in	r24, 0x04	; 4
     c08:	87 62       	ori	r24, 0x27	; 39
     c0a:	84 b9       	out	0x04, r24	; 4
		
		//SET SPI_EN and LED_LATCH and VCO_SW_LATCH and EG2_POL pins as outputs
		DDRJ |= (SPI_EN | LED_LATCH | (1<<VCO_SW_LATCH) | (1<<EG2_POL));
     c0c:	ec ed       	ldi	r30, 0xDC	; 220
     c0e:	f0 e0       	ldi	r31, 0x00	; 0
     c10:	80 81       	ld	r24, Z
     c12:	8c 65       	ori	r24, 0x5C	; 92
     c14:	80 83       	st	Z, r24
		
		//SET SPI_DATA_OUT and SPI_CLK and SPI_SW_LATCH outputs LOW
		SPI_PORT &= ~(SPI_DATA_OUT | SPI_CLK | SPI_SW_LATCH);
     c16:	85 b1       	in	r24, 0x05	; 5
     c18:	89 7d       	andi	r24, 0xD9	; 217
     c1a:	85 b9       	out	0x05, r24	; 5
		
		//SET SPI_EN LOW (active) and LED_LATCH LOW (active)
		SPI_LATCH_PORT &= ~(SPI_EN | LED_LATCH);
     c1c:	ed ed       	ldi	r30, 0xDD	; 221
     c1e:	f0 e0       	ldi	r31, 0x00	; 0
     c20:	80 81       	ld	r24, Z
     c22:	83 7f       	andi	r24, 0xF3	; 243
     c24:	80 83       	st	Z, r24
		
		//SET UP SPI
		SPCR = (1<<SPE) | (1<<MSTR); //Start SPI as MASTER
     c26:	80 e5       	ldi	r24, 0x50	; 80
     c28:	8c bd       	out	0x2c, r24	; 44
		
		//Pull LED_LATCH LOW
		SPI_LATCH_PORT &= ~LED_LATCH;
     c2a:	80 81       	ld	r24, Z
     c2c:	87 7f       	andi	r24, 0xF7	; 247
     c2e:	80 83       	st	Z, r24
		
		
		//Toggle LED_LATCH to shift data to 74HC595 shift register outputs
		
		SPI_LATCH_PORT &= ~LED_LATCH;
     c30:	80 81       	ld	r24, Z
     c32:	87 7f       	andi	r24, 0xF7	; 247
     c34:	80 83       	st	Z, r24
		SPI_LATCH_PORT |= LED_LATCH;
     c36:	80 81       	ld	r24, Z
     c38:	88 60       	ori	r24, 0x08	; 8
     c3a:	80 83       	st	Z, r24
		
		//set EG2 POL
		EG2_POL_PORT &= ~(1 << EG2_POL); //0 for normal, 1 for inverted
     c3c:	80 81       	ld	r24, Z
     c3e:	8f 7e       	andi	r24, 0xEF	; 239
     c40:	80 83       	st	Z, r24
	
}
     c42:	08 95       	ret

00000c44 <spi_shift_byte>:

uint8_t spi_shift_byte(uint8_t byte) { //shifts out byte for LED data and simultaneously reads switch data
	
	SPDR = byte;
     c44:	8e bd       	out	0x2e, r24	; 46
	while (!(SPSR & (1<<SPIF)));
     c46:	0d b4       	in	r0, 0x2d	; 45
     c48:	07 fe       	sbrs	r0, 7
     c4a:	fd cf       	rjmp	.-6      	; 0xc46 <spi_shift_byte+0x2>
	return SPDR;
     c4c:	8e b5       	in	r24, 0x2e	; 46
	
}
     c4e:	08 95       	ret

00000c50 <update_spi>:

void update_spi(void) {
	
			SPI_PORT |= SPI_SW_LATCH;
     c50:	2d 9a       	sbi	0x05, 5	; 5
			
			//SHIFT 5th BYTE				
			//Read SPDR for switch data shifted in from 74XX165 U14 and write LED data to LED latch 5
			spi_sw_byte0_current_state = spi_shift_byte(current_patch.byte_5);
     c52:	80 91 02 03 	lds	r24, 0x0302
     c56:	0e 94 22 06 	call	0xc44	; 0xc44 <spi_shift_byte>
			switch_press |= spi_sw_byte0_current_state; //set switch press global flag
     c5a:	90 91 c1 02 	lds	r25, 0x02C1
     c5e:	98 2b       	or	r25, r24
     c60:	90 93 c1 02 	sts	0x02C1, r25
			spi_sw_byte0_current_state ^= spi_sw_byte0_previous_state;
     c64:	20 91 bf 02 	lds	r18, 0x02BF
     c68:	98 2f       	mov	r25, r24
     c6a:	92 27       	eor	r25, r18
			spi_sw_byte0_previous_state ^= spi_sw_byte0_current_state;
     c6c:	89 2f       	mov	r24, r25
     c6e:	82 27       	eor	r24, r18
     c70:	80 93 bf 02 	sts	0x02BF, r24
			spi_sw_byte0_current_state &= spi_sw_byte0_previous_state;
     c74:	89 23       	and	r24, r25
     c76:	80 93 c0 02 	sts	0x02C0, r24
			
			//toggle switch state		
			switch_states.byte0 ^= spi_sw_byte0_current_state; //Omar's solution.
     c7a:	90 91 78 03 	lds	r25, 0x0378
     c7e:	89 27       	eor	r24, r25
     c80:	80 93 78 03 	sts	0x0378, r24
			//Now read SPDR for switch data shifted in from 74XX165 (U9)
			//uint8_t spi_data = (1<<VCO2_32F | 1<<VCO1_32F); //turn on 32' octave LEDs as default 
			
			uint8_t spi_data = current_patch.byte_4;
					
			spi_sw_byte1_current_state = spi_shift_byte(spi_data);
     c84:	80 91 01 03 	lds	r24, 0x0301
     c88:	0e 94 22 06 	call	0xc44	; 0xc44 <spi_shift_byte>
			switch_press |= spi_sw_byte1_current_state;
     c8c:	90 91 c1 02 	lds	r25, 0x02C1
     c90:	98 2b       	or	r25, r24
     c92:	90 93 c1 02 	sts	0x02C1, r25
			spi_sw_byte1_current_state ^= spi_sw_byte1_previous_state;
     c96:	20 91 bd 02 	lds	r18, 0x02BD
     c9a:	98 2f       	mov	r25, r24
     c9c:	92 27       	eor	r25, r18
			spi_sw_byte1_previous_state ^= spi_sw_byte1_current_state;
     c9e:	89 2f       	mov	r24, r25
     ca0:	82 27       	eor	r24, r18
     ca2:	80 93 bd 02 	sts	0x02BD, r24
			spi_sw_byte1_current_state &= spi_sw_byte1_previous_state;
     ca6:	89 23       	and	r24, r25
     ca8:	80 93 be 02 	sts	0x02BE, r24
			
			//toggle switch state
			switch_states.byte1 ^= spi_sw_byte1_current_state; //Omar's solution.			
     cac:	90 91 79 03 	lds	r25, 0x0379
     cb0:	89 27       	eor	r24, r25
     cb2:	80 93 79 03 	sts	0x0379, r24
							
			//SHIFT 3th BYTE
			spi_shift_byte(current_patch.byte_3);
     cb6:	80 91 00 03 	lds	r24, 0x0300
     cba:	0e 94 22 06 	call	0xc44	; 0xc44 <spi_shift_byte>

			//SHIFT 2th BYTE
			spi_shift_byte(current_patch.byte_2);
     cbe:	80 91 ff 02 	lds	r24, 0x02FF
     cc2:	0e 94 22 06 	call	0xc44	; 0xc44 <spi_shift_byte>
			
			//SHIFT 1st BYTE	//eventually need to parse this elsewhere		
			spi_data =	((switch_states.byte1 >> ARP_MODE_SW) & 1) << ARP_MODE | 
     cc6:	30 91 79 03 	lds	r19, 0x0379
     cca:	36 95       	lsr	r19
     ccc:	36 95       	lsr	r19
     cce:	36 95       	lsr	r19
     cd0:	34 70       	andi	r19, 0x04	; 4
     cd2:	80 91 05 03 	lds	r24, 0x0305
     cd6:	83 30       	cpi	r24, 0x03	; 3
     cd8:	11 f4       	brne	.+4      	; 0xcde <update_spi+0x8e>
     cda:	80 e8       	ldi	r24, 0x80	; 128
     cdc:	01 c0       	rjmp	.+2      	; 0xce0 <update_spi+0x90>
     cde:	80 e0       	ldi	r24, 0x00	; 0
						//((switch_states.byte2 >> PROG_WRITE_SW) & 1) << PROG_WRITE | 
						((current_patch.mode == WRITE) << PROG_WRITE) | //hack to light PROG WRITE LED only when in WRITE mode
						((switch_states.byte2 >> EG2_INV_SW) &1 ) << EG2_INV |
     ce0:	90 91 7a 03 	lds	r25, 0x037A
						((switch_states.byte2 >> PROG_MANUAL_SW &1) << PROG_MANUAL); 			
     ce4:	29 2f       	mov	r18, r25
     ce6:	22 1f       	adc	r18, r18
     ce8:	22 27       	eor	r18, r18
     cea:	22 1f       	adc	r18, r18
     cec:	22 95       	swap	r18
     cee:	22 0f       	add	r18, r18
     cf0:	22 0f       	add	r18, r18
     cf2:	20 7c       	andi	r18, 0xC0	; 192

			//SHIFT 2th BYTE
			spi_shift_byte(current_patch.byte_2);
			
			//SHIFT 1st BYTE	//eventually need to parse this elsewhere		
			spi_data =	((switch_states.byte1 >> ARP_MODE_SW) & 1) << ARP_MODE | 
     cf4:	23 2b       	or	r18, r19
     cf6:	96 95       	lsr	r25
     cf8:	96 95       	lsr	r25
     cfa:	96 95       	lsr	r25
     cfc:	91 70       	andi	r25, 0x01	; 1
     cfe:	92 2b       	or	r25, r18
						//((switch_states.byte2 >> PROG_WRITE_SW) & 1) << PROG_WRITE | 
						((current_patch.mode == WRITE) << PROG_WRITE) | //hack to light PROG WRITE LED only when in WRITE mode
						((switch_states.byte2 >> EG2_INV_SW) &1 ) << EG2_INV |
						((switch_states.byte2 >> PROG_MANUAL_SW &1) << PROG_MANUAL); 			
			//Wait for SPI shift to complete
			spi_shift_byte(spi_data);
     d00:	89 2b       	or	r24, r25
     d02:	0e 94 22 06 	call	0xc44	; 0xc44 <spi_shift_byte>
			
			//Toggle LED_LATCH to shift data to 74HC595 shift register outputs
			
			SPI_LATCH_PORT &= ~LED_LATCH;
     d06:	ed ed       	ldi	r30, 0xDD	; 221
     d08:	f0 e0       	ldi	r31, 0x00	; 0
     d0a:	80 81       	ld	r24, Z
     d0c:	87 7f       	andi	r24, 0xF7	; 247
     d0e:	80 83       	st	Z, r24
			SPI_LATCH_PORT |= LED_LATCH;
     d10:	80 81       	ld	r24, Z
     d12:	88 60       	ori	r24, 0x08	; 8
     d14:	80 83       	st	Z, r24
			
			//clear SPI_SW_LATCH
			SPI_PORT &= ~SPI_SW_LATCH;
     d16:	2d 98       	cbi	0x05, 5	; 5
			
			

	
     d18:	08 95       	ret

00000d1a <lock_pots>:
		LFO_PULSE_ADDR,
		LFO_RNDM_ADDR
	};
	

void lock_pots(void) { //run this every time new patch is loaded to lock pots and store locked values
     d1a:	a0 e0       	ldi	r26, 0x00	; 0
     d1c:	b1 e0       	ldi	r27, 0x01	; 1
     d1e:	9d 01       	movw	r18, r26
     d20:	24 5c       	subi	r18, 0xC4	; 196
     d22:	3f 4f       	sbci	r19, 0xFF	; 255

for (int i = 0; i <= 29; i++) {
	
	pot_id[i]->locked_value = (pot_id[i]->value) >> 2;
     d24:	ed 91       	ld	r30, X+
     d26:	fc 91       	ld	r31, X
     d28:	11 97       	sbiw	r26, 0x01	; 1
     d2a:	80 81       	ld	r24, Z
     d2c:	41 81       	ldd	r20, Z+1	; 0x01
     d2e:	94 2f       	mov	r25, r20
     d30:	93 70       	andi	r25, 0x03	; 3
     d32:	95 95       	asr	r25
     d34:	87 95       	ror	r24
     d36:	95 95       	asr	r25
     d38:	87 95       	ror	r24
     d3a:	82 83       	std	Z+2, r24	; 0x02
	pot_id[i]->locked = 1;
     d3c:	ed 91       	ld	r30, X+
     d3e:	fd 91       	ld	r31, X+
     d40:	83 81       	ldd	r24, Z+3	; 0x03
     d42:	80 68       	ori	r24, 0x80	; 128
     d44:	83 83       	std	Z+3, r24	; 0x03
	};
	

void lock_pots(void) { //run this every time new patch is loaded to lock pots and store locked values

for (int i = 0; i <= 29; i++) {
     d46:	a2 17       	cp	r26, r18
     d48:	b3 07       	cpc	r27, r19
     d4a:	61 f7       	brne	.-40     	; 0xd24 <lock_pots+0xa>
	pot_id[i]->locked_value = (pot_id[i]->value) >> 2;
	pot_id[i]->locked = 1;
	
}

}
     d4c:	08 95       	ret

00000d4e <unlock_pots>:

void unlock_pots(void) {
     d4e:	e0 e0       	ldi	r30, 0x00	; 0
     d50:	f1 e0       	ldi	r31, 0x01	; 1
     d52:	cf 01       	movw	r24, r30
     d54:	cc 96       	adiw	r24, 0x3c	; 60
	
	for (int i = 0; i <= 29; i++) {
		
		pot_id[i]->locked = 0;
     d56:	a1 91       	ld	r26, Z+
     d58:	b1 91       	ld	r27, Z+
     d5a:	13 96       	adiw	r26, 0x03	; 3
     d5c:	2c 91       	ld	r18, X
     d5e:	13 97       	sbiw	r26, 0x03	; 3
     d60:	2f 77       	andi	r18, 0x7F	; 127
     d62:	13 96       	adiw	r26, 0x03	; 3
     d64:	2c 93       	st	X, r18
     d66:	13 97       	sbiw	r26, 0x03	; 3

}

void unlock_pots(void) {
	
	for (int i = 0; i <= 29; i++) {
     d68:	e8 17       	cp	r30, r24
     d6a:	f9 07       	cpc	r31, r25
     d6c:	a1 f7       	brne	.-24     	; 0xd56 <unlock_pots+0x8>
		
		pot_id[i]->locked = 0;
		
	}
	
}			
     d6e:	08 95       	ret

00000d70 <save_patch>:
	
	
void save_patch(uint8_t patch_number) {
     d70:	1f 93       	push	r17
     d72:	cf 93       	push	r28
     d74:	df 93       	push	r29
     d76:	cd b7       	in	r28, 0x3d	; 61
     d78:	de b7       	in	r29, 0x3e	; 62
     d7a:	ab 97       	sbiw	r28, 0x2b	; 43
     d7c:	0f b6       	in	r0, 0x3f	; 63
     d7e:	f8 94       	cli
     d80:	de bf       	out	0x3e, r29	; 62
     d82:	0f be       	out	0x3f, r0	; 63
     d84:	cd bf       	out	0x3d, r28	; 61
     d86:	18 2f       	mov	r17, r24
	
	struct eeprom_patch patch_to_save;
	//because of bit fields in eeprom patch struct, a temporary eeprom patch needs to be filled with current_patch values and then saved to memory.
	
	patch_to_save.vco2_pw = current_patch.vco2_pw;
     d88:	ee ed       	ldi	r30, 0xDE	; 222
     d8a:	f2 e0       	ldi	r31, 0x02	; 2
     d8c:	20 91 de 02 	lds	r18, 0x02DE
     d90:	82 2f       	mov	r24, r18
     d92:	82 95       	swap	r24
     d94:	80 7f       	andi	r24, 0xF0	; 240
     d96:	22 95       	swap	r18
     d98:	2f 70       	andi	r18, 0x0F	; 15
     d9a:	90 91 df 02 	lds	r25, 0x02DF
     d9e:	93 70       	andi	r25, 0x03	; 3
     da0:	92 95       	swap	r25
     da2:	90 7f       	andi	r25, 0xF0	; 240
	patch_to_save.vco1_mix = current_patch.vco1_mix;
     da4:	df 01       	movw	r26, r30
     da6:	5a 97       	sbiw	r26, 0x1a	; 26
     da8:	3c 91       	ld	r19, X
     daa:	53 2f       	mov	r21, r19
     dac:	55 0f       	add	r21, r21
     dae:	55 0f       	add	r21, r21
     db0:	4a 81       	ldd	r20, Y+2	; 0x02
     db2:	43 70       	andi	r20, 0x03	; 3
     db4:	45 2b       	or	r20, r21
     db6:	4a 83       	std	Y+2, r20	; 0x02
     db8:	63 2f       	mov	r22, r19
     dba:	62 95       	swap	r22
     dbc:	66 95       	lsr	r22
     dbe:	66 95       	lsr	r22
     dc0:	63 70       	andi	r22, 0x03	; 3
     dc2:	11 96       	adiw	r26, 0x01	; 1
     dc4:	4c 91       	ld	r20, X
     dc6:	43 70       	andi	r20, 0x03	; 3
     dc8:	44 0f       	add	r20, r20
     dca:	44 0f       	add	r20, r20
	patch_to_save.pitch_eg2 = current_patch.pitch_eg2;
     dcc:	df 01       	movw	r26, r30
     dce:	58 97       	sbiw	r26, 0x18	; 24
     dd0:	3c 91       	ld	r19, X
     dd2:	53 2f       	mov	r21, r19
     dd4:	52 95       	swap	r21
     dd6:	50 7f       	andi	r21, 0xF0	; 240
     dd8:	46 2b       	or	r20, r22
     dda:	45 2b       	or	r20, r21
     ddc:	4b 83       	std	Y+3, r20	; 0x03
     dde:	63 2f       	mov	r22, r19
     de0:	62 95       	swap	r22
     de2:	6f 70       	andi	r22, 0x0F	; 15
     de4:	11 96       	adiw	r26, 0x01	; 1
     de6:	4c 91       	ld	r20, X
     de8:	43 70       	andi	r20, 0x03	; 3
     dea:	42 95       	swap	r20
     dec:	40 7f       	andi	r20, 0xF0	; 240
	patch_to_save.pitch_vco2 = current_patch.pitch_vco2;
     dee:	df 01       	movw	r26, r30
     df0:	56 97       	sbiw	r26, 0x16	; 22
     df2:	3c 91       	ld	r19, X
     df4:	53 2f       	mov	r21, r19
     df6:	52 95       	swap	r21
     df8:	55 0f       	add	r21, r21
     dfa:	55 0f       	add	r21, r21
     dfc:	50 7c       	andi	r21, 0xC0	; 192
     dfe:	46 2b       	or	r20, r22
     e00:	45 2b       	or	r20, r21
     e02:	4c 83       	std	Y+4, r20	; 0x04
     e04:	11 96       	adiw	r26, 0x01	; 1
     e06:	4c 91       	ld	r20, X
     e08:	42 95       	swap	r20
     e0a:	44 0f       	add	r20, r20
     e0c:	44 0f       	add	r20, r20
     e0e:	40 7c       	andi	r20, 0xC0	; 192
     e10:	36 95       	lsr	r19
     e12:	36 95       	lsr	r19
     e14:	34 2b       	or	r19, r20
     e16:	3d 83       	std	Y+5, r19	; 0x05
	patch_to_save.pitch_lfo = current_patch.pitch_lfo;
     e18:	df 01       	movw	r26, r30
     e1a:	54 97       	sbiw	r26, 0x14	; 20
     e1c:	3c 91       	ld	r19, X
     e1e:	3e 83       	std	Y+6, r19	; 0x06
     e20:	11 96       	adiw	r26, 0x01	; 1
     e22:	4c 91       	ld	r20, X
	patch_to_save.pwm_lfo = current_patch.pwm_lfo;
     e24:	df 01       	movw	r26, r30
     e26:	52 97       	sbiw	r26, 0x12	; 18
     e28:	3c 91       	ld	r19, X
     e2a:	53 2f       	mov	r21, r19
     e2c:	55 0f       	add	r21, r21
     e2e:	55 0f       	add	r21, r21
     e30:	43 70       	andi	r20, 0x03	; 3
     e32:	45 2b       	or	r20, r21
     e34:	4f 83       	std	Y+7, r20	; 0x07
     e36:	63 2f       	mov	r22, r19
     e38:	62 95       	swap	r22
     e3a:	66 95       	lsr	r22
     e3c:	66 95       	lsr	r22
     e3e:	63 70       	andi	r22, 0x03	; 3
     e40:	11 96       	adiw	r26, 0x01	; 1
     e42:	4c 91       	ld	r20, X
     e44:	43 70       	andi	r20, 0x03	; 3
     e46:	44 0f       	add	r20, r20
     e48:	44 0f       	add	r20, r20
	patch_to_save.pwm_eg2 = current_patch.pwm_eg2;
     e4a:	df 01       	movw	r26, r30
     e4c:	50 97       	sbiw	r26, 0x10	; 16
     e4e:	3c 91       	ld	r19, X
     e50:	53 2f       	mov	r21, r19
     e52:	52 95       	swap	r21
     e54:	50 7f       	andi	r21, 0xF0	; 240
     e56:	46 2b       	or	r20, r22
     e58:	45 2b       	or	r20, r21
     e5a:	48 87       	std	Y+8, r20	; 0x08
     e5c:	63 2f       	mov	r22, r19
     e5e:	62 95       	swap	r22
     e60:	6f 70       	andi	r22, 0x0F	; 15
     e62:	11 96       	adiw	r26, 0x01	; 1
     e64:	4c 91       	ld	r20, X
     e66:	43 70       	andi	r20, 0x03	; 3
     e68:	42 95       	swap	r20
     e6a:	40 7f       	andi	r20, 0xF0	; 240
	patch_to_save.vco1_pw = current_patch.vco1_pw;
     e6c:	df 01       	movw	r26, r30
     e6e:	1e 97       	sbiw	r26, 0x0e	; 14
     e70:	3c 91       	ld	r19, X
     e72:	53 2f       	mov	r21, r19
     e74:	52 95       	swap	r21
     e76:	55 0f       	add	r21, r21
     e78:	55 0f       	add	r21, r21
     e7a:	50 7c       	andi	r21, 0xC0	; 192
     e7c:	46 2b       	or	r20, r22
     e7e:	45 2b       	or	r20, r21
     e80:	49 87       	std	Y+9, r20	; 0x09
     e82:	11 96       	adiw	r26, 0x01	; 1
     e84:	4c 91       	ld	r20, X
     e86:	42 95       	swap	r20
     e88:	44 0f       	add	r20, r20
     e8a:	44 0f       	add	r20, r20
     e8c:	40 7c       	andi	r20, 0xC0	; 192
     e8e:	36 95       	lsr	r19
     e90:	36 95       	lsr	r19
     e92:	34 2b       	or	r19, r20
     e94:	3a 87       	std	Y+10, r19	; 0x0a
	patch_to_save.fine = current_patch.fine;
     e96:	df 01       	movw	r26, r30
     e98:	1c 97       	sbiw	r26, 0x0c	; 12
     e9a:	3c 91       	ld	r19, X
     e9c:	3b 87       	std	Y+11, r19	; 0x0b
     e9e:	11 96       	adiw	r26, 0x01	; 1
     ea0:	4c 91       	ld	r20, X
	patch_to_save.tune = current_patch.tune; //probably shouldn't save master tune value. Like volume, it is a parameter that doesn't apply to a patch.
     ea2:	df 01       	movw	r26, r30
     ea4:	1a 97       	sbiw	r26, 0x0a	; 10
     ea6:	3c 91       	ld	r19, X
     ea8:	53 2f       	mov	r21, r19
     eaa:	55 0f       	add	r21, r21
     eac:	55 0f       	add	r21, r21
     eae:	43 70       	andi	r20, 0x03	; 3
     eb0:	45 2b       	or	r20, r21
     eb2:	4c 87       	std	Y+12, r20	; 0x0c
     eb4:	63 2f       	mov	r22, r19
     eb6:	62 95       	swap	r22
     eb8:	66 95       	lsr	r22
     eba:	66 95       	lsr	r22
     ebc:	63 70       	andi	r22, 0x03	; 3
     ebe:	11 96       	adiw	r26, 0x01	; 1
     ec0:	4c 91       	ld	r20, X
     ec2:	43 70       	andi	r20, 0x03	; 3
     ec4:	44 0f       	add	r20, r20
     ec6:	44 0f       	add	r20, r20
	patch_to_save.lfo_rate = current_patch.lfo_rate;
     ec8:	df 01       	movw	r26, r30
     eca:	18 97       	sbiw	r26, 0x08	; 8
     ecc:	3c 91       	ld	r19, X
     ece:	53 2f       	mov	r21, r19
     ed0:	52 95       	swap	r21
     ed2:	50 7f       	andi	r21, 0xF0	; 240
     ed4:	46 2b       	or	r20, r22
     ed6:	45 2b       	or	r20, r21
     ed8:	4d 87       	std	Y+13, r20	; 0x0d
     eda:	63 2f       	mov	r22, r19
     edc:	62 95       	swap	r22
     ede:	6f 70       	andi	r22, 0x0F	; 15
     ee0:	11 96       	adiw	r26, 0x01	; 1
     ee2:	4c 91       	ld	r20, X
     ee4:	43 70       	andi	r20, 0x03	; 3
     ee6:	42 95       	swap	r20
     ee8:	40 7f       	andi	r20, 0xF0	; 240
	patch_to_save.arp_rate = current_patch.arp_rate;
     eea:	df 01       	movw	r26, r30
     eec:	16 97       	sbiw	r26, 0x06	; 6
     eee:	3c 91       	ld	r19, X
     ef0:	53 2f       	mov	r21, r19
     ef2:	52 95       	swap	r21
     ef4:	55 0f       	add	r21, r21
     ef6:	55 0f       	add	r21, r21
     ef8:	50 7c       	andi	r21, 0xC0	; 192
     efa:	46 2b       	or	r20, r22
     efc:	45 2b       	or	r20, r21
     efe:	4e 87       	std	Y+14, r20	; 0x0e
     f00:	11 96       	adiw	r26, 0x01	; 1
     f02:	4c 91       	ld	r20, X
     f04:	42 95       	swap	r20
     f06:	44 0f       	add	r20, r20
     f08:	44 0f       	add	r20, r20
     f0a:	40 7c       	andi	r20, 0xC0	; 192
     f0c:	36 95       	lsr	r19
     f0e:	36 95       	lsr	r19
     f10:	34 2b       	or	r19, r20
     f12:	3f 87       	std	Y+15, r19	; 0x0f
	patch_to_save.glide	= current_patch.glide;
     f14:	df 01       	movw	r26, r30
     f16:	14 97       	sbiw	r26, 0x04	; 4
     f18:	3c 91       	ld	r19, X
     f1a:	38 8b       	std	Y+16, r19	; 0x10
     f1c:	11 96       	adiw	r26, 0x01	; 1
     f1e:	4c 91       	ld	r20, X
	patch_to_save.amp_lfo = current_patch.amp_lfo;
     f20:	df 01       	movw	r26, r30
     f22:	12 97       	sbiw	r26, 0x02	; 2
     f24:	3c 91       	ld	r19, X
     f26:	53 2f       	mov	r21, r19
     f28:	55 0f       	add	r21, r21
     f2a:	55 0f       	add	r21, r21
     f2c:	43 70       	andi	r20, 0x03	; 3
     f2e:	45 2b       	or	r20, r21
     f30:	49 8b       	std	Y+17, r20	; 0x11
     f32:	32 95       	swap	r19
     f34:	36 95       	lsr	r19
     f36:	36 95       	lsr	r19
     f38:	33 70       	andi	r19, 0x03	; 3
     f3a:	11 96       	adiw	r26, 0x01	; 1
     f3c:	4c 91       	ld	r20, X
     f3e:	43 70       	andi	r20, 0x03	; 3
     f40:	44 0f       	add	r20, r20
     f42:	44 0f       	add	r20, r20
     f44:	83 2b       	or	r24, r19
     f46:	84 2b       	or	r24, r20
     f48:	8a 8b       	std	Y+18, r24	; 0x12
	patch_to_save.vco2_pw = current_patch.vco2_pw;
	
	patch_to_save.fil_eg2 = current_patch.fil_eg2;
     f4a:	80 91 e0 02 	lds	r24, 0x02E0
     f4e:	38 2f       	mov	r19, r24
     f50:	32 95       	swap	r19
     f52:	33 0f       	add	r19, r19
     f54:	33 0f       	add	r19, r19
     f56:	30 7c       	andi	r19, 0xC0	; 192
     f58:	92 2b       	or	r25, r18
     f5a:	93 2b       	or	r25, r19
     f5c:	9b 8b       	std	Y+19, r25	; 0x13
     f5e:	93 81       	ldd	r25, Z+3	; 0x03
     f60:	92 95       	swap	r25
     f62:	99 0f       	add	r25, r25
     f64:	99 0f       	add	r25, r25
     f66:	90 7c       	andi	r25, 0xC0	; 192
     f68:	86 95       	lsr	r24
     f6a:	86 95       	lsr	r24
     f6c:	89 2b       	or	r24, r25
     f6e:	8c 8b       	std	Y+20, r24	; 0x14
	patch_to_save.res = current_patch.res;
     f70:	80 91 e2 02 	lds	r24, 0x02E2
     f74:	8d 8b       	std	Y+21, r24	; 0x15
     f76:	95 81       	ldd	r25, Z+5	; 0x05
	patch_to_save.cutoff = current_patch.cutoff;
     f78:	80 91 e4 02 	lds	r24, 0x02E4
     f7c:	28 2f       	mov	r18, r24
     f7e:	22 0f       	add	r18, r18
     f80:	22 0f       	add	r18, r18
     f82:	93 70       	andi	r25, 0x03	; 3
     f84:	92 2b       	or	r25, r18
     f86:	9e 8b       	std	Y+22, r25	; 0x16
     f88:	38 2f       	mov	r19, r24
     f8a:	32 95       	swap	r19
     f8c:	36 95       	lsr	r19
     f8e:	36 95       	lsr	r19
     f90:	33 70       	andi	r19, 0x03	; 3
     f92:	97 81       	ldd	r25, Z+7	; 0x07
     f94:	93 70       	andi	r25, 0x03	; 3
     f96:	99 0f       	add	r25, r25
     f98:	99 0f       	add	r25, r25
	patch_to_save.key_track = current_patch.key_track;
     f9a:	80 91 e6 02 	lds	r24, 0x02E6
     f9e:	28 2f       	mov	r18, r24
     fa0:	22 95       	swap	r18
     fa2:	20 7f       	andi	r18, 0xF0	; 240
     fa4:	93 2b       	or	r25, r19
     fa6:	92 2b       	or	r25, r18
     fa8:	9f 8b       	std	Y+23, r25	; 0x17
     faa:	38 2f       	mov	r19, r24
     fac:	32 95       	swap	r19
     fae:	3f 70       	andi	r19, 0x0F	; 15
     fb0:	91 85       	ldd	r25, Z+9	; 0x09
     fb2:	93 70       	andi	r25, 0x03	; 3
     fb4:	92 95       	swap	r25
     fb6:	90 7f       	andi	r25, 0xF0	; 240
	patch_to_save.fil_vco2 = current_patch.fil_vco2;
     fb8:	80 91 e8 02 	lds	r24, 0x02E8
     fbc:	28 2f       	mov	r18, r24
     fbe:	22 95       	swap	r18
     fc0:	22 0f       	add	r18, r18
     fc2:	22 0f       	add	r18, r18
     fc4:	20 7c       	andi	r18, 0xC0	; 192
     fc6:	93 2b       	or	r25, r19
     fc8:	92 2b       	or	r25, r18
     fca:	98 8f       	std	Y+24, r25	; 0x18
     fcc:	93 85       	ldd	r25, Z+11	; 0x0b
     fce:	92 95       	swap	r25
     fd0:	99 0f       	add	r25, r25
     fd2:	99 0f       	add	r25, r25
     fd4:	90 7c       	andi	r25, 0xC0	; 192
     fd6:	86 95       	lsr	r24
     fd8:	86 95       	lsr	r24
     fda:	89 2b       	or	r24, r25
     fdc:	89 8f       	std	Y+25, r24	; 0x19
	patch_to_save.fil_lfo = current_patch.fil_lfo;
     fde:	80 91 ea 02 	lds	r24, 0x02EA
     fe2:	8a 8f       	std	Y+26, r24	; 0x1a
     fe4:	95 85       	ldd	r25, Z+13	; 0x0d
	patch_to_save.noise_mix = current_patch.noise_mix;
     fe6:	80 91 ec 02 	lds	r24, 0x02EC
     fea:	28 2f       	mov	r18, r24
     fec:	22 0f       	add	r18, r18
     fee:	22 0f       	add	r18, r18
     ff0:	93 70       	andi	r25, 0x03	; 3
     ff2:	92 2b       	or	r25, r18
     ff4:	9b 8f       	std	Y+27, r25	; 0x1b
     ff6:	38 2f       	mov	r19, r24
     ff8:	32 95       	swap	r19
     ffa:	36 95       	lsr	r19
     ffc:	36 95       	lsr	r19
     ffe:	33 70       	andi	r19, 0x03	; 3
    1000:	97 85       	ldd	r25, Z+15	; 0x0f
    1002:	93 70       	andi	r25, 0x03	; 3
    1004:	99 0f       	add	r25, r25
    1006:	99 0f       	add	r25, r25
	patch_to_save.attack_2 = current_patch.attack_2;
    1008:	80 91 ee 02 	lds	r24, 0x02EE
    100c:	28 2f       	mov	r18, r24
    100e:	22 95       	swap	r18
    1010:	20 7f       	andi	r18, 0xF0	; 240
    1012:	93 2b       	or	r25, r19
    1014:	92 2b       	or	r25, r18
    1016:	9c 8f       	std	Y+28, r25	; 0x1c
    1018:	38 2f       	mov	r19, r24
    101a:	32 95       	swap	r19
    101c:	3f 70       	andi	r19, 0x0F	; 15
    101e:	91 89       	ldd	r25, Z+17	; 0x11
    1020:	93 70       	andi	r25, 0x03	; 3
    1022:	92 95       	swap	r25
    1024:	90 7f       	andi	r25, 0xF0	; 240
	patch_to_save.attack_1 = current_patch.attack_1;
    1026:	80 91 f0 02 	lds	r24, 0x02F0
    102a:	28 2f       	mov	r18, r24
    102c:	22 95       	swap	r18
    102e:	22 0f       	add	r18, r18
    1030:	22 0f       	add	r18, r18
    1032:	20 7c       	andi	r18, 0xC0	; 192
    1034:	93 2b       	or	r25, r19
    1036:	92 2b       	or	r25, r18
    1038:	9d 8f       	std	Y+29, r25	; 0x1d
    103a:	93 89       	ldd	r25, Z+19	; 0x13
    103c:	92 95       	swap	r25
    103e:	99 0f       	add	r25, r25
    1040:	99 0f       	add	r25, r25
    1042:	90 7c       	andi	r25, 0xC0	; 192
    1044:	86 95       	lsr	r24
    1046:	86 95       	lsr	r24
    1048:	89 2b       	or	r24, r25
    104a:	8e 8f       	std	Y+30, r24	; 0x1e
	patch_to_save.decay_2 = current_patch.decay_2;
    104c:	80 91 f2 02 	lds	r24, 0x02F2
    1050:	8f 8f       	std	Y+31, r24	; 0x1f
    1052:	95 89       	ldd	r25, Z+21	; 0x15
	patch_to_save.decay_1 = current_patch.decay_1;
    1054:	80 91 f4 02 	lds	r24, 0x02F4
    1058:	28 2f       	mov	r18, r24
    105a:	22 0f       	add	r18, r18
    105c:	22 0f       	add	r18, r18
    105e:	93 70       	andi	r25, 0x03	; 3
    1060:	92 2b       	or	r25, r18
    1062:	98 a3       	lds	r25, 0x58
    1064:	38 2f       	mov	r19, r24
    1066:	32 95       	swap	r19
    1068:	36 95       	lsr	r19
    106a:	36 95       	lsr	r19
    106c:	33 70       	andi	r19, 0x03	; 3
    106e:	97 89       	ldd	r25, Z+23	; 0x17
    1070:	93 70       	andi	r25, 0x03	; 3
    1072:	99 0f       	add	r25, r25
    1074:	99 0f       	add	r25, r25
	patch_to_save.sustain_2 = current_patch.sustain_2;
    1076:	80 91 f6 02 	lds	r24, 0x02F6
    107a:	28 2f       	mov	r18, r24
    107c:	22 95       	swap	r18
    107e:	20 7f       	andi	r18, 0xF0	; 240
    1080:	93 2b       	or	r25, r19
    1082:	92 2b       	or	r25, r18
    1084:	99 a3       	lds	r25, 0x59
    1086:	38 2f       	mov	r19, r24
    1088:	32 95       	swap	r19
    108a:	3f 70       	andi	r19, 0x0F	; 15
    108c:	91 8d       	ldd	r25, Z+25	; 0x19
    108e:	93 70       	andi	r25, 0x03	; 3
    1090:	92 95       	swap	r25
    1092:	90 7f       	andi	r25, 0xF0	; 240
	patch_to_save.sustain_1 = current_patch.sustain_1;
    1094:	80 91 f8 02 	lds	r24, 0x02F8
    1098:	28 2f       	mov	r18, r24
    109a:	22 95       	swap	r18
    109c:	22 0f       	add	r18, r18
    109e:	22 0f       	add	r18, r18
    10a0:	20 7c       	andi	r18, 0xC0	; 192
    10a2:	93 2b       	or	r25, r19
    10a4:	92 2b       	or	r25, r18
    10a6:	9a a3       	lds	r25, 0x5a
    10a8:	93 8d       	ldd	r25, Z+27	; 0x1b
    10aa:	92 95       	swap	r25
    10ac:	99 0f       	add	r25, r25
    10ae:	99 0f       	add	r25, r25
    10b0:	90 7c       	andi	r25, 0xC0	; 192
    10b2:	86 95       	lsr	r24
    10b4:	86 95       	lsr	r24
    10b6:	89 2b       	or	r24, r25
    10b8:	8b a3       	lds	r24, 0x5b
	patch_to_save.release_2 = current_patch.release_2;
    10ba:	80 91 fa 02 	lds	r24, 0x02FA
    10be:	8c a3       	lds	r24, 0x5c
    10c0:	95 8d       	ldd	r25, Z+29	; 0x1d
	patch_to_save.release_1 = current_patch.release_1;
    10c2:	80 91 fc 02 	lds	r24, 0x02FC
    10c6:	28 2f       	mov	r18, r24
    10c8:	22 0f       	add	r18, r18
    10ca:	22 0f       	add	r18, r18
    10cc:	93 70       	andi	r25, 0x03	; 3
    10ce:	92 2b       	or	r25, r18
    10d0:	9d a3       	lds	r25, 0x5d
    10d2:	82 95       	swap	r24
    10d4:	86 95       	lsr	r24
    10d6:	86 95       	lsr	r24
    10d8:	83 70       	andi	r24, 0x03	; 3
    10da:	2e a1       	lds	r18, 0x4e
    10dc:	20 7f       	andi	r18, 0xF0	; 240
    10de:	97 8d       	ldd	r25, Z+31	; 0x1f
    10e0:	93 70       	andi	r25, 0x03	; 3
    10e2:	99 0f       	add	r25, r25
    10e4:	99 0f       	add	r25, r25
    10e6:	82 2b       	or	r24, r18
    10e8:	89 2b       	or	r24, r25
    10ea:	8e a3       	lds	r24, 0x5e
	
		
	patch_to_save.byte_1 = current_patch.byte_1;
    10ec:	80 91 fe 02 	lds	r24, 0x02FE
    10f0:	8f a3       	lds	r24, 0x5f
	patch_to_save.byte_2 = current_patch.byte_2;
    10f2:	80 91 ff 02 	lds	r24, 0x02FF
    10f6:	88 a7       	lds	r24, 0x78
	patch_to_save.byte_3 = current_patch.byte_3;
    10f8:	80 91 00 03 	lds	r24, 0x0300
    10fc:	89 a7       	lds	r24, 0x79
	patch_to_save.byte_4 = current_patch.byte_4;
    10fe:	80 91 01 03 	lds	r24, 0x0301
    1102:	8a a7       	lds	r24, 0x7a
	patch_to_save.byte_5 = current_patch.byte_5;
    1104:	80 91 02 03 	lds	r24, 0x0302
    1108:	8b a7       	lds	r24, 0x7b
	
	
	lock_pots();
    110a:	0e 94 8d 06 	call	0xd1a	; 0xd1a <lock_pots>
	//if (current_patch.mode == MANUAL) switch_states.byte2 &= ~(1<< PROG_MANUAL_SW); //if in MANUAL mode, turn off MANUAL LED
	switch_states.byte2 &= ~(1<< PROG_MANUAL_SW);
    110e:	80 91 7a 03 	lds	r24, 0x037A
    1112:	8f 77       	andi	r24, 0x7F	; 127
    1114:	80 93 7a 03 	sts	0x037A, r24
	current_patch.mode = MEMORY;
    1118:	10 92 05 03 	sts	0x0305, r1
	
	eeprom_update_block((const void*)&patch_to_save, (void*)&patch_memory[patch_number], sizeof(patch_to_save));
    111c:	21 2f       	mov	r18, r17
    111e:	30 e0       	ldi	r19, 0x00	; 0
    1120:	8b e2       	ldi	r24, 0x2B	; 43
    1122:	90 e0       	ldi	r25, 0x00	; 0
    1124:	28 9f       	mul	r18, r24
    1126:	b0 01       	movw	r22, r0
    1128:	29 9f       	mul	r18, r25
    112a:	70 0d       	add	r23, r0
    112c:	38 9f       	mul	r19, r24
    112e:	70 0d       	add	r23, r0
    1130:	11 24       	eor	r1, r1
    1132:	60 50       	subi	r22, 0x00	; 0
    1134:	70 40       	sbci	r23, 0x00	; 0
    1136:	ce 01       	movw	r24, r28
    1138:	01 96       	adiw	r24, 0x01	; 1
    113a:	4b e2       	ldi	r20, 0x2B	; 43
    113c:	50 e0       	ldi	r21, 0x00	; 0
    113e:	0e 94 33 1b 	call	0x3666	; 0x3666 <__eeupd_block_m6450a>
}	
    1142:	ab 96       	adiw	r28, 0x2b	; 43
    1144:	0f b6       	in	r0, 0x3f	; 63
    1146:	f8 94       	cli
    1148:	de bf       	out	0x3e, r29	; 62
    114a:	0f be       	out	0x3f, r0	; 63
    114c:	cd bf       	out	0x3d, r28	; 61
    114e:	df 91       	pop	r29
    1150:	cf 91       	pop	r28
    1152:	1f 91       	pop	r17
    1154:	08 95       	ret

00001156 <load_patch>:
	
void load_patch(uint8_t patch_number) {
    1156:	1f 93       	push	r17
    1158:	cf 93       	push	r28
    115a:	df 93       	push	r29
    115c:	cd b7       	in	r28, 0x3d	; 61
    115e:	de b7       	in	r29, 0x3e	; 62
    1160:	c3 54       	subi	r28, 0x43	; 67
    1162:	d0 40       	sbci	r29, 0x00	; 0
    1164:	0f b6       	in	r0, 0x3f	; 63
    1166:	f8 94       	cli
    1168:	de bf       	out	0x3e, r29	; 62
    116a:	0f be       	out	0x3f, r0	; 63
    116c:	cd bf       	out	0x3d, r28	; 61
	
	struct eeprom_patch loaded_patch;
	//because of bit fields in eeprom patch struct, a temporary eeprom patch needs to be filled with current_patch values and then saved to memory.
	eeprom_read_block((void*)&loaded_patch, (const void*)&patch_memory[patch_number], sizeof(loaded_patch));
    116e:	90 e0       	ldi	r25, 0x00	; 0
    1170:	2b e2       	ldi	r18, 0x2B	; 43
    1172:	30 e0       	ldi	r19, 0x00	; 0
    1174:	82 9f       	mul	r24, r18
    1176:	b0 01       	movw	r22, r0
    1178:	83 9f       	mul	r24, r19
    117a:	70 0d       	add	r23, r0
    117c:	92 9f       	mul	r25, r18
    117e:	70 0d       	add	r23, r0
    1180:	11 24       	eor	r1, r1
    1182:	60 50       	subi	r22, 0x00	; 0
    1184:	70 40       	sbci	r23, 0x00	; 0
    1186:	ce 01       	movw	r24, r28
    1188:	01 96       	adiw	r24, 0x01	; 1
    118a:	4b e2       	ldi	r20, 0x2B	; 43
    118c:	50 e0       	ldi	r21, 0x00	; 0
    118e:	0e 94 1d 1b 	call	0x363a	; 0x363a <__eerd_block_m6450a>
	
	
	
	current_patch.vco2_pw = loaded_patch.vco2_pw;
    1192:	ee ed       	ldi	r30, 0xDE	; 222
    1194:	f2 e0       	ldi	r31, 0x02	; 2
    1196:	8a 89       	ldd	r24, Y+18	; 0x12
    1198:	28 2f       	mov	r18, r24
    119a:	22 95       	swap	r18
    119c:	2f 70       	andi	r18, 0x0F	; 15
    119e:	9b 89       	ldd	r25, Y+19	; 0x13
    11a0:	39 2f       	mov	r19, r25
    11a2:	32 95       	swap	r19
    11a4:	30 7f       	andi	r19, 0xF0	; 240
    11a6:	32 2b       	or	r19, r18
    11a8:	29 2f       	mov	r18, r25
    11aa:	22 95       	swap	r18
    11ac:	2f 70       	andi	r18, 0x0F	; 15
    11ae:	23 70       	andi	r18, 0x03	; 3
    11b0:	30 93 de 02 	sts	0x02DE, r19
    11b4:	20 93 df 02 	sts	0x02DF, r18
	current_patch.vco1_mix = loaded_patch.vco1_mix;
    11b8:	df 01       	movw	r26, r30
    11ba:	5a 97       	sbiw	r26, 0x1a	; 26
    11bc:	4a 81       	ldd	r20, Y+2	; 0x02
    11be:	46 95       	lsr	r20
    11c0:	46 95       	lsr	r20
    11c2:	2b 81       	ldd	r18, Y+3	; 0x03
    11c4:	32 2f       	mov	r19, r18
    11c6:	32 95       	swap	r19
    11c8:	33 0f       	add	r19, r19
    11ca:	33 0f       	add	r19, r19
    11cc:	30 7c       	andi	r19, 0xC0	; 192
    11ce:	43 2b       	or	r20, r19
    11d0:	32 2f       	mov	r19, r18
    11d2:	36 95       	lsr	r19
    11d4:	36 95       	lsr	r19
    11d6:	33 70       	andi	r19, 0x03	; 3
    11d8:	4c 93       	st	X, r20
    11da:	11 96       	adiw	r26, 0x01	; 1
    11dc:	3c 93       	st	X, r19
	current_patch.pitch_eg2 = loaded_patch.pitch_eg2;
    11de:	df 01       	movw	r26, r30
    11e0:	58 97       	sbiw	r26, 0x18	; 24
    11e2:	32 2f       	mov	r19, r18
    11e4:	32 95       	swap	r19
    11e6:	3f 70       	andi	r19, 0x0F	; 15
    11e8:	2c 81       	ldd	r18, Y+4	; 0x04
    11ea:	42 2f       	mov	r20, r18
    11ec:	42 95       	swap	r20
    11ee:	40 7f       	andi	r20, 0xF0	; 240
    11f0:	43 2b       	or	r20, r19
    11f2:	32 2f       	mov	r19, r18
    11f4:	32 95       	swap	r19
    11f6:	3f 70       	andi	r19, 0x0F	; 15
    11f8:	33 70       	andi	r19, 0x03	; 3
    11fa:	4c 93       	st	X, r20
    11fc:	11 96       	adiw	r26, 0x01	; 1
    11fe:	3c 93       	st	X, r19
	current_patch.pitch_vco2 = loaded_patch.pitch_vco2;
    1200:	df 01       	movw	r26, r30
    1202:	56 97       	sbiw	r26, 0x16	; 22
    1204:	22 95       	swap	r18
    1206:	26 95       	lsr	r18
    1208:	26 95       	lsr	r18
    120a:	23 70       	andi	r18, 0x03	; 3
    120c:	3d 81       	ldd	r19, Y+5	; 0x05
    120e:	43 2f       	mov	r20, r19
    1210:	44 0f       	add	r20, r20
    1212:	44 0f       	add	r20, r20
    1214:	24 2b       	or	r18, r20
    1216:	32 95       	swap	r19
    1218:	36 95       	lsr	r19
    121a:	36 95       	lsr	r19
    121c:	33 70       	andi	r19, 0x03	; 3
    121e:	2c 93       	st	X, r18
    1220:	11 96       	adiw	r26, 0x01	; 1
    1222:	3c 93       	st	X, r19
	current_patch.pitch_lfo = loaded_patch.pitch_lfo;
    1224:	df 01       	movw	r26, r30
    1226:	54 97       	sbiw	r26, 0x14	; 20
    1228:	4e 81       	ldd	r20, Y+6	; 0x06
    122a:	2f 81       	ldd	r18, Y+7	; 0x07
    122c:	32 2f       	mov	r19, r18
    122e:	33 70       	andi	r19, 0x03	; 3
    1230:	4c 93       	st	X, r20
    1232:	11 96       	adiw	r26, 0x01	; 1
    1234:	3c 93       	st	X, r19
	current_patch.pwm_lfo = loaded_patch.pwm_lfo;
    1236:	df 01       	movw	r26, r30
    1238:	52 97       	sbiw	r26, 0x12	; 18
    123a:	32 2f       	mov	r19, r18
    123c:	36 95       	lsr	r19
    123e:	36 95       	lsr	r19
    1240:	28 85       	ldd	r18, Y+8	; 0x08
    1242:	42 2f       	mov	r20, r18
    1244:	42 95       	swap	r20
    1246:	44 0f       	add	r20, r20
    1248:	44 0f       	add	r20, r20
    124a:	40 7c       	andi	r20, 0xC0	; 192
    124c:	43 2b       	or	r20, r19
    124e:	32 2f       	mov	r19, r18
    1250:	36 95       	lsr	r19
    1252:	36 95       	lsr	r19
    1254:	33 70       	andi	r19, 0x03	; 3
    1256:	4c 93       	st	X, r20
    1258:	11 96       	adiw	r26, 0x01	; 1
    125a:	3c 93       	st	X, r19
	current_patch.pwm_eg2 = loaded_patch.pwm_eg2;
    125c:	df 01       	movw	r26, r30
    125e:	50 97       	sbiw	r26, 0x10	; 16
    1260:	32 2f       	mov	r19, r18
    1262:	32 95       	swap	r19
    1264:	3f 70       	andi	r19, 0x0F	; 15
    1266:	29 85       	ldd	r18, Y+9	; 0x09
    1268:	42 2f       	mov	r20, r18
    126a:	42 95       	swap	r20
    126c:	40 7f       	andi	r20, 0xF0	; 240
    126e:	43 2b       	or	r20, r19
    1270:	32 2f       	mov	r19, r18
    1272:	32 95       	swap	r19
    1274:	3f 70       	andi	r19, 0x0F	; 15
    1276:	33 70       	andi	r19, 0x03	; 3
    1278:	4c 93       	st	X, r20
    127a:	11 96       	adiw	r26, 0x01	; 1
    127c:	3c 93       	st	X, r19
	current_patch.vco1_pw = loaded_patch.vco1_pw;
    127e:	df 01       	movw	r26, r30
    1280:	1e 97       	sbiw	r26, 0x0e	; 14
    1282:	22 95       	swap	r18
    1284:	26 95       	lsr	r18
    1286:	26 95       	lsr	r18
    1288:	23 70       	andi	r18, 0x03	; 3
    128a:	3a 85       	ldd	r19, Y+10	; 0x0a
    128c:	43 2f       	mov	r20, r19
    128e:	44 0f       	add	r20, r20
    1290:	44 0f       	add	r20, r20
    1292:	24 2b       	or	r18, r20
    1294:	32 95       	swap	r19
    1296:	36 95       	lsr	r19
    1298:	36 95       	lsr	r19
    129a:	33 70       	andi	r19, 0x03	; 3
    129c:	2c 93       	st	X, r18
    129e:	11 96       	adiw	r26, 0x01	; 1
    12a0:	3c 93       	st	X, r19
	current_patch.fine = loaded_patch.fine;
    12a2:	df 01       	movw	r26, r30
    12a4:	1c 97       	sbiw	r26, 0x0c	; 12
    12a6:	4b 85       	ldd	r20, Y+11	; 0x0b
    12a8:	2c 85       	ldd	r18, Y+12	; 0x0c
    12aa:	32 2f       	mov	r19, r18
    12ac:	33 70       	andi	r19, 0x03	; 3
    12ae:	4c 93       	st	X, r20
    12b0:	11 96       	adiw	r26, 0x01	; 1
    12b2:	3c 93       	st	X, r19
	current_patch.tune = loaded_patch.tune; //probably shouldn't save master tune value. Like volume, it is a parameter that doesn't apply to a patch.
    12b4:	df 01       	movw	r26, r30
    12b6:	1a 97       	sbiw	r26, 0x0a	; 10
    12b8:	32 2f       	mov	r19, r18
    12ba:	36 95       	lsr	r19
    12bc:	36 95       	lsr	r19
    12be:	2d 85       	ldd	r18, Y+13	; 0x0d
    12c0:	42 2f       	mov	r20, r18
    12c2:	42 95       	swap	r20
    12c4:	44 0f       	add	r20, r20
    12c6:	44 0f       	add	r20, r20
    12c8:	40 7c       	andi	r20, 0xC0	; 192
    12ca:	43 2b       	or	r20, r19
    12cc:	32 2f       	mov	r19, r18
    12ce:	36 95       	lsr	r19
    12d0:	36 95       	lsr	r19
    12d2:	33 70       	andi	r19, 0x03	; 3
    12d4:	4c 93       	st	X, r20
    12d6:	11 96       	adiw	r26, 0x01	; 1
    12d8:	3c 93       	st	X, r19
	current_patch.lfo_rate = loaded_patch.lfo_rate;
    12da:	df 01       	movw	r26, r30
    12dc:	18 97       	sbiw	r26, 0x08	; 8
    12de:	32 2f       	mov	r19, r18
    12e0:	32 95       	swap	r19
    12e2:	3f 70       	andi	r19, 0x0F	; 15
    12e4:	2e 85       	ldd	r18, Y+14	; 0x0e
    12e6:	42 2f       	mov	r20, r18
    12e8:	42 95       	swap	r20
    12ea:	40 7f       	andi	r20, 0xF0	; 240
    12ec:	43 2b       	or	r20, r19
    12ee:	32 2f       	mov	r19, r18
    12f0:	32 95       	swap	r19
    12f2:	3f 70       	andi	r19, 0x0F	; 15
    12f4:	33 70       	andi	r19, 0x03	; 3
    12f6:	4c 93       	st	X, r20
    12f8:	11 96       	adiw	r26, 0x01	; 1
    12fa:	3c 93       	st	X, r19
	current_patch.arp_rate = loaded_patch.arp_rate;
    12fc:	df 01       	movw	r26, r30
    12fe:	16 97       	sbiw	r26, 0x06	; 6
    1300:	22 95       	swap	r18
    1302:	26 95       	lsr	r18
    1304:	26 95       	lsr	r18
    1306:	23 70       	andi	r18, 0x03	; 3
    1308:	3f 85       	ldd	r19, Y+15	; 0x0f
    130a:	43 2f       	mov	r20, r19
    130c:	44 0f       	add	r20, r20
    130e:	44 0f       	add	r20, r20
    1310:	24 2b       	or	r18, r20
    1312:	32 95       	swap	r19
    1314:	36 95       	lsr	r19
    1316:	36 95       	lsr	r19
    1318:	33 70       	andi	r19, 0x03	; 3
    131a:	2c 93       	st	X, r18
    131c:	11 96       	adiw	r26, 0x01	; 1
    131e:	3c 93       	st	X, r19
	current_patch.glide	= loaded_patch.glide;
    1320:	df 01       	movw	r26, r30
    1322:	14 97       	sbiw	r26, 0x04	; 4
    1324:	48 89       	ldd	r20, Y+16	; 0x10
    1326:	29 89       	ldd	r18, Y+17	; 0x11
    1328:	32 2f       	mov	r19, r18
    132a:	33 70       	andi	r19, 0x03	; 3
    132c:	4c 93       	st	X, r20
    132e:	11 96       	adiw	r26, 0x01	; 1
    1330:	3c 93       	st	X, r19
	current_patch.amp_lfo = loaded_patch.amp_lfo;
    1332:	df 01       	movw	r26, r30
    1334:	12 97       	sbiw	r26, 0x02	; 2
    1336:	26 95       	lsr	r18
    1338:	26 95       	lsr	r18
    133a:	38 2f       	mov	r19, r24
    133c:	32 95       	swap	r19
    133e:	33 0f       	add	r19, r19
    1340:	33 0f       	add	r19, r19
    1342:	30 7c       	andi	r19, 0xC0	; 192
    1344:	23 2b       	or	r18, r19
    1346:	86 95       	lsr	r24
    1348:	86 95       	lsr	r24
    134a:	83 70       	andi	r24, 0x03	; 3
    134c:	2c 93       	st	X, r18
    134e:	11 96       	adiw	r26, 0x01	; 1
    1350:	8c 93       	st	X, r24
	current_patch.vco2_pw = loaded_patch.vco2_pw;
	
	current_patch.fil_eg2 = loaded_patch.fil_eg2;
    1352:	92 95       	swap	r25
    1354:	96 95       	lsr	r25
    1356:	96 95       	lsr	r25
    1358:	93 70       	andi	r25, 0x03	; 3
    135a:	8c 89       	ldd	r24, Y+20	; 0x14
    135c:	28 2f       	mov	r18, r24
    135e:	22 0f       	add	r18, r18
    1360:	22 0f       	add	r18, r18
    1362:	92 2b       	or	r25, r18
    1364:	82 95       	swap	r24
    1366:	86 95       	lsr	r24
    1368:	86 95       	lsr	r24
    136a:	83 70       	andi	r24, 0x03	; 3
    136c:	90 93 e0 02 	sts	0x02E0, r25
    1370:	83 83       	std	Z+3, r24	; 0x03
	current_patch.res = loaded_patch.res;
    1372:	2d 89       	ldd	r18, Y+21	; 0x15
    1374:	8e 89       	ldd	r24, Y+22	; 0x16
    1376:	98 2f       	mov	r25, r24
    1378:	93 70       	andi	r25, 0x03	; 3
    137a:	20 93 e2 02 	sts	0x02E2, r18
    137e:	95 83       	std	Z+5, r25	; 0x05
	current_patch.cutoff = loaded_patch.cutoff;
    1380:	98 2f       	mov	r25, r24
    1382:	96 95       	lsr	r25
    1384:	96 95       	lsr	r25
    1386:	8f 89       	ldd	r24, Y+23	; 0x17
    1388:	28 2f       	mov	r18, r24
    138a:	22 95       	swap	r18
    138c:	22 0f       	add	r18, r18
    138e:	22 0f       	add	r18, r18
    1390:	20 7c       	andi	r18, 0xC0	; 192
    1392:	29 2b       	or	r18, r25
    1394:	98 2f       	mov	r25, r24
    1396:	96 95       	lsr	r25
    1398:	96 95       	lsr	r25
    139a:	93 70       	andi	r25, 0x03	; 3
    139c:	20 93 e4 02 	sts	0x02E4, r18
    13a0:	97 83       	std	Z+7, r25	; 0x07
	current_patch.key_track = loaded_patch.key_track;
    13a2:	98 2f       	mov	r25, r24
    13a4:	92 95       	swap	r25
    13a6:	9f 70       	andi	r25, 0x0F	; 15
    13a8:	88 8d       	ldd	r24, Y+24	; 0x18
    13aa:	28 2f       	mov	r18, r24
    13ac:	22 95       	swap	r18
    13ae:	20 7f       	andi	r18, 0xF0	; 240
    13b0:	29 2b       	or	r18, r25
    13b2:	98 2f       	mov	r25, r24
    13b4:	92 95       	swap	r25
    13b6:	9f 70       	andi	r25, 0x0F	; 15
    13b8:	93 70       	andi	r25, 0x03	; 3
    13ba:	20 93 e6 02 	sts	0x02E6, r18
    13be:	91 87       	std	Z+9, r25	; 0x09
	current_patch.fil_vco2 = loaded_patch.fil_vco2;
    13c0:	82 95       	swap	r24
    13c2:	86 95       	lsr	r24
    13c4:	86 95       	lsr	r24
    13c6:	83 70       	andi	r24, 0x03	; 3
    13c8:	99 8d       	ldd	r25, Y+25	; 0x19
    13ca:	29 2f       	mov	r18, r25
    13cc:	22 0f       	add	r18, r18
    13ce:	22 0f       	add	r18, r18
    13d0:	82 2b       	or	r24, r18
    13d2:	92 95       	swap	r25
    13d4:	96 95       	lsr	r25
    13d6:	96 95       	lsr	r25
    13d8:	93 70       	andi	r25, 0x03	; 3
    13da:	80 93 e8 02 	sts	0x02E8, r24
    13de:	93 87       	std	Z+11, r25	; 0x0b
	current_patch.fil_lfo = loaded_patch.fil_lfo;
    13e0:	2a 8d       	ldd	r18, Y+26	; 0x1a
    13e2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    13e4:	98 2f       	mov	r25, r24
    13e6:	93 70       	andi	r25, 0x03	; 3
    13e8:	20 93 ea 02 	sts	0x02EA, r18
    13ec:	95 87       	std	Z+13, r25	; 0x0d
	current_patch.noise_mix = loaded_patch.noise_mix;
    13ee:	98 2f       	mov	r25, r24
    13f0:	96 95       	lsr	r25
    13f2:	96 95       	lsr	r25
    13f4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    13f6:	28 2f       	mov	r18, r24
    13f8:	22 95       	swap	r18
    13fa:	22 0f       	add	r18, r18
    13fc:	22 0f       	add	r18, r18
    13fe:	20 7c       	andi	r18, 0xC0	; 192
    1400:	29 2b       	or	r18, r25
    1402:	98 2f       	mov	r25, r24
    1404:	96 95       	lsr	r25
    1406:	96 95       	lsr	r25
    1408:	93 70       	andi	r25, 0x03	; 3
    140a:	20 93 ec 02 	sts	0x02EC, r18
    140e:	97 87       	std	Z+15, r25	; 0x0f
	current_patch.attack_2 = loaded_patch.attack_2;
    1410:	98 2f       	mov	r25, r24
    1412:	92 95       	swap	r25
    1414:	9f 70       	andi	r25, 0x0F	; 15
    1416:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1418:	28 2f       	mov	r18, r24
    141a:	22 95       	swap	r18
    141c:	20 7f       	andi	r18, 0xF0	; 240
    141e:	29 2b       	or	r18, r25
    1420:	98 2f       	mov	r25, r24
    1422:	92 95       	swap	r25
    1424:	9f 70       	andi	r25, 0x0F	; 15
    1426:	93 70       	andi	r25, 0x03	; 3
    1428:	20 93 ee 02 	sts	0x02EE, r18
    142c:	91 8b       	std	Z+17, r25	; 0x11
	current_patch.attack_1 = loaded_patch.attack_1;
    142e:	82 95       	swap	r24
    1430:	86 95       	lsr	r24
    1432:	86 95       	lsr	r24
    1434:	83 70       	andi	r24, 0x03	; 3
    1436:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1438:	29 2f       	mov	r18, r25
    143a:	22 0f       	add	r18, r18
    143c:	22 0f       	add	r18, r18
    143e:	82 2b       	or	r24, r18
    1440:	92 95       	swap	r25
    1442:	96 95       	lsr	r25
    1444:	96 95       	lsr	r25
    1446:	93 70       	andi	r25, 0x03	; 3
    1448:	80 93 f0 02 	sts	0x02F0, r24
    144c:	93 8b       	std	Z+19, r25	; 0x13
	current_patch.decay_2 = loaded_patch.decay_2;
    144e:	2f 8d       	ldd	r18, Y+31	; 0x1f
    1450:	88 a1       	lds	r24, 0x48
    1452:	98 2f       	mov	r25, r24
    1454:	93 70       	andi	r25, 0x03	; 3
    1456:	20 93 f2 02 	sts	0x02F2, r18
    145a:	95 8b       	std	Z+21, r25	; 0x15
	current_patch.decay_1 = loaded_patch.decay_1;
    145c:	98 2f       	mov	r25, r24
    145e:	96 95       	lsr	r25
    1460:	96 95       	lsr	r25
    1462:	89 a1       	lds	r24, 0x49
    1464:	28 2f       	mov	r18, r24
    1466:	22 95       	swap	r18
    1468:	22 0f       	add	r18, r18
    146a:	22 0f       	add	r18, r18
    146c:	20 7c       	andi	r18, 0xC0	; 192
    146e:	29 2b       	or	r18, r25
    1470:	98 2f       	mov	r25, r24
    1472:	96 95       	lsr	r25
    1474:	96 95       	lsr	r25
    1476:	93 70       	andi	r25, 0x03	; 3
    1478:	20 93 f4 02 	sts	0x02F4, r18
    147c:	97 8b       	std	Z+23, r25	; 0x17
	current_patch.sustain_2 = loaded_patch.sustain_2;
    147e:	98 2f       	mov	r25, r24
    1480:	92 95       	swap	r25
    1482:	9f 70       	andi	r25, 0x0F	; 15
    1484:	8a a1       	lds	r24, 0x4a
    1486:	28 2f       	mov	r18, r24
    1488:	22 95       	swap	r18
    148a:	20 7f       	andi	r18, 0xF0	; 240
    148c:	29 2b       	or	r18, r25
    148e:	98 2f       	mov	r25, r24
    1490:	92 95       	swap	r25
    1492:	9f 70       	andi	r25, 0x0F	; 15
    1494:	93 70       	andi	r25, 0x03	; 3
    1496:	20 93 f6 02 	sts	0x02F6, r18
    149a:	91 8f       	std	Z+25, r25	; 0x19
	current_patch.sustain_1 = loaded_patch.sustain_1;
    149c:	82 95       	swap	r24
    149e:	86 95       	lsr	r24
    14a0:	86 95       	lsr	r24
    14a2:	83 70       	andi	r24, 0x03	; 3
    14a4:	9b a1       	lds	r25, 0x4b
    14a6:	29 2f       	mov	r18, r25
    14a8:	22 0f       	add	r18, r18
    14aa:	22 0f       	add	r18, r18
    14ac:	82 2b       	or	r24, r18
    14ae:	92 95       	swap	r25
    14b0:	96 95       	lsr	r25
    14b2:	96 95       	lsr	r25
    14b4:	93 70       	andi	r25, 0x03	; 3
    14b6:	80 93 f8 02 	sts	0x02F8, r24
    14ba:	93 8f       	std	Z+27, r25	; 0x1b
	current_patch.release_2 = loaded_patch.release_2;
    14bc:	2c a1       	lds	r18, 0x4c
    14be:	8d a1       	lds	r24, 0x4d
    14c0:	98 2f       	mov	r25, r24
    14c2:	93 70       	andi	r25, 0x03	; 3
    14c4:	20 93 fa 02 	sts	0x02FA, r18
    14c8:	95 8f       	std	Z+29, r25	; 0x1d
	current_patch.release_1 = loaded_patch.release_1;
    14ca:	98 2f       	mov	r25, r24
    14cc:	96 95       	lsr	r25
    14ce:	96 95       	lsr	r25
    14d0:	8e a1       	lds	r24, 0x4e
    14d2:	28 2f       	mov	r18, r24
    14d4:	22 95       	swap	r18
    14d6:	22 0f       	add	r18, r18
    14d8:	22 0f       	add	r18, r18
    14da:	20 7c       	andi	r18, 0xC0	; 192
    14dc:	29 2b       	or	r18, r25
    14de:	86 95       	lsr	r24
    14e0:	86 95       	lsr	r24
    14e2:	98 2f       	mov	r25, r24
    14e4:	93 70       	andi	r25, 0x03	; 3
    14e6:	20 93 fc 02 	sts	0x02FC, r18
    14ea:	97 8f       	std	Z+31, r25	; 0x1f
	
	
	current_patch.byte_1 = loaded_patch.byte_1;
    14ec:	7f a1       	lds	r23, 0x4f
    14ee:	70 93 fe 02 	sts	0x02FE, r23
	current_patch.byte_2 = loaded_patch.byte_2;
    14f2:	68 a5       	lds	r22, 0x68
    14f4:	60 93 ff 02 	sts	0x02FF, r22
	current_patch.byte_3 = loaded_patch.byte_3;
    14f8:	89 a5       	lds	r24, 0x69
    14fa:	80 93 00 03 	sts	0x0300, r24
	current_patch.byte_4 = loaded_patch.byte_4;
    14fe:	9a a5       	lds	r25, 0x6a
    1500:	90 93 01 03 	sts	0x0301, r25
	current_patch.byte_5 = loaded_patch.byte_5;
    1504:	1b a5       	lds	r17, 0x6b
    1506:	10 93 02 03 	sts	0x0302, r17
	
	//using De Bruijn sequence to determine which bit is set. For alphabet size k = 2 (binary - 0 and 1) and n = 3. 2^3 = 8. The minimum number of bits required to represent the 5 octave positions
	uint8_t vco1_lookup[] = {7, 2, 5, 0, 6, 4, 3, 1}; // *modified* De Bruijn lookup table for octave number, see: http://stackoverflow.com/questions/14429661/determine-which-single-bit-in-the-byte-is-set
    150a:	de 01       	movw	r26, r28
    150c:	9c 96       	adiw	r26, 0x2c	; 44
    150e:	ef ef       	ldi	r30, 0xFF	; 255
    1510:	f1 e0       	ldi	r31, 0x01	; 1
    1512:	28 e0       	ldi	r18, 0x08	; 8
    1514:	01 90       	ld	r0, Z+
    1516:	0d 92       	st	X+, r0
    1518:	21 50       	subi	r18, 0x01	; 1
    151a:	e1 f7       	brne	.-8      	; 0x1514 <load_patch+0x3be>
	//lookup table modified from standard 8 bit De Bruijn sequence to handle non sequential order of octave LEDs in byte_4
	uint8_t vco1_bitfield = current_patch.byte_4 & 0b00011111; //clear top 3 bits, which are used for VCO2 octave lookup - probably don't need to clear these bits
    151c:	e9 2f       	mov	r30, r25
    151e:	ef 71       	andi	r30, 0x1F	; 31
	uint8_t bit_index = ((vco1_bitfield*0x1D) >> 4) & 0x7;	//0x1D 0b11101 is the De Bruijn sequence for 8 bits 
    1520:	f0 e0       	ldi	r31, 0x00	; 0
    1522:	9f 01       	movw	r18, r30
    1524:	22 0f       	add	r18, r18
    1526:	33 1f       	adc	r19, r19
    1528:	22 0f       	add	r18, r18
    152a:	33 1f       	adc	r19, r19
    152c:	a9 01       	movw	r20, r18
    152e:	44 0f       	add	r20, r20
    1530:	55 1f       	adc	r21, r21
    1532:	44 0f       	add	r20, r20
    1534:	55 1f       	adc	r21, r21
    1536:	44 0f       	add	r20, r20
    1538:	55 1f       	adc	r21, r21
    153a:	42 1b       	sub	r20, r18
    153c:	53 0b       	sbc	r21, r19
    153e:	4e 0f       	add	r20, r30
    1540:	5f 1f       	adc	r21, r31
    1542:	55 95       	asr	r21
    1544:	47 95       	ror	r20
    1546:	55 95       	asr	r21
    1548:	47 95       	ror	r20
    154a:	55 95       	asr	r21
    154c:	47 95       	ror	r20
    154e:	55 95       	asr	r21
    1550:	47 95       	ror	r20
    1552:	47 70       	andi	r20, 0x07	; 7
	octave_index.vco1 = vco1_lookup[bit_index];	
    1554:	fe 01       	movw	r30, r28
    1556:	e4 0f       	add	r30, r20
    1558:	f1 1d       	adc	r31, r1
    155a:	24 a5       	lds	r18, 0x64
    155c:	20 93 06 03 	sts	0x0306, r18
	
	uint8_t vco2_lookup[] = {7, 4, 5, 3, 6, 2, 1, 0}; 
    1560:	de 01       	movw	r26, r28
    1562:	d4 96       	adiw	r26, 0x34	; 52
    1564:	e7 e0       	ldi	r30, 0x07	; 7
    1566:	f2 e0       	ldi	r31, 0x02	; 2
    1568:	28 e0       	ldi	r18, 0x08	; 8
    156a:	01 90       	ld	r0, Z+
    156c:	0d 92       	st	X+, r0
    156e:	21 50       	subi	r18, 0x01	; 1
    1570:	e1 f7       	brne	.-8      	; 0x156a <load_patch+0x414>
																																				 //bit order 4   3    2    1   0
	uint8_t vco2_bitfield = ((current_patch.byte_4 & 0b11100000) >> 3) | (current_patch.byte_3 & 0b00000011); //combine  all VCO2 octave bits into one byte: 8', 16', 32', 4', 2'
    1572:	29 2f       	mov	r18, r25
    1574:	30 e0       	ldi	r19, 0x00	; 0
    1576:	20 7e       	andi	r18, 0xE0	; 224
    1578:	30 70       	andi	r19, 0x00	; 0
    157a:	35 95       	asr	r19
    157c:	27 95       	ror	r18
    157e:	35 95       	asr	r19
    1580:	27 95       	ror	r18
    1582:	35 95       	asr	r19
    1584:	27 95       	ror	r18
    1586:	83 70       	andi	r24, 0x03	; 3
    1588:	28 2b       	or	r18, r24
	bit_index = ((vco2_bitfield*0x1D) >> 4) & 0x7;																								     //index 2   1    0    3   4
    158a:	42 2f       	mov	r20, r18
    158c:	50 e0       	ldi	r21, 0x00	; 0
    158e:	ca 01       	movw	r24, r20
    1590:	88 0f       	add	r24, r24
    1592:	99 1f       	adc	r25, r25
    1594:	88 0f       	add	r24, r24
    1596:	99 1f       	adc	r25, r25
    1598:	9c 01       	movw	r18, r24
    159a:	22 0f       	add	r18, r18
    159c:	33 1f       	adc	r19, r19
    159e:	22 0f       	add	r18, r18
    15a0:	33 1f       	adc	r19, r19
    15a2:	22 0f       	add	r18, r18
    15a4:	33 1f       	adc	r19, r19
    15a6:	28 1b       	sub	r18, r24
    15a8:	39 0b       	sbc	r19, r25
    15aa:	42 0f       	add	r20, r18
    15ac:	53 1f       	adc	r21, r19
    15ae:	ca 01       	movw	r24, r20
    15b0:	95 95       	asr	r25
    15b2:	87 95       	ror	r24
    15b4:	95 95       	asr	r25
    15b6:	87 95       	ror	r24
    15b8:	95 95       	asr	r25
    15ba:	87 95       	ror	r24
    15bc:	95 95       	asr	r25
    15be:	87 95       	ror	r24
    15c0:	87 70       	andi	r24, 0x07	; 7
	octave_index.vco2 = vco2_lookup[bit_index];
    15c2:	fe 01       	movw	r30, r28
    15c4:	e8 0f       	add	r30, r24
    15c6:	f1 1d       	adc	r31, r1
    15c8:	84 a9       	sts	0x44, r24
    15ca:	80 93 07 03 	sts	0x0307, r24
	
	uint8_t lfo_lookup[] = {0, 0, 2, 2, 1, 3, 3, 1}; //bits 7, 5, 4, 6 are irrelevant here. Complier seems to be reformatting this table???
    15ce:	de 01       	movw	r26, r28
    15d0:	dc 96       	adiw	r26, 0x3c	; 60
    15d2:	ef e0       	ldi	r30, 0x0F	; 15
    15d4:	f2 e0       	ldi	r31, 0x02	; 2
    15d6:	88 e0       	ldi	r24, 0x08	; 8
    15d8:	01 90       	ld	r0, Z+
    15da:	0d 92       	st	X+, r0
    15dc:	81 50       	subi	r24, 0x01	; 1
    15de:	e1 f7       	brne	.-8      	; 0x15d8 <load_patch+0x482>
	uint8_t lfo_bitfield = current_patch.byte_2 & 0b11110000; //shave off 4 LSBs. Really could use 4 bit De Bruijn sequence here
    15e0:	60 7f       	andi	r22, 0xF0	; 240
	bit_index = ((lfo_bitfield*0x1D) >> 4) & 0x7;
    15e2:	46 2f       	mov	r20, r22
    15e4:	50 e0       	ldi	r21, 0x00	; 0
    15e6:	ca 01       	movw	r24, r20
    15e8:	88 0f       	add	r24, r24
    15ea:	99 1f       	adc	r25, r25
    15ec:	88 0f       	add	r24, r24
    15ee:	99 1f       	adc	r25, r25
    15f0:	9c 01       	movw	r18, r24
    15f2:	22 0f       	add	r18, r18
    15f4:	33 1f       	adc	r19, r19
    15f6:	22 0f       	add	r18, r18
    15f8:	33 1f       	adc	r19, r19
    15fa:	22 0f       	add	r18, r18
    15fc:	33 1f       	adc	r19, r19
    15fe:	28 1b       	sub	r18, r24
    1600:	39 0b       	sbc	r19, r25
    1602:	42 0f       	add	r20, r18
    1604:	53 1f       	adc	r21, r19
    1606:	ca 01       	movw	r24, r20
    1608:	95 95       	asr	r25
    160a:	87 95       	ror	r24
    160c:	95 95       	asr	r25
    160e:	87 95       	ror	r24
    1610:	95 95       	asr	r25
    1612:	87 95       	ror	r24
    1614:	95 95       	asr	r25
    1616:	87 95       	ror	r24
    1618:	87 70       	andi	r24, 0x07	; 7
	lfo_shape_index = lfo_lookup[bit_index];
    161a:	fe 01       	movw	r30, r28
    161c:	e8 0f       	add	r30, r24
    161e:	f1 1d       	adc	r31, r1
    1620:	84 ad       	sts	0x64, r24
    1622:	80 93 08 03 	sts	0x0308, r24
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1626:	21 2f       	mov	r18, r17
    1628:	26 95       	lsr	r18
    162a:	27 95       	ror	r18
    162c:	22 27       	eor	r18, r18
    162e:	27 95       	ror	r18
    1630:	81 2f       	mov	r24, r17
    1632:	81 70       	andi	r24, 0x01	; 1
    1634:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
    1636:	81 2f       	mov	r24, r17
    1638:	86 95       	lsr	r24
    163a:	86 95       	lsr	r24
    163c:	90 e0       	ldi	r25, 0x00	; 0
    163e:	81 70       	andi	r24, 0x01	; 1
    1640:	90 70       	andi	r25, 0x00	; 0
    1642:	88 0f       	add	r24, r24
    1644:	99 1f       	adc	r25, r25
    1646:	88 0f       	add	r24, r24
    1648:	99 1f       	adc	r25, r25
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    164a:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
							((current_patch.byte_5 >> VCO1_TRI) & 1) << VCO1_TRI_SW |
    164c:	81 2f       	mov	r24, r17
    164e:	86 95       	lsr	r24
    1650:	86 95       	lsr	r24
    1652:	86 95       	lsr	r24
    1654:	90 e0       	ldi	r25, 0x00	; 0
    1656:	81 70       	andi	r24, 0x01	; 1
    1658:	90 70       	andi	r25, 0x00	; 0
    165a:	88 0f       	add	r24, r24
    165c:	99 1f       	adc	r25, r25
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    165e:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
							((current_patch.byte_5 >> VCO1_TRI) & 1) << VCO1_TRI_SW |
							((current_patch.byte_5 >> VCO1_PULSE) & 1) << VCO1_PULSE_SW |
							((current_patch.byte_5 >> VCO2_SAW) & 1) << VCO2_SAW_SW |
    1660:	81 2f       	mov	r24, r17
    1662:	82 95       	swap	r24
    1664:	8f 70       	andi	r24, 0x0F	; 15
    1666:	90 e0       	ldi	r25, 0x00	; 0
    1668:	81 70       	andi	r24, 0x01	; 1
    166a:	90 70       	andi	r25, 0x00	; 0
    166c:	82 95       	swap	r24
    166e:	92 95       	swap	r25
    1670:	90 7f       	andi	r25, 0xF0	; 240
    1672:	98 27       	eor	r25, r24
    1674:	80 7f       	andi	r24, 0xF0	; 240
    1676:	98 27       	eor	r25, r24
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1678:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
							((current_patch.byte_5 >> VCO1_TRI) & 1) << VCO1_TRI_SW |
							((current_patch.byte_5 >> VCO1_PULSE) & 1) << VCO1_PULSE_SW |
							((current_patch.byte_5 >> VCO2_SAW) & 1) << VCO2_SAW_SW |
							((current_patch.byte_5 >> VCO2_TRI) & 1) << VCO2_TRI_SW |
    167a:	81 2f       	mov	r24, r17
    167c:	82 95       	swap	r24
    167e:	86 95       	lsr	r24
    1680:	87 70       	andi	r24, 0x07	; 7
    1682:	90 e0       	ldi	r25, 0x00	; 0
    1684:	81 70       	andi	r24, 0x01	; 1
    1686:	90 70       	andi	r25, 0x00	; 0
    1688:	88 0f       	add	r24, r24
    168a:	99 1f       	adc	r25, r25
    168c:	82 95       	swap	r24
    168e:	92 95       	swap	r25
    1690:	90 7f       	andi	r25, 0xF0	; 240
    1692:	98 27       	eor	r25, r24
    1694:	80 7f       	andi	r24, 0xF0	; 240
    1696:	98 27       	eor	r25, r24
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    1698:	28 2b       	or	r18, r24
							((current_patch.byte_5 >> VCO1_SAW) & 1) << VCO1_SAW_SW |
							((current_patch.byte_5 >> VCO1_TRI) & 1) << VCO1_TRI_SW |
							((current_patch.byte_5 >> VCO1_PULSE) & 1) << VCO1_PULSE_SW |
							((current_patch.byte_5 >> VCO2_SAW) & 1) << VCO2_SAW_SW |
							((current_patch.byte_5 >> VCO2_TRI) & 1) << VCO2_TRI_SW |
							((current_patch.byte_5 >> VCO2_PULSE) & 1) << VCO2_PULSE_SW;
    169a:	81 2f       	mov	r24, r17
    169c:	82 95       	swap	r24
    169e:	86 95       	lsr	r24
    16a0:	86 95       	lsr	r24
    16a2:	83 70       	andi	r24, 0x03	; 3
    16a4:	90 e0       	ldi	r25, 0x00	; 0
    16a6:	81 70       	andi	r24, 0x01	; 1
    16a8:	90 70       	andi	r25, 0x00	; 0
    16aa:	00 24       	eor	r0, r0
    16ac:	96 95       	lsr	r25
    16ae:	87 95       	ror	r24
    16b0:	07 94       	ror	r0
    16b2:	96 95       	lsr	r25
    16b4:	87 95       	ror	r24
    16b6:	07 94       	ror	r0
    16b8:	98 2f       	mov	r25, r24
    16ba:	80 2d       	mov	r24, r0
	//lfo_shape_index = 0; //reset lfo bytes
	//current_patch.byte_2 = (1<<LFO_TRI);
	
	//set toggle switch bits according to patch data
	//probably need to handle previous switch states here, which are in spi.c
	switch_states.byte0 =	((current_patch.byte_5 >> VCO_SYNC) & 1) << VCO_SYNC_SW |
    16bc:	82 2b       	or	r24, r18
    16be:	80 93 78 03 	sts	0x0378, r24
							((current_patch.byte_5 >> VCO2_PULSE) & 1) << VCO2_PULSE_SW;
							
	switch_states.byte2 &= 0b11110011; //preserve PROG switches states, clear BMOD and EG2 states
	
	switch_states.byte2 |=	((current_patch.byte_5 >> BMOD) & 1) << BMOD_SW |
							((current_patch.byte_1 >> EG2_INV) & 1) << EG2_INV_SW;	
    16c2:	87 2f       	mov	r24, r23
    16c4:	90 e0       	ldi	r25, 0x00	; 0
    16c6:	81 70       	andi	r24, 0x01	; 1
    16c8:	90 70       	andi	r25, 0x00	; 0
    16ca:	88 0f       	add	r24, r24
    16cc:	99 1f       	adc	r25, r25
    16ce:	88 0f       	add	r24, r24
    16d0:	99 1f       	adc	r25, r25
    16d2:	88 0f       	add	r24, r24
    16d4:	99 1f       	adc	r25, r25
							((current_patch.byte_5 >> VCO1_PULSE) & 1) << VCO1_PULSE_SW |
							((current_patch.byte_5 >> VCO2_SAW) & 1) << VCO2_SAW_SW |
							((current_patch.byte_5 >> VCO2_TRI) & 1) << VCO2_TRI_SW |
							((current_patch.byte_5 >> VCO2_PULSE) & 1) << VCO2_PULSE_SW;
							
	switch_states.byte2 &= 0b11110011; //preserve PROG switches states, clear BMOD and EG2 states
    16d6:	90 91 7a 03 	lds	r25, 0x037A
    16da:	93 7f       	andi	r25, 0xF3	; 243
	
	switch_states.byte2 |=	((current_patch.byte_5 >> BMOD) & 1) << BMOD_SW |
    16dc:	89 2b       	or	r24, r25
    16de:	11 1f       	adc	r17, r17
    16e0:	11 27       	eor	r17, r17
    16e2:	11 1f       	adc	r17, r17
    16e4:	11 0f       	add	r17, r17
    16e6:	11 0f       	add	r17, r17
    16e8:	81 2b       	or	r24, r17
    16ea:	80 93 7a 03 	sts	0x037A, r24
													
	//spi_sw_byte0_current_state = spi_sw_byte0_previous_state = switch_states.byte0;
	//
	//spi_sw_byte1_current_state = spi_sw_byte1_previous_state = switch_states.byte1;						
			
	lock_pots();
    16ee:	0e 94 8d 06 	call	0xd1a	; 0xd1a <lock_pots>
	
	//if (current_patch.mode == MANUAL) switch_states.byte2 &= ~(1<< PROG_MANUAL_SW); //if in MANUAL mode, turn off MANUAL LED
	switch_states.byte2 &= ~(1<<PROG_MANUAL_SW);
    16f2:	80 91 7a 03 	lds	r24, 0x037A
    16f6:	8f 77       	andi	r24, 0x7F	; 127
    16f8:	80 93 7a 03 	sts	0x037A, r24
	
	current_patch.mode = MEMORY;
    16fc:	10 92 05 03 	sts	0x0305, r1
	
}
    1700:	cd 5b       	subi	r28, 0xBD	; 189
    1702:	df 4f       	sbci	r29, 0xFF	; 255
    1704:	0f b6       	in	r0, 0x3f	; 63
    1706:	f8 94       	cli
    1708:	de bf       	out	0x3e, r29	; 62
    170a:	0f be       	out	0x3f, r0	; 63
    170c:	cd bf       	out	0x3d, r28	; 61
    170e:	df 91       	pop	r29
    1710:	cf 91       	pop	r28
    1712:	1f 91       	pop	r17
    1714:	08 95       	ret

00001716 <transpose_note>:

uint8_t transpose_note (uint8_t note, uint8_t vco) {
	
	uint8_t n = 0;
	
	n = octave_index.vco1;
    1716:	90 91 06 03 	lds	r25, 0x0306
	if (vco == VCO2) n = octave_index.vco2;
    171a:	60 3f       	cpi	r22, 0xF0	; 240
    171c:	11 f4       	brne	.+4      	; 0x1722 <transpose_note+0xc>
    171e:	90 91 07 03 	lds	r25, 0x0307

	note = (n*12) + note; //calculate MIDI note after octave addition
    1722:	29 2f       	mov	r18, r25
    1724:	22 0f       	add	r18, r18
    1726:	92 0f       	add	r25, r18
    1728:	99 0f       	add	r25, r25
    172a:	99 0f       	add	r25, r25
    172c:	89 0f       	add	r24, r25
			
		note = 136;
			
	}
		
	return note;	
    172e:	89 38       	cpi	r24, 0x89	; 137
    1730:	08 f0       	brcs	.+2      	; 0x1734 <transpose_note+0x1e>
    1732:	88 e8       	ldi	r24, 0x88	; 136
	
}
    1734:	08 95       	ret

00001736 <update_octave_range>:

void update_octave_range(void) {
	
	if ((switch_states.byte0 >> VCO1_OCTAVE_UP_SW) & 1) {
    1736:	80 91 78 03 	lds	r24, 0x0378
    173a:	98 2f       	mov	r25, r24
    173c:	96 95       	lsr	r25
    173e:	96 95       	lsr	r25
    1740:	96 95       	lsr	r25
    1742:	90 ff       	sbrs	r25, 0
    1744:	0e c0       	rjmp	.+28     	; 0x1762 <update_octave_range+0x2c>
		
		if (++octave_index.vco1 == 5) octave_index.vco1 = 4;
    1746:	90 91 06 03 	lds	r25, 0x0306
    174a:	9f 5f       	subi	r25, 0xFF	; 255
    174c:	90 93 06 03 	sts	0x0306, r25
    1750:	95 30       	cpi	r25, 0x05	; 5
    1752:	19 f4       	brne	.+6      	; 0x175a <update_octave_range+0x24>
    1754:	94 e0       	ldi	r25, 0x04	; 4
    1756:	90 93 06 03 	sts	0x0306, r25
		switch_states.byte0 ^= (1<<VCO1_OCTAVE_UP_SW); //toggle switch state bit
    175a:	98 e0       	ldi	r25, 0x08	; 8
    175c:	89 27       	eor	r24, r25
    175e:	80 93 78 03 	sts	0x0378, r24
		
	}
	
	if ((switch_states.byte1 >> VCO1_OCTAVE_DOWN_SW) & 1) { //this didn't work initially because VCO1_OCTAVE_DOWN_SW pull down resistor wasn't installed on PCB!!!
    1762:	80 91 79 03 	lds	r24, 0x0379
    1766:	98 2f       	mov	r25, r24
    1768:	96 95       	lsr	r25
    176a:	96 95       	lsr	r25
    176c:	96 95       	lsr	r25
    176e:	90 ff       	sbrs	r25, 0
    1770:	0b c0       	rjmp	.+22     	; 0x1788 <update_octave_range+0x52>
	
		if (octave_index.vco1 == 0) {} else {octave_index.vco1--;}
    1772:	90 91 06 03 	lds	r25, 0x0306
    1776:	99 23       	and	r25, r25
    1778:	19 f0       	breq	.+6      	; 0x1780 <update_octave_range+0x4a>
    177a:	91 50       	subi	r25, 0x01	; 1
    177c:	90 93 06 03 	sts	0x0306, r25
		switch_states.byte1 ^= (1<<VCO1_OCTAVE_DOWN_SW);
    1780:	98 e0       	ldi	r25, 0x08	; 8
    1782:	89 27       	eor	r24, r25
    1784:	80 93 79 03 	sts	0x0379, r24

	}
	
	current_patch.byte_4 = 0; //clear the whole damn byte as all bits are set below
	current_patch.byte_4 |= (1<<vco1_octave[octave_index.vco1]); //set octave	
    1788:	80 91 06 03 	lds	r24, 0x0306
    178c:	e1 e2       	ldi	r30, 0x21	; 33
    178e:	f2 e0       	ldi	r31, 0x02	; 2
    1790:	e8 0f       	add	r30, r24
    1792:	f1 1d       	adc	r31, r1
    1794:	81 e0       	ldi	r24, 0x01	; 1
    1796:	90 e0       	ldi	r25, 0x00	; 0
    1798:	00 80       	ld	r0, Z
    179a:	02 c0       	rjmp	.+4      	; 0x17a0 <update_octave_range+0x6a>
    179c:	88 0f       	add	r24, r24
    179e:	99 1f       	adc	r25, r25
    17a0:	0a 94       	dec	r0
    17a2:	e2 f7       	brpl	.-8      	; 0x179c <update_octave_range+0x66>
    17a4:	58 2f       	mov	r21, r24
    17a6:	80 93 01 03 	sts	0x0301, r24
	
	if ((switch_states.byte1 >> VCO2_OCTAVE_UP_SW) & 1) {
    17aa:	90 91 79 03 	lds	r25, 0x0379
    17ae:	29 2f       	mov	r18, r25
    17b0:	26 95       	lsr	r18
    17b2:	26 95       	lsr	r18
    17b4:	20 ff       	sbrs	r18, 0
    17b6:	0e c0       	rjmp	.+28     	; 0x17d4 <update_octave_range+0x9e>
		
		if (++octave_index.vco2 == 5) octave_index.vco2 = 4;
    17b8:	80 91 07 03 	lds	r24, 0x0307
    17bc:	8f 5f       	subi	r24, 0xFF	; 255
    17be:	80 93 07 03 	sts	0x0307, r24
    17c2:	85 30       	cpi	r24, 0x05	; 5
    17c4:	19 f4       	brne	.+6      	; 0x17cc <update_octave_range+0x96>
    17c6:	84 e0       	ldi	r24, 0x04	; 4
    17c8:	80 93 07 03 	sts	0x0307, r24
		switch_states.byte1 ^= (1<<VCO2_OCTAVE_UP_SW); //toggle switch state bit		
    17cc:	84 e0       	ldi	r24, 0x04	; 4
    17ce:	98 27       	eor	r25, r24
    17d0:	90 93 79 03 	sts	0x0379, r25
	}	
	
	if ((switch_states.byte1 >> VCO2_OCTAVE_DOWN_SW) & 1) {
    17d4:	90 91 79 03 	lds	r25, 0x0379
    17d8:	29 2f       	mov	r18, r25
    17da:	26 95       	lsr	r18
    17dc:	20 ff       	sbrs	r18, 0
    17de:	0b c0       	rjmp	.+22     	; 0x17f6 <update_octave_range+0xc0>
		
		if (octave_index.vco2 == 0) {} else {octave_index.vco2--;}
    17e0:	80 91 07 03 	lds	r24, 0x0307
    17e4:	88 23       	and	r24, r24
    17e6:	19 f0       	breq	.+6      	; 0x17ee <update_octave_range+0xb8>
    17e8:	81 50       	subi	r24, 0x01	; 1
    17ea:	80 93 07 03 	sts	0x0307, r24
		switch_states.byte1 ^= (1<<VCO2_OCTAVE_DOWN_SW);
    17ee:	82 e0       	ldi	r24, 0x02	; 2
    17f0:	98 27       	eor	r25, r24
    17f2:	90 93 79 03 	sts	0x0379, r25
		
	}
			
	current_patch.byte_3 &= 0b11111100; //clear bottom 2 bits for patch byte_3, which are for VCO2 2' and 4'
    17f6:	40 91 00 03 	lds	r20, 0x0300
    17fa:	4c 7f       	andi	r20, 0xFC	; 252
    17fc:	40 93 00 03 	sts	0x0300, r20
	
	if (octave_index.vco2 > 2) { //VCO2 2' and 4' LEDs are on LED latch 3
    1800:	90 91 07 03 	lds	r25, 0x0307
    1804:	93 30       	cpi	r25, 0x03	; 3
    1806:	88 f0       	brcs	.+34     	; 0x182a <update_octave_range+0xf4>

						
		current_patch.byte_3 |= (1<<vco2_octave[octave_index.vco2]);	
    1808:	ec e1       	ldi	r30, 0x1C	; 28
    180a:	f2 e0       	ldi	r31, 0x02	; 2
    180c:	e9 0f       	add	r30, r25
    180e:	f1 1d       	adc	r31, r1
    1810:	21 e0       	ldi	r18, 0x01	; 1
    1812:	30 e0       	ldi	r19, 0x00	; 0
    1814:	c9 01       	movw	r24, r18
    1816:	00 80       	ld	r0, Z
    1818:	02 c0       	rjmp	.+4      	; 0x181e <update_octave_range+0xe8>
    181a:	88 0f       	add	r24, r24
    181c:	99 1f       	adc	r25, r25
    181e:	0a 94       	dec	r0
    1820:	e2 f7       	brpl	.-8      	; 0x181a <update_octave_range+0xe4>
    1822:	84 2b       	or	r24, r20
    1824:	80 93 00 03 	sts	0x0300, r24
    1828:	08 95       	ret
				
	} else { //VCO2 8', 16' and 32' are on LED latch 4
		
		current_patch.byte_4 |= (1<<vco2_octave[octave_index.vco2]); //set octave
    182a:	ec e1       	ldi	r30, 0x1C	; 28
    182c:	f2 e0       	ldi	r31, 0x02	; 2
    182e:	e9 0f       	add	r30, r25
    1830:	f1 1d       	adc	r31, r1
    1832:	21 e0       	ldi	r18, 0x01	; 1
    1834:	30 e0       	ldi	r19, 0x00	; 0
    1836:	c9 01       	movw	r24, r18
    1838:	00 80       	ld	r0, Z
    183a:	02 c0       	rjmp	.+4      	; 0x1840 <update_octave_range+0x10a>
    183c:	88 0f       	add	r24, r24
    183e:	99 1f       	adc	r25, r25
    1840:	0a 94       	dec	r0
    1842:	e2 f7       	brpl	.-8      	; 0x183c <update_octave_range+0x106>
    1844:	85 2b       	or	r24, r21
    1846:	80 93 01 03 	sts	0x0301, r24
    184a:	08 95       	ret

0000184c <update_lfo_shape>:
	
}	
	
void update_lfo_shape(void) {

	if ((switch_states.byte1 >> LFO_SHAPE_SW) & 1) {
    184c:	80 91 79 03 	lds	r24, 0x0379
    1850:	88 23       	and	r24, r24
    1852:	64 f4       	brge	.+24     	; 0x186c <update_lfo_shape+0x20>
	
		switch_states.byte1 ^= (1<<LFO_SHAPE_SW); //toggle switch state
    1854:	80 58       	subi	r24, 0x80	; 128
    1856:	80 93 79 03 	sts	0x0379, r24
		if (++lfo_shape_index == 5) lfo_shape_index = 0;
    185a:	80 91 08 03 	lds	r24, 0x0308
    185e:	8f 5f       	subi	r24, 0xFF	; 255
    1860:	80 93 08 03 	sts	0x0308, r24
    1864:	85 30       	cpi	r24, 0x05	; 5
    1866:	11 f4       	brne	.+4      	; 0x186c <update_lfo_shape+0x20>
    1868:	10 92 08 03 	sts	0x0308, r1
	}
	
	current_patch.byte_2 &= 0b00001111; //clear top 4 bits
	current_patch.byte_2 |= 1 << lfo[lfo_shape_index].led_addr;
    186c:	e0 91 08 03 	lds	r30, 0x0308
    1870:	f0 e0       	ldi	r31, 0x00	; 0
    1872:	ee 0f       	add	r30, r30
    1874:	ff 1f       	adc	r31, r31
    1876:	ea 5d       	subi	r30, 0xDA	; 218
    1878:	fd 4f       	sbci	r31, 0xFD	; 253
    187a:	81 e0       	ldi	r24, 0x01	; 1
    187c:	90 e0       	ldi	r25, 0x00	; 0
    187e:	01 80       	ldd	r0, Z+1	; 0x01
    1880:	02 c0       	rjmp	.+4      	; 0x1886 <update_lfo_shape+0x3a>
    1882:	88 0f       	add	r24, r24
    1884:	99 1f       	adc	r25, r25
    1886:	0a 94       	dec	r0
    1888:	e2 f7       	brpl	.-8      	; 0x1882 <update_lfo_shape+0x36>
	
		switch_states.byte1 ^= (1<<LFO_SHAPE_SW); //toggle switch state
		if (++lfo_shape_index == 5) lfo_shape_index = 0;
	}
	
	current_patch.byte_2 &= 0b00001111; //clear top 4 bits
    188a:	90 91 ff 02 	lds	r25, 0x02FF
    188e:	9f 70       	andi	r25, 0x0F	; 15
	current_patch.byte_2 |= 1 << lfo[lfo_shape_index].led_addr;
    1890:	89 2b       	or	r24, r25
    1892:	80 93 ff 02 	sts	0x02FF, r24
	DATA_BUS = lfo[lfo_shape_index].waveform_addr;
    1896:	80 81       	ld	r24, Z
    1898:	82 b9       	out	0x02, r24	; 2
	LFO_LATCH_PORT |= (1<<LFO_SW_LATCH);
    189a:	ed ed       	ldi	r30, 0xDD	; 221
    189c:	f0 e0       	ldi	r31, 0x00	; 0
    189e:	80 81       	ld	r24, Z
    18a0:	80 62       	ori	r24, 0x20	; 32
    18a2:	80 83       	st	Z, r24
	LFO_LATCH_PORT &= ~(1<<LFO_SW_LATCH);
    18a4:	80 81       	ld	r24, Z
    18a6:	8f 7d       	andi	r24, 0xDF	; 223
    18a8:	80 83       	st	Z, r24
	
}		
    18aa:	08 95       	ret

000018ac <update_patch>:
	
	
void update_patch(void) {
    18ac:	cf 93       	push	r28
    18ae:	df 93       	push	r29
		//return;
					//
	//}
	//switch_press = 0;
	
	PORTB ^= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED 
    18b0:	85 b1       	in	r24, 0x05	; 5
    18b2:	80 58       	subi	r24, 0x80	; 128
    18b4:	85 b9       	out	0x05, r24	; 5
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    18b6:	90 91 78 03 	lds	r25, 0x0378
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
							((switch_states.byte0 >> VCO1_PULSE_SW) & 1) << VCO1_PULSE |
							((switch_states.byte0 >> VCO2_SAW_SW) & 1) << VCO2_SAW |
							((switch_states.byte0 >> VCO2_TRI_SW) & 1) << VCO2_TRI |
							((switch_states.byte0 >> VCO2_PULSE_SW) & 1) << VCO2_PULSE |
							((switch_states.byte2 >> BMOD_SW) & 1) << BMOD;
    18ba:	80 91 7a 03 	lds	r24, 0x037A
    18be:	86 95       	lsr	r24
    18c0:	86 95       	lsr	r24
    18c2:	68 2f       	mov	r22, r24
    18c4:	67 95       	ror	r22
    18c6:	66 27       	eor	r22, r22
    18c8:	67 95       	ror	r22
	//}
	//switch_press = 0;
	
	PORTB ^= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED 
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    18ca:	29 2f       	mov	r18, r25
    18cc:	21 70       	andi	r18, 0x01	; 1
    18ce:	26 2b       	or	r18, r22
    18d0:	69 2f       	mov	r22, r25
    18d2:	66 1f       	adc	r22, r22
    18d4:	66 27       	eor	r22, r22
    18d6:	66 1f       	adc	r22, r22
    18d8:	66 0f       	add	r22, r22
    18da:	62 2b       	or	r22, r18
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
    18dc:	c9 2f       	mov	r28, r25
    18de:	c6 95       	lsr	r28
    18e0:	c6 95       	lsr	r28
    18e2:	d0 e0       	ldi	r29, 0x00	; 0
    18e4:	c1 70       	andi	r28, 0x01	; 1
    18e6:	d0 70       	andi	r29, 0x00	; 0
    18e8:	de 01       	movw	r26, r28
    18ea:	aa 0f       	add	r26, r26
    18ec:	bb 1f       	adc	r27, r27
    18ee:	aa 0f       	add	r26, r26
    18f0:	bb 1f       	adc	r27, r27
	//}
	//switch_press = 0;
	
	PORTB ^= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED 
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    18f2:	6a 2b       	or	r22, r26
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
    18f4:	a9 2f       	mov	r26, r25
    18f6:	a6 95       	lsr	r26
    18f8:	b0 e0       	ldi	r27, 0x00	; 0
    18fa:	a1 70       	andi	r26, 0x01	; 1
    18fc:	b0 70       	andi	r27, 0x00	; 0
    18fe:	fd 01       	movw	r30, r26
    1900:	ee 0f       	add	r30, r30
    1902:	ff 1f       	adc	r31, r31
    1904:	ee 0f       	add	r30, r30
    1906:	ff 1f       	adc	r31, r31
    1908:	ee 0f       	add	r30, r30
    190a:	ff 1f       	adc	r31, r31
	//}
	//switch_press = 0;
	
	PORTB ^= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED 
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    190c:	a6 2f       	mov	r26, r22
    190e:	ae 2b       	or	r26, r30
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
							((switch_states.byte0 >> VCO1_PULSE_SW) & 1) << VCO1_PULSE |
							((switch_states.byte0 >> VCO2_SAW_SW) & 1) << VCO2_SAW |
    1910:	e9 2f       	mov	r30, r25
    1912:	e2 95       	swap	r30
    1914:	ef 70       	andi	r30, 0x0F	; 15
    1916:	f0 e0       	ldi	r31, 0x00	; 0
    1918:	e1 70       	andi	r30, 0x01	; 1
    191a:	f0 70       	andi	r31, 0x00	; 0
    191c:	bf 01       	movw	r22, r30
    191e:	62 95       	swap	r22
    1920:	72 95       	swap	r23
    1922:	70 7f       	andi	r23, 0xF0	; 240
    1924:	76 27       	eor	r23, r22
    1926:	60 7f       	andi	r22, 0xF0	; 240
    1928:	76 27       	eor	r23, r22
	//}
	//switch_press = 0;
	
	PORTB ^= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED 
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    192a:	ea 2f       	mov	r30, r26
    192c:	e6 2b       	or	r30, r22
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
							((switch_states.byte0 >> VCO1_PULSE_SW) & 1) << VCO1_PULSE |
							((switch_states.byte0 >> VCO2_SAW_SW) & 1) << VCO2_SAW |
							((switch_states.byte0 >> VCO2_TRI_SW) & 1) << VCO2_TRI |
    192e:	69 2f       	mov	r22, r25
    1930:	62 95       	swap	r22
    1932:	66 95       	lsr	r22
    1934:	67 70       	andi	r22, 0x07	; 7
    1936:	70 e0       	ldi	r23, 0x00	; 0
    1938:	61 70       	andi	r22, 0x01	; 1
    193a:	70 70       	andi	r23, 0x00	; 0
    193c:	ab 01       	movw	r20, r22
    193e:	44 0f       	add	r20, r20
    1940:	55 1f       	adc	r21, r21
    1942:	42 95       	swap	r20
    1944:	52 95       	swap	r21
    1946:	50 7f       	andi	r21, 0xF0	; 240
    1948:	54 27       	eor	r21, r20
    194a:	40 7f       	andi	r20, 0xF0	; 240
    194c:	54 27       	eor	r21, r20
	//}
	//switch_press = 0;
	
	PORTB ^= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED 
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    194e:	6e 2f       	mov	r22, r30
    1950:	64 2b       	or	r22, r20
							((switch_states.byte0 >> VCO1_SAW_SW) & 1) << VCO1_SAW |
							((switch_states.byte0 >> VCO1_TRI_SW) & 1) << VCO1_TRI |
							((switch_states.byte0 >> VCO1_PULSE_SW) & 1) << VCO1_PULSE |
							((switch_states.byte0 >> VCO2_SAW_SW) & 1) << VCO2_SAW |
							((switch_states.byte0 >> VCO2_TRI_SW) & 1) << VCO2_TRI |
							((switch_states.byte0 >> VCO2_PULSE_SW) & 1) << VCO2_PULSE |
    1952:	49 2f       	mov	r20, r25
    1954:	42 95       	swap	r20
    1956:	46 95       	lsr	r20
    1958:	46 95       	lsr	r20
    195a:	43 70       	andi	r20, 0x03	; 3
    195c:	50 e0       	ldi	r21, 0x00	; 0
    195e:	41 70       	andi	r20, 0x01	; 1
    1960:	50 70       	andi	r21, 0x00	; 0
    1962:	9a 01       	movw	r18, r20
    1964:	00 24       	eor	r0, r0
    1966:	36 95       	lsr	r19
    1968:	27 95       	ror	r18
    196a:	07 94       	ror	r0
    196c:	36 95       	lsr	r19
    196e:	27 95       	ror	r18
    1970:	07 94       	ror	r0
    1972:	32 2f       	mov	r19, r18
    1974:	20 2d       	mov	r18, r0
	//}
	//switch_press = 0;
	
	PORTB ^= (1<<ARP_SYNC_LED); //toggle arp VCO_SYNC_LATCH_BIT LED 
	//parse LED data for LED latch 5
	current_patch.byte_5 =	((switch_states.byte0 >> VCO_SYNC_SW) & 1) << VCO_SYNC |					
    1976:	26 2b       	or	r18, r22
    1978:	20 93 02 03 	sts	0x0302, r18
			
	//update analog switch latch:
	//need to incorporate BMOD_LATCH_BIT switch state into data byte sent to analog switch latch
	//3rd switch bit is VCO1_OCTAVE_UP_SW state, which isn't used by analog switch latch
	uint8_t analog_sw_byte = switch_states.byte0;
	uint8_t BMOD_SW_ON = (switch_states.byte2 >> BMOD_SW) & 1;
    197c:	81 70       	andi	r24, 0x01	; 1
	analog_sw_byte ^= (-BMOD_SW_ON ^ analog_sw_byte) & (1<<3);//set third bit dependent on BMOD switch state
    197e:	81 95       	neg	r24
    1980:	89 27       	eor	r24, r25
    1982:	88 70       	andi	r24, 0x08	; 8
	update_analog_switch_latch(analog_sw_byte);
    1984:	89 27       	eor	r24, r25
    1986:	0e 94 99 13 	call	0x2732	; 0x2732 <update_analog_switch_latch>
					
	//set EG2 INV bit. This changes the nth bit to x from: http://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit-in-c-c
	//need to make sure this doesn't interfere with anything else on this port
	uint8_t EG2_INV_ON = (switch_states.byte2 >> EG2_INV_SW) & 1;	
	EG2_POL_PORT ^= (-EG2_INV_ON ^ EG2_POL_PORT) & (1<<EG2_POL);
    198a:	ed ed       	ldi	r30, 0xDD	; 221
    198c:	f0 e0       	ldi	r31, 0x00	; 0
    198e:	20 81       	ld	r18, Z
	analog_sw_byte ^= (-BMOD_SW_ON ^ analog_sw_byte) & (1<<3);//set third bit dependent on BMOD switch state
	update_analog_switch_latch(analog_sw_byte);
					
	//set EG2 INV bit. This changes the nth bit to x from: http://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit-in-c-c
	//need to make sure this doesn't interfere with anything else on this port
	uint8_t EG2_INV_ON = (switch_states.byte2 >> EG2_INV_SW) & 1;	
    1990:	90 91 7a 03 	lds	r25, 0x037A
    1994:	96 95       	lsr	r25
    1996:	96 95       	lsr	r25
    1998:	96 95       	lsr	r25
    199a:	91 70       	andi	r25, 0x01	; 1
	EG2_POL_PORT ^= (-EG2_INV_ON ^ EG2_POL_PORT) & (1<<EG2_POL);
    199c:	91 95       	neg	r25
    199e:	80 81       	ld	r24, Z
    19a0:	89 27       	eor	r24, r25
    19a2:	80 71       	andi	r24, 0x10	; 16
    19a4:	82 27       	eor	r24, r18
    19a6:	80 83       	st	Z, r24
	current_patch.byte_1 ^= (-EG2_INV_ON ^ current_patch.byte_1) & (1 << EG2_INV); //don't forget to set it in patch or it won't be saved!
    19a8:	ee ef       	ldi	r30, 0xFE	; 254
    19aa:	f2 e0       	ldi	r31, 0x02	; 2
    19ac:	80 81       	ld	r24, Z
    19ae:	98 27       	eor	r25, r24
    19b0:	91 70       	andi	r25, 0x01	; 1
    19b2:	89 27       	eor	r24, r25
    19b4:	80 83       	st	Z, r24
	
	//parse octave switch data
	update_octave_range();
    19b6:	0e 94 9b 0b 	call	0x1736	; 0x1736 <update_octave_range>
	
	//parse LFO data
	update_lfo_shape();
    19ba:	0e 94 26 0c 	call	0x184c	; 0x184c <update_lfo_shape>
	

	
	//update_patch_programmer();		
				
	if ((switch_states.byte1 >> ARP_MODE_SW) & 1) //temporary tune button hack
    19be:	80 91 79 03 	lds	r24, 0x0379
    19c2:	98 2f       	mov	r25, r24
    19c4:	92 95       	swap	r25
    19c6:	96 95       	lsr	r25
    19c8:	97 70       	andi	r25, 0x07	; 7
    19ca:	90 ff       	sbrs	r25, 0
    19cc:	3f c0       	rjmp	.+126    	; 0x1a4c <update_patch+0x1a0>
		{ 
				
		switch_states.byte1 ^= (1<<ARP_MODE_SW); //toggle read switch state
    19ce:	90 e2       	ldi	r25, 0x20	; 32
    19d0:	89 27       	eor	r24, r25
    19d2:	80 93 79 03 	sts	0x0379, r24


		//TURN OFF LFO OUTPUT
		DATA_BUS = 0b00000111; //turn off LFO waveform
    19d6:	87 e0       	ldi	r24, 0x07	; 7
    19d8:	82 b9       	out	0x02, r24	; 2
		LFO_LATCH_PORT |= (1<<LFO_SW_LATCH);
    19da:	cd ed       	ldi	r28, 0xDD	; 221
    19dc:	d0 e0       	ldi	r29, 0x00	; 0
    19de:	88 81       	ld	r24, Y
    19e0:	80 62       	ori	r24, 0x20	; 32
    19e2:	88 83       	st	Y, r24
		LFO_LATCH_PORT &= ~(1<<LFO_SW_LATCH);
    19e4:	88 81       	ld	r24, Y
    19e6:	8f 7d       	andi	r24, 0xDF	; 223
    19e8:	88 83       	st	Y, r24
		DATA_BUS = 0;
    19ea:	12 b8       	out	0x02, r1	; 2
		
		vco1_init_cv = set_vco_init_cv(VCO1, 24079);
    19ec:	8f e0       	ldi	r24, 0x0F	; 15
    19ee:	6f e0       	ldi	r22, 0x0F	; 15
    19f0:	7e e5       	ldi	r23, 0x5E	; 94
    19f2:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <set_vco_init_cv>
    19f6:	90 93 70 03 	sts	0x0370, r25
    19fa:	80 93 6f 03 	sts	0x036F, r24
		vco2_init_cv = set_vco_init_cv(VCO2, 24079);
    19fe:	80 ef       	ldi	r24, 0xF0	; 240
    1a00:	6f e0       	ldi	r22, 0x0F	; 15
    1a02:	7e e5       	ldi	r23, 0x5E	; 94
    1a04:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <set_vco_init_cv>
    1a08:	90 93 6e 03 	sts	0x036E, r25
    1a0c:	80 93 6d 03 	sts	0x036D, r24
		//vco1_init_cv = vco2_init_cv;
		tune_8ths(VCO1);
    1a10:	8f e0       	ldi	r24, 0x0F	; 15
    1a12:	0e 94 79 0f 	call	0x1ef2	; 0x1ef2 <tune_8ths>
		tune_8ths(VCO2);
    1a16:	80 ef       	ldi	r24, 0xF0	; 240
    1a18:	0e 94 79 0f 	call	0x1ef2	; 0x1ef2 <tune_8ths>
		tune_filter();
    1a1c:	0e 94 1b 11 	call	0x2236	; 0x2236 <tune_filter>
		save_tuning_tables();
    1a20:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <save_tuning_tables>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1a24:	8f e4       	ldi	r24, 0x4F	; 79
    1a26:	93 ec       	ldi	r25, 0xC3	; 195
    1a28:	01 97       	sbiw	r24, 0x01	; 1
    1a2a:	f1 f7       	brne	.-4      	; 0x1a28 <update_patch+0x17c>
    1a2c:	00 c0       	rjmp	.+0      	; 0x1a2e <update_patch+0x182>
    1a2e:	00 00       	nop
		_delay_ms(200);	//give some time for release to decay to avoid pops	
		
		DATA_BUS = LFO_TRI_ADDR;
    1a30:	12 b8       	out	0x02, r1	; 2
		LFO_LATCH_PORT |= (1<<LFO_SW_LATCH);
    1a32:	88 81       	ld	r24, Y
    1a34:	80 62       	ori	r24, 0x20	; 32
    1a36:	88 83       	st	Y, r24
		LFO_LATCH_PORT &= ~(1<<LFO_SW_LATCH);
    1a38:	88 81       	ld	r24, Y
    1a3a:	8f 7d       	andi	r24, 0xDF	; 223
    1a3c:	88 83       	st	Y, r24
		DATA_BUS = 0;
    1a3e:	12 b8       	out	0x02, r1	; 2
		current_patch.byte_2 &= 0b00001111; //clear top 4 bits 
    1a40:	80 91 ff 02 	lds	r24, 0x02FF
    1a44:	8f 70       	andi	r24, 0x0F	; 15
		current_patch.byte_2 |= (1<<LFO_TRI);
    1a46:	80 68       	ori	r24, 0x80	; 128
    1a48:	80 93 ff 02 	sts	0x02FF, r24
				
		}
		
		
	
}
    1a4c:	df 91       	pop	r29
    1a4e:	cf 91       	pop	r28
    1a50:	08 95       	ret

00001a52 <update_patch_programmer>:
	
}

void update_patch_programmer(void) {
	
	if ((switch_states.byte2>> PROG_UP_SW) & 1) {
    1a52:	80 91 7a 03 	lds	r24, 0x037A
    1a56:	98 2f       	mov	r25, r24
    1a58:	92 95       	swap	r25
    1a5a:	96 95       	lsr	r25
    1a5c:	96 95       	lsr	r25
    1a5e:	93 70       	andi	r25, 0x03	; 3
    1a60:	90 ff       	sbrs	r25, 0
    1a62:	17 c0       	rjmp	.+46     	; 0x1a92 <update_patch_programmer+0x40>
		
		switch_states.byte2 ^= (1<<PROG_UP_SW); //toggle switch state bit
    1a64:	90 e4       	ldi	r25, 0x40	; 64
    1a66:	89 27       	eor	r24, r25
    1a68:	80 93 7a 03 	sts	0x037A, r24
		
		if (++current_patch.number == NUM_PATCHES + 1) {			
    1a6c:	80 91 03 03 	lds	r24, 0x0303
    1a70:	8f 5f       	subi	r24, 0xFF	; 255
    1a72:	80 93 03 03 	sts	0x0303, r24
    1a76:	85 32       	cpi	r24, 0x25	; 37
    1a78:	21 f4       	brne	.+8      	; 0x1a82 <update_patch_programmer+0x30>
			
			current_patch.number = NUM_PATCHES; //max patch number
    1a7a:	84 e2       	ldi	r24, 0x24	; 36
    1a7c:	80 93 03 03 	sts	0x0303, r24
    1a80:	08 c0       	rjmp	.+16     	; 0x1a92 <update_patch_programmer+0x40>
		
					
		} else if (current_patch.mode != WRITE) { //load next patch if not in WRITE mode
    1a82:	90 91 05 03 	lds	r25, 0x0305
    1a86:	93 30       	cpi	r25, 0x03	; 3
    1a88:	21 f0       	breq	.+8      	; 0x1a92 <update_patch_programmer+0x40>
			
			load_patch(current_patch.number);
    1a8a:	0e 94 ab 08 	call	0x1156	; 0x1156 <load_patch>
			update_patch();
    1a8e:	0e 94 56 0c 	call	0x18ac	; 0x18ac <update_patch>
			
		}		
		
	}
	
	if ((switch_states.byte2 >> PROG_DOWN_SW) & 1) {
    1a92:	80 91 7a 03 	lds	r24, 0x037A
    1a96:	98 2f       	mov	r25, r24
    1a98:	92 95       	swap	r25
    1a9a:	96 95       	lsr	r25
    1a9c:	97 70       	andi	r25, 0x07	; 7
    1a9e:	90 ff       	sbrs	r25, 0
    1aa0:	15 c0       	rjmp	.+42     	; 0x1acc <update_patch_programmer+0x7a>
	
		switch_states.byte2 ^= (1<<PROG_DOWN_SW); //toggle switch state bit
    1aa2:	90 e2       	ldi	r25, 0x20	; 32
    1aa4:	89 27       	eor	r24, r25
    1aa6:	80 93 7a 03 	sts	0x037A, r24

		if (current_patch.number == 1) {} else {current_patch.number--;}
    1aaa:	80 91 03 03 	lds	r24, 0x0303
    1aae:	81 30       	cpi	r24, 0x01	; 1
    1ab0:	19 f0       	breq	.+6      	; 0x1ab8 <update_patch_programmer+0x66>
    1ab2:	81 50       	subi	r24, 0x01	; 1
    1ab4:	80 93 03 03 	sts	0x0303, r24
		
		if (current_patch.mode != WRITE) {
    1ab8:	80 91 05 03 	lds	r24, 0x0305
    1abc:	83 30       	cpi	r24, 0x03	; 3
    1abe:	31 f0       	breq	.+12     	; 0x1acc <update_patch_programmer+0x7a>
			
			load_patch(current_patch.number); 
    1ac0:	80 91 03 03 	lds	r24, 0x0303
    1ac4:	0e 94 ab 08 	call	0x1156	; 0x1156 <load_patch>
			update_patch();
    1ac8:	0e 94 56 0c 	call	0x18ac	; 0x18ac <update_patch>
		}			
	}
	
	
	if ((switch_states.byte2 >> PROG_WRITE_SW) & 1) {
    1acc:	80 91 7a 03 	lds	r24, 0x037A
    1ad0:	98 2f       	mov	r25, r24
    1ad2:	92 95       	swap	r25
    1ad4:	9f 70       	andi	r25, 0x0F	; 15
    1ad6:	90 ff       	sbrs	r25, 0
    1ad8:	15 c0       	rjmp	.+42     	; 0x1b04 <update_patch_programmer+0xb2>
		
		switch_states.byte2 ^= (1<<PROG_WRITE_SW);
    1ada:	90 e1       	ldi	r25, 0x10	; 16
    1adc:	89 27       	eor	r24, r25
    1ade:	80 93 7a 03 	sts	0x037A, r24
		if (current_patch.mode != WRITE) {
    1ae2:	90 91 05 03 	lds	r25, 0x0305
    1ae6:	93 30       	cpi	r25, 0x03	; 3
    1ae8:	49 f0       	breq	.+18     	; 0x1afc <update_patch_programmer+0xaa>
			switch_states.byte2 &= ~(1<< PROG_MANUAL_SW); //turn off manual mode
    1aea:	8f 77       	andi	r24, 0x7F	; 127
    1aec:	80 93 7a 03 	sts	0x037A, r24
			current_patch.mode = WRITE;
    1af0:	83 e0       	ldi	r24, 0x03	; 3
    1af2:	80 93 05 03 	sts	0x0305, r24
			lock_pots();
    1af6:	0e 94 8d 06 	call	0xd1a	; 0xd1a <lock_pots>
    1afa:	04 c0       	rjmp	.+8      	; 0x1b04 <update_patch_programmer+0xb2>
			
			
		} else {
			
			save_patch(current_patch.number); //write the patch
    1afc:	80 91 03 03 	lds	r24, 0x0303
    1b00:	0e 94 b8 06 	call	0xd70	; 0xd70 <save_patch>
		//save_patch(current_patch.number);
		
		
	}
	
	if (((switch_states.byte2 >> PROG_MANUAL_SW) & 1)) {
    1b04:	80 91 7a 03 	lds	r24, 0x037A
    1b08:	88 23       	and	r24, r24
    1b0a:	44 f4       	brge	.+16     	; 0x1b1c <update_patch_programmer+0xca>
			
		switch_states.byte2 |= (1<< PROG_MANUAL_SW);
    1b0c:	80 68       	ori	r24, 0x80	; 128
    1b0e:	80 93 7a 03 	sts	0x037A, r24
		current_patch.mode = MANUAL;
    1b12:	81 e0       	ldi	r24, 0x01	; 1
    1b14:	80 93 05 03 	sts	0x0305, r24
		unlock_pots();
    1b18:	0e 94 a7 06 	call	0xd4e	; 0xd4e <unlock_pots>
			
	}
	value_to_display = current_patch.number;	
    1b1c:	80 91 03 03 	lds	r24, 0x0303
    1b20:	90 e0       	ldi	r25, 0x00	; 0
    1b22:	90 93 fe 01 	sts	0x01FE, r25
    1b26:	80 93 fd 01 	sts	0x01FD, r24
	//value_to_display = vco1_init_cv>>1;
	
	
}	
    1b2a:	08 95       	ret

00001b2c <initialize_voice_for_tuning>:
	

void initialize_voice_for_tuning(void) { //this function sets all CVs required for oscillator tuning
	

	set_control_voltage(&volume_cv, MIN); //turn volume all the way down
    1b2c:	88 ed       	ldi	r24, 0xD8	; 216
    1b2e:	91 e0       	ldi	r25, 0x01	; 1
    1b30:	60 e0       	ldi	r22, 0x00	; 0
    1b32:	70 e0       	ldi	r23, 0x00	; 0
    1b34:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	//turn off all pitch modulation
	set_control_voltage(&pitch_lfo_cv, MIN);
    1b38:	81 ee       	ldi	r24, 0xE1	; 225
    1b3a:	91 e0       	ldi	r25, 0x01	; 1
    1b3c:	60 e0       	ldi	r22, 0x00	; 0
    1b3e:	70 e0       	ldi	r23, 0x00	; 0
    1b40:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&pitch_eg2_cv, MIN);
    1b44:	82 ee       	ldi	r24, 0xE2	; 226
    1b46:	91 e0       	ldi	r25, 0x01	; 1
    1b48:	60 e0       	ldi	r22, 0x00	; 0
    1b4a:	70 e0       	ldi	r23, 0x00	; 0
    1b4c:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&pitch_vco2_cv, MIN);
    1b50:	82 eb       	ldi	r24, 0xB2	; 178
    1b52:	92 e0       	ldi	r25, 0x02	; 2
    1b54:	60 e0       	ldi	r22, 0x00	; 0
    1b56:	70 e0       	ldi	r23, 0x00	; 0
    1b58:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	//turn off glide
	set_control_voltage(&glide_cv, MIN);
    1b5c:	8a ed       	ldi	r24, 0xDA	; 218
    1b5e:	91 e0       	ldi	r25, 0x01	; 1
    1b60:	60 e0       	ldi	r22, 0x00	; 0
    1b62:	70 e0       	ldi	r23, 0x00	; 0
    1b64:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	//turn off all pulse width modulation
	set_control_voltage(&pwm_eg2_cv, MIN);
    1b68:	8f ed       	ldi	r24, 0xDF	; 223
    1b6a:	91 e0       	ldi	r25, 0x01	; 1
    1b6c:	60 e0       	ldi	r22, 0x00	; 0
    1b6e:	70 e0       	ldi	r23, 0x00	; 0
    1b70:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&pwm_lfo_cv, MIN);
    1b74:	80 ee       	ldi	r24, 0xE0	; 224
    1b76:	91 e0       	ldi	r25, 0x01	; 1
    1b78:	60 e0       	ldi	r22, 0x00	; 0
    1b7a:	70 e0       	ldi	r23, 0x00	; 0
    1b7c:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	//turn off all filter modulation
	set_control_voltage(&fil_lfo_cv, MIN);
    1b80:	81 ed       	ldi	r24, 0xD1	; 209
    1b82:	91 e0       	ldi	r25, 0x01	; 1
    1b84:	60 e0       	ldi	r22, 0x00	; 0
    1b86:	70 e0       	ldi	r23, 0x00	; 0
    1b88:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&fil_eg2_cv, MIN);
    1b8c:	86 ed       	ldi	r24, 0xD6	; 214
    1b8e:	91 e0       	ldi	r25, 0x01	; 1
    1b90:	60 e0       	ldi	r22, 0x00	; 0
    1b92:	70 e0       	ldi	r23, 0x00	; 0
    1b94:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&fil_vco2_cv, MIN);
    1b98:	82 ed       	ldi	r24, 0xD2	; 210
    1b9a:	91 e0       	ldi	r25, 0x01	; 1
    1b9c:	60 e0       	ldi	r22, 0x00	; 0
    1b9e:	70 e0       	ldi	r23, 0x00	; 0
    1ba0:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&key_track_cv, MIN);
    1ba4:	83 ed       	ldi	r24, 0xD3	; 211
    1ba6:	91 e0       	ldi	r25, 0x01	; 1
    1ba8:	60 e0       	ldi	r22, 0x00	; 0
    1baa:	70 e0       	ldi	r23, 0x00	; 0
    1bac:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	//open filter with no resonance
	set_control_voltage(&cutoff_cv, MAX);
    1bb0:	84 ed       	ldi	r24, 0xD4	; 212
    1bb2:	91 e0       	ldi	r25, 0x01	; 1
    1bb4:	6f ef       	ldi	r22, 0xFF	; 255
    1bb6:	7f e3       	ldi	r23, 0x3F	; 63
    1bb8:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&res_cv, MIN);
    1bbc:	85 ed       	ldi	r24, 0xD5	; 213
    1bbe:	91 e0       	ldi	r25, 0x01	; 1
    1bc0:	60 e0       	ldi	r22, 0x00	; 0
    1bc2:	70 e0       	ldi	r23, 0x00	; 0
    1bc4:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	//turn off VCA LFO modulation
	set_control_voltage(&amp_lfo_cv, MIN);
    1bc8:	89 ed       	ldi	r24, 0xD9	; 217
    1bca:	91 e0       	ldi	r25, 0x01	; 1
    1bcc:	60 e0       	ldi	r22, 0x00	; 0
    1bce:	70 e0       	ldi	r23, 0x00	; 0
    1bd0:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	//initialize VCA envelope
	set_control_voltage(&attack_1_cv, MIN);
    1bd4:	8e ec       	ldi	r24, 0xCE	; 206
    1bd6:	91 e0       	ldi	r25, 0x01	; 1
    1bd8:	60 e0       	ldi	r22, 0x00	; 0
    1bda:	70 e0       	ldi	r23, 0x00	; 0
    1bdc:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&decay_1_cv, MIN);
    1be0:	8c ec       	ldi	r24, 0xCC	; 204
    1be2:	91 e0       	ldi	r25, 0x01	; 1
    1be4:	60 e0       	ldi	r22, 0x00	; 0
    1be6:	70 e0       	ldi	r23, 0x00	; 0
    1be8:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&sustain_1_cv, MAX);
    1bec:	8a ec       	ldi	r24, 0xCA	; 202
    1bee:	91 e0       	ldi	r25, 0x01	; 1
    1bf0:	6f ef       	ldi	r22, 0xFF	; 255
    1bf2:	7f e3       	ldi	r23, 0x3F	; 63
    1bf4:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&release_1_cv, MIN);
    1bf8:	88 ec       	ldi	r24, 0xC8	; 200
    1bfa:	91 e0       	ldi	r25, 0x01	; 1
    1bfc:	60 e0       	ldi	r22, 0x00	; 0
    1bfe:	70 e0       	ldi	r23, 0x00	; 0
    1c00:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	//turn off noise
	set_control_voltage(&noise_mix_cv, MIN);
    1c04:	80 ed       	ldi	r24, 0xD0	; 208
    1c06:	91 e0       	ldi	r25, 0x01	; 1
    1c08:	60 e0       	ldi	r22, 0x00	; 0
    1c0a:	70 e0       	ldi	r23, 0x00	; 0
    1c0c:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&vco1_mix_cv, MIN);
    1c10:	83 ee       	ldi	r24, 0xE3	; 227
    1c12:	91 e0       	ldi	r25, 0x01	; 1
    1c14:	60 e0       	ldi	r22, 0x00	; 0
    1c16:	70 e0       	ldi	r23, 0x00	; 0
    1c18:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&vco2_mix_cv, MIN);
    1c1c:	84 ee       	ldi	r24, 0xE4	; 228
    1c1e:	91 e0       	ldi	r25, 0x01	; 1
    1c20:	60 e0       	ldi	r22, 0x00	; 0
    1c22:	70 e0       	ldi	r23, 0x00	; 0
    1c24:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
}	
    1c28:	08 95       	ret

00001c2a <set_vco_init_cv>:
	
uint16_t set_vco_init_cv(uint8_t vco, uint16_t base_reference) { 
    1c2a:	2f 92       	push	r2
    1c2c:	3f 92       	push	r3
    1c2e:	4f 92       	push	r4
    1c30:	5f 92       	push	r5
    1c32:	6f 92       	push	r6
    1c34:	7f 92       	push	r7
    1c36:	8f 92       	push	r8
    1c38:	9f 92       	push	r9
    1c3a:	af 92       	push	r10
    1c3c:	bf 92       	push	r11
    1c3e:	cf 92       	push	r12
    1c40:	df 92       	push	r13
    1c42:	ef 92       	push	r14
    1c44:	ff 92       	push	r15
    1c46:	0f 93       	push	r16
    1c48:	1f 93       	push	r17
    1c4a:	cf 93       	push	r28
    1c4c:	df 93       	push	r29
    1c4e:	cd b7       	in	r28, 0x3d	; 61
    1c50:	de b7       	in	r29, 0x3e	; 62
    1c52:	2c 97       	sbiw	r28, 0x0c	; 12
    1c54:	0f b6       	in	r0, 0x3f	; 63
    1c56:	f8 94       	cli
    1c58:	de bf       	out	0x3e, r29	; 62
    1c5a:	0f be       	out	0x3f, r0	; 63
    1c5c:	cd bf       	out	0x3d, r28	; 61
    1c5e:	08 2f       	mov	r16, r24
    1c60:	78 87       	std	Y+8, r23	; 0x08
    1c62:	6f 83       	std	Y+7, r22	; 0x07

	uint16_t init_cv = 0;
	timer1_clock |= (1<<CS11) | (1<<CS10);
    1c64:	80 91 75 03 	lds	r24, 0x0375
    1c68:	83 60       	ori	r24, 0x03	; 3
    1c6a:	80 93 75 03 	sts	0x0375, r24
	 
	//TO DO: disable UART so MIDI data doesn't interrupt tuning
	
	//setup control voltages	
	initialize_voice_for_tuning();
    1c6e:	0e 94 96 0d 	call	0x1b2c	; 0x1b2c <initialize_voice_for_tuning>
	struct control_voltage *vco_init_cv;
	struct control_voltage *vco_mix_cv;
	struct control_voltage *vco_pw_cv;
	struct control_voltage *vco_pitch_cv;

	count_finished = FALSE;
    1c72:	10 92 74 03 	sts	0x0374, r1
	
	if (vco == VCO1) { //turn on VCO1 pulse
    1c76:	0f 30       	cpi	r16, 0x0F	; 15
    1c78:	e1 f4       	brne	.+56     	; 0x1cb2 <set_vco_init_cv+0x88>
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
		vco_mix_cv = &vco1_mix_cv;
		vco_pw_cv = &vco1_pw_cv;
		vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
    1c7a:	0f 2e       	mov	r0, r31
    1c7c:	f6 ee       	ldi	r31, 0xE6	; 230
    1c7e:	4f 2e       	mov	r4, r31
    1c80:	f1 e0       	ldi	r31, 0x01	; 1
    1c82:	5f 2e       	mov	r5, r31
    1c84:	f0 2d       	mov	r31, r0
	if (vco == VCO1) { //turn on VCO1 pulse
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
		vco_mix_cv = &vco1_mix_cv;
		vco_pw_cv = &vco1_pw_cv;
    1c86:	0f 2e       	mov	r0, r31
    1c88:	fe ed       	ldi	r31, 0xDE	; 222
    1c8a:	2f 2e       	mov	r2, r31
    1c8c:	f1 e0       	ldi	r31, 0x01	; 1
    1c8e:	3f 2e       	mov	r3, r31
    1c90:	f0 2d       	mov	r31, r0
	
	if (vco == VCO1) { //turn on VCO1 pulse
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
		vco_mix_cv = &vco1_mix_cv;
    1c92:	23 ee       	ldi	r18, 0xE3	; 227
    1c94:	31 e0       	ldi	r19, 0x01	; 1
    1c96:	3a 83       	std	Y+2, r19	; 0x02
    1c98:	29 83       	std	Y+1, r18	; 0x01
	count_finished = FALSE;
	
	if (vco == VCO1) { //turn on VCO1 pulse
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
		vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
    1c9a:	0f 2e       	mov	r0, r31
    1c9c:	fc ed       	ldi	r31, 0xDC	; 220
    1c9e:	8f 2e       	mov	r8, r31
    1ca0:	f1 e0       	ldi	r31, 0x01	; 1
    1ca2:	9f 2e       	mov	r9, r31
    1ca4:	f0 2d       	mov	r31, r0
		vco_mix_cv = &vco1_mix_cv;
		vco_pw_cv = &vco1_pw_cv;
		vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
		reference_count = base_reference;//38222; //make this an argument passed to function
		eeprom_addr = &vco1_init_cv_eeprom;
    1ca6:	82 e7       	ldi	r24, 0x72	; 114
    1ca8:	96 e0       	ldi	r25, 0x06	; 6
    1caa:	9a 87       	std	Y+10, r25	; 0x0a
    1cac:	89 87       	std	Y+9, r24	; 0x09

	count_finished = FALSE;
	
	if (vco == VCO1) { //turn on VCO1 pulse
		//turn on VCO1 pulse, all others off
		switch_byte = (1<<VCO1_SAW_LATCH_BIT);
    1cae:	81 e0       	ldi	r24, 0x01	; 1
    1cb0:	1b c0       	rjmp	.+54     	; 0x1ce8 <set_vco_init_cv+0xbe>
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
		vco_mix_cv = &vco2_mix_cv;
		vco_pw_cv = &vco2_pw_cv;
		vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
    1cb2:	0f 2e       	mov	r0, r31
    1cb4:	f5 ee       	ldi	r31, 0xE5	; 229
    1cb6:	4f 2e       	mov	r4, r31
    1cb8:	f1 e0       	ldi	r31, 0x01	; 1
    1cba:	5f 2e       	mov	r5, r31
    1cbc:	f0 2d       	mov	r31, r0
	} else { //turn on VCO2 pulse	
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
		vco_mix_cv = &vco2_mix_cv;
		vco_pw_cv = &vco2_pw_cv;
    1cbe:	0f 2e       	mov	r0, r31
    1cc0:	f7 ed       	ldi	r31, 0xD7	; 215
    1cc2:	2f 2e       	mov	r2, r31
    1cc4:	f1 e0       	ldi	r31, 0x01	; 1
    1cc6:	3f 2e       	mov	r3, r31
    1cc8:	f0 2d       	mov	r31, r0
		
	} else { //turn on VCO2 pulse	
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
		vco_mix_cv = &vco2_mix_cv;
    1cca:	e4 ee       	ldi	r30, 0xE4	; 228
    1ccc:	f1 e0       	ldi	r31, 0x01	; 1
    1cce:	fa 83       	std	Y+2, r31	; 0x02
    1cd0:	e9 83       	std	Y+1, r30	; 0x01
		eeprom_addr = &vco1_init_cv_eeprom;
		
	} else { //turn on VCO2 pulse	
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
		vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
    1cd2:	0f 2e       	mov	r0, r31
    1cd4:	fd ed       	ldi	r31, 0xDD	; 221
    1cd6:	8f 2e       	mov	r8, r31
    1cd8:	f1 e0       	ldi	r31, 0x01	; 1
    1cda:	9f 2e       	mov	r9, r31
    1cdc:	f0 2d       	mov	r31, r0
		vco_mix_cv = &vco2_mix_cv;
		vco_pw_cv = &vco2_pw_cv;
		vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
		reference_count = base_reference;
		eeprom_addr = &vco2_init_cv_eeprom;
    1cde:	20 e7       	ldi	r18, 0x70	; 112
    1ce0:	36 e0       	ldi	r19, 0x06	; 6
    1ce2:	3a 87       	std	Y+10, r19	; 0x0a
    1ce4:	29 87       	std	Y+9, r18	; 0x09
		reference_count = base_reference;//38222; //make this an argument passed to function
		eeprom_addr = &vco1_init_cv_eeprom;
		
	} else { //turn on VCO2 pulse	
		//turn on VCO2 pulse, all others off
		switch_byte = (1<<VCO2_SAW_LATCH_BIT);
    1ce6:	80 e4       	ldi	r24, 0x40	; 64
		reference_count = base_reference;
		eeprom_addr = &vco2_init_cv_eeprom;
	}
	
	//latch switch data
	DATA_BUS = switch_byte;
    1ce8:	82 b9       	out	0x02, r24	; 2
	VCO_SW_LATCH_PORT |= (1<<VCO_SW_LATCH);
    1cea:	ed ed       	ldi	r30, 0xDD	; 221
    1cec:	f0 e0       	ldi	r31, 0x00	; 0
    1cee:	80 81       	ld	r24, Z
    1cf0:	80 64       	ori	r24, 0x40	; 64
    1cf2:	80 83       	st	Z, r24
	//_delay_us(1); //why is this delay here????
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    1cf4:	80 81       	ld	r24, Z
    1cf6:	8f 7b       	andi	r24, 0xBF	; 191
    1cf8:	80 83       	st	Z, r24
	DATA_BUS = 0;
    1cfa:	12 b8       	out	0x02, r1	; 2

	PORTF |= (1<<GATE); //turn gate on
    1cfc:	89 9a       	sbi	0x11, 1	; 17
	
	//set up timer/counter0 to be clocked by T0 input
	
	TCCR0A |= (1<<CS02) | (1<<CS01) | (1<<CS00) | (1<<WGM01); //clocked by external T0 pin, rising edge + clear timer on compare match
    1cfe:	84 b5       	in	r24, 0x24	; 36
    1d00:	8f 60       	ori	r24, 0x0F	; 15
    1d02:	84 bd       	out	0x24, r24	; 36
	OCR0A = 1; //output compare register - set to number of periods to be counted. OCR0A needs to be set to (periods_to_be_counted - 1)
    1d04:	81 e0       	ldi	r24, 0x01	; 1
    1d06:	87 bd       	out	0x27, r24	; 39
	//set OCR0A to 1 here means first ISR interrupt will occur after 2 periods, it is then set to 0 to count only single periods
	//for reasons I don't understand yet, starting with OCR0A set to 0 results in a multi-second delay before first compare match ISR is called ***ACTUALLY, THIS MAY BE RELATED TO LEAVING Timer0 RUNNING. COULD TRY TO SET OCR0A TO 0 NOW and SEE IF IT WORKS
	TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt	
    1d08:	ee e6       	ldi	r30, 0x6E	; 110
    1d0a:	f0 e0       	ldi	r31, 0x00	; 0
    1d0c:	90 81       	ld	r25, Z
    1d0e:	92 60       	ori	r25, 0x02	; 2
    1d10:	90 83       	st	Z, r25
	period = 1; //only counting 1 period 
    1d12:	80 93 76 03 	sts	0x0376, r24
	for (int dac_bit = 13; dac_bit >= 0; dac_bit--) {
    1d16:	8d e0       	ldi	r24, 0x0D	; 13
    1d18:	90 e0       	ldi	r25, 0x00	; 0
    1d1a:	9c 83       	std	Y+4, r25	; 0x04
    1d1c:	8b 83       	std	Y+3, r24	; 0x03
		//enable watchdog timer
		//WDTCR |= (1<<WDP2) | (1<<WDP1) | (1<<WDP0) | (1<<WDE)| (1<<WDCE);
		wdt_enable(WDTO_2S);
		while (count_finished == FALSE) { //need to have a watchdog timer here to escape while loop if it takes too long
			
			update_display(vco + 1, DEC);
    1d1e:	80 2f       	mov	r24, r16
    1d20:	90 e0       	ldi	r25, 0x00	; 0
    1d22:	8c 01       	movw	r16, r24
    1d24:	0f 5f       	subi	r16, 0xFF	; 255
    1d26:	1f 4f       	sbci	r17, 0xFF	; 255
		
			set_control_voltage(vco_init_cv, init_cv);
			set_control_voltage(vco_pw_cv, MAX);
			set_control_voltage(&volume_cv, MIN);
    1d28:	0f 2e       	mov	r0, r31
    1d2a:	f8 ed       	ldi	r31, 0xD8	; 216
    1d2c:	ef 2e       	mov	r14, r31
    1d2e:	f1 e0       	ldi	r31, 0x01	; 1
    1d30:	ff 2e       	mov	r15, r31
    1d32:	f0 2d       	mov	r31, r0
			set_control_voltage(&cutoff_cv, MAX);
    1d34:	0f 2e       	mov	r0, r31
    1d36:	f4 ed       	ldi	r31, 0xD4	; 212
    1d38:	cf 2e       	mov	r12, r31
    1d3a:	f1 e0       	ldi	r31, 0x01	; 1
    1d3c:	df 2e       	mov	r13, r31
    1d3e:	f0 2d       	mov	r31, r0
			set_control_voltage(&sustain_1_cv, MAX);
    1d40:	0f 2e       	mov	r0, r31
    1d42:	fa ec       	ldi	r31, 0xCA	; 202
    1d44:	af 2e       	mov	r10, r31
    1d46:	f1 e0       	ldi	r31, 0x01	; 1
    1d48:	bf 2e       	mov	r11, r31
    1d4a:	f0 2d       	mov	r31, r0
			set_control_voltage(&sustain_2_cv, MAX); //can't remember is EG1 for VCA or EG2????
    1d4c:	0f 2e       	mov	r0, r31
    1d4e:	fb ec       	ldi	r31, 0xCB	; 203
    1d50:	6f 2e       	mov	r6, r31
    1d52:	f1 e0       	ldi	r31, 0x01	; 1
    1d54:	7f 2e       	mov	r7, r31
    1d56:	f0 2d       	mov	r31, r0
    1d58:	e0 e0       	ldi	r30, 0x00	; 0
    1d5a:	f0 e0       	ldi	r31, 0x00	; 0
    1d5c:	fc 87       	std	Y+12, r31	; 0x0c
    1d5e:	eb 87       	std	Y+11, r30	; 0x0b
	//for reasons I don't understand yet, starting with OCR0A set to 0 results in a multi-second delay before first compare match ISR is called ***ACTUALLY, THIS MAY BE RELATED TO LEAVING Timer0 RUNNING. COULD TRY TO SET OCR0A TO 0 NOW and SEE IF IT WORKS
	TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt	
	period = 1; //only counting 1 period 
	for (int dac_bit = 13; dac_bit >= 0; dac_bit--) {
	
		init_cv |= (1<<dac_bit);
    1d60:	21 e0       	ldi	r18, 0x01	; 1
    1d62:	30 e0       	ldi	r19, 0x00	; 0
    1d64:	0b 80       	ldd	r0, Y+3	; 0x03
    1d66:	02 c0       	rjmp	.+4      	; 0x1d6c <set_vco_init_cv+0x142>
    1d68:	22 0f       	add	r18, r18
    1d6a:	33 1f       	adc	r19, r19
    1d6c:	0a 94       	dec	r0
    1d6e:	e2 f7       	brpl	.-8      	; 0x1d68 <set_vco_init_cv+0x13e>
    1d70:	3e 83       	std	Y+6, r19	; 0x06
    1d72:	2d 83       	std	Y+5, r18	; 0x05
    1d74:	8b 85       	ldd	r24, Y+11	; 0x0b
    1d76:	9c 85       	ldd	r25, Y+12	; 0x0c
    1d78:	82 2b       	or	r24, r18
    1d7a:	93 2b       	or	r25, r19
    1d7c:	9c 87       	std	Y+12, r25	; 0x0c
    1d7e:	8b 87       	std	Y+11, r24	; 0x0b
		
		set_control_voltage(vco_init_cv, init_cv);
    1d80:	c4 01       	movw	r24, r8
    1d82:	6b 85       	ldd	r22, Y+11	; 0x0b
    1d84:	7c 85       	ldd	r23, Y+12	; 0x0c
    1d86:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
		
		
		count_finished = FALSE;
    1d8a:	10 92 74 03 	sts	0x0374, r1
		period_counter = 0;
    1d8e:	10 92 77 03 	sts	0x0377, r1
		//TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
		//enable watchdog timer
		//WDTCR |= (1<<WDP2) | (1<<WDP1) | (1<<WDP0) | (1<<WDE)| (1<<WDCE);
		wdt_enable(WDTO_2S);
    1d92:	8f e0       	ldi	r24, 0x0F	; 15
    1d94:	e8 e1       	ldi	r30, 0x18	; 24
    1d96:	f0 e0       	ldi	r31, 0x00	; 0
    1d98:	0f b6       	in	r0, 0x3f	; 63
    1d9a:	f8 94       	cli
    1d9c:	a8 95       	wdr
    1d9e:	e0 93 60 00 	sts	0x0060, r30
    1da2:	0f be       	out	0x3f, r0	; 63
    1da4:	80 93 60 00 	sts	0x0060, r24
		while (count_finished == FALSE) { //need to have a watchdog timer here to escape while loop if it takes too long
    1da8:	80 91 74 03 	lds	r24, 0x0374
    1dac:	88 23       	and	r24, r24
    1dae:	89 f5       	brne	.+98     	; 0x1e12 <set_vco_init_cv+0x1e8>
			
			update_display(vco + 1, DEC);
    1db0:	c8 01       	movw	r24, r16
    1db2:	60 e0       	ldi	r22, 0x00	; 0
    1db4:	0e 94 2f 02 	call	0x45e	; 0x45e <update_display>
		
			set_control_voltage(vco_init_cv, init_cv);
    1db8:	c4 01       	movw	r24, r8
    1dba:	6b 85       	ldd	r22, Y+11	; 0x0b
    1dbc:	7c 85       	ldd	r23, Y+12	; 0x0c
    1dbe:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
			set_control_voltage(vco_pw_cv, MAX);
    1dc2:	c1 01       	movw	r24, r2
    1dc4:	6f ef       	ldi	r22, 0xFF	; 255
    1dc6:	7f e3       	ldi	r23, 0x3F	; 63
    1dc8:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
			set_control_voltage(&volume_cv, MIN);
    1dcc:	c7 01       	movw	r24, r14
    1dce:	60 e0       	ldi	r22, 0x00	; 0
    1dd0:	70 e0       	ldi	r23, 0x00	; 0
    1dd2:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
			set_control_voltage(&cutoff_cv, MAX);
    1dd6:	c6 01       	movw	r24, r12
    1dd8:	6f ef       	ldi	r22, 0xFF	; 255
    1dda:	7f e3       	ldi	r23, 0x3F	; 63
    1ddc:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
			set_control_voltage(&sustain_1_cv, MAX);
    1de0:	c5 01       	movw	r24, r10
    1de2:	6f ef       	ldi	r22, 0xFF	; 255
    1de4:	7f e3       	ldi	r23, 0x3F	; 63
    1de6:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
			set_control_voltage(&sustain_2_cv, MAX); //can't remember is EG1 for VCA or EG2????
    1dea:	c3 01       	movw	r24, r6
    1dec:	6f ef       	ldi	r22, 0xFF	; 255
    1dee:	7f e3       	ldi	r23, 0x3F	; 63
    1df0:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
			set_control_voltage(vco_mix_cv, MAX);
    1df4:	89 81       	ldd	r24, Y+1	; 0x01
    1df6:	9a 81       	ldd	r25, Y+2	; 0x02
    1df8:	6f ef       	ldi	r22, 0xFF	; 255
    1dfa:	7f e3       	ldi	r23, 0x3F	; 63
    1dfc:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
			set_control_voltage(vco_pitch_cv, 0);	
    1e00:	c2 01       	movw	r24, r4
    1e02:	60 e0       	ldi	r22, 0x00	; 0
    1e04:	70 e0       	ldi	r23, 0x00	; 0
    1e06:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
		period_counter = 0;
		//TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
		//enable watchdog timer
		//WDTCR |= (1<<WDP2) | (1<<WDP1) | (1<<WDP0) | (1<<WDE)| (1<<WDCE);
		wdt_enable(WDTO_2S);
		while (count_finished == FALSE) { //need to have a watchdog timer here to escape while loop if it takes too long
    1e0a:	80 91 74 03 	lds	r24, 0x0374
    1e0e:	88 23       	and	r24, r24
    1e10:	79 f2       	breq	.-98     	; 0x1db0 <set_vco_init_cv+0x186>
			
		}
		//turn off watchdog timer
		//WDTCR |= (1<<WDCE) | (1<<WDE);
		//WDTCR = 0x00;
		wdt_disable();
    1e12:	88 e1       	ldi	r24, 0x18	; 24
    1e14:	0f b6       	in	r0, 0x3f	; 63
    1e16:	f8 94       	cli
    1e18:	80 93 60 00 	sts	0x0060, r24
    1e1c:	10 92 60 00 	sts	0x0060, r1
    1e20:	0f be       	out	0x3f, r0	; 63
		//remember that as INIT_CV goes up, pitch goes down, so looking for osc_count >= reference_count instead of <= as is the case for normal oscillator tuning
		//similarily, OR no_overflow == FALSE *not* AND no_overflow == FALSE to clear bits that make initial pitch too low
		if ((osc_count > reference_count)  || (no_overflow == FALSE)) init_cv &= ~(1 << dac_bit);
    1e22:	80 91 72 03 	lds	r24, 0x0372
    1e26:	90 91 73 03 	lds	r25, 0x0373
    1e2a:	ef 81       	ldd	r30, Y+7	; 0x07
    1e2c:	f8 85       	ldd	r31, Y+8	; 0x08
    1e2e:	e8 17       	cp	r30, r24
    1e30:	f9 07       	cpc	r31, r25
    1e32:	20 f0       	brcs	.+8      	; 0x1e3c <set_vco_init_cv+0x212>
    1e34:	80 91 af 02 	lds	r24, 0x02AF
    1e38:	88 23       	and	r24, r24
    1e3a:	51 f4       	brne	.+20     	; 0x1e50 <set_vco_init_cv+0x226>
    1e3c:	8d 81       	ldd	r24, Y+5	; 0x05
    1e3e:	9e 81       	ldd	r25, Y+6	; 0x06
    1e40:	80 95       	com	r24
    1e42:	90 95       	com	r25
    1e44:	2b 85       	ldd	r18, Y+11	; 0x0b
    1e46:	3c 85       	ldd	r19, Y+12	; 0x0c
    1e48:	28 23       	and	r18, r24
    1e4a:	39 23       	and	r19, r25
    1e4c:	3c 87       	std	Y+12, r19	; 0x0c
    1e4e:	2b 87       	std	Y+11, r18	; 0x0b
		no_overflow = TRUE;
    1e50:	81 e0       	ldi	r24, 0x01	; 1
    1e52:	80 93 af 02 	sts	0x02AF, r24
	OCR0A = 1; //output compare register - set to number of periods to be counted. OCR0A needs to be set to (periods_to_be_counted - 1)
	//set OCR0A to 1 here means first ISR interrupt will occur after 2 periods, it is then set to 0 to count only single periods
	//for reasons I don't understand yet, starting with OCR0A set to 0 results in a multi-second delay before first compare match ISR is called ***ACTUALLY, THIS MAY BE RELATED TO LEAVING Timer0 RUNNING. COULD TRY TO SET OCR0A TO 0 NOW and SEE IF IT WORKS
	TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt	
	period = 1; //only counting 1 period 
	for (int dac_bit = 13; dac_bit >= 0; dac_bit--) {
    1e56:	8b 81       	ldd	r24, Y+3	; 0x03
    1e58:	9c 81       	ldd	r25, Y+4	; 0x04
    1e5a:	01 97       	sbiw	r24, 0x01	; 1
    1e5c:	9c 83       	std	Y+4, r25	; 0x04
    1e5e:	8b 83       	std	Y+3, r24	; 0x03
    1e60:	ef ef       	ldi	r30, 0xFF	; 255
    1e62:	8f 3f       	cpi	r24, 0xFF	; 255
    1e64:	9e 07       	cpc	r25, r30
    1e66:	09 f0       	breq	.+2      	; 0x1e6a <set_vco_init_cv+0x240>
    1e68:	7b cf       	rjmp	.-266    	; 0x1d60 <set_vco_init_cv+0x136>
    1e6a:	2b 85       	ldd	r18, Y+11	; 0x0b
    1e6c:	3c 85       	ldd	r19, Y+12	; 0x0c
    1e6e:	3e 83       	std	Y+6, r19	; 0x06
    1e70:	2d 83       	std	Y+5, r18	; 0x05
		no_overflow = TRUE;
		
	}		
	
	//none of these help with clicking when returning from this function and starting to read pots	
	set_control_voltage(&release_1_cv, MIN); //this will hopefully reduce popping after returning from initializing pitch CV
    1e72:	88 ec       	ldi	r24, 0xC8	; 200
    1e74:	91 e0       	ldi	r25, 0x01	; 1
    1e76:	60 e0       	ldi	r22, 0x00	; 0
    1e78:	70 e0       	ldi	r23, 0x00	; 0
    1e7a:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&release_2_cv, MIN);
    1e7e:	89 ec       	ldi	r24, 0xC9	; 201
    1e80:	91 e0       	ldi	r25, 0x01	; 1
    1e82:	60 e0       	ldi	r22, 0x00	; 0
    1e84:	70 e0       	ldi	r23, 0x00	; 0
    1e86:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&cutoff_cv, MIN);
    1e8a:	84 ed       	ldi	r24, 0xD4	; 212
    1e8c:	91 e0       	ldi	r25, 0x01	; 1
    1e8e:	60 e0       	ldi	r22, 0x00	; 0
    1e90:	70 e0       	ldi	r23, 0x00	; 0
    1e92:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&volume_cv, MIN);
    1e96:	88 ed       	ldi	r24, 0xD8	; 216
    1e98:	91 e0       	ldi	r25, 0x01	; 1
    1e9a:	60 e0       	ldi	r22, 0x00	; 0
    1e9c:	70 e0       	ldi	r23, 0x00	; 0
    1e9e:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
		
	PORTF &= ~(1<<GATE); //turn gate off
    1ea2:	89 98       	cbi	0x11, 1	; 17
	
	TIMSK0 &= ~(1<<OCIE0A); //turn off compare match A interrupt
    1ea4:	ee e6       	ldi	r30, 0x6E	; 110
    1ea6:	f0 e0       	ldi	r31, 0x00	; 0
    1ea8:	80 81       	ld	r24, Z
    1eaa:	8d 7f       	andi	r24, 0xFD	; 253
    1eac:	80 83       	st	Z, r24
	TCCR0A = 0; //turn off timer0 period timer
    1eae:	14 bc       	out	0x24, r1	; 36
	//} else {
		//
		//eeprom_update_word(&vco2_init_cv_eeprom, init_cv);
	//}				
		
	eeprom_update_word(eeprom_addr, init_cv);
    1eb0:	89 85       	ldd	r24, Y+9	; 0x09
    1eb2:	9a 85       	ldd	r25, Y+10	; 0x0a
    1eb4:	6d 81       	ldd	r22, Y+5	; 0x05
    1eb6:	7e 81       	ldd	r23, Y+6	; 0x06
    1eb8:	0e 94 54 1b 	call	0x36a8	; 0x36a8 <__eeupd_word_m6450a>
	//value_to_display = eeprom_read_word(&vco1_init_cv_eeprom);	

	
	return init_cv;
	
}
    1ebc:	8d 81       	ldd	r24, Y+5	; 0x05
    1ebe:	9e 81       	ldd	r25, Y+6	; 0x06
    1ec0:	2c 96       	adiw	r28, 0x0c	; 12
    1ec2:	0f b6       	in	r0, 0x3f	; 63
    1ec4:	f8 94       	cli
    1ec6:	de bf       	out	0x3e, r29	; 62
    1ec8:	0f be       	out	0x3f, r0	; 63
    1eca:	cd bf       	out	0x3d, r28	; 61
    1ecc:	df 91       	pop	r29
    1ece:	cf 91       	pop	r28
    1ed0:	1f 91       	pop	r17
    1ed2:	0f 91       	pop	r16
    1ed4:	ff 90       	pop	r15
    1ed6:	ef 90       	pop	r14
    1ed8:	df 90       	pop	r13
    1eda:	cf 90       	pop	r12
    1edc:	bf 90       	pop	r11
    1ede:	af 90       	pop	r10
    1ee0:	9f 90       	pop	r9
    1ee2:	8f 90       	pop	r8
    1ee4:	7f 90       	pop	r7
    1ee6:	6f 90       	pop	r6
    1ee8:	5f 90       	pop	r5
    1eea:	4f 90       	pop	r4
    1eec:	3f 90       	pop	r3
    1eee:	2f 90       	pop	r2
    1ef0:	08 95       	ret

00001ef2 <tune_8ths>:



void tune_8ths(uint8_t vco) {
    1ef2:	2f 92       	push	r2
    1ef4:	3f 92       	push	r3
    1ef6:	4f 92       	push	r4
    1ef8:	5f 92       	push	r5
    1efa:	6f 92       	push	r6
    1efc:	7f 92       	push	r7
    1efe:	8f 92       	push	r8
    1f00:	9f 92       	push	r9
    1f02:	af 92       	push	r10
    1f04:	bf 92       	push	r11
    1f06:	cf 92       	push	r12
    1f08:	df 92       	push	r13
    1f0a:	ef 92       	push	r14
    1f0c:	ff 92       	push	r15
    1f0e:	0f 93       	push	r16
    1f10:	1f 93       	push	r17
    1f12:	cf 93       	push	r28
    1f14:	df 93       	push	r29
    1f16:	cd b7       	in	r28, 0x3d	; 61
    1f18:	de b7       	in	r29, 0x3e	; 62
    1f1a:	c0 54       	subi	r28, 0x40	; 64
    1f1c:	d0 40       	sbci	r29, 0x00	; 0
    1f1e:	0f b6       	in	r0, 0x3f	; 63
    1f20:	f8 94       	cli
    1f22:	de bf       	out	0x3e, r29	; 62
    1f24:	0f be       	out	0x3f, r0	; 63
    1f26:	cd bf       	out	0x3d, r28	; 61
    1f28:	08 2f       	mov	r16, r24
		uint8_t period;
		uint16_t count;
	
		};

	struct pitch_reference reference[16] = 
    1f2a:	de 01       	movw	r26, r28
    1f2c:	11 96       	adiw	r26, 0x01	; 1
    1f2e:	e0 e3       	ldi	r30, 0x30	; 48
    1f30:	f2 e0       	ldi	r31, 0x02	; 2
    1f32:	80 e3       	ldi	r24, 0x30	; 48
    1f34:	01 90       	ld	r0, Z+
    1f36:	0d 92       	st	X+, r0
    1f38:	81 50       	subi	r24, 0x01	; 1
    1f3a:	e1 f7       	brne	.-8      	; 0x1f34 <tune_8ths+0x42>
	
		//to do:
		//disable UART so MIDI data doesn't interrupt tuning
	
		//setup control voltages	
		initialize_voice_for_tuning();
    1f3c:	0e 94 96 0d 	call	0x1b2c	; 0x1b2c <initialize_voice_for_tuning>
		struct control_voltage *vco_init_cv;
		struct control_voltage *vco_mix_cv;
		struct control_voltage *vco_pw_cv;
		struct control_voltage *vco_pitch_cv;	

		if (vco == VCO1) { //set up parameters for VCO1 tuning
    1f40:	0f 30       	cpi	r16, 0x0F	; 15
    1f42:	11 f5       	brne	.+68     	; 0x1f88 <tune_8ths+0x96>
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
			vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 1; //allows second digit to display VCO being tuned
			init_cv = vco1_init_cv;
    1f44:	40 90 6f 03 	lds	r4, 0x036F
    1f48:	50 90 70 03 	lds	r5, 0x0370
			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
			vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
    1f4c:	0f 2e       	mov	r0, r31
    1f4e:	f6 ee       	ldi	r31, 0xE6	; 230
    1f50:	8f 2e       	mov	r8, r31
    1f52:	f1 e0       	ldi	r31, 0x01	; 1
    1f54:	9f 2e       	mov	r9, r31
    1f56:	f0 2d       	mov	r31, r0

			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
    1f58:	0f 2e       	mov	r0, r31
    1f5a:	fe ed       	ldi	r31, 0xDE	; 222
    1f5c:	2f 2e       	mov	r2, r31
    1f5e:	f1 e0       	ldi	r31, 0x01	; 1
    1f60:	3f 2e       	mov	r3, r31
    1f62:	f0 2d       	mov	r31, r0
		if (vco == VCO1) { //set up parameters for VCO1 tuning

			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
    1f64:	23 ee       	ldi	r18, 0xE3	; 227
    1f66:	31 e0       	ldi	r19, 0x01	; 1
    1f68:	3a ab       	sts	0x5a, r19
    1f6a:	29 ab       	sts	0x59, r18

		if (vco == VCO1) { //set up parameters for VCO1 tuning

			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
    1f6c:	0f 2e       	mov	r0, r31
    1f6e:	fc ed       	ldi	r31, 0xDC	; 220
    1f70:	6f 2e       	mov	r6, r31
    1f72:	f1 e0       	ldi	r31, 0x01	; 1
    1f74:	7f 2e       	mov	r7, r31
    1f76:	f0 2d       	mov	r31, r0
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
			vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 1; //allows second digit to display VCO being tuned
			init_cv = vco1_init_cv;
			vco_pitch_table = vco1_pitch_table;
    1f78:	0b e4       	ldi	r16, 0x4B	; 75
    1f7a:	13 e0       	ldi	r17, 0x03	; 3
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
			vco_init_cv = &tune_cv; //VCO1 init CV currently mapped to tune_cv - need to rename tune_cv to vco1_init_cv
			vco_mix_cv = &vco1_mix_cv;
			vco_pw_cv = &vco1_pw_cv;
			vco_pitch_cv = &vco1_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 1; //allows second digit to display VCO being tuned
    1f7c:	cc 24       	eor	r12, r12
    1f7e:	c3 94       	inc	r12
		struct control_voltage *vco_pitch_cv;	

		if (vco == VCO1) { //set up parameters for VCO1 tuning

			//turn on VCO1 SAW, all others off
			switch_byte = (1<<VCO1_PULSE_LATCH_BIT);
    1f80:	ee 24       	eor	r14, r14
    1f82:	68 94       	set
    1f84:	e1 f8       	bld	r14, 1
    1f86:	22 c0       	rjmp	.+68     	; 0x1fcc <tune_8ths+0xda>
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
			vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 2; //allows second digit to display VCO being tuned
			init_cv = vco2_init_cv;
    1f88:	40 90 6d 03 	lds	r4, 0x036D
    1f8c:	50 90 6e 03 	lds	r5, 0x036E
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
			vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
    1f90:	0f 2e       	mov	r0, r31
    1f92:	f5 ee       	ldi	r31, 0xE5	; 229
    1f94:	8f 2e       	mov	r8, r31
    1f96:	f1 e0       	ldi	r31, 0x01	; 1
    1f98:	9f 2e       	mov	r9, r31
    1f9a:	f0 2d       	mov	r31, r0
		
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
    1f9c:	0f 2e       	mov	r0, r31
    1f9e:	f7 ed       	ldi	r31, 0xD7	; 215
    1fa0:	2f 2e       	mov	r2, r31
    1fa2:	f1 e0       	ldi	r31, 0x01	; 1
    1fa4:	3f 2e       	mov	r3, r31
    1fa6:	f0 2d       	mov	r31, r0
		} else { //set up parameters for VCO2 tuning
		
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
    1fa8:	44 ee       	ldi	r20, 0xE4	; 228
    1faa:	51 e0       	ldi	r21, 0x01	; 1
    1fac:	5a ab       	sts	0x5a, r21
    1fae:	49 ab       	sts	0x59, r20
		
		} else { //set up parameters for VCO2 tuning
		
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
    1fb0:	0f 2e       	mov	r0, r31
    1fb2:	fd ed       	ldi	r31, 0xDD	; 221
    1fb4:	6f 2e       	mov	r6, r31
    1fb6:	f1 e0       	ldi	r31, 0x01	; 1
    1fb8:	7f 2e       	mov	r7, r31
    1fba:	f0 2d       	mov	r31, r0
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
			vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 2; //allows second digit to display VCO being tuned
			init_cv = vco2_init_cv;
			vco_pitch_table = vco2_pitch_table;
    1fbc:	09 e2       	ldi	r16, 0x29	; 41
    1fbe:	13 e0       	ldi	r17, 0x03	; 3
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
			vco_init_cv = &fine_cv;	//VCO2 initi CV currently mapped to fine_cv - need to rename fine_cv to vco2_init_cv
			vco_mix_cv = &vco2_mix_cv;
			vco_pw_cv = &vco2_pw_cv;
			vco_pitch_cv = &vco2_pitch_cv; //need to keep this 0V during initial pitch setting
			vco_number = 2; //allows second digit to display VCO being tuned
    1fc0:	cc 24       	eor	r12, r12
    1fc2:	68 94       	set
    1fc4:	c1 f8       	bld	r12, 1
		
		
		} else { //set up parameters for VCO2 tuning
		
			//turn on VCO2 SAW, all others off
			switch_byte = (1<<VCO2_PULSE_LATCH_BIT);
    1fc6:	ee 24       	eor	r14, r14
    1fc8:	68 94       	set
    1fca:	e5 f8       	bld	r14, 5
		}
	


		//set VCO init offset CV
		set_control_voltage(vco_init_cv, init_cv);
    1fcc:	c3 01       	movw	r24, r6
    1fce:	b2 01       	movw	r22, r4
    1fd0:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
		
	
		//latch switch data
		DATA_BUS = switch_byte;
    1fd4:	e2 b8       	out	0x02, r14	; 2
		VCO_SW_LATCH_PORT |= (1<<VCO_SW_LATCH);
    1fd6:	ed ed       	ldi	r30, 0xDD	; 221
    1fd8:	f0 e0       	ldi	r31, 0x00	; 0
    1fda:	80 81       	ld	r24, Z
    1fdc:	80 64       	ori	r24, 0x40	; 64
    1fde:	80 83       	st	Z, r24
		//_delay_us(1); //why is this delay here????
		VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    1fe0:	80 81       	ld	r24, Z
    1fe2:	8f 7b       	andi	r24, 0xBF	; 191
    1fe4:	80 83       	st	Z, r24
		DATA_BUS = 0;
    1fe6:	12 b8       	out	0x02, r1	; 2

		PORTF |= (1<<GATE); //turn gate on
    1fe8:	89 9a       	sbi	0x11, 1	; 17
			
		period = 1; //need to initialize to minimum period number here
    1fea:	81 e0       	ldi	r24, 0x01	; 1
    1fec:	80 93 76 03 	sts	0x0376, r24
		
		compare_match_counter = 0;	
    1ff0:	10 92 71 03 	sts	0x0371, r1
			
				//enable watchdog timer
				wdt_enable(WDTO_2S);
				while (count_finished == FALSE) {
					//update_display(vco_number + period + (compare_match_counter>>4)*100, DEC);
					update_display(vco_number*100 + period, DEC);//
    1ff4:	8c 2d       	mov	r24, r12
    1ff6:	90 e0       	ldi	r25, 0x00	; 0
    1ff8:	24 e6       	ldi	r18, 0x64	; 100
    1ffa:	30 e0       	ldi	r19, 0x00	; 0
    1ffc:	82 9f       	mul	r24, r18
    1ffe:	d0 01       	movw	r26, r0
    2000:	83 9f       	mul	r24, r19
    2002:	b0 0d       	add	r27, r0
    2004:	92 9f       	mul	r25, r18
    2006:	b0 0d       	add	r27, r0
    2008:	11 24       	eor	r1, r1
    200a:	bc ab       	sts	0x5c, r27
    200c:	ab ab       	sts	0x5b, r26
    200e:	fe 01       	movw	r30, r28
    2010:	31 96       	adiw	r30, 0x01	; 1
    2012:	fc af       	sts	0x7c, r31
    2014:	eb af       	sts	0x7b, r30
	
}



void tune_8ths(uint8_t vco) {
    2016:	98 01       	movw	r18, r16
    2018:	2e 5f       	subi	r18, 0xFE	; 254
    201a:	3f 4f       	sbci	r19, 0xFF	; 255
    201c:	21 96       	adiw	r28, 0x01	; 1
    201e:	3f af       	sts	0x7f, r19
    2020:	2e af       	sts	0x7e, r18
    2022:	21 97       	sbiw	r28, 0x01	; 1
		PORTF |= (1<<GATE); //turn gate on
			
		period = 1; //need to initialize to minimum period number here
		
		compare_match_counter = 0;	
		for (int note_number = 0; note_number <= 15; note_number++) 
    2024:	1e ae       	sts	0xbe, r17
    2026:	1d ae       	sts	0xbd, r17
					//not sure what's really necessary here - definitely pitch and init_cv, but what else?
					set_control_voltage(vco_init_cv, init_cv);
					set_control_voltage(vco_pitch_cv, osc_pitch_cv);
					//set_control_voltage(&pitch_lfo_cv, MIN);
					//set_control_voltage(vco_pw_cv, MAX); //not necessary as SAW is being used to clock comparator
					set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
    2028:	0f 2e       	mov	r0, r31
    202a:	f8 ed       	ldi	r31, 0xD8	; 216
    202c:	ef 2e       	mov	r14, r31
    202e:	f1 e0       	ldi	r31, 0x01	; 1
    2030:	ff 2e       	mov	r15, r31
    2032:	f0 2d       	mov	r31, r0
					set_control_voltage(&cutoff_cv, MAX);
    2034:	0f 2e       	mov	r0, r31
    2036:	f4 ed       	ldi	r31, 0xD4	; 212
    2038:	cf 2e       	mov	r12, r31
    203a:	f1 e0       	ldi	r31, 0x01	; 1
    203c:	df 2e       	mov	r13, r31
    203e:	f0 2d       	mov	r31, r0
					//set_control_voltage(&res_cv, MIN);
					set_control_voltage(&sustain_1_cv, MAX);
    2040:	0f 2e       	mov	r0, r31
    2042:	fa ec       	ldi	r31, 0xCA	; 202
    2044:	af 2e       	mov	r10, r31
    2046:	f1 e0       	ldi	r31, 0x01	; 1
    2048:	bf 2e       	mov	r11, r31
    204a:	f0 2d       	mov	r31, r0
	
}



void tune_8ths(uint8_t vco) {
    204c:	eb ad       	sts	0x6b, r30
    204e:	fc ad       	sts	0x6c, r31
		period = 1; //need to initialize to minimum period number here
		
		compare_match_counter = 0;	
		for (int note_number = 0; note_number <= 15; note_number++) 
			{
			period = reference[note_number].period;
    2050:	80 81       	ld	r24, Z
    2052:	80 93 76 03 	sts	0x0376, r24
			//period timer needs to be initialized here and turned off after each note's SAR to prevent glitching caused by leaving timer0 running
			TCCR0A |= (1<<CS02) | (1<<CS01) | (1<<CS00) | (1<<WGM01); //clocked by external T0 pin, rising edge + clear timer on compare match
    2056:	84 b5       	in	r24, 0x24	; 36
    2058:	8f 60       	ori	r24, 0x0F	; 15
    205a:	84 bd       	out	0x24, r24	; 36
			OCR0A = 1; //output compare register - set to number of periods to be counted. OCR0A needs to be set to (periods_to_be_counted - 1) ***COULD PROBABLY CHANGE THIS TO 0 NOW*** - NOPE. NEEDS TO BE 1!!!
    205c:	81 e0       	ldi	r24, 0x01	; 1
    205e:	87 bd       	out	0x27, r24	; 39
			//TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
			TCNT0 = 0; //make sure timer/counter0 is actually 0. 
    2060:	16 bc       	out	0x26, r1	; 38
			
			if (note_number <= 2) {
    2062:	4d ad       	sts	0x6d, r20
    2064:	5e ad       	sts	0x6e, r21
    2066:	43 30       	cpi	r20, 0x03	; 3
    2068:	51 05       	cpc	r21, r1
    206a:	24 f4       	brge	.+8      	; 0x2074 <tune_8ths+0x182>
	
				//set timer/counter1 to /64 0.3125 MHz
				timer1_clock = (1<<CS11) | (1<<CS10);
    206c:	83 e0       	ldi	r24, 0x03	; 3
    206e:	80 93 75 03 	sts	0x0375, r24
    2072:	03 c0       	rjmp	.+6      	; 0x207a <tune_8ths+0x188>
	
			} else {
	
				//set timer/counter1 to /8 2.5 MHz
				timer1_clock = (1<<CS11);
    2074:	82 e0       	ldi	r24, 0x02	; 2
    2076:	80 93 75 03 	sts	0x0375, r24
	
			}
			//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
			uint16_t reference_count = reference[note_number].count;
    207a:	81 81       	ldd	r24, Z+1	; 0x01
    207c:	92 81       	ldd	r25, Z+2	; 0x02
    207e:	9a af       	sts	0x7a, r25
    2080:	89 af       	sts	0x79, r24
			uint16_t osc_pitch_cv = 0;
			for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
    2082:	ad e0       	ldi	r26, 0x0D	; 13
    2084:	b0 e0       	ldi	r27, 0x00	; 0
    2086:	be ab       	sts	0x5e, r27
    2088:	ad ab       	sts	0x5d, r26
				timer1_clock = (1<<CS11);
	
			}
			//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
			uint16_t reference_count = reference[note_number].count;
			uint16_t osc_pitch_cv = 0;
    208a:	00 e0       	ldi	r16, 0x00	; 0
    208c:	10 e0       	ldi	r17, 0x00	; 0
			for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
				
				osc_pitch_cv |= (1<<dac_bit);
    208e:	e1 e0       	ldi	r30, 0x01	; 1
    2090:	f0 e0       	ldi	r31, 0x00	; 0
    2092:	0d a8       	sts	0x8d, r16
    2094:	02 c0       	rjmp	.+4      	; 0x209a <tune_8ths+0x1a8>
    2096:	ee 0f       	add	r30, r30
    2098:	ff 1f       	adc	r31, r31
    209a:	0a 94       	dec	r0
    209c:	e2 f7       	brpl	.-8      	; 0x2096 <tune_8ths+0x1a4>
    209e:	f8 af       	sts	0x78, r31
    20a0:	ef ab       	sts	0x5f, r30
    20a2:	0e 2b       	or	r16, r30
    20a4:	1f 2b       	or	r17, r31
				TIMSK0 &= ~(1<<OCIE0A); //turn off output compare match A interrupt
    20a6:	ae e6       	ldi	r26, 0x6E	; 110
    20a8:	b0 e0       	ldi	r27, 0x00	; 0
    20aa:	8c 91       	ld	r24, X
    20ac:	8d 7f       	andi	r24, 0xFD	; 253
    20ae:	8c 93       	st	X, r24
				set_control_voltage(vco_pitch_cv, osc_pitch_cv);
    20b0:	c4 01       	movw	r24, r8
    20b2:	b8 01       	movw	r22, r16
    20b4:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
    20b8:	e3 ef       	ldi	r30, 0xF3	; 243
    20ba:	f1 e0       	ldi	r31, 0x01	; 1
    20bc:	31 97       	sbiw	r30, 0x01	; 1
    20be:	f1 f7       	brne	.-4      	; 0x20bc <tune_8ths+0x1ca>
    20c0:	00 c0       	rjmp	.+0      	; 0x20c2 <tune_8ths+0x1d0>
    20c2:	00 00       	nop
				_delay_ms(2); //add delay here to allow pitch to slew to its final value
				TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
    20c4:	ae e6       	ldi	r26, 0x6E	; 110
    20c6:	b0 e0       	ldi	r27, 0x00	; 0
    20c8:	8c 91       	ld	r24, X
    20ca:	82 60       	ori	r24, 0x02	; 2
    20cc:	8c 93       	st	X, r24
				//TCNT0 = 0;
				
				count_finished = FALSE;
    20ce:	10 92 74 03 	sts	0x0374, r1
				period_counter = 0;
    20d2:	10 92 77 03 	sts	0x0377, r1
			
				//enable watchdog timer
				wdt_enable(WDTO_2S);
    20d6:	e8 e1       	ldi	r30, 0x18	; 24
    20d8:	f0 e0       	ldi	r31, 0x00	; 0
    20da:	2f e0       	ldi	r18, 0x0F	; 15
    20dc:	0f b6       	in	r0, 0x3f	; 63
    20de:	f8 94       	cli
    20e0:	a8 95       	wdr
    20e2:	e0 93 60 00 	sts	0x0060, r30
    20e6:	0f be       	out	0x3f, r0	; 63
    20e8:	20 93 60 00 	sts	0x0060, r18
				while (count_finished == FALSE) {
    20ec:	80 91 74 03 	lds	r24, 0x0374
    20f0:	88 23       	and	r24, r24
    20f2:	81 f5       	brne	.+96     	; 0x2154 <tune_8ths+0x262>
					//update_display(vco_number + period + (compare_match_counter>>4)*100, DEC);
					update_display(vco_number*100 + period, DEC);//
    20f4:	80 91 76 03 	lds	r24, 0x0376
    20f8:	4b a9       	sts	0x4b, r20
    20fa:	5c a9       	sts	0x4c, r21
    20fc:	48 0f       	add	r20, r24
    20fe:	51 1d       	adc	r21, r1
    2100:	ca 01       	movw	r24, r20
    2102:	60 e0       	ldi	r22, 0x00	; 0
    2104:	0e 94 2f 02 	call	0x45e	; 0x45e <update_display>
					//update_display(value_to_display, DEC);	
					//need to have a watchdog timer here to escape while loop if it takes too long
				
					//not sure what's really necessary here - definitely pitch and init_cv, but what else?
					set_control_voltage(vco_init_cv, init_cv);
    2108:	c3 01       	movw	r24, r6
    210a:	b2 01       	movw	r22, r4
    210c:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
					set_control_voltage(vco_pitch_cv, osc_pitch_cv);
    2110:	c4 01       	movw	r24, r8
    2112:	b8 01       	movw	r22, r16
    2114:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
					//set_control_voltage(&pitch_lfo_cv, MIN);
					//set_control_voltage(vco_pw_cv, MAX); //not necessary as SAW is being used to clock comparator
					set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
    2118:	c7 01       	movw	r24, r14
    211a:	60 e0       	ldi	r22, 0x00	; 0
    211c:	70 e0       	ldi	r23, 0x00	; 0
    211e:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
					set_control_voltage(&cutoff_cv, MAX);
    2122:	c6 01       	movw	r24, r12
    2124:	6f ef       	ldi	r22, 0xFF	; 255
    2126:	7f e3       	ldi	r23, 0x3F	; 63
    2128:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
					//set_control_voltage(&res_cv, MIN);
					set_control_voltage(&sustain_1_cv, MAX);
    212c:	c5 01       	movw	r24, r10
    212e:	6f ef       	ldi	r22, 0xFF	; 255
    2130:	7f e3       	ldi	r23, 0x3F	; 63
    2132:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
					//set_control_voltage(&attack_1_cv, MIN); //keep attack at minimum
					set_control_voltage(vco_pw_cv, 8192);
    2136:	c1 01       	movw	r24, r2
    2138:	60 e0       	ldi	r22, 0x00	; 0
    213a:	70 e2       	ldi	r23, 0x20	; 32
    213c:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
					set_control_voltage(vco_mix_cv, MAX);
    2140:	89 a9       	sts	0x49, r24
    2142:	9a a9       	sts	0x4a, r25
    2144:	6f ef       	ldi	r22, 0xFF	; 255
    2146:	7f e3       	ldi	r23, 0x3F	; 63
    2148:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
				count_finished = FALSE;
				period_counter = 0;
			
				//enable watchdog timer
				wdt_enable(WDTO_2S);
				while (count_finished == FALSE) {
    214c:	80 91 74 03 	lds	r24, 0x0374
    2150:	88 23       	and	r24, r24
    2152:	81 f2       	breq	.-96     	; 0x20f4 <tune_8ths+0x202>

			
			
				}							
				//turn off watchdog timer
				wdt_disable();
    2154:	58 e1       	ldi	r21, 0x18	; 24
    2156:	0f b6       	in	r0, 0x3f	; 63
    2158:	f8 94       	cli
    215a:	50 93 60 00 	sts	0x0060, r21
    215e:	10 92 60 00 	sts	0x0060, r1
    2162:	0f be       	out	0x3f, r0	; 63
				//Omar changed this from <= to < which makes sense. <= was an error because if it's equal you don't want to clear the bit
				if ((osc_count <= reference_count) && (no_overflow == TRUE)) osc_pitch_cv &= ~(1<<dac_bit);
    2164:	80 91 72 03 	lds	r24, 0x0372
    2168:	90 91 73 03 	lds	r25, 0x0373
    216c:	a9 ad       	sts	0x69, r26
    216e:	ba ad       	sts	0x6a, r27
    2170:	a8 17       	cp	r26, r24
    2172:	b9 07       	cpc	r27, r25
    2174:	50 f0       	brcs	.+20     	; 0x218a <tune_8ths+0x298>
    2176:	80 91 af 02 	lds	r24, 0x02AF
    217a:	81 30       	cpi	r24, 0x01	; 1
    217c:	31 f4       	brne	.+12     	; 0x218a <tune_8ths+0x298>
    217e:	8f a9       	sts	0x4f, r24
    2180:	98 ad       	sts	0x68, r25
    2182:	80 95       	com	r24
    2184:	90 95       	com	r25
    2186:	08 23       	and	r16, r24
    2188:	19 23       	and	r17, r25
				
				if (osc_count == reference_count && no_overflow == TRUE) {
    218a:	80 91 72 03 	lds	r24, 0x0372
    218e:	90 91 73 03 	lds	r25, 0x0373
    2192:	e9 ad       	sts	0x69, r30
    2194:	fa ad       	sts	0x6a, r31
    2196:	8e 17       	cp	r24, r30
    2198:	9f 07       	cpc	r25, r31
    219a:	21 f4       	brne	.+8      	; 0x21a4 <tune_8ths+0x2b2>
    219c:	80 91 af 02 	lds	r24, 0x02AF
    21a0:	81 30       	cpi	r24, 0x01	; 1
    21a2:	71 f0       	breq	.+28     	; 0x21c0 <tune_8ths+0x2ce>
					break;	//if you hit the reference count then get out of here		
				}				
				no_overflow = TRUE;
    21a4:	f1 e0       	ldi	r31, 0x01	; 1
    21a6:	f0 93 af 02 	sts	0x02AF, r31
	
			}
			//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
			uint16_t reference_count = reference[note_number].count;
			uint16_t osc_pitch_cv = 0;
			for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
    21aa:	2d a9       	sts	0x4d, r18
    21ac:	3e a9       	sts	0x4e, r19
    21ae:	21 50       	subi	r18, 0x01	; 1
    21b0:	30 40       	sbci	r19, 0x00	; 0
    21b2:	3e ab       	sts	0x5e, r19
    21b4:	2d ab       	sts	0x5d, r18
    21b6:	4f ef       	ldi	r20, 0xFF	; 255
    21b8:	2f 3f       	cpi	r18, 0xFF	; 255
    21ba:	34 07       	cpc	r19, r20
    21bc:	09 f0       	breq	.+2      	; 0x21c0 <tune_8ths+0x2ce>
    21be:	67 cf       	rjmp	.-306    	; 0x208e <tune_8ths+0x19c>
			
			
			}
		
			//vco_pitch_table[octave*12 + note_number] = osc_pitch_cv; //store the note control voltage in the pitch table
			*(vco_pitch_table + (note_number+1)) = osc_pitch_cv;		
    21c0:	21 96       	adiw	r28, 0x01	; 1
    21c2:	ae ad       	sts	0x6e, r26
    21c4:	bf ad       	sts	0x6f, r27
    21c6:	21 97       	sbiw	r28, 0x01	; 1
    21c8:	0d 93       	st	X+, r16
    21ca:	1d 93       	st	X+, r17
    21cc:	21 96       	adiw	r28, 0x01	; 1
    21ce:	bf af       	sts	0x7f, r27
    21d0:	ae af       	sts	0x7e, r26
    21d2:	21 97       	sbiw	r28, 0x01	; 1
			
			//need to turn timer off here. This seems to have stopped periodic glitching of first note of first VCO tuned.
			TIMSK0 &= ~(1<<OCIE0A); //turn off timer0 compare match A interrupt
    21d4:	ee e6       	ldi	r30, 0x6E	; 110
    21d6:	f0 e0       	ldi	r31, 0x00	; 0
    21d8:	80 81       	ld	r24, Z
    21da:	8d 7f       	andi	r24, 0xFD	; 253
    21dc:	80 83       	st	Z, r24
			TCCR0A = 0; //turn off timer0
    21de:	14 bc       	out	0x24, r1	; 36
		PORTF |= (1<<GATE); //turn gate on
			
		period = 1; //need to initialize to minimum period number here
		
		compare_match_counter = 0;	
		for (int note_number = 0; note_number <= 15; note_number++) 
    21e0:	2d ad       	sts	0x6d, r18
    21e2:	3e ad       	sts	0x6e, r19
    21e4:	2f 5f       	subi	r18, 0xFF	; 255
    21e6:	3f 4f       	sbci	r19, 0xFF	; 255
    21e8:	3e af       	sts	0x7e, r19
    21ea:	2d af       	sts	0x7d, r18
    21ec:	4b ad       	sts	0x6b, r20
    21ee:	5c ad       	sts	0x6c, r21
    21f0:	4d 5f       	subi	r20, 0xFD	; 253
    21f2:	5f 4f       	sbci	r21, 0xFF	; 255
    21f4:	5c af       	sts	0x7c, r21
    21f6:	4b af       	sts	0x7b, r20
    21f8:	20 31       	cpi	r18, 0x10	; 16
    21fa:	31 05       	cpc	r19, r1
    21fc:	09 f0       	breq	.+2      	; 0x2200 <tune_8ths+0x30e>
    21fe:	26 cf       	rjmp	.-436    	; 0x204c <tune_8ths+0x15a>
		}
	
		
		//eeprom_update_block((const void*)vco_pitch_table, (void*)vco_pitch_table_eeprom, sizeof(vco_pitch_table));
		
		PORTF &= ~(1<<GATE); //turn gate off
    2200:	89 98       	cbi	0x11, 1	; 17
		
		
	
	
	}
    2202:	c0 5c       	subi	r28, 0xC0	; 192
    2204:	df 4f       	sbci	r29, 0xFF	; 255
    2206:	0f b6       	in	r0, 0x3f	; 63
    2208:	f8 94       	cli
    220a:	de bf       	out	0x3e, r29	; 62
    220c:	0f be       	out	0x3f, r0	; 63
    220e:	cd bf       	out	0x3d, r28	; 61
    2210:	df 91       	pop	r29
    2212:	cf 91       	pop	r28
    2214:	1f 91       	pop	r17
    2216:	0f 91       	pop	r16
    2218:	ff 90       	pop	r15
    221a:	ef 90       	pop	r14
    221c:	df 90       	pop	r13
    221e:	cf 90       	pop	r12
    2220:	bf 90       	pop	r11
    2222:	af 90       	pop	r10
    2224:	9f 90       	pop	r9
    2226:	8f 90       	pop	r8
    2228:	7f 90       	pop	r7
    222a:	6f 90       	pop	r6
    222c:	5f 90       	pop	r5
    222e:	4f 90       	pop	r4
    2230:	3f 90       	pop	r3
    2232:	2f 90       	pop	r2
    2234:	08 95       	ret

00002236 <tune_filter>:
	
void tune_filter(void) {
    2236:	2f 92       	push	r2
    2238:	3f 92       	push	r3
    223a:	4f 92       	push	r4
    223c:	5f 92       	push	r5
    223e:	6f 92       	push	r6
    2240:	7f 92       	push	r7
    2242:	8f 92       	push	r8
    2244:	9f 92       	push	r9
    2246:	af 92       	push	r10
    2248:	bf 92       	push	r11
    224a:	cf 92       	push	r12
    224c:	df 92       	push	r13
    224e:	ef 92       	push	r14
    2250:	ff 92       	push	r15
    2252:	0f 93       	push	r16
    2254:	1f 93       	push	r17
    2256:	cf 93       	push	r28
    2258:	df 93       	push	r29
    225a:	cd b7       	in	r28, 0x3d	; 61
    225c:	de b7       	in	r29, 0x3e	; 62
    225e:	e9 97       	sbiw	r28, 0x39	; 57
    2260:	0f b6       	in	r0, 0x3f	; 63
    2262:	f8 94       	cli
    2264:	de bf       	out	0x3e, r29	; 62
    2266:	0f be       	out	0x3f, r0	; 63
    2268:	cd bf       	out	0x3d, r28	; 61
		uint8_t period;
		uint16_t count;
		
	};

	struct pitch_reference reference[15] =
    226a:	de 01       	movw	r26, r28
    226c:	11 96       	adiw	r26, 0x01	; 1
    226e:	e0 e6       	ldi	r30, 0x60	; 96
    2270:	f2 e0       	ldi	r31, 0x02	; 2
    2272:	8d e2       	ldi	r24, 0x2D	; 45
    2274:	01 90       	ld	r0, Z+
    2276:	0d 92       	st	X+, r0
    2278:	81 50       	subi	r24, 0x01	; 1
    227a:	e1 f7       	brne	.-8      	; 0x2274 <tune_filter+0x3e>
		
	};

	
	//initialize CVs for filter tuning
	set_control_voltage(&volume_cv, MIN); //turn volume all the way down
    227c:	88 ed       	ldi	r24, 0xD8	; 216
    227e:	91 e0       	ldi	r25, 0x01	; 1
    2280:	60 e0       	ldi	r22, 0x00	; 0
    2282:	70 e0       	ldi	r23, 0x00	; 0
    2284:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	//turn off all pitch modulation
	set_control_voltage(&pitch_lfo_cv, MIN);
    2288:	81 ee       	ldi	r24, 0xE1	; 225
    228a:	91 e0       	ldi	r25, 0x01	; 1
    228c:	60 e0       	ldi	r22, 0x00	; 0
    228e:	70 e0       	ldi	r23, 0x00	; 0
    2290:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&pitch_eg2_cv, MIN);
    2294:	82 ee       	ldi	r24, 0xE2	; 226
    2296:	91 e0       	ldi	r25, 0x01	; 1
    2298:	60 e0       	ldi	r22, 0x00	; 0
    229a:	70 e0       	ldi	r23, 0x00	; 0
    229c:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&pitch_vco2_cv, MIN);
    22a0:	82 eb       	ldi	r24, 0xB2	; 178
    22a2:	92 e0       	ldi	r25, 0x02	; 2
    22a4:	60 e0       	ldi	r22, 0x00	; 0
    22a6:	70 e0       	ldi	r23, 0x00	; 0
    22a8:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	//turn off glide
	set_control_voltage(&glide_cv, MIN);
    22ac:	8a ed       	ldi	r24, 0xDA	; 218
    22ae:	91 e0       	ldi	r25, 0x01	; 1
    22b0:	60 e0       	ldi	r22, 0x00	; 0
    22b2:	70 e0       	ldi	r23, 0x00	; 0
    22b4:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	//turn off all pulse width modulation
	set_control_voltage(&pwm_eg2_cv, MIN);
    22b8:	8f ed       	ldi	r24, 0xDF	; 223
    22ba:	91 e0       	ldi	r25, 0x01	; 1
    22bc:	60 e0       	ldi	r22, 0x00	; 0
    22be:	70 e0       	ldi	r23, 0x00	; 0
    22c0:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&pwm_lfo_cv, MIN);
    22c4:	80 ee       	ldi	r24, 0xE0	; 224
    22c6:	91 e0       	ldi	r25, 0x01	; 1
    22c8:	60 e0       	ldi	r22, 0x00	; 0
    22ca:	70 e0       	ldi	r23, 0x00	; 0
    22cc:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	//turn off all filter modulation
	set_control_voltage(&fil_lfo_cv, MIN);
    22d0:	81 ed       	ldi	r24, 0xD1	; 209
    22d2:	91 e0       	ldi	r25, 0x01	; 1
    22d4:	60 e0       	ldi	r22, 0x00	; 0
    22d6:	70 e0       	ldi	r23, 0x00	; 0
    22d8:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&fil_eg2_cv, MIN);
    22dc:	86 ed       	ldi	r24, 0xD6	; 214
    22de:	91 e0       	ldi	r25, 0x01	; 1
    22e0:	60 e0       	ldi	r22, 0x00	; 0
    22e2:	70 e0       	ldi	r23, 0x00	; 0
    22e4:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&fil_vco2_cv, MIN);
    22e8:	82 ed       	ldi	r24, 0xD2	; 210
    22ea:	91 e0       	ldi	r25, 0x01	; 1
    22ec:	60 e0       	ldi	r22, 0x00	; 0
    22ee:	70 e0       	ldi	r23, 0x00	; 0
    22f0:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&key_track_cv, MIN);
    22f4:	83 ed       	ldi	r24, 0xD3	; 211
    22f6:	91 e0       	ldi	r25, 0x01	; 1
    22f8:	60 e0       	ldi	r22, 0x00	; 0
    22fa:	70 e0       	ldi	r23, 0x00	; 0
    22fc:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	//open filter with max resonance
	set_control_voltage(&cutoff_cv, MAX); //need to start with MAX to get filter oscillating
    2300:	84 ed       	ldi	r24, 0xD4	; 212
    2302:	91 e0       	ldi	r25, 0x01	; 1
    2304:	6f ef       	ldi	r22, 0xFF	; 255
    2306:	7f e3       	ldi	r23, 0x3F	; 63
    2308:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&res_cv, MAX);
    230c:	85 ed       	ldi	r24, 0xD5	; 213
    230e:	91 e0       	ldi	r25, 0x01	; 1
    2310:	6f ef       	ldi	r22, 0xFF	; 255
    2312:	7f e3       	ldi	r23, 0x3F	; 63
    2314:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	//turn off VCA LFO modulation
	set_control_voltage(&amp_lfo_cv, MIN);
    2318:	89 ed       	ldi	r24, 0xD9	; 217
    231a:	91 e0       	ldi	r25, 0x01	; 1
    231c:	60 e0       	ldi	r22, 0x00	; 0
    231e:	70 e0       	ldi	r23, 0x00	; 0
    2320:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	//initialize VCA envelope
	set_control_voltage(&attack_1_cv, MIN);
    2324:	8e ec       	ldi	r24, 0xCE	; 206
    2326:	91 e0       	ldi	r25, 0x01	; 1
    2328:	60 e0       	ldi	r22, 0x00	; 0
    232a:	70 e0       	ldi	r23, 0x00	; 0
    232c:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&decay_1_cv, MIN);
    2330:	8c ec       	ldi	r24, 0xCC	; 204
    2332:	91 e0       	ldi	r25, 0x01	; 1
    2334:	60 e0       	ldi	r22, 0x00	; 0
    2336:	70 e0       	ldi	r23, 0x00	; 0
    2338:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&sustain_1_cv, MAX);
    233c:	8a ec       	ldi	r24, 0xCA	; 202
    233e:	91 e0       	ldi	r25, 0x01	; 1
    2340:	6f ef       	ldi	r22, 0xFF	; 255
    2342:	7f e3       	ldi	r23, 0x3F	; 63
    2344:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&release_1_cv, MIN);
    2348:	88 ec       	ldi	r24, 0xC8	; 200
    234a:	91 e0       	ldi	r25, 0x01	; 1
    234c:	60 e0       	ldi	r22, 0x00	; 0
    234e:	70 e0       	ldi	r23, 0x00	; 0
    2350:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	//turn off noise, VCO1 and VCO2
	set_control_voltage(&noise_mix_cv, MIN);
    2354:	80 ed       	ldi	r24, 0xD0	; 208
    2356:	91 e0       	ldi	r25, 0x01	; 1
    2358:	60 e0       	ldi	r22, 0x00	; 0
    235a:	70 e0       	ldi	r23, 0x00	; 0
    235c:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&vco1_mix_cv, MIN);
    2360:	83 ee       	ldi	r24, 0xE3	; 227
    2362:	91 e0       	ldi	r25, 0x01	; 1
    2364:	60 e0       	ldi	r22, 0x00	; 0
    2366:	70 e0       	ldi	r23, 0x00	; 0
    2368:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
	set_control_voltage(&vco2_mix_cv, MIN);
    236c:	84 ee       	ldi	r24, 0xE4	; 228
    236e:	91 e0       	ldi	r25, 0x01	; 1
    2370:	60 e0       	ldi	r22, 0x00	; 0
    2372:	70 e0       	ldi	r23, 0x00	; 0
    2374:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>


	//latch switch data
	DATA_BUS = 0; //turn off all VCO waveforms
    2378:	12 b8       	out	0x02, r1	; 2
	VCO_SW_LATCH_PORT |= (1<<VCO_SW_LATCH);
    237a:	ed ed       	ldi	r30, 0xDD	; 221
    237c:	f0 e0       	ldi	r31, 0x00	; 0
    237e:	80 81       	ld	r24, Z
    2380:	80 64       	ori	r24, 0x40	; 64
    2382:	80 83       	st	Z, r24
	//_delay_us(1); //why is this delay here????
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    2384:	80 81       	ld	r24, Z
    2386:	8f 7b       	andi	r24, 0xBF	; 191
    2388:	80 83       	st	Z, r24
	//DATA_BUS = 0;


	period = 1; //need to initialize to minimum period number here
    238a:	81 e0       	ldi	r24, 0x01	; 1
    238c:	80 93 76 03 	sts	0x0376, r24
	PORTF |= (1<<GATE); //turn gate on
    2390:	89 9a       	sbi	0x11, 1	; 17
    2392:	9e 01       	movw	r18, r28
    2394:	2f 5f       	subi	r18, 0xFF	; 255
    2396:	3f 4f       	sbci	r19, 0xFF	; 255
    2398:	3d ab       	sts	0x5d, r19
    239a:	2c ab       	sts	0x5c, r18
    239c:	8b e0       	ldi	r24, 0x0B	; 11
    239e:	93 e0       	ldi	r25, 0x03	; 3
    23a0:	99 af       	sts	0x79, r25
    23a2:	88 af       	sts	0x78, r24
	
	
	
	for (int note_number = 0; note_number <= 14; note_number++)
    23a4:	1f aa       	sts	0x9f, r17
    23a6:	1e aa       	sts	0x9e, r17
		uint16_t pitch_cv = 0;
		for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
		
			pitch_cv |= (1<<dac_bit);

			set_control_voltage(&cutoff_cv, pitch_cv);
    23a8:	0f 2e       	mov	r0, r31
    23aa:	f4 ed       	ldi	r31, 0xD4	; 212
    23ac:	af 2e       	mov	r10, r31
    23ae:	f1 e0       	ldi	r31, 0x01	; 1
    23b0:	bf 2e       	mov	r11, r31
    23b2:	f0 2d       	mov	r31, r0
				//value_to_display = TCNT0;
				//update_display(value_to_display, DEC);
				
		
				set_control_voltage(&cutoff_cv, pitch_cv);
				set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
    23b4:	0f 2e       	mov	r0, r31
    23b6:	f8 ed       	ldi	r31, 0xD8	; 216
    23b8:	6f 2e       	mov	r6, r31
    23ba:	f1 e0       	ldi	r31, 0x01	; 1
    23bc:	7f 2e       	mov	r7, r31
    23be:	f0 2d       	mov	r31, r0
				set_control_voltage(&res_cv, MAX);
    23c0:	0f 2e       	mov	r0, r31
    23c2:	f5 ed       	ldi	r31, 0xD5	; 213
    23c4:	4f 2e       	mov	r4, r31
    23c6:	f1 e0       	ldi	r31, 0x01	; 1
    23c8:	5f 2e       	mov	r5, r31
    23ca:	f0 2d       	mov	r31, r0
				set_control_voltage(&sustain_1_cv, MAX);
    23cc:	0f 2e       	mov	r0, r31
    23ce:	fa ec       	ldi	r31, 0xCA	; 202
    23d0:	2f 2e       	mov	r2, r31
    23d2:	f1 e0       	ldi	r31, 0x01	; 1
    23d4:	3f 2e       	mov	r3, r31
    23d6:	f0 2d       	mov	r31, r0
		
	
	
	}
	
void tune_filter(void) {
    23d8:	ac a9       	sts	0x4c, r26
    23da:	bd a9       	sts	0x4d, r27
	
	
	
	for (int note_number = 0; note_number <= 14; note_number++)
	{
		period = reference[note_number].period;
    23dc:	8c 91       	ld	r24, X
    23de:	80 93 76 03 	sts	0x0376, r24
		//period timer needs to be initialized here and turned off after each note's SAR to prevent glitching caused by leaving timer0 running
		TCCR0A |= (1<<CS02) | (1<<CS01) | (1<<CS00) | (1<<WGM01); //clocked by external T0 pin, rising edge + clear timer on compare match
    23e2:	84 b5       	in	r24, 0x24	; 36
    23e4:	8f 60       	ori	r24, 0x0F	; 15
    23e6:	84 bd       	out	0x24, r24	; 36
		OCR0A = 1; //output compare register - set to number of periods to be counted. OCR0A needs to be set to (periods_to_be_counted - 1) ***COULD PROBABLY CHANGE THIS TO 0 NOW*** - NOPE. NEEDS TO BE 1!!!
    23e8:	81 e0       	ldi	r24, 0x01	; 1
    23ea:	87 bd       	out	0x27, r24	; 39
		TIMSK0 |= (1<<OCIE0A); //enable output compare match A interrupt
    23ec:	ee e6       	ldi	r30, 0x6E	; 110
    23ee:	f0 e0       	ldi	r31, 0x00	; 0
    23f0:	80 81       	ld	r24, Z
    23f2:	82 60       	ori	r24, 0x02	; 2
    23f4:	80 83       	st	Z, r24
		TCNT0 = 0; //make sure timer/counter0 is actually 0.
    23f6:	16 bc       	out	0x26, r1	; 38
		
		if (note_number <= 1) {
    23f8:	ee a9       	sts	0x4e, r30
    23fa:	ff a9       	sts	0x4f, r31
    23fc:	e2 30       	cpi	r30, 0x02	; 2
    23fe:	f1 05       	cpc	r31, r1
    2400:	24 f4       	brge	.+8      	; 0x240a <tune_filter+0x1d4>
			
			//set timer/counter1 to /64 0.3125 MHz
			timer1_clock = (1<<CS11) | (1<<CS10);
    2402:	83 e0       	ldi	r24, 0x03	; 3
    2404:	80 93 75 03 	sts	0x0375, r24
    2408:	03 c0       	rjmp	.+6      	; 0x2410 <tune_filter+0x1da>
			
		} else {
			
			//set timer/counter1 to /8 2.5 MHz
			timer1_clock = (1<<CS11);
    240a:	82 e0       	ldi	r24, 0x02	; 2
    240c:	80 93 75 03 	sts	0x0375, r24
			
		}
		//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
		uint16_t reference_count = reference[note_number].count;
    2410:	11 96       	adiw	r26, 0x01	; 1
    2412:	2d 91       	ld	r18, X+
    2414:	3c 91       	ld	r19, X
    2416:	12 97       	sbiw	r26, 0x02	; 2
    2418:	3b ab       	sts	0x5b, r19
    241a:	2a ab       	sts	0x5a, r18
		uint16_t pitch_cv = 0;
		for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
    241c:	8d e0       	ldi	r24, 0x0D	; 13
    241e:	90 e0       	ldi	r25, 0x00	; 0
    2420:	9f a7       	lds	r25, 0x7f
    2422:	8e a7       	lds	r24, 0x7e
			timer1_clock = (1<<CS11);
			
		}
		//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
		uint16_t reference_count = reference[note_number].count;
		uint16_t pitch_cv = 0;
    2424:	ee 24       	eor	r14, r14
    2426:	ff 24       	eor	r15, r15
				set_control_voltage(&cutoff_cv, pitch_cv);
				set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
				set_control_voltage(&res_cv, MAX);
				set_control_voltage(&sustain_1_cv, MAX);
				set_control_voltage(&attack_1_cv, MIN); //keep attack at minimum
				set_control_voltage(&fil_lfo_cv, MIN);	//keep all filter modulation at a minimum
    2428:	0f 2e       	mov	r0, r31
    242a:	f1 ed       	ldi	r31, 0xD1	; 209
    242c:	cf 2e       	mov	r12, r31
    242e:	f1 e0       	ldi	r31, 0x01	; 1
    2430:	df 2e       	mov	r13, r31
    2432:	f0 2d       	mov	r31, r0
				set_control_voltage(&fil_eg2_cv, MIN);
    2434:	0f 2e       	mov	r0, r31
    2436:	f6 ed       	ldi	r31, 0xD6	; 214
    2438:	8f 2e       	mov	r8, r31
    243a:	f1 e0       	ldi	r31, 0x01	; 1
    243c:	9f 2e       	mov	r9, r31
    243e:	f0 2d       	mov	r31, r0
		//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
		uint16_t reference_count = reference[note_number].count;
		uint16_t pitch_cv = 0;
		for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
		
			pitch_cv |= (1<<dac_bit);
    2440:	81 e0       	ldi	r24, 0x01	; 1
    2442:	90 e0       	ldi	r25, 0x00	; 0
    2444:	fc 01       	movw	r30, r24
    2446:	0e a4       	lds	r16, 0xae
    2448:	02 c0       	rjmp	.+4      	; 0x244e <tune_filter+0x218>
    244a:	ee 0f       	add	r30, r30
    244c:	ff 1f       	adc	r31, r31
    244e:	0a 94       	dec	r0
    2450:	e2 f7       	brpl	.-8      	; 0x244a <tune_filter+0x214>
    2452:	f9 ab       	sts	0x59, r31
    2454:	e8 ab       	sts	0x58, r30
    2456:	ee 2a       	or	r14, r30
    2458:	ff 2a       	or	r15, r31

			set_control_voltage(&cutoff_cv, pitch_cv);
    245a:	c5 01       	movw	r24, r10
    245c:	b7 01       	movw	r22, r14
    245e:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
			count_finished = FALSE;
    2462:	10 92 74 03 	sts	0x0374, r1
			period_counter = 0;
    2466:	10 92 77 03 	sts	0x0377, r1
		
			//enable watchdog timer
			wdt_enable(WDTO_2S);
    246a:	8f e0       	ldi	r24, 0x0F	; 15
    246c:	28 e1       	ldi	r18, 0x18	; 24
    246e:	30 e0       	ldi	r19, 0x00	; 0
    2470:	0f b6       	in	r0, 0x3f	; 63
    2472:	f8 94       	cli
    2474:	a8 95       	wdr
    2476:	20 93 60 00 	sts	0x0060, r18
    247a:	0f be       	out	0x3f, r0	; 63
    247c:	80 93 60 00 	sts	0x0060, r24
			while (count_finished == FALSE) {
    2480:	80 91 74 03 	lds	r24, 0x0374
    2484:	88 23       	and	r24, r24
    2486:	b1 f5       	brne	.+108    	; 0x24f4 <tune_filter+0x2be>
				set_control_voltage(&res_cv, MAX);
				set_control_voltage(&sustain_1_cv, MAX);
				set_control_voltage(&attack_1_cv, MIN); //keep attack at minimum
				set_control_voltage(&fil_lfo_cv, MIN);	//keep all filter modulation at a minimum
				set_control_voltage(&fil_eg2_cv, MIN);
				set_control_voltage(&fil_vco2_cv, MIN);
    2488:	02 ed       	ldi	r16, 0xD2	; 210
    248a:	11 e0       	ldi	r17, 0x01	; 1
		
			//enable watchdog timer
			wdt_enable(WDTO_2S);
			while (count_finished == FALSE) {
				//update_display(vco_number + period + (compare_match_counter>>4)*100, DEC);
				update_display(300 + period, DEC);//
    248c:	80 91 76 03 	lds	r24, 0x0376
    2490:	90 e0       	ldi	r25, 0x00	; 0
    2492:	84 5d       	subi	r24, 0xD4	; 212
    2494:	9e 4f       	sbci	r25, 0xFE	; 254
    2496:	60 e0       	ldi	r22, 0x00	; 0
    2498:	0e 94 2f 02 	call	0x45e	; 0x45e <update_display>
				//value_to_display = TCNT0;
				//update_display(value_to_display, DEC);
				
		
				set_control_voltage(&cutoff_cv, pitch_cv);
    249c:	c5 01       	movw	r24, r10
    249e:	b7 01       	movw	r22, r14
    24a0:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
				set_control_voltage(&volume_cv, MIN);//only necessary for first 2 octaves that use lower frequency reference clock
    24a4:	c3 01       	movw	r24, r6
    24a6:	60 e0       	ldi	r22, 0x00	; 0
    24a8:	70 e0       	ldi	r23, 0x00	; 0
    24aa:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
				set_control_voltage(&res_cv, MAX);
    24ae:	c2 01       	movw	r24, r4
    24b0:	6f ef       	ldi	r22, 0xFF	; 255
    24b2:	7f e3       	ldi	r23, 0x3F	; 63
    24b4:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
				set_control_voltage(&sustain_1_cv, MAX);
    24b8:	c1 01       	movw	r24, r2
    24ba:	6f ef       	ldi	r22, 0xFF	; 255
    24bc:	7f e3       	ldi	r23, 0x3F	; 63
    24be:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
				set_control_voltage(&attack_1_cv, MIN); //keep attack at minimum
    24c2:	8e ec       	ldi	r24, 0xCE	; 206
    24c4:	91 e0       	ldi	r25, 0x01	; 1
    24c6:	60 e0       	ldi	r22, 0x00	; 0
    24c8:	70 e0       	ldi	r23, 0x00	; 0
    24ca:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
				set_control_voltage(&fil_lfo_cv, MIN);	//keep all filter modulation at a minimum
    24ce:	c6 01       	movw	r24, r12
    24d0:	60 e0       	ldi	r22, 0x00	; 0
    24d2:	70 e0       	ldi	r23, 0x00	; 0
    24d4:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
				set_control_voltage(&fil_eg2_cv, MIN);
    24d8:	c4 01       	movw	r24, r8
    24da:	60 e0       	ldi	r22, 0x00	; 0
    24dc:	70 e0       	ldi	r23, 0x00	; 0
    24de:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
				set_control_voltage(&fil_vco2_cv, MIN);
    24e2:	c8 01       	movw	r24, r16
    24e4:	60 e0       	ldi	r22, 0x00	; 0
    24e6:	70 e0       	ldi	r23, 0x00	; 0
    24e8:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <set_control_voltage>
			count_finished = FALSE;
			period_counter = 0;
		
			//enable watchdog timer
			wdt_enable(WDTO_2S);
			while (count_finished == FALSE) {
    24ec:	80 91 74 03 	lds	r24, 0x0374
    24f0:	88 23       	and	r24, r24
    24f2:	61 f2       	breq	.-104    	; 0x248c <tune_filter+0x256>
				set_control_voltage(&fil_eg2_cv, MIN);
				set_control_voltage(&fil_vco2_cv, MIN);
						
			}
			//turn off watchdog timer
			wdt_disable();
    24f4:	88 e1       	ldi	r24, 0x18	; 24
    24f6:	0f b6       	in	r0, 0x3f	; 63
    24f8:	f8 94       	cli
    24fa:	80 93 60 00 	sts	0x0060, r24
    24fe:	10 92 60 00 	sts	0x0060, r1
    2502:	0f be       	out	0x3f, r0	; 63
			//Omar changed this from <= to < which makes sense. <= was an error because if it's equal you don't want to clear the bit
			if ((osc_count <= reference_count) && (no_overflow == TRUE))pitch_cv &= ~(1<<dac_bit);
    2504:	80 91 72 03 	lds	r24, 0x0372
    2508:	90 91 73 03 	lds	r25, 0x0373
    250c:	2a a9       	sts	0x4a, r18
    250e:	3b a9       	sts	0x4b, r19
    2510:	28 17       	cp	r18, r24
    2512:	39 07       	cpc	r19, r25
    2514:	50 f0       	brcs	.+20     	; 0x252a <tune_filter+0x2f4>
    2516:	80 91 af 02 	lds	r24, 0x02AF
    251a:	81 30       	cpi	r24, 0x01	; 1
    251c:	31 f4       	brne	.+12     	; 0x252a <tune_filter+0x2f4>
    251e:	88 a9       	sts	0x48, r24
    2520:	99 a9       	sts	0x49, r25
    2522:	80 95       	com	r24
    2524:	90 95       	com	r25
    2526:	e8 22       	and	r14, r24
    2528:	f9 22       	and	r15, r25
		
			if (osc_count == reference_count && no_overflow == TRUE) {
    252a:	80 91 72 03 	lds	r24, 0x0372
    252e:	90 91 73 03 	lds	r25, 0x0373
    2532:	ea a9       	sts	0x4a, r30
    2534:	fb a9       	sts	0x4b, r31
    2536:	8e 17       	cp	r24, r30
    2538:	9f 07       	cpc	r25, r31
    253a:	21 f4       	brne	.+8      	; 0x2544 <tune_filter+0x30e>
    253c:	80 91 af 02 	lds	r24, 0x02AF
    2540:	81 30       	cpi	r24, 0x01	; 1
    2542:	71 f0       	breq	.+28     	; 0x2560 <tune_filter+0x32a>
				break;	//if you hit the reference count then get out of here
			}
			no_overflow = TRUE;
    2544:	81 e0       	ldi	r24, 0x01	; 1
    2546:	80 93 af 02 	sts	0x02AF, r24
			
		}
		//the following should be moved to its own function as it is duplicated in the init_cv function. Something like tune_note(*cv, period, reference_count), where *cv points to CV that needs to be calculated`
		uint16_t reference_count = reference[note_number].count;
		uint16_t pitch_cv = 0;
		for (int dac_bit = 13; dac_bit >= 0; dac_bit--) { //now do successive approximation
    254a:	2e a5       	lds	r18, 0x6e
    254c:	3f a5       	lds	r19, 0x6f
    254e:	21 50       	subi	r18, 0x01	; 1
    2550:	30 40       	sbci	r19, 0x00	; 0
    2552:	3f a7       	lds	r19, 0x7f
    2554:	2e a7       	lds	r18, 0x7e
    2556:	8f ef       	ldi	r24, 0xFF	; 255
    2558:	2f 3f       	cpi	r18, 0xFF	; 255
    255a:	38 07       	cpc	r19, r24
    255c:	09 f0       	breq	.+2      	; 0x2560 <tune_filter+0x32a>
    255e:	70 cf       	rjmp	.-288    	; 0x2440 <tune_filter+0x20a>
		
		
	}
	
	
	filter_pitch_table[note_number+1] = pitch_cv + 32; //32 is an offset that is trying to fix a bug somewhere else. This fix seems to work, but why 2^5 shift is required doesn't make sense to me yet. Need to look into this further
    2560:	ee a9       	sts	0x4e, r30
    2562:	ff a9       	sts	0x4f, r31
    2564:	31 96       	adiw	r30, 0x01	; 1
    2566:	ff ab       	sts	0x5f, r31
    2568:	ee ab       	sts	0x5e, r30
    256a:	c7 01       	movw	r24, r14
    256c:	80 96       	adiw	r24, 0x20	; 32
    256e:	e8 ad       	sts	0x68, r30
    2570:	f9 ad       	sts	0x69, r31
    2572:	81 93       	st	Z+, r24
    2574:	91 93       	st	Z+, r25
    2576:	f9 af       	sts	0x79, r31
    2578:	e8 af       	sts	0x78, r30
	
	//need to turn timer off here. This seems to have stopped periodic glitching of first note of first VCO tuned.
	TIMSK0 &= ~(1<<OCIE0A); //turn off timer0 compare match A interrupt
    257a:	ee e6       	ldi	r30, 0x6E	; 110
    257c:	f0 e0       	ldi	r31, 0x00	; 0
    257e:	80 81       	ld	r24, Z
    2580:	8d 7f       	andi	r24, 0xFD	; 253
    2582:	80 83       	st	Z, r24
	TCCR0A = 0; //turn off timer0
    2584:	14 bc       	out	0x24, r1	; 36
    2586:	2c a9       	sts	0x4c, r18
    2588:	3d a9       	sts	0x4d, r19
    258a:	2d 5f       	subi	r18, 0xFD	; 253
    258c:	3f 4f       	sbci	r19, 0xFF	; 255
    258e:	3d ab       	sts	0x5d, r19
    2590:	2c ab       	sts	0x5c, r18
	period = 1; //need to initialize to minimum period number here
	PORTF |= (1<<GATE); //turn gate on
	
	
	
	for (int note_number = 0; note_number <= 14; note_number++)
    2592:	8e a9       	sts	0x4e, r24
    2594:	9f a9       	sts	0x4f, r25
    2596:	8f 30       	cpi	r24, 0x0F	; 15
    2598:	91 05       	cpc	r25, r1
    259a:	09 f0       	breq	.+2      	; 0x259e <tune_filter+0x368>
    259c:	1d cf       	rjmp	.-454    	; 0x23d8 <tune_filter+0x1a2>
}


//eeprom_update_block((const void*)filter_pitch_table, (void*)filter_pitch_table_eeprom, sizeof(filter_pitch_table));

PORTF &= ~(1<<GATE); //turn gate off
    259e:	89 98       	cbi	0x11, 1	; 17
	
	
}	
    25a0:	e9 96       	adiw	r28, 0x39	; 57
    25a2:	0f b6       	in	r0, 0x3f	; 63
    25a4:	f8 94       	cli
    25a6:	de bf       	out	0x3e, r29	; 62
    25a8:	0f be       	out	0x3f, r0	; 63
    25aa:	cd bf       	out	0x3d, r28	; 61
    25ac:	df 91       	pop	r29
    25ae:	cf 91       	pop	r28
    25b0:	1f 91       	pop	r17
    25b2:	0f 91       	pop	r16
    25b4:	ff 90       	pop	r15
    25b6:	ef 90       	pop	r14
    25b8:	df 90       	pop	r13
    25ba:	cf 90       	pop	r12
    25bc:	bf 90       	pop	r11
    25be:	af 90       	pop	r10
    25c0:	9f 90       	pop	r9
    25c2:	8f 90       	pop	r8
    25c4:	7f 90       	pop	r7
    25c6:	6f 90       	pop	r6
    25c8:	5f 90       	pop	r5
    25ca:	4f 90       	pop	r4
    25cc:	3f 90       	pop	r3
    25ce:	2f 90       	pop	r2
    25d0:	08 95       	ret

000025d2 <save_tuning_tables>:


void save_tuning_tables(void) { //write tuning tables to memory
	
	eeprom_update_block((const void*)filter_pitch_table, (void*)filter_pitch_table_eeprom, sizeof(filter_pitch_table));
    25d2:	89 e0       	ldi	r24, 0x09	; 9
    25d4:	93 e0       	ldi	r25, 0x03	; 3
    25d6:	6c e0       	ldi	r22, 0x0C	; 12
    25d8:	76 e0       	ldi	r23, 0x06	; 6
    25da:	40 e2       	ldi	r20, 0x20	; 32
    25dc:	50 e0       	ldi	r21, 0x00	; 0
    25de:	0e 94 33 1b 	call	0x3666	; 0x3666 <__eeupd_block_m6450a>
	eeprom_update_block((const void*)vco1_pitch_table, (void*)vco1_pitch_table_eeprom, sizeof(vco1_pitch_table));
    25e2:	8b e4       	ldi	r24, 0x4B	; 75
    25e4:	93 e0       	ldi	r25, 0x03	; 3
    25e6:	6e e4       	ldi	r22, 0x4E	; 78
    25e8:	76 e0       	ldi	r23, 0x06	; 6
    25ea:	42 e2       	ldi	r20, 0x22	; 34
    25ec:	50 e0       	ldi	r21, 0x00	; 0
    25ee:	0e 94 33 1b 	call	0x3666	; 0x3666 <__eeupd_block_m6450a>
	eeprom_update_block((const void*)vco2_pitch_table, (void*)vco2_pitch_table_eeprom, sizeof(vco2_pitch_table));
    25f2:	89 e2       	ldi	r24, 0x29	; 41
    25f4:	93 e0       	ldi	r25, 0x03	; 3
    25f6:	6c e2       	ldi	r22, 0x2C	; 44
    25f8:	76 e0       	ldi	r23, 0x06	; 6
    25fa:	42 e2       	ldi	r20, 0x22	; 34
    25fc:	50 e0       	ldi	r21, 0x00	; 0
    25fe:	0e 94 33 1b 	call	0x3666	; 0x3666 <__eeupd_block_m6450a>
	
	
}
    2602:	08 95       	ret

00002604 <load_tuning_tables>:

void load_tuning_tables(void) { //retrieve tuning tables from memory
	
	
	vco1_init_cv = eeprom_read_word(&vco1_init_cv_eeprom);
    2604:	82 e7       	ldi	r24, 0x72	; 114
    2606:	96 e0       	ldi	r25, 0x06	; 6
    2608:	0e 94 2d 1b 	call	0x365a	; 0x365a <__eerd_word_m6450a>
    260c:	90 93 70 03 	sts	0x0370, r25
    2610:	80 93 6f 03 	sts	0x036F, r24
	vco2_init_cv = eeprom_read_word(&vco2_init_cv_eeprom);
    2614:	80 e7       	ldi	r24, 0x70	; 112
    2616:	96 e0       	ldi	r25, 0x06	; 6
    2618:	0e 94 2d 1b 	call	0x365a	; 0x365a <__eerd_word_m6450a>
    261c:	90 93 6e 03 	sts	0x036E, r25
    2620:	80 93 6d 03 	sts	0x036D, r24
	//uint16_t eeprom_addr = 0;
	//vco1_init_cv = eeprom_read_word((uint16_t*)eeprom_addr);
	//eeprom_addr += sizeof(vco2_init_cv);
	//vco2_init_cv = eeprom_read_word((uint16_t*)eeprom_addr);
	eeprom_read_block((void*)vco1_pitch_table, (const void*)vco1_pitch_table_eeprom, sizeof(vco1_pitch_table));
    2624:	8b e4       	ldi	r24, 0x4B	; 75
    2626:	93 e0       	ldi	r25, 0x03	; 3
    2628:	6e e4       	ldi	r22, 0x4E	; 78
    262a:	76 e0       	ldi	r23, 0x06	; 6
    262c:	42 e2       	ldi	r20, 0x22	; 34
    262e:	50 e0       	ldi	r21, 0x00	; 0
    2630:	0e 94 1d 1b 	call	0x363a	; 0x363a <__eerd_block_m6450a>
	eeprom_read_block((void*)vco2_pitch_table, (const void*)vco2_pitch_table_eeprom, sizeof(vco2_pitch_table));
    2634:	89 e2       	ldi	r24, 0x29	; 41
    2636:	93 e0       	ldi	r25, 0x03	; 3
    2638:	6c e2       	ldi	r22, 0x2C	; 44
    263a:	76 e0       	ldi	r23, 0x06	; 6
    263c:	42 e2       	ldi	r20, 0x22	; 34
    263e:	50 e0       	ldi	r21, 0x00	; 0
    2640:	0e 94 1d 1b 	call	0x363a	; 0x363a <__eerd_block_m6450a>
	eeprom_read_block((void*)filter_pitch_table, (const void*)filter_pitch_table_eeprom, sizeof(filter_pitch_table));
    2644:	89 e0       	ldi	r24, 0x09	; 9
    2646:	93 e0       	ldi	r25, 0x03	; 3
    2648:	6c e0       	ldi	r22, 0x0C	; 12
    264a:	76 e0       	ldi	r23, 0x06	; 6
    264c:	40 e2       	ldi	r20, 0x20	; 32
    264e:	50 e0       	ldi	r21, 0x00	; 0
    2650:	0e 94 1d 1b 	call	0x363a	; 0x363a <__eerd_block_m6450a>
	
	//value_to_display = vco1_init_cv_eeprom;
	
}			
    2654:	08 95       	ret

00002656 <interpolate_pitch_cv>:
	
uint16_t interpolate_pitch_cv(uint8_t note, uint16_t *pitch_table) {
	
	uint8_t pitch_index = note>>3;
    2656:	98 2f       	mov	r25, r24
    2658:	96 95       	lsr	r25
    265a:	96 95       	lsr	r25
    265c:	96 95       	lsr	r25
	uint8_t delta_note = note - pitch_index*8; //will range from 0 to 7
		
	uint16_t y0 = pitch_table[pitch_index -1];
    265e:	29 2f       	mov	r18, r25
    2660:	30 e0       	ldi	r19, 0x00	; 0
    2662:	f9 01       	movw	r30, r18
    2664:	31 97       	sbiw	r30, 0x01	; 1
    2666:	ee 0f       	add	r30, r30
    2668:	ff 1f       	adc	r31, r31
    266a:	e6 0f       	add	r30, r22
    266c:	f7 1f       	adc	r31, r23
    266e:	01 90       	ld	r0, Z+
    2670:	f0 81       	ld	r31, Z
    2672:	e0 2d       	mov	r30, r0
	uint16_t y1 = pitch_table[pitch_index];
    2674:	22 0f       	add	r18, r18
    2676:	33 1f       	adc	r19, r19
    2678:	26 0f       	add	r18, r22
    267a:	37 1f       	adc	r19, r23
	
	uint16_t interpolated_pitch_cv = y0 + (((y1 - y0)*delta_note)>>3); //mind order of operations here: + is evaluated before >>	also, might be possible to optimize this with 16MUL8SHIFT8 from Anushri ASM util
    267c:	d9 01       	movw	r26, r18
    267e:	4d 91       	ld	r20, X+
    2680:	5c 91       	ld	r21, X
    2682:	11 97       	sbiw	r26, 0x01	; 1
    2684:	4e 1b       	sub	r20, r30
    2686:	5f 0b       	sbc	r21, r31
}			
	
uint16_t interpolate_pitch_cv(uint8_t note, uint16_t *pitch_table) {
	
	uint8_t pitch_index = note>>3;
	uint8_t delta_note = note - pitch_index*8; //will range from 0 to 7
    2688:	99 0f       	add	r25, r25
    268a:	99 0f       	add	r25, r25
    268c:	99 0f       	add	r25, r25
    268e:	89 1b       	sub	r24, r25
		
	uint16_t y0 = pitch_table[pitch_index -1];
	uint16_t y1 = pitch_table[pitch_index];
	
	uint16_t interpolated_pitch_cv = y0 + (((y1 - y0)*delta_note)>>3); //mind order of operations here: + is evaluated before >>	also, might be possible to optimize this with 16MUL8SHIFT8 from Anushri ASM util
    2690:	90 e0       	ldi	r25, 0x00	; 0
    2692:	48 9f       	mul	r20, r24
    2694:	90 01       	movw	r18, r0
    2696:	49 9f       	mul	r20, r25
    2698:	30 0d       	add	r19, r0
    269a:	58 9f       	mul	r21, r24
    269c:	30 0d       	add	r19, r0
    269e:	11 24       	eor	r1, r1
    26a0:	36 95       	lsr	r19
    26a2:	27 95       	ror	r18
    26a4:	36 95       	lsr	r19
    26a6:	27 95       	ror	r18
    26a8:	36 95       	lsr	r19
    26aa:	27 95       	ror	r18
    26ac:	e2 0f       	add	r30, r18
    26ae:	f3 1f       	adc	r31, r19
	
	
	
	return interpolated_pitch_cv;
	
}
    26b0:	8e 2f       	mov	r24, r30
    26b2:	9f 2f       	mov	r25, r31
    26b4:	08 95       	ret

000026b6 <set_one_volt_per_octave>:

void set_one_volt_per_octave(void) { //does this get stored in RAM? Should it go in progmem instead?
    26b6:	cf 93       	push	r28
    26b8:	df 93       	push	r29
    26ba:	cd b7       	in	r28, 0x3d	; 61
    26bc:	de b7       	in	r29, 0x3e	; 62
    26be:	a2 97       	sbiw	r28, 0x22	; 34
    26c0:	0f b6       	in	r0, 0x3f	; 63
    26c2:	f8 94       	cli
    26c4:	de bf       	out	0x3e, r29	; 62
    26c6:	0f be       	out	0x3f, r0	; 63
    26c8:	cd bf       	out	0x3d, r28	; 61
	
	uint16_t vpo_pitch_table[17] = {
    26ca:	de 01       	movw	r26, r28
    26cc:	11 96       	adiw	r26, 0x01	; 1
    26ce:	ed e8       	ldi	r30, 0x8D	; 141
    26d0:	f2 e0       	ldi	r31, 0x02	; 2
    26d2:	82 e2       	ldi	r24, 0x22	; 34
    26d4:	01 90       	ld	r0, Z+
    26d6:	0d 92       	st	X+, r0
    26d8:	81 50       	subi	r24, 0x01	; 1
    26da:	e1 f7       	brne	.-8      	; 0x26d4 <set_one_volt_per_octave+0x1e>
		16384
		
	};
	
	
	memcpy((void*)vco1_pitch_table, (const void*)vpo_pitch_table, (size_t)sizeof(vpo_pitch_table));
    26dc:	ab e4       	ldi	r26, 0x4B	; 75
    26de:	b3 e0       	ldi	r27, 0x03	; 3
    26e0:	fe 01       	movw	r30, r28
    26e2:	31 96       	adiw	r30, 0x01	; 1
    26e4:	82 e2       	ldi	r24, 0x22	; 34
    26e6:	01 90       	ld	r0, Z+
    26e8:	0d 92       	st	X+, r0
    26ea:	81 50       	subi	r24, 0x01	; 1
    26ec:	e1 f7       	brne	.-8      	; 0x26e6 <set_one_volt_per_octave+0x30>
	memcpy((void*)vco2_pitch_table, (const void*)vpo_pitch_table, (size_t)sizeof(vpo_pitch_table));
    26ee:	a9 e2       	ldi	r26, 0x29	; 41
    26f0:	b3 e0       	ldi	r27, 0x03	; 3
    26f2:	fe 01       	movw	r30, r28
    26f4:	31 96       	adiw	r30, 0x01	; 1
    26f6:	82 e2       	ldi	r24, 0x22	; 34
    26f8:	01 90       	ld	r0, Z+
    26fa:	0d 92       	st	X+, r0
    26fc:	81 50       	subi	r24, 0x01	; 1
    26fe:	e1 f7       	brne	.-8      	; 0x26f8 <set_one_volt_per_octave+0x42>
	
	
    2700:	a2 96       	adiw	r28, 0x22	; 34
    2702:	0f b6       	in	r0, 0x3f	; 63
    2704:	f8 94       	cli
    2706:	de bf       	out	0x3e, r29	; 62
    2708:	0f be       	out	0x3f, r0	; 63
    270a:	cd bf       	out	0x3d, r28	; 61
    270c:	df 91       	pop	r29
    270e:	cf 91       	pop	r28
    2710:	08 95       	ret

00002712 <read_switch_port>:

uint8_t read_switch_port(void) {
	
	static uint8_t previous_port_state = 0;
	
	uint8_t current_port_state = SWITCH_PORT; //read switch state byte
    2712:	9f b1       	in	r25, 0x0f	; 15
	switch_press |= current_port_state & 0b00001100; //mask for four PROG buttons 
    2714:	89 2f       	mov	r24, r25
    2716:	8c 70       	andi	r24, 0x0C	; 12
    2718:	20 91 c1 02 	lds	r18, 0x02C1
    271c:	82 2b       	or	r24, r18
    271e:	80 93 c1 02 	sts	0x02C1, r24
	//this toggle code works, but I haven't figured out how it works
	//source: http://forum.allaboutcircuits.com/threads/help-with-programming-uc-toggle-led-using-one-switch.51602/	
	current_port_state ^= previous_port_state;
    2722:	80 91 7b 03 	lds	r24, 0x037B
    2726:	98 27       	eor	r25, r24
	previous_port_state ^= current_port_state;
    2728:	89 27       	eor	r24, r25
    272a:	80 93 7b 03 	sts	0x037B, r24
	current_port_state &= previous_port_state;
	
	return current_port_state;
	
}
    272e:	89 23       	and	r24, r25
    2730:	08 95       	ret

00002732 <update_analog_switch_latch>:

void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    2732:	ed ed       	ldi	r30, 0xDD	; 221
    2734:	f0 e0       	ldi	r31, 0x00	; 0
    2736:	90 81       	ld	r25, Z
    2738:	9f 7b       	andi	r25, 0xBF	; 191
    273a:	90 83       	st	Z, r25
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
	((switch_state_byte >> VCO_SYNC_SW) & 1) << VCO_SYNC_LATCH_BIT |
	((switch_state_byte >> VCO1_SAW_SW) & 1) << VCO1_SAW_LATCH_BIT |
	((switch_state_byte >> VCO1_TRI_SW) & 1) << VCO1_TRI_LATCH_BIT |
	((switch_state_byte >> VCO1_PULSE_SW) & 1) << VCO1_PULSE_LATCH_BIT |
    273c:	28 2f       	mov	r18, r24
    273e:	30 e0       	ldi	r19, 0x00	; 0
    2740:	21 70       	andi	r18, 0x01	; 1
    2742:	30 70       	andi	r19, 0x00	; 0
    2744:	22 0f       	add	r18, r18
    2746:	33 1f       	adc	r19, r19
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
	((switch_state_byte >> VCO2_TRI_SW) & 1) << VCO2_TRI_LATCH_BIT |
    2748:	68 2f       	mov	r22, r24
    274a:	62 95       	swap	r22
    274c:	66 95       	lsr	r22
    274e:	67 70       	andi	r22, 0x07	; 7
    2750:	67 95       	ror	r22
    2752:	66 27       	eor	r22, r22
    2754:	67 95       	ror	r22
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2756:	26 2b       	or	r18, r22
    2758:	98 2f       	mov	r25, r24
    275a:	96 95       	lsr	r25
    275c:	96 95       	lsr	r25
    275e:	91 70       	andi	r25, 0x01	; 1
    2760:	29 2b       	or	r18, r25
	((switch_state_byte >> VCO_SYNC_SW) & 1) << VCO_SYNC_LATCH_BIT |
    2762:	68 2f       	mov	r22, r24
    2764:	66 1f       	adc	r22, r22
    2766:	66 27       	eor	r22, r22
    2768:	66 1f       	adc	r22, r22
    276a:	66 0f       	add	r22, r22
    276c:	66 0f       	add	r22, r22
    276e:	66 0f       	add	r22, r22
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2770:	26 2b       	or	r18, r22
	((switch_state_byte >> VCO_SYNC_SW) & 1) << VCO_SYNC_LATCH_BIT |
	((switch_state_byte >> VCO1_SAW_SW) & 1) << VCO1_SAW_LATCH_BIT |
	((switch_state_byte >> VCO1_TRI_SW) & 1) << VCO1_TRI_LATCH_BIT |
    2772:	a8 2f       	mov	r26, r24
    2774:	a6 95       	lsr	r26
    2776:	b0 e0       	ldi	r27, 0x00	; 0
    2778:	a1 70       	andi	r26, 0x01	; 1
    277a:	b0 70       	andi	r27, 0x00	; 0
    277c:	bd 01       	movw	r22, r26
    277e:	66 0f       	add	r22, r22
    2780:	77 1f       	adc	r23, r23
    2782:	66 0f       	add	r22, r22
    2784:	77 1f       	adc	r23, r23
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    2786:	26 2b       	or	r18, r22
	((switch_state_byte >> VCO_SYNC_SW) & 1) << VCO_SYNC_LATCH_BIT |
	((switch_state_byte >> VCO1_SAW_SW) & 1) << VCO1_SAW_LATCH_BIT |
	((switch_state_byte >> VCO1_TRI_SW) & 1) << VCO1_TRI_LATCH_BIT |
	((switch_state_byte >> VCO1_PULSE_SW) & 1) << VCO1_PULSE_LATCH_BIT |
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
    2788:	68 2f       	mov	r22, r24
    278a:	62 95       	swap	r22
    278c:	6f 70       	andi	r22, 0x0F	; 15
    278e:	70 e0       	ldi	r23, 0x00	; 0
    2790:	61 70       	andi	r22, 0x01	; 1
    2792:	70 70       	andi	r23, 0x00	; 0
    2794:	ab 01       	movw	r20, r22
    2796:	00 24       	eor	r0, r0
    2798:	56 95       	lsr	r21
    279a:	47 95       	ror	r20
    279c:	07 94       	ror	r0
    279e:	56 95       	lsr	r21
    27a0:	47 95       	ror	r20
    27a2:	07 94       	ror	r0
    27a4:	54 2f       	mov	r21, r20
    27a6:	40 2d       	mov	r20, r0
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    27a8:	62 2f       	mov	r22, r18
    27aa:	64 2b       	or	r22, r20
	((switch_state_byte >> VCO1_SAW_SW) & 1) << VCO1_SAW_LATCH_BIT |
	((switch_state_byte >> VCO1_TRI_SW) & 1) << VCO1_TRI_LATCH_BIT |
	((switch_state_byte >> VCO1_PULSE_SW) & 1) << VCO1_PULSE_LATCH_BIT |
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
	((switch_state_byte >> VCO2_TRI_SW) & 1) << VCO2_TRI_LATCH_BIT |
	((switch_state_byte >> VCO2_PULSE_SW) & 1) << VCO2_PULSE_LATCH_BIT |
    27ac:	48 2f       	mov	r20, r24
    27ae:	42 95       	swap	r20
    27b0:	46 95       	lsr	r20
    27b2:	46 95       	lsr	r20
    27b4:	43 70       	andi	r20, 0x03	; 3
    27b6:	50 e0       	ldi	r21, 0x00	; 0
    27b8:	41 70       	andi	r20, 0x01	; 1
    27ba:	50 70       	andi	r21, 0x00	; 0
    27bc:	9a 01       	movw	r18, r20
    27be:	22 0f       	add	r18, r18
    27c0:	33 1f       	adc	r19, r19
    27c2:	22 95       	swap	r18
    27c4:	32 95       	swap	r19
    27c6:	30 7f       	andi	r19, 0xF0	; 240
    27c8:	32 27       	eor	r19, r18
    27ca:	20 7f       	andi	r18, 0xF0	; 240
    27cc:	32 27       	eor	r19, r18
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    27ce:	46 2f       	mov	r20, r22
    27d0:	42 2b       	or	r20, r18
	((switch_state_byte >> VCO1_PULSE_SW) & 1) << VCO1_PULSE_LATCH_BIT |
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
	((switch_state_byte >> VCO2_TRI_SW) & 1) << VCO2_TRI_LATCH_BIT |
	((switch_state_byte >> VCO2_PULSE_SW) & 1) << VCO2_PULSE_LATCH_BIT |
	//BMOD_SW_ON << BMOD_LATCH_BIT;
	((switch_state_byte >> 3) & 1) << BMOD_LATCH_BIT;
    27d2:	86 95       	lsr	r24
    27d4:	86 95       	lsr	r24
    27d6:	86 95       	lsr	r24
    27d8:	28 2f       	mov	r18, r24
    27da:	30 e0       	ldi	r19, 0x00	; 0
    27dc:	21 70       	andi	r18, 0x01	; 1
    27de:	30 70       	andi	r19, 0x00	; 0
    27e0:	c9 01       	movw	r24, r18
    27e2:	82 95       	swap	r24
    27e4:	92 95       	swap	r25
    27e6:	90 7f       	andi	r25, 0xF0	; 240
    27e8:	98 27       	eor	r25, r24
    27ea:	80 7f       	andi	r24, 0xF0	; 240
    27ec:	98 27       	eor	r25, r24
void update_analog_switch_latch(uint8_t switch_state_byte) {
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
	//enable output on VCO analog switch latch:
	//switch latch: 7: B TRI 6: B SAW 5: B PULSE 4: B MOD 3: VCO_SYNC_LATCH_BIT 2: A TRI 1: A PULSE 0: A SAW
	DATA_BUS = //I wonder if some kind of bitmask could be implemented here to do a single cycle manipulation rather than a bit-by-bit change
    27ee:	84 2b       	or	r24, r20
    27f0:	82 b9       	out	0x02, r24	; 2
	((switch_state_byte >> VCO2_SAW_SW) & 1) << VCO2_SAW_LATCH_BIT |
	((switch_state_byte >> VCO2_TRI_SW) & 1) << VCO2_TRI_LATCH_BIT |
	((switch_state_byte >> VCO2_PULSE_SW) & 1) << VCO2_PULSE_LATCH_BIT |
	//BMOD_SW_ON << BMOD_LATCH_BIT;
	((switch_state_byte >> 3) & 1) << BMOD_LATCH_BIT;
	VCO_SW_LATCH_PORT |= (1<<VCO_SW_LATCH);
    27f2:	80 81       	ld	r24, Z
    27f4:	80 64       	ori	r24, 0x40	; 64
    27f6:	80 83       	st	Z, r24
	
	VCO_SW_LATCH_PORT &= ~(1<<VCO_SW_LATCH);
    27f8:	80 81       	ld	r24, Z
    27fa:	8f 7b       	andi	r24, 0xBF	; 191
    27fc:	80 83       	st	Z, r24
	DATA_BUS = 0;
    27fe:	12 b8       	out	0x02, r1	; 2
	
	
    2800:	08 95       	ret

00002802 <bytequeue_init>:
//along with avr-bytequeue.  If not, see <http://www.gnu.org/licenses/>.

#include "bytequeue.h"
#include "interrupt_setting.h"

void bytequeue_init(byteQueue_t * queue, uint8_t * dataArray, byteQueueIndex_t arrayLen){
    2802:	fc 01       	movw	r30, r24
   queue->length = arrayLen;
    2804:	42 83       	std	Z+2, r20	; 0x02
   queue->data = dataArray;
    2806:	74 83       	std	Z+4, r23	; 0x04
    2808:	63 83       	std	Z+3, r22	; 0x03
   queue->start = queue->end = 0;
    280a:	11 82       	std	Z+1, r1	; 0x01
    280c:	10 82       	st	Z, r1
}
    280e:	08 95       	ret

00002810 <bytequeue_enqueue>:

bool bytequeue_enqueue(byteQueue_t * queue, uint8_t item){
    2810:	1f 93       	push	r17
    2812:	cf 93       	push	r28
    2814:	df 93       	push	r29
    2816:	ec 01       	movw	r28, r24
    2818:	16 2f       	mov	r17, r22
   interrupt_setting_t setting = store_and_clear_interrupt();
    281a:	0e 94 77 14 	call	0x28ee	; 0x28ee <store_and_clear_interrupt>
    281e:	28 2f       	mov	r18, r24
   //full
   if(((queue->end + 1) % queue->length) == queue->start){
    2820:	39 81       	ldd	r19, Y+1	; 0x01
    2822:	83 2f       	mov	r24, r19
    2824:	90 e0       	ldi	r25, 0x00	; 0
    2826:	01 96       	adiw	r24, 0x01	; 1
    2828:	6a 81       	ldd	r22, Y+2	; 0x02
    282a:	70 e0       	ldi	r23, 0x00	; 0
    282c:	0e 94 ef 1a 	call	0x35de	; 0x35de <__divmodhi4>
    2830:	48 81       	ld	r20, Y
    2832:	50 e0       	ldi	r21, 0x00	; 0
    2834:	84 17       	cp	r24, r20
    2836:	95 07       	cpc	r25, r21
    2838:	29 f4       	brne	.+10     	; 0x2844 <bytequeue_enqueue+0x34>
      restore_interrupt_setting(setting);
    283a:	82 2f       	mov	r24, r18
    283c:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <restore_interrupt_setting>
      return false;
    2840:	80 e0       	ldi	r24, 0x00	; 0
    2842:	11 c0       	rjmp	.+34     	; 0x2866 <bytequeue_enqueue+0x56>
   } else {
      queue->data[queue->end] = item;
    2844:	eb 81       	ldd	r30, Y+3	; 0x03
    2846:	fc 81       	ldd	r31, Y+4	; 0x04
    2848:	e3 0f       	add	r30, r19
    284a:	f1 1d       	adc	r31, r1
    284c:	10 83       	st	Z, r17
      queue->end = (queue->end + 1) % queue->length;
    284e:	89 81       	ldd	r24, Y+1	; 0x01
    2850:	90 e0       	ldi	r25, 0x00	; 0
    2852:	01 96       	adiw	r24, 0x01	; 1
    2854:	6a 81       	ldd	r22, Y+2	; 0x02
    2856:	70 e0       	ldi	r23, 0x00	; 0
    2858:	0e 94 ef 1a 	call	0x35de	; 0x35de <__divmodhi4>
    285c:	89 83       	std	Y+1, r24	; 0x01
      restore_interrupt_setting(setting);
    285e:	82 2f       	mov	r24, r18
    2860:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <restore_interrupt_setting>
      return true;
    2864:	81 e0       	ldi	r24, 0x01	; 1
   }
}
    2866:	df 91       	pop	r29
    2868:	cf 91       	pop	r28
    286a:	1f 91       	pop	r17
    286c:	08 95       	ret

0000286e <bytequeue_length>:

byteQueueIndex_t bytequeue_length(byteQueue_t * queue){
    286e:	cf 93       	push	r28
    2870:	df 93       	push	r29
    2872:	ec 01       	movw	r28, r24
   byteQueueIndex_t len;
   interrupt_setting_t setting = store_and_clear_interrupt();
    2874:	0e 94 77 14 	call	0x28ee	; 0x28ee <store_and_clear_interrupt>
   if(queue->end >= queue->start)
    2878:	29 81       	ldd	r18, Y+1	; 0x01
    287a:	98 81       	ld	r25, Y
    287c:	29 17       	cp	r18, r25
    287e:	18 f0       	brcs	.+6      	; 0x2886 <bytequeue_length+0x18>
      len = queue->end - queue->start;
    2880:	c2 2f       	mov	r28, r18
    2882:	c9 1b       	sub	r28, r25
    2884:	03 c0       	rjmp	.+6      	; 0x288c <bytequeue_length+0x1e>
   else
      len = (queue->length - queue->start) + queue->end;
    2886:	ca 81       	ldd	r28, Y+2	; 0x02
    2888:	c2 0f       	add	r28, r18
    288a:	c9 1b       	sub	r28, r25
   restore_interrupt_setting(setting);
    288c:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <restore_interrupt_setting>
   return len;
}
    2890:	8c 2f       	mov	r24, r28
    2892:	df 91       	pop	r29
    2894:	cf 91       	pop	r28
    2896:	08 95       	ret

00002898 <bytequeue_get>:

//we don't need to avoid interrupts if there is only one reader
uint8_t bytequeue_get(byteQueue_t * queue, byteQueueIndex_t index){
    2898:	fc 01       	movw	r30, r24
   return queue->data[(queue->start + index) % queue->length];
    289a:	20 81       	ld	r18, Z
    289c:	86 2f       	mov	r24, r22
    289e:	90 e0       	ldi	r25, 0x00	; 0
    28a0:	82 0f       	add	r24, r18
    28a2:	91 1d       	adc	r25, r1
    28a4:	62 81       	ldd	r22, Z+2	; 0x02
    28a6:	70 e0       	ldi	r23, 0x00	; 0
    28a8:	0e 94 ef 1a 	call	0x35de	; 0x35de <__divmodhi4>
    28ac:	03 80       	ldd	r0, Z+3	; 0x03
    28ae:	f4 81       	ldd	r31, Z+4	; 0x04
    28b0:	e0 2d       	mov	r30, r0
    28b2:	e8 0f       	add	r30, r24
    28b4:	f9 1f       	adc	r31, r25
}
    28b6:	80 81       	ld	r24, Z
    28b8:	08 95       	ret

000028ba <bytequeue_remove>:

//we just update the start index to remove elements
void bytequeue_remove(byteQueue_t * queue, byteQueueIndex_t numToRemove){
    28ba:	1f 93       	push	r17
    28bc:	cf 93       	push	r28
    28be:	df 93       	push	r29
    28c0:	ec 01       	movw	r28, r24
    28c2:	16 2f       	mov	r17, r22
   interrupt_setting_t setting = store_and_clear_interrupt();
    28c4:	0e 94 77 14 	call	0x28ee	; 0x28ee <store_and_clear_interrupt>
    28c8:	48 2f       	mov	r20, r24
   queue->start = (queue->start + numToRemove) % queue->length;
    28ca:	88 81       	ld	r24, Y
    28cc:	21 2f       	mov	r18, r17
    28ce:	30 e0       	ldi	r19, 0x00	; 0
    28d0:	28 0f       	add	r18, r24
    28d2:	31 1d       	adc	r19, r1
    28d4:	6a 81       	ldd	r22, Y+2	; 0x02
    28d6:	c9 01       	movw	r24, r18
    28d8:	70 e0       	ldi	r23, 0x00	; 0
    28da:	0e 94 ef 1a 	call	0x35de	; 0x35de <__divmodhi4>
    28de:	88 83       	st	Y, r24
   restore_interrupt_setting(setting);
    28e0:	84 2f       	mov	r24, r20
    28e2:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <restore_interrupt_setting>
}
    28e6:	df 91       	pop	r29
    28e8:	cf 91       	pop	r28
    28ea:	1f 91       	pop	r17
    28ec:	08 95       	ret

000028ee <store_and_clear_interrupt>:

#include "interrupt_setting.h"
#include <avr/interrupt.h>

interrupt_setting_t store_and_clear_interrupt(void) {
   uint8_t sreg = SREG;
    28ee:	8f b7       	in	r24, 0x3f	; 63
   cli();
    28f0:	f8 94       	cli
   return sreg;
}
    28f2:	08 95       	ret

000028f4 <restore_interrupt_setting>:

void restore_interrupt_setting(interrupt_setting_t setting) {
   SREG = setting;
    28f4:	8f bf       	out	0x3f, r24	; 63
}
    28f6:	08 95       	ret

000028f8 <midi_is_statusbyte>:
#define NULL 0
#endif

bool midi_is_statusbyte(uint8_t theByte){
   return (bool)(theByte & MIDI_STATUSMASK);
}
    28f8:	88 1f       	adc	r24, r24
    28fa:	88 27       	eor	r24, r24
    28fc:	88 1f       	adc	r24, r24
    28fe:	08 95       	ret

00002900 <midi_is_realtime>:

bool midi_is_realtime(uint8_t theByte){
   return (theByte >= MIDI_CLOCK);
    2900:	91 e0       	ldi	r25, 0x01	; 1
    2902:	88 3f       	cpi	r24, 0xF8	; 248
    2904:	08 f4       	brcc	.+2      	; 0x2908 <midi_is_realtime+0x8>
    2906:	90 e0       	ldi	r25, 0x00	; 0
}
    2908:	89 2f       	mov	r24, r25
    290a:	08 95       	ret

0000290c <midi_packet_length>:

midi_packet_length_t midi_packet_length(uint8_t status){
   switch(status & 0xF0){
    290c:	28 2f       	mov	r18, r24
    290e:	30 e0       	ldi	r19, 0x00	; 0
    2910:	20 7f       	andi	r18, 0xF0	; 240
    2912:	30 70       	andi	r19, 0x00	; 0
    2914:	20 3c       	cpi	r18, 0xC0	; 192
    2916:	31 05       	cpc	r19, r1
    2918:	e9 f1       	breq	.+122    	; 0x2994 <midi_packet_length+0x88>
    291a:	21 3c       	cpi	r18, 0xC1	; 193
    291c:	31 05       	cpc	r19, r1
    291e:	8c f4       	brge	.+34     	; 0x2942 <midi_packet_length+0x36>
    2920:	20 39       	cpi	r18, 0x90	; 144
    2922:	31 05       	cpc	r19, r1
    2924:	e1 f0       	breq	.+56     	; 0x295e <midi_packet_length+0x52>
    2926:	21 39       	cpi	r18, 0x91	; 145
    2928:	31 05       	cpc	r19, r1
    292a:	24 f4       	brge	.+8      	; 0x2934 <midi_packet_length+0x28>
    292c:	20 38       	cpi	r18, 0x80	; 128
    292e:	31 05       	cpc	r19, r1
    2930:	79 f5       	brne	.+94     	; 0x2990 <midi_packet_length+0x84>
    2932:	15 c0       	rjmp	.+42     	; 0x295e <midi_packet_length+0x52>
    2934:	20 3a       	cpi	r18, 0xA0	; 160
    2936:	31 05       	cpc	r19, r1
    2938:	91 f0       	breq	.+36     	; 0x295e <midi_packet_length+0x52>
    293a:	20 3b       	cpi	r18, 0xB0	; 176
    293c:	31 05       	cpc	r19, r1
    293e:	41 f5       	brne	.+80     	; 0x2990 <midi_packet_length+0x84>
    2940:	0e c0       	rjmp	.+28     	; 0x295e <midi_packet_length+0x52>
    2942:	20 3e       	cpi	r18, 0xE0	; 224
    2944:	31 05       	cpc	r19, r1
    2946:	59 f0       	breq	.+22     	; 0x295e <midi_packet_length+0x52>
    2948:	21 3e       	cpi	r18, 0xE1	; 225
    294a:	31 05       	cpc	r19, r1
    294c:	24 f4       	brge	.+8      	; 0x2956 <midi_packet_length+0x4a>
    294e:	20 3d       	cpi	r18, 0xD0	; 208
    2950:	31 05       	cpc	r19, r1
    2952:	f1 f4       	brne	.+60     	; 0x2990 <midi_packet_length+0x84>
    2954:	1f c0       	rjmp	.+62     	; 0x2994 <midi_packet_length+0x88>
    2956:	20 3f       	cpi	r18, 0xF0	; 240
    2958:	31 05       	cpc	r19, r1
    295a:	d1 f4       	brne	.+52     	; 0x2990 <midi_packet_length+0x84>
    295c:	02 c0       	rjmp	.+4      	; 0x2962 <midi_packet_length+0x56>
      case MIDI_CC:
      case MIDI_NOTEON:
      case MIDI_NOTEOFF:
      case MIDI_AFTERTOUCH:
      case MIDI_PITCHBEND:
         return THREE3;
    295e:	83 e0       	ldi	r24, 0x03	; 3
    2960:	08 95       	ret
      case MIDI_PROGCHANGE:
      case MIDI_CHANPRESSURE:
      case MIDI_SONGSELECT:
         return TWO2;
      case 0xF0:
         switch(status) {
    2962:	86 3f       	cpi	r24, 0xF6	; 246
    2964:	79 f0       	breq	.+30     	; 0x2984 <midi_packet_length+0x78>
    2966:	87 3f       	cpi	r24, 0xF7	; 247
    2968:	38 f4       	brcc	.+14     	; 0x2978 <midi_packet_length+0x6c>
    296a:	82 3f       	cpi	r24, 0xF2	; 242
    296c:	a9 f0       	breq	.+42     	; 0x2998 <midi_packet_length+0x8c>
    296e:	83 3f       	cpi	r24, 0xF3	; 243
    2970:	59 f0       	breq	.+22     	; 0x2988 <midi_packet_length+0x7c>
    2972:	81 3f       	cpi	r24, 0xF1	; 241
    2974:	59 f4       	brne	.+22     	; 0x298c <midi_packet_length+0x80>
    2976:	08 c0       	rjmp	.+16     	; 0x2988 <midi_packet_length+0x7c>
    2978:	88 3f       	cpi	r24, 0xF8	; 248
    297a:	40 f0       	brcs	.+16     	; 0x298c <midi_packet_length+0x80>
    297c:	8d 3f       	cpi	r24, 0xFD	; 253
    297e:	10 f0       	brcs	.+4      	; 0x2984 <midi_packet_length+0x78>
    2980:	8e 3f       	cpi	r24, 0xFE	; 254
    2982:	20 f0       	brcs	.+8      	; 0x298c <midi_packet_length+0x80>
            case MIDI_CONTINUE:
            case MIDI_STOP:
            case MIDI_ACTIVESENSE:
            case MIDI_RESET:
            case MIDI_TUNEREQUEST:
               return ONE1;
    2984:	81 e0       	ldi	r24, 0x01	; 1
    2986:	08 95       	ret
            case MIDI_SONGPOSITION:
               return THREE3;
            case MIDI_TC_QUARTERFRAME:
            case MIDI_SONGSELECT:
               return TWO2;
    2988:	82 e0       	ldi	r24, 0x02	; 2
    298a:	08 95       	ret
            case SYSEX_END:
            case SYSEX_BEGIN:
            default:
               return UNDEFINED;
    298c:	80 e0       	ldi	r24, 0x00	; 0
    298e:	08 95       	ret
         }
      default:
         return UNDEFINED;
    2990:	80 e0       	ldi	r24, 0x00	; 0
    2992:	08 95       	ret
      case MIDI_PITCHBEND:
         return THREE3;
      case MIDI_PROGCHANGE:
      case MIDI_CHANPRESSURE:
      case MIDI_SONGSELECT:
         return TWO2;
    2994:	82 e0       	ldi	r24, 0x02	; 2
    2996:	08 95       	ret
            case MIDI_ACTIVESENSE:
            case MIDI_RESET:
            case MIDI_TUNEREQUEST:
               return ONE1;
            case MIDI_SONGPOSITION:
               return THREE3;
    2998:	83 e0       	ldi	r24, 0x03	; 3
               return UNDEFINED;
         }
      default:
         return UNDEFINED;
   }
}
    299a:	08 95       	ret

0000299c <midi_send_cc>:

void midi_send_cc(MidiDevice * device, uint8_t chan, uint8_t num, uint8_t val){
    299c:	0f 93       	push	r16
    299e:	34 2f       	mov	r19, r20
    29a0:	02 2f       	mov	r16, r18
   //CC Status: 0xB0 to 0xBF where the low nibble is the MIDI channel.
   //CC Data: Controller Num, Controller Val
   device->send_func(device, 3,
    29a2:	46 2f       	mov	r20, r22
    29a4:	4f 70       	andi	r20, 0x0F	; 15
    29a6:	40 6b       	ori	r20, 0xB0	; 176
    29a8:	23 2f       	mov	r18, r19
    29aa:	2f 77       	andi	r18, 0x7F	; 127
    29ac:	0f 77       	andi	r16, 0x7F	; 127
    29ae:	dc 01       	movw	r26, r24
    29b0:	ed 91       	ld	r30, X+
    29b2:	fc 91       	ld	r31, X
    29b4:	63 e0       	ldi	r22, 0x03	; 3
    29b6:	70 e0       	ldi	r23, 0x00	; 0
    29b8:	09 95       	icall
         MIDI_CC | (chan & MIDI_CHANMASK),
         num & 0x7F,
         val & 0x7F);
}
    29ba:	0f 91       	pop	r16
    29bc:	08 95       	ret

000029be <midi_send_noteon>:

void midi_send_noteon(MidiDevice * device, uint8_t chan, uint8_t num, uint8_t vel){
    29be:	0f 93       	push	r16
    29c0:	34 2f       	mov	r19, r20
    29c2:	02 2f       	mov	r16, r18
   //Note Data: Note Num, Note Velocity
   device->send_func(device, 3,
    29c4:	46 2f       	mov	r20, r22
    29c6:	4f 70       	andi	r20, 0x0F	; 15
    29c8:	40 69       	ori	r20, 0x90	; 144
    29ca:	23 2f       	mov	r18, r19
    29cc:	2f 77       	andi	r18, 0x7F	; 127
    29ce:	0f 77       	andi	r16, 0x7F	; 127
    29d0:	dc 01       	movw	r26, r24
    29d2:	ed 91       	ld	r30, X+
    29d4:	fc 91       	ld	r31, X
    29d6:	63 e0       	ldi	r22, 0x03	; 3
    29d8:	70 e0       	ldi	r23, 0x00	; 0
    29da:	09 95       	icall
         MIDI_NOTEON | (chan & MIDI_CHANMASK),
         num & 0x7F,
         vel & 0x7F);
}
    29dc:	0f 91       	pop	r16
    29de:	08 95       	ret

000029e0 <midi_send_noteoff>:

void midi_send_noteoff(MidiDevice * device, uint8_t chan, uint8_t num, uint8_t vel){
    29e0:	0f 93       	push	r16
    29e2:	34 2f       	mov	r19, r20
    29e4:	02 2f       	mov	r16, r18
   //Note Data: Note Num, Note Velocity
   device->send_func(device, 3,
    29e6:	46 2f       	mov	r20, r22
    29e8:	4f 70       	andi	r20, 0x0F	; 15
    29ea:	40 68       	ori	r20, 0x80	; 128
    29ec:	23 2f       	mov	r18, r19
    29ee:	2f 77       	andi	r18, 0x7F	; 127
    29f0:	0f 77       	andi	r16, 0x7F	; 127
    29f2:	dc 01       	movw	r26, r24
    29f4:	ed 91       	ld	r30, X+
    29f6:	fc 91       	ld	r31, X
    29f8:	63 e0       	ldi	r22, 0x03	; 3
    29fa:	70 e0       	ldi	r23, 0x00	; 0
    29fc:	09 95       	icall
         MIDI_NOTEOFF | (chan & MIDI_CHANMASK),
         num & 0x7F,
         vel & 0x7F);
}
    29fe:	0f 91       	pop	r16
    2a00:	08 95       	ret

00002a02 <midi_send_aftertouch>:

void midi_send_aftertouch(MidiDevice * device, uint8_t chan, uint8_t note_num, uint8_t amt){
    2a02:	0f 93       	push	r16
    2a04:	34 2f       	mov	r19, r20
    2a06:	02 2f       	mov	r16, r18
   device->send_func(device, 3,
    2a08:	46 2f       	mov	r20, r22
    2a0a:	4f 70       	andi	r20, 0x0F	; 15
    2a0c:	40 6a       	ori	r20, 0xA0	; 160
    2a0e:	23 2f       	mov	r18, r19
    2a10:	2f 77       	andi	r18, 0x7F	; 127
    2a12:	0f 77       	andi	r16, 0x7F	; 127
    2a14:	dc 01       	movw	r26, r24
    2a16:	ed 91       	ld	r30, X+
    2a18:	fc 91       	ld	r31, X
    2a1a:	63 e0       	ldi	r22, 0x03	; 3
    2a1c:	70 e0       	ldi	r23, 0x00	; 0
    2a1e:	09 95       	icall
         MIDI_AFTERTOUCH | (chan & MIDI_CHANMASK),
         note_num & 0x7F,
         amt & 0x7F);
}
    2a20:	0f 91       	pop	r16
    2a22:	08 95       	ret

00002a24 <midi_send_pitchbend>:

//XXX does this work right?
//amt in range -0x2000, 0x1fff
//uAmt should be in range..
//0x0000 to 0x3FFF
void midi_send_pitchbend(MidiDevice * device, uint8_t chan, int16_t amt){
    2a24:	0f 93       	push	r16
    2a26:	1f 93       	push	r17
   uint16_t uAmt;
   //check range
   if(amt > 0x1fff){
    2a28:	20 e2       	ldi	r18, 0x20	; 32
    2a2a:	40 30       	cpi	r20, 0x00	; 0
    2a2c:	52 07       	cpc	r21, r18
    2a2e:	44 f4       	brge	.+16     	; 0x2a40 <midi_send_pitchbend+0x1c>
      uAmt = 0x3FFF;
   } else if(amt < -0x2000){
    2a30:	a0 ee       	ldi	r26, 0xE0	; 224
    2a32:	40 30       	cpi	r20, 0x00	; 0
    2a34:	5a 07       	cpc	r21, r26
    2a36:	3c f0       	brlt	.+14     	; 0x2a46 <midi_send_pitchbend+0x22>
      uAmt = 0;
   } else {
      uAmt = amt + 0x2000;
    2a38:	8a 01       	movw	r16, r20
    2a3a:	00 50       	subi	r16, 0x00	; 0
    2a3c:	10 4e       	sbci	r17, 0xE0	; 224
    2a3e:	05 c0       	rjmp	.+10     	; 0x2a4a <midi_send_pitchbend+0x26>
//0x0000 to 0x3FFF
void midi_send_pitchbend(MidiDevice * device, uint8_t chan, int16_t amt){
   uint16_t uAmt;
   //check range
   if(amt > 0x1fff){
      uAmt = 0x3FFF;
    2a40:	0f ef       	ldi	r16, 0xFF	; 255
    2a42:	1f e3       	ldi	r17, 0x3F	; 63
    2a44:	02 c0       	rjmp	.+4      	; 0x2a4a <midi_send_pitchbend+0x26>
   } else if(amt < -0x2000){
      uAmt = 0;
    2a46:	00 e0       	ldi	r16, 0x00	; 0
    2a48:	10 e0       	ldi	r17, 0x00	; 0
   } else {
      uAmt = amt + 0x2000;
   }
   device->send_func(device, 3,
    2a4a:	46 2f       	mov	r20, r22
    2a4c:	4f 70       	andi	r20, 0x0F	; 15
    2a4e:	40 6e       	ori	r20, 0xE0	; 224
    2a50:	20 2f       	mov	r18, r16
    2a52:	2f 77       	andi	r18, 0x7F	; 127
         MIDI_PITCHBEND | (chan & MIDI_CHANMASK),
         uAmt & 0x7F,
         (uAmt >> 7) & 0x7F);
    2a54:	00 0f       	add	r16, r16
    2a56:	01 2f       	mov	r16, r17
    2a58:	00 1f       	adc	r16, r16
    2a5a:	11 0b       	sbc	r17, r17
    2a5c:	11 95       	neg	r17
   } else if(amt < -0x2000){
      uAmt = 0;
   } else {
      uAmt = amt + 0x2000;
   }
   device->send_func(device, 3,
    2a5e:	0f 77       	andi	r16, 0x7F	; 127
    2a60:	dc 01       	movw	r26, r24
    2a62:	ed 91       	ld	r30, X+
    2a64:	fc 91       	ld	r31, X
    2a66:	63 e0       	ldi	r22, 0x03	; 3
    2a68:	70 e0       	ldi	r23, 0x00	; 0
    2a6a:	09 95       	icall
         MIDI_PITCHBEND | (chan & MIDI_CHANMASK),
         uAmt & 0x7F,
         (uAmt >> 7) & 0x7F);
}
    2a6c:	1f 91       	pop	r17
    2a6e:	0f 91       	pop	r16
    2a70:	08 95       	ret

00002a72 <midi_send_programchange>:

void midi_send_programchange(MidiDevice * device, uint8_t chan, uint8_t num){
    2a72:	0f 93       	push	r16
    2a74:	24 2f       	mov	r18, r20
   device->send_func(device, 2,
    2a76:	46 2f       	mov	r20, r22
    2a78:	4f 70       	andi	r20, 0x0F	; 15
    2a7a:	40 6c       	ori	r20, 0xC0	; 192
    2a7c:	2f 77       	andi	r18, 0x7F	; 127
    2a7e:	dc 01       	movw	r26, r24
    2a80:	ed 91       	ld	r30, X+
    2a82:	fc 91       	ld	r31, X
    2a84:	62 e0       	ldi	r22, 0x02	; 2
    2a86:	70 e0       	ldi	r23, 0x00	; 0
    2a88:	00 e0       	ldi	r16, 0x00	; 0
    2a8a:	09 95       	icall
         MIDI_PROGCHANGE | (chan & MIDI_CHANMASK),
         num & 0x7F,
         0);
}
    2a8c:	0f 91       	pop	r16
    2a8e:	08 95       	ret

00002a90 <midi_send_channelpressure>:

void midi_send_channelpressure(MidiDevice * device, uint8_t chan, uint8_t amt){
    2a90:	0f 93       	push	r16
    2a92:	24 2f       	mov	r18, r20
   device->send_func(device, 2,
    2a94:	46 2f       	mov	r20, r22
    2a96:	4f 70       	andi	r20, 0x0F	; 15
    2a98:	40 6d       	ori	r20, 0xD0	; 208
    2a9a:	2f 77       	andi	r18, 0x7F	; 127
    2a9c:	dc 01       	movw	r26, r24
    2a9e:	ed 91       	ld	r30, X+
    2aa0:	fc 91       	ld	r31, X
    2aa2:	62 e0       	ldi	r22, 0x02	; 2
    2aa4:	70 e0       	ldi	r23, 0x00	; 0
    2aa6:	00 e0       	ldi	r16, 0x00	; 0
    2aa8:	09 95       	icall
         MIDI_CHANPRESSURE | (chan & MIDI_CHANMASK),
         amt & 0x7F,
         0);
}
    2aaa:	0f 91       	pop	r16
    2aac:	08 95       	ret

00002aae <midi_send_clock>:

void midi_send_clock(MidiDevice * device){
    2aae:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_CLOCK, 0, 0);
    2ab0:	dc 01       	movw	r26, r24
    2ab2:	ed 91       	ld	r30, X+
    2ab4:	fc 91       	ld	r31, X
    2ab6:	61 e0       	ldi	r22, 0x01	; 1
    2ab8:	70 e0       	ldi	r23, 0x00	; 0
    2aba:	48 ef       	ldi	r20, 0xF8	; 248
    2abc:	20 e0       	ldi	r18, 0x00	; 0
    2abe:	00 e0       	ldi	r16, 0x00	; 0
    2ac0:	09 95       	icall
}
    2ac2:	0f 91       	pop	r16
    2ac4:	08 95       	ret

00002ac6 <midi_send_tick>:

void midi_send_tick(MidiDevice * device){
    2ac6:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_TICK, 0, 0);
    2ac8:	dc 01       	movw	r26, r24
    2aca:	ed 91       	ld	r30, X+
    2acc:	fc 91       	ld	r31, X
    2ace:	61 e0       	ldi	r22, 0x01	; 1
    2ad0:	70 e0       	ldi	r23, 0x00	; 0
    2ad2:	49 ef       	ldi	r20, 0xF9	; 249
    2ad4:	20 e0       	ldi	r18, 0x00	; 0
    2ad6:	00 e0       	ldi	r16, 0x00	; 0
    2ad8:	09 95       	icall
}
    2ada:	0f 91       	pop	r16
    2adc:	08 95       	ret

00002ade <midi_send_start>:

void midi_send_start(MidiDevice * device){
    2ade:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_START, 0, 0);
    2ae0:	dc 01       	movw	r26, r24
    2ae2:	ed 91       	ld	r30, X+
    2ae4:	fc 91       	ld	r31, X
    2ae6:	61 e0       	ldi	r22, 0x01	; 1
    2ae8:	70 e0       	ldi	r23, 0x00	; 0
    2aea:	4a ef       	ldi	r20, 0xFA	; 250
    2aec:	20 e0       	ldi	r18, 0x00	; 0
    2aee:	00 e0       	ldi	r16, 0x00	; 0
    2af0:	09 95       	icall
}
    2af2:	0f 91       	pop	r16
    2af4:	08 95       	ret

00002af6 <midi_send_continue>:

void midi_send_continue(MidiDevice * device){
    2af6:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_CONTINUE, 0, 0);
    2af8:	dc 01       	movw	r26, r24
    2afa:	ed 91       	ld	r30, X+
    2afc:	fc 91       	ld	r31, X
    2afe:	61 e0       	ldi	r22, 0x01	; 1
    2b00:	70 e0       	ldi	r23, 0x00	; 0
    2b02:	4b ef       	ldi	r20, 0xFB	; 251
    2b04:	20 e0       	ldi	r18, 0x00	; 0
    2b06:	00 e0       	ldi	r16, 0x00	; 0
    2b08:	09 95       	icall
}
    2b0a:	0f 91       	pop	r16
    2b0c:	08 95       	ret

00002b0e <midi_send_stop>:

void midi_send_stop(MidiDevice * device){
    2b0e:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_STOP, 0, 0);
    2b10:	dc 01       	movw	r26, r24
    2b12:	ed 91       	ld	r30, X+
    2b14:	fc 91       	ld	r31, X
    2b16:	61 e0       	ldi	r22, 0x01	; 1
    2b18:	70 e0       	ldi	r23, 0x00	; 0
    2b1a:	4c ef       	ldi	r20, 0xFC	; 252
    2b1c:	20 e0       	ldi	r18, 0x00	; 0
    2b1e:	00 e0       	ldi	r16, 0x00	; 0
    2b20:	09 95       	icall
}
    2b22:	0f 91       	pop	r16
    2b24:	08 95       	ret

00002b26 <midi_send_activesense>:

void midi_send_activesense(MidiDevice * device){
    2b26:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_ACTIVESENSE, 0, 0);
    2b28:	dc 01       	movw	r26, r24
    2b2a:	ed 91       	ld	r30, X+
    2b2c:	fc 91       	ld	r31, X
    2b2e:	61 e0       	ldi	r22, 0x01	; 1
    2b30:	70 e0       	ldi	r23, 0x00	; 0
    2b32:	4e ef       	ldi	r20, 0xFE	; 254
    2b34:	20 e0       	ldi	r18, 0x00	; 0
    2b36:	00 e0       	ldi	r16, 0x00	; 0
    2b38:	09 95       	icall
}
    2b3a:	0f 91       	pop	r16
    2b3c:	08 95       	ret

00002b3e <midi_send_reset>:

void midi_send_reset(MidiDevice * device){
    2b3e:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_RESET, 0, 0);
    2b40:	dc 01       	movw	r26, r24
    2b42:	ed 91       	ld	r30, X+
    2b44:	fc 91       	ld	r31, X
    2b46:	61 e0       	ldi	r22, 0x01	; 1
    2b48:	70 e0       	ldi	r23, 0x00	; 0
    2b4a:	4f ef       	ldi	r20, 0xFF	; 255
    2b4c:	20 e0       	ldi	r18, 0x00	; 0
    2b4e:	00 e0       	ldi	r16, 0x00	; 0
    2b50:	09 95       	icall
}
    2b52:	0f 91       	pop	r16
    2b54:	08 95       	ret

00002b56 <midi_send_tcquarterframe>:

void midi_send_tcquarterframe(MidiDevice * device, uint8_t time){
    2b56:	0f 93       	push	r16
   device->send_func(device, 2,
    2b58:	26 2f       	mov	r18, r22
    2b5a:	2f 77       	andi	r18, 0x7F	; 127
    2b5c:	dc 01       	movw	r26, r24
    2b5e:	ed 91       	ld	r30, X+
    2b60:	fc 91       	ld	r31, X
    2b62:	62 e0       	ldi	r22, 0x02	; 2
    2b64:	70 e0       	ldi	r23, 0x00	; 0
    2b66:	41 ef       	ldi	r20, 0xF1	; 241
    2b68:	00 e0       	ldi	r16, 0x00	; 0
    2b6a:	09 95       	icall
         MIDI_TC_QUARTERFRAME,
         time & 0x7F,
         0);
}
    2b6c:	0f 91       	pop	r16
    2b6e:	08 95       	ret

00002b70 <midi_send_songposition>:

//XXX is this right?
void midi_send_songposition(MidiDevice * device, uint16_t pos){
    2b70:	0f 93       	push	r16
    2b72:	1f 93       	push	r17
   device->send_func(device, 3,
    2b74:	26 2f       	mov	r18, r22
    2b76:	2f 77       	andi	r18, 0x7F	; 127
         MIDI_SONGPOSITION,
         pos & 0x7F,
         (pos >> 7) & 0x7F);
    2b78:	8b 01       	movw	r16, r22
    2b7a:	00 0f       	add	r16, r16
    2b7c:	01 2f       	mov	r16, r17
    2b7e:	00 1f       	adc	r16, r16
    2b80:	11 0b       	sbc	r17, r17
    2b82:	11 95       	neg	r17
         0);
}

//XXX is this right?
void midi_send_songposition(MidiDevice * device, uint16_t pos){
   device->send_func(device, 3,
    2b84:	0f 77       	andi	r16, 0x7F	; 127
    2b86:	dc 01       	movw	r26, r24
    2b88:	ed 91       	ld	r30, X+
    2b8a:	fc 91       	ld	r31, X
    2b8c:	63 e0       	ldi	r22, 0x03	; 3
    2b8e:	70 e0       	ldi	r23, 0x00	; 0
    2b90:	42 ef       	ldi	r20, 0xF2	; 242
    2b92:	09 95       	icall
         MIDI_SONGPOSITION,
         pos & 0x7F,
         (pos >> 7) & 0x7F);
}
    2b94:	1f 91       	pop	r17
    2b96:	0f 91       	pop	r16
    2b98:	08 95       	ret

00002b9a <midi_send_songselect>:

void midi_send_songselect(MidiDevice * device, uint8_t song){
    2b9a:	0f 93       	push	r16
   device->send_func(device, 2,
    2b9c:	26 2f       	mov	r18, r22
    2b9e:	2f 77       	andi	r18, 0x7F	; 127
    2ba0:	dc 01       	movw	r26, r24
    2ba2:	ed 91       	ld	r30, X+
    2ba4:	fc 91       	ld	r31, X
    2ba6:	62 e0       	ldi	r22, 0x02	; 2
    2ba8:	70 e0       	ldi	r23, 0x00	; 0
    2baa:	43 ef       	ldi	r20, 0xF3	; 243
    2bac:	00 e0       	ldi	r16, 0x00	; 0
    2bae:	09 95       	icall
         MIDI_SONGSELECT,
         song & 0x7F,
         0);
}
    2bb0:	0f 91       	pop	r16
    2bb2:	08 95       	ret

00002bb4 <midi_send_tunerequest>:

void midi_send_tunerequest(MidiDevice * device){
    2bb4:	0f 93       	push	r16
   device->send_func(device, 1, MIDI_TUNEREQUEST, 0, 0);
    2bb6:	dc 01       	movw	r26, r24
    2bb8:	ed 91       	ld	r30, X+
    2bba:	fc 91       	ld	r31, X
    2bbc:	61 e0       	ldi	r22, 0x01	; 1
    2bbe:	70 e0       	ldi	r23, 0x00	; 0
    2bc0:	46 ef       	ldi	r20, 0xF6	; 246
    2bc2:	20 e0       	ldi	r18, 0x00	; 0
    2bc4:	00 e0       	ldi	r16, 0x00	; 0
    2bc6:	09 95       	icall
}
    2bc8:	0f 91       	pop	r16
    2bca:	08 95       	ret

00002bcc <midi_send_byte>:

void midi_send_byte(MidiDevice * device, uint8_t b){
    2bcc:	0f 93       	push	r16
    2bce:	46 2f       	mov	r20, r22
   device->send_func(device, 1, b, 0, 0);
    2bd0:	dc 01       	movw	r26, r24
    2bd2:	ed 91       	ld	r30, X+
    2bd4:	fc 91       	ld	r31, X
    2bd6:	61 e0       	ldi	r22, 0x01	; 1
    2bd8:	70 e0       	ldi	r23, 0x00	; 0
    2bda:	20 e0       	ldi	r18, 0x00	; 0
    2bdc:	00 e0       	ldi	r16, 0x00	; 0
    2bde:	09 95       	icall
}
    2be0:	0f 91       	pop	r16
    2be2:	08 95       	ret

00002be4 <midi_send_data>:

void midi_send_data(MidiDevice * device, uint16_t count, uint8_t byte0, uint8_t byte1, uint8_t byte2){
    2be4:	0f 93       	push	r16
   //ensure that the count passed along is always 3 or lower
   if (count > 3) {
      //TODO how to do this correctly?
   }
   device->send_func(device, count, byte0, byte1, byte2);
    2be6:	dc 01       	movw	r26, r24
    2be8:	ed 91       	ld	r30, X+
    2bea:	fc 91       	ld	r31, X
    2bec:	09 95       	icall
}
    2bee:	0f 91       	pop	r16
    2bf0:	08 95       	ret

00002bf2 <midi_send_array>:

void midi_send_array(MidiDevice * device, uint16_t count, uint8_t * array) {
    2bf2:	6f 92       	push	r6
    2bf4:	7f 92       	push	r7
    2bf6:	8f 92       	push	r8
    2bf8:	9f 92       	push	r9
    2bfa:	af 92       	push	r10
    2bfc:	bf 92       	push	r11
    2bfe:	cf 92       	push	r12
    2c00:	df 92       	push	r13
    2c02:	ef 92       	push	r14
    2c04:	ff 92       	push	r15
    2c06:	0f 93       	push	r16
    2c08:	1f 93       	push	r17
    2c0a:	cf 93       	push	r28
    2c0c:	df 93       	push	r29
    2c0e:	00 d0       	rcall	.+0      	; 0x2c10 <midi_send_array+0x1e>
    2c10:	0f 92       	push	r0
    2c12:	cd b7       	in	r28, 0x3d	; 61
    2c14:	de b7       	in	r29, 0x3e	; 62
    2c16:	4c 01       	movw	r8, r24
    2c18:	6b 01       	movw	r12, r22
    2c1a:	5a 01       	movw	r10, r20
  uint16_t i;
  for (i = 0; i < count; i += 3) {
    2c1c:	61 15       	cp	r22, r1
    2c1e:	71 05       	cpc	r23, r1
    2c20:	41 f1       	breq	.+80     	; 0x2c72 <midi_send_array+0x80>
    2c22:	ee 24       	eor	r14, r14
    2c24:	ff 24       	eor	r15, r15
    uint8_t b[3] = { 0, 0, 0 };
    uint16_t to_send = count - i;
    to_send = (to_send > 3) ? 3 : to_send;
    2c26:	0f 2e       	mov	r0, r31
    2c28:	f3 e0       	ldi	r31, 0x03	; 3
    2c2a:	6f 2e       	mov	r6, r31
    2c2c:	77 24       	eor	r7, r7
    2c2e:	f0 2d       	mov	r31, r0
}

void midi_send_array(MidiDevice * device, uint16_t count, uint8_t * array) {
  uint16_t i;
  for (i = 0; i < count; i += 3) {
    uint8_t b[3] = { 0, 0, 0 };
    2c30:	19 82       	std	Y+1, r1	; 0x01
    2c32:	1a 82       	std	Y+2, r1	; 0x02
    2c34:	1b 82       	std	Y+3, r1	; 0x03
    uint16_t to_send = count - i;
    2c36:	86 01       	movw	r16, r12
    2c38:	0e 19       	sub	r16, r14
    2c3a:	1f 09       	sbc	r17, r15
    to_send = (to_send > 3) ? 3 : to_send;
    2c3c:	04 30       	cpi	r16, 0x04	; 4
    2c3e:	11 05       	cpc	r17, r1
    2c40:	08 f0       	brcs	.+2      	; 0x2c44 <midi_send_array+0x52>
    2c42:	83 01       	movw	r16, r6
      //TODO how to do this correctly?
   }
   device->send_func(device, count, byte0, byte1, byte2);
}

void midi_send_array(MidiDevice * device, uint16_t count, uint8_t * array) {
    2c44:	b5 01       	movw	r22, r10
    2c46:	6e 0d       	add	r22, r14
    2c48:	7f 1d       	adc	r23, r15
  uint16_t i;
  for (i = 0; i < count; i += 3) {
    uint8_t b[3] = { 0, 0, 0 };
    uint16_t to_send = count - i;
    to_send = (to_send > 3) ? 3 : to_send;
    memcpy(b, array + i, to_send);
    2c4a:	ce 01       	movw	r24, r28
    2c4c:	01 96       	adiw	r24, 0x01	; 1
    2c4e:	40 2f       	mov	r20, r16
    2c50:	51 2f       	mov	r21, r17
    2c52:	0e 94 02 1b 	call	0x3604	; 0x3604 <memcpy>
    midi_send_data(device, to_send, b[0], b[1], b[2]);
    2c56:	c4 01       	movw	r24, r8
    2c58:	b8 01       	movw	r22, r16
    2c5a:	49 81       	ldd	r20, Y+1	; 0x01
    2c5c:	2a 81       	ldd	r18, Y+2	; 0x02
    2c5e:	0b 81       	ldd	r16, Y+3	; 0x03
    2c60:	0e 94 f2 15 	call	0x2be4	; 0x2be4 <midi_send_data>
   device->send_func(device, count, byte0, byte1, byte2);
}

void midi_send_array(MidiDevice * device, uint16_t count, uint8_t * array) {
  uint16_t i;
  for (i = 0; i < count; i += 3) {
    2c64:	83 e0       	ldi	r24, 0x03	; 3
    2c66:	90 e0       	ldi	r25, 0x00	; 0
    2c68:	e8 0e       	add	r14, r24
    2c6a:	f9 1e       	adc	r15, r25
    2c6c:	ec 14       	cp	r14, r12
    2c6e:	fd 04       	cpc	r15, r13
    2c70:	f8 f2       	brcs	.-66     	; 0x2c30 <midi_send_array+0x3e>
    uint16_t to_send = count - i;
    to_send = (to_send > 3) ? 3 : to_send;
    memcpy(b, array + i, to_send);
    midi_send_data(device, to_send, b[0], b[1], b[2]);
  }
}
    2c72:	0f 90       	pop	r0
    2c74:	0f 90       	pop	r0
    2c76:	0f 90       	pop	r0
    2c78:	df 91       	pop	r29
    2c7a:	cf 91       	pop	r28
    2c7c:	1f 91       	pop	r17
    2c7e:	0f 91       	pop	r16
    2c80:	ff 90       	pop	r15
    2c82:	ef 90       	pop	r14
    2c84:	df 90       	pop	r13
    2c86:	cf 90       	pop	r12
    2c88:	bf 90       	pop	r11
    2c8a:	af 90       	pop	r10
    2c8c:	9f 90       	pop	r9
    2c8e:	8f 90       	pop	r8
    2c90:	7f 90       	pop	r7
    2c92:	6f 90       	pop	r6
    2c94:	08 95       	ret

00002c96 <midi_register_cc_callback>:


void midi_register_cc_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_cc_callback = func;
    2c96:	fc 01       	movw	r30, r24
    2c98:	73 83       	std	Z+3, r23	; 0x03
    2c9a:	62 83       	std	Z+2, r22	; 0x02
}
    2c9c:	08 95       	ret

00002c9e <midi_register_noteon_callback>:

void midi_register_noteon_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_noteon_callback = func;
    2c9e:	fc 01       	movw	r30, r24
    2ca0:	75 83       	std	Z+5, r23	; 0x05
    2ca2:	64 83       	std	Z+4, r22	; 0x04
}
    2ca4:	08 95       	ret

00002ca6 <midi_register_noteoff_callback>:

void midi_register_noteoff_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_noteoff_callback = func;
    2ca6:	fc 01       	movw	r30, r24
    2ca8:	77 83       	std	Z+7, r23	; 0x07
    2caa:	66 83       	std	Z+6, r22	; 0x06
}
    2cac:	08 95       	ret

00002cae <midi_register_aftertouch_callback>:

void midi_register_aftertouch_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_aftertouch_callback = func;
    2cae:	fc 01       	movw	r30, r24
    2cb0:	71 87       	std	Z+9, r23	; 0x09
    2cb2:	60 87       	std	Z+8, r22	; 0x08
}
    2cb4:	08 95       	ret

00002cb6 <midi_register_pitchbend_callback>:

void midi_register_pitchbend_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_pitchbend_callback = func;
    2cb6:	fc 01       	movw	r30, r24
    2cb8:	73 87       	std	Z+11, r23	; 0x0b
    2cba:	62 87       	std	Z+10, r22	; 0x0a
}
    2cbc:	08 95       	ret

00002cbe <midi_register_songposition_callback>:

void midi_register_songposition_callback(MidiDevice * device, midi_three_byte_func_t func){
   device->input_songposition_callback = func;
    2cbe:	fc 01       	movw	r30, r24
    2cc0:	75 87       	std	Z+13, r23	; 0x0d
    2cc2:	64 87       	std	Z+12, r22	; 0x0c
}
    2cc4:	08 95       	ret

00002cc6 <midi_register_progchange_callback>:

void midi_register_progchange_callback(MidiDevice * device, midi_two_byte_func_t func) {
   device->input_progchange_callback = func;
    2cc6:	fc 01       	movw	r30, r24
    2cc8:	77 87       	std	Z+15, r23	; 0x0f
    2cca:	66 87       	std	Z+14, r22	; 0x0e
}
    2ccc:	08 95       	ret

00002cce <midi_register_chanpressure_callback>:

void midi_register_chanpressure_callback(MidiDevice * device, midi_two_byte_func_t func) {
   device->input_chanpressure_callback = func;
    2cce:	fc 01       	movw	r30, r24
    2cd0:	71 8b       	std	Z+17, r23	; 0x11
    2cd2:	60 8b       	std	Z+16, r22	; 0x10
}
    2cd4:	08 95       	ret

00002cd6 <midi_register_songselect_callback>:

void midi_register_songselect_callback(MidiDevice * device, midi_two_byte_func_t func) {
   device->input_songselect_callback = func;
    2cd6:	fc 01       	movw	r30, r24
    2cd8:	73 8b       	std	Z+19, r23	; 0x13
    2cda:	62 8b       	std	Z+18, r22	; 0x12
}
    2cdc:	08 95       	ret

00002cde <midi_register_tc_quarterframe_callback>:

void midi_register_tc_quarterframe_callback(MidiDevice * device, midi_two_byte_func_t func) {
   device->input_tc_quarterframe_callback = func;
    2cde:	fc 01       	movw	r30, r24
    2ce0:	75 8b       	std	Z+21, r23	; 0x15
    2ce2:	64 8b       	std	Z+20, r22	; 0x14
}
    2ce4:	08 95       	ret

00002ce6 <midi_register_realtime_callback>:

void midi_register_realtime_callback(MidiDevice * device, midi_one_byte_func_t func){
   device->input_realtime_callback = func;
    2ce6:	fc 01       	movw	r30, r24
    2ce8:	77 8b       	std	Z+23, r23	; 0x17
    2cea:	66 8b       	std	Z+22, r22	; 0x16
}
    2cec:	08 95       	ret

00002cee <midi_register_tunerequest_callback>:

void midi_register_tunerequest_callback(MidiDevice * device, midi_one_byte_func_t func){
   device->input_tunerequest_callback = func;
    2cee:	fc 01       	movw	r30, r24
    2cf0:	71 8f       	std	Z+25, r23	; 0x19
    2cf2:	60 8f       	std	Z+24, r22	; 0x18
}
    2cf4:	08 95       	ret

00002cf6 <midi_register_sysex_callback>:

void midi_register_sysex_callback(MidiDevice * device, midi_sysex_func_t func) {
   device->input_sysex_callback = func;
    2cf6:	fc 01       	movw	r30, r24
    2cf8:	73 8f       	std	Z+27, r23	; 0x1b
    2cfa:	62 8f       	std	Z+26, r22	; 0x1a
}
    2cfc:	08 95       	ret

00002cfe <midi_register_fallthrough_callback>:

void midi_register_fallthrough_callback(MidiDevice * device, midi_var_byte_func_t func){
   device->input_fallthrough_callback = func;
    2cfe:	fc 01       	movw	r30, r24
    2d00:	75 8f       	std	Z+29, r23	; 0x1d
    2d02:	64 8f       	std	Z+28, r22	; 0x1c
}
    2d04:	08 95       	ret

00002d06 <midi_register_catchall_callback>:

void midi_register_catchall_callback(MidiDevice * device, midi_var_byte_func_t func){
   device->input_catchall_callback = func;
    2d06:	fc 01       	movw	r30, r24
    2d08:	77 8f       	std	Z+31, r23	; 0x1f
    2d0a:	66 8f       	std	Z+30, r22	; 0x1e
}
    2d0c:	08 95       	ret

00002d0e <midi_device_init>:

//forward declarations, internally used to call the callbacks
void midi_input_callbacks(MidiDevice * device, uint16_t cnt, uint8_t byte0, uint8_t byte1, uint8_t byte2);
void midi_process_byte(MidiDevice * device, uint8_t input);

void midi_device_init(MidiDevice * device){
    2d0e:	cf 93       	push	r28
    2d10:	df 93       	push	r29
    2d12:	ec 01       	movw	r28, r24
  device->input_state = IDLE;
    2d14:	1d a2       	lds	r17, 0x9d
  device->input_count = 0;
    2d16:	1f a2       	lds	r17, 0x9f
    2d18:	1e a2       	lds	r17, 0x9e
  bytequeue_init(&device->input_queue, device->input_queue_data, MIDI_INPUT_QUEUE_LENGTH);
    2d1a:	bc 01       	movw	r22, r24
    2d1c:	68 5d       	subi	r22, 0xD8	; 216
    2d1e:	7f 4f       	sbci	r23, 0xFF	; 255
    2d20:	88 51       	subi	r24, 0x18	; 24
    2d22:	9f 4f       	sbci	r25, 0xFF	; 255
    2d24:	40 ec       	ldi	r20, 0xC0	; 192
    2d26:	0e 94 01 14 	call	0x2802	; 0x2802 <bytequeue_init>

  //three byte funcs
  device->input_cc_callback = NULL;
    2d2a:	1b 82       	std	Y+3, r1	; 0x03
    2d2c:	1a 82       	std	Y+2, r1	; 0x02
  device->input_noteon_callback = NULL;
    2d2e:	1d 82       	std	Y+5, r1	; 0x05
    2d30:	1c 82       	std	Y+4, r1	; 0x04
  device->input_noteoff_callback = NULL;
    2d32:	1f 82       	std	Y+7, r1	; 0x07
    2d34:	1e 82       	std	Y+6, r1	; 0x06
  device->input_aftertouch_callback = NULL;
    2d36:	19 86       	std	Y+9, r1	; 0x09
    2d38:	18 86       	std	Y+8, r1	; 0x08
  device->input_pitchbend_callback = NULL;
    2d3a:	1b 86       	std	Y+11, r1	; 0x0b
    2d3c:	1a 86       	std	Y+10, r1	; 0x0a
  device->input_songposition_callback = NULL;
    2d3e:	1d 86       	std	Y+13, r1	; 0x0d
    2d40:	1c 86       	std	Y+12, r1	; 0x0c

  //two byte funcs
  device->input_progchange_callback = NULL;
    2d42:	1f 86       	std	Y+15, r1	; 0x0f
    2d44:	1e 86       	std	Y+14, r1	; 0x0e
  device->input_chanpressure_callback = NULL;
    2d46:	19 8a       	std	Y+17, r1	; 0x11
    2d48:	18 8a       	std	Y+16, r1	; 0x10
  device->input_songselect_callback = NULL;
    2d4a:	1b 8a       	std	Y+19, r1	; 0x13
    2d4c:	1a 8a       	std	Y+18, r1	; 0x12
  device->input_tc_quarterframe_callback = NULL;
    2d4e:	1d 8a       	std	Y+21, r1	; 0x15
    2d50:	1c 8a       	std	Y+20, r1	; 0x14

  //one byte funcs
  device->input_realtime_callback = NULL;
    2d52:	1f 8a       	std	Y+23, r1	; 0x17
    2d54:	1e 8a       	std	Y+22, r1	; 0x16
  device->input_tunerequest_callback = NULL;
    2d56:	19 8e       	std	Y+25, r1	; 0x19
    2d58:	18 8e       	std	Y+24, r1	; 0x18

  //var byte functions
  device->input_sysex_callback = NULL;
    2d5a:	1b 8e       	std	Y+27, r1	; 0x1b
    2d5c:	1a 8e       	std	Y+26, r1	; 0x1a
  device->input_fallthrough_callback = NULL;
    2d5e:	1d 8e       	std	Y+29, r1	; 0x1d
    2d60:	1c 8e       	std	Y+28, r1	; 0x1c
  device->input_catchall_callback = NULL;
    2d62:	1f 8e       	std	Y+31, r1	; 0x1f
    2d64:	1e 8e       	std	Y+30, r1	; 0x1e

  device->pre_input_process_callback = NULL;
    2d66:	19 a2       	lds	r17, 0x99
    2d68:	18 a2       	lds	r17, 0x98
}
    2d6a:	df 91       	pop	r29
    2d6c:	cf 91       	pop	r28
    2d6e:	08 95       	ret

00002d70 <midi_device_input>:

void midi_device_input(MidiDevice * device, uint8_t cnt, uint8_t * input) {
    2d70:	ef 92       	push	r14
    2d72:	ff 92       	push	r15
    2d74:	0f 93       	push	r16
    2d76:	1f 93       	push	r17
    2d78:	cf 93       	push	r28
    2d7a:	df 93       	push	r29
    2d7c:	d6 2f       	mov	r29, r22
  uint8_t i;
  for (i = 0; i < cnt; i++)
    2d7e:	66 23       	and	r22, r22
    2d80:	99 f0       	breq	.+38     	; 0x2da8 <midi_device_input+0x38>
    2d82:	04 2f       	mov	r16, r20
    2d84:	15 2f       	mov	r17, r21
    2d86:	c0 e0       	ldi	r28, 0x00	; 0
    bytequeue_enqueue(&device->input_queue, input[i]);
    2d88:	0f 2e       	mov	r0, r31
    2d8a:	f8 ee       	ldi	r31, 0xE8	; 232
    2d8c:	ef 2e       	mov	r14, r31
    2d8e:	ff 24       	eor	r15, r15
    2d90:	f0 2d       	mov	r31, r0
    2d92:	e8 0e       	add	r14, r24
    2d94:	f9 1e       	adc	r15, r25
    2d96:	f8 01       	movw	r30, r16
    2d98:	61 91       	ld	r22, Z+
    2d9a:	8f 01       	movw	r16, r30
    2d9c:	c7 01       	movw	r24, r14
    2d9e:	0e 94 08 14 	call	0x2810	; 0x2810 <bytequeue_enqueue>
  device->pre_input_process_callback = NULL;
}

void midi_device_input(MidiDevice * device, uint8_t cnt, uint8_t * input) {
  uint8_t i;
  for (i = 0; i < cnt; i++)
    2da2:	cf 5f       	subi	r28, 0xFF	; 255
    2da4:	cd 17       	cp	r28, r29
    2da6:	b9 f7       	brne	.-18     	; 0x2d96 <midi_device_input+0x26>
    bytequeue_enqueue(&device->input_queue, input[i]);
}
    2da8:	df 91       	pop	r29
    2daa:	cf 91       	pop	r28
    2dac:	1f 91       	pop	r17
    2dae:	0f 91       	pop	r16
    2db0:	ff 90       	pop	r15
    2db2:	ef 90       	pop	r14
    2db4:	08 95       	ret

00002db6 <midi_device_set_send_func>:

void midi_device_set_send_func(MidiDevice * device, midi_var_byte_func_t send_func){
  device->send_func = send_func;
    2db6:	fc 01       	movw	r30, r24
    2db8:	71 83       	std	Z+1, r23	; 0x01
    2dba:	60 83       	st	Z, r22
}
    2dbc:	08 95       	ret

00002dbe <midi_device_set_pre_input_process_func>:

void midi_device_set_pre_input_process_func(MidiDevice * device, midi_no_byte_func_t pre_process_func){
  device->pre_input_process_callback = pre_process_func;
    2dbe:	fc 01       	movw	r30, r24
    2dc0:	71 a3       	lds	r23, 0x51
    2dc2:	60 a3       	lds	r22, 0x50
}
    2dc4:	08 95       	ret

00002dc6 <midi_input_callbacks>:
      }
    }
  }
}

void midi_input_callbacks(MidiDevice * device, uint16_t cnt, uint8_t byte0, uint8_t byte1, uint8_t byte2) {
    2dc6:	af 92       	push	r10
    2dc8:	bf 92       	push	r11
    2dca:	cf 92       	push	r12
    2dcc:	df 92       	push	r13
    2dce:	ef 92       	push	r14
    2dd0:	ff 92       	push	r15
    2dd2:	0f 93       	push	r16
    2dd4:	1f 93       	push	r17
    2dd6:	cf 93       	push	r28
    2dd8:	df 93       	push	r29
    2dda:	00 d0       	rcall	.+0      	; 0x2ddc <midi_input_callbacks+0x16>
    2ddc:	0f 92       	push	r0
    2dde:	cd b7       	in	r28, 0x3d	; 61
    2de0:	de b7       	in	r29, 0x3e	; 62
    2de2:	6c 01       	movw	r12, r24
    2de4:	5b 01       	movw	r10, r22
    2de6:	f4 2e       	mov	r15, r20
    2de8:	e2 2e       	mov	r14, r18
    2dea:	10 2f       	mov	r17, r16
  //did we end up calling a callback?
  bool called = false;
  if (device->input_state == SYSEX_MESSAGE) {
    2dec:	dc 01       	movw	r26, r24
    2dee:	95 96       	adiw	r26, 0x25	; 37
    2df0:	8c 91       	ld	r24, X
    2df2:	95 97       	sbiw	r26, 0x25	; 37
    2df4:	84 30       	cpi	r24, 0x04	; 4
    2df6:	e9 f4       	brne	.+58     	; 0x2e32 <midi_input_callbacks+0x6c>
    if (device->input_sysex_callback) {
    2df8:	5a 96       	adiw	r26, 0x1a	; 26
    2dfa:	ed 91       	ld	r30, X+
    2dfc:	fc 91       	ld	r31, X
    2dfe:	5b 97       	sbiw	r26, 0x1b	; 27
    2e00:	30 97       	sbiw	r30, 0x00	; 0
    2e02:	09 f4       	brne	.+2      	; 0x2e06 <midi_input_callbacks+0x40>
    2e04:	ee c0       	rjmp	.+476    	; 0x2fe2 <midi_input_callbacks+0x21c>
      const uint16_t start = ((cnt - 1) / 3) * 3;
    2e06:	cb 01       	movw	r24, r22
    2e08:	01 97       	sbiw	r24, 0x01	; 1
    2e0a:	63 e0       	ldi	r22, 0x03	; 3
    2e0c:	70 e0       	ldi	r23, 0x00	; 0
    2e0e:	0e 94 db 1a 	call	0x35b6	; 0x35b6 <__udivmodhi4>
    2e12:	cb 01       	movw	r24, r22
    2e14:	88 0f       	add	r24, r24
    2e16:	99 1f       	adc	r25, r25
    2e18:	68 0f       	add	r22, r24
    2e1a:	79 1f       	adc	r23, r25
      const uint8_t length = (cnt - start);
      uint8_t data[3];
      data[0] = byte0;
    2e1c:	49 83       	std	Y+1, r20	; 0x01
      data[1] = byte1;
    2e1e:	2a 83       	std	Y+2, r18	; 0x02
      data[2] = byte2;
    2e20:	0b 83       	std	Y+3, r16	; 0x03
  //did we end up calling a callback?
  bool called = false;
  if (device->input_state == SYSEX_MESSAGE) {
    if (device->input_sysex_callback) {
      const uint16_t start = ((cnt - 1) / 3) * 3;
      const uint8_t length = (cnt - start);
    2e22:	4a 2d       	mov	r20, r10
    2e24:	46 1b       	sub	r20, r22
      uint8_t data[3];
      data[0] = byte0;
      data[1] = byte1;
      data[2] = byte2;
      device->input_sysex_callback(device, start, length, data);
    2e26:	c6 01       	movw	r24, r12
    2e28:	9e 01       	movw	r18, r28
    2e2a:	2f 5f       	subi	r18, 0xFF	; 255
    2e2c:	3f 4f       	sbci	r19, 0xFF	; 255
    2e2e:	09 95       	icall
    2e30:	c8 c0       	rjmp	.+400    	; 0x2fc2 <midi_input_callbacks+0x1fc>
      called = true;
    }
  } else {
    switch (cnt) {
    2e32:	62 30       	cpi	r22, 0x02	; 2
    2e34:	71 05       	cpc	r23, r1
    2e36:	09 f4       	brne	.+2      	; 0x2e3a <midi_input_callbacks+0x74>
    2e38:	5f c0       	rjmp	.+190    	; 0x2ef8 <midi_input_callbacks+0x132>
    2e3a:	63 30       	cpi	r22, 0x03	; 3
    2e3c:	71 05       	cpc	r23, r1
    2e3e:	29 f0       	breq	.+10     	; 0x2e4a <midi_input_callbacks+0x84>
    2e40:	61 30       	cpi	r22, 0x01	; 1
    2e42:	71 05       	cpc	r23, r1
    2e44:	09 f0       	breq	.+2      	; 0x2e48 <midi_input_callbacks+0x82>
    2e46:	b3 c0       	rjmp	.+358    	; 0x2fae <midi_input_callbacks+0x1e8>
    2e48:	99 c0       	rjmp	.+306    	; 0x2f7c <midi_input_callbacks+0x1b6>
      case 3:
        {
          midi_three_byte_func_t func = NULL;
          switch (byte0 & 0xF0) {
    2e4a:	84 2f       	mov	r24, r20
    2e4c:	90 e0       	ldi	r25, 0x00	; 0
    2e4e:	80 7f       	andi	r24, 0xF0	; 240
    2e50:	90 70       	andi	r25, 0x00	; 0
    2e52:	80 3a       	cpi	r24, 0xA0	; 160
    2e54:	91 05       	cpc	r25, r1
    2e56:	29 f1       	breq	.+74     	; 0x2ea2 <midi_input_callbacks+0xdc>
    2e58:	81 3a       	cpi	r24, 0xA1	; 161
    2e5a:	91 05       	cpc	r25, r1
    2e5c:	3c f4       	brge	.+14     	; 0x2e6c <midi_input_callbacks+0xa6>
    2e5e:	80 38       	cpi	r24, 0x80	; 128
    2e60:	91 05       	cpc	r25, r1
    2e62:	c9 f0       	breq	.+50     	; 0x2e96 <midi_input_callbacks+0xd0>
    2e64:	80 39       	cpi	r24, 0x90	; 144
    2e66:	91 05       	cpc	r25, r1
    2e68:	91 f5       	brne	.+100    	; 0x2ece <midi_input_callbacks+0x108>
    2e6a:	0f c0       	rjmp	.+30     	; 0x2e8a <midi_input_callbacks+0xc4>
    2e6c:	80 3e       	cpi	r24, 0xE0	; 224
    2e6e:	91 05       	cpc	r25, r1
    2e70:	f1 f0       	breq	.+60     	; 0x2eae <midi_input_callbacks+0xe8>
    2e72:	80 3f       	cpi	r24, 0xF0	; 240
    2e74:	91 05       	cpc	r25, r1
    2e76:	09 f1       	breq	.+66     	; 0x2eba <midi_input_callbacks+0xf4>
    2e78:	80 3b       	cpi	r24, 0xB0	; 176
    2e7a:	91 05       	cpc	r25, r1
    2e7c:	41 f5       	brne	.+80     	; 0x2ece <midi_input_callbacks+0x108>
            case MIDI_CC:
              func = device->input_cc_callback;
    2e7e:	d6 01       	movw	r26, r12
    2e80:	12 96       	adiw	r26, 0x02	; 2
    2e82:	ed 91       	ld	r30, X+
    2e84:	fc 91       	ld	r31, X
    2e86:	13 97       	sbiw	r26, 0x03	; 3
              break;
    2e88:	24 c0       	rjmp	.+72     	; 0x2ed2 <midi_input_callbacks+0x10c>
            case MIDI_NOTEON:
              func = device->input_noteon_callback;
    2e8a:	d6 01       	movw	r26, r12
    2e8c:	14 96       	adiw	r26, 0x04	; 4
    2e8e:	ed 91       	ld	r30, X+
    2e90:	fc 91       	ld	r31, X
    2e92:	15 97       	sbiw	r26, 0x05	; 5
              break;
    2e94:	1e c0       	rjmp	.+60     	; 0x2ed2 <midi_input_callbacks+0x10c>
            case MIDI_NOTEOFF:
              func = device->input_noteoff_callback;
    2e96:	d6 01       	movw	r26, r12
    2e98:	16 96       	adiw	r26, 0x06	; 6
    2e9a:	ed 91       	ld	r30, X+
    2e9c:	fc 91       	ld	r31, X
    2e9e:	17 97       	sbiw	r26, 0x07	; 7
              break;
    2ea0:	18 c0       	rjmp	.+48     	; 0x2ed2 <midi_input_callbacks+0x10c>
            case MIDI_AFTERTOUCH:
              func = device->input_aftertouch_callback;
    2ea2:	d6 01       	movw	r26, r12
    2ea4:	18 96       	adiw	r26, 0x08	; 8
    2ea6:	ed 91       	ld	r30, X+
    2ea8:	fc 91       	ld	r31, X
    2eaa:	19 97       	sbiw	r26, 0x09	; 9
              break;
    2eac:	12 c0       	rjmp	.+36     	; 0x2ed2 <midi_input_callbacks+0x10c>
            case MIDI_PITCHBEND:
              func = device->input_pitchbend_callback;
    2eae:	d6 01       	movw	r26, r12
    2eb0:	1a 96       	adiw	r26, 0x0a	; 10
    2eb2:	ed 91       	ld	r30, X+
    2eb4:	fc 91       	ld	r31, X
    2eb6:	1b 97       	sbiw	r26, 0x0b	; 11
              break;
    2eb8:	0c c0       	rjmp	.+24     	; 0x2ed2 <midi_input_callbacks+0x10c>
            case 0xF0:
              if (byte0 == MIDI_SONGPOSITION)
    2eba:	b2 ef       	ldi	r27, 0xF2	; 242
    2ebc:	4b 17       	cp	r20, r27
    2ebe:	09 f0       	breq	.+2      	; 0x2ec2 <midi_input_callbacks+0xfc>
    2ec0:	90 c0       	rjmp	.+288    	; 0x2fe2 <midi_input_callbacks+0x21c>
                func = device->input_songposition_callback;
    2ec2:	d6 01       	movw	r26, r12
    2ec4:	1c 96       	adiw	r26, 0x0c	; 12
    2ec6:	ed 91       	ld	r30, X+
    2ec8:	fc 91       	ld	r31, X
    2eca:	1d 97       	sbiw	r26, 0x0d	; 13
    2ecc:	02 c0       	rjmp	.+4      	; 0x2ed2 <midi_input_callbacks+0x10c>
    }
  } else {
    switch (cnt) {
      case 3:
        {
          midi_three_byte_func_t func = NULL;
    2ece:	e0 e0       	ldi	r30, 0x00	; 0
    2ed0:	f0 e0       	ldi	r31, 0x00	; 0
                func = device->input_songposition_callback;
              break;
            default:
              break;
          }
          if(func) {
    2ed2:	30 97       	sbiw	r30, 0x00	; 0
    2ed4:	09 f4       	brne	.+2      	; 0x2ed8 <midi_input_callbacks+0x112>
    2ed6:	85 c0       	rjmp	.+266    	; 0x2fe2 <midi_input_callbacks+0x21c>
            //mask off the channel for non song position functions
            if (byte0 == MIDI_SONGPOSITION)
    2ed8:	b2 ef       	ldi	r27, 0xF2	; 242
    2eda:	fb 16       	cp	r15, r27
    2edc:	31 f4       	brne	.+12     	; 0x2eea <midi_input_callbacks+0x124>
              func(device, byte0, byte1, byte2);
    2ede:	c6 01       	movw	r24, r12
    2ee0:	62 ef       	ldi	r22, 0xF2	; 242
    2ee2:	4e 2d       	mov	r20, r14
    2ee4:	21 2f       	mov	r18, r17
    2ee6:	09 95       	icall
    2ee8:	6c c0       	rjmp	.+216    	; 0x2fc2 <midi_input_callbacks+0x1fc>
            else
              func(device, byte0 & 0x0F, byte1, byte2);
    2eea:	6f 2d       	mov	r22, r15
    2eec:	6f 70       	andi	r22, 0x0F	; 15
    2eee:	c6 01       	movw	r24, r12
    2ef0:	4e 2d       	mov	r20, r14
    2ef2:	21 2f       	mov	r18, r17
    2ef4:	09 95       	icall
    2ef6:	65 c0       	rjmp	.+202    	; 0x2fc2 <midi_input_callbacks+0x1fc>
        }
        break;
      case 2:
        {
          midi_two_byte_func_t func = NULL;
          switch (byte0 & 0xF0) {
    2ef8:	84 2f       	mov	r24, r20
    2efa:	90 e0       	ldi	r25, 0x00	; 0
    2efc:	80 7f       	andi	r24, 0xF0	; 240
    2efe:	90 70       	andi	r25, 0x00	; 0
    2f00:	80 3d       	cpi	r24, 0xD0	; 208
    2f02:	91 05       	cpc	r25, r1
    2f04:	61 f0       	breq	.+24     	; 0x2f1e <midi_input_callbacks+0x158>
    2f06:	80 3f       	cpi	r24, 0xF0	; 240
    2f08:	91 05       	cpc	r25, r1
    2f0a:	79 f0       	breq	.+30     	; 0x2f2a <midi_input_callbacks+0x164>
    2f0c:	80 3c       	cpi	r24, 0xC0	; 192
    2f0e:	91 05       	cpc	r25, r1
    2f10:	f9 f4       	brne	.+62     	; 0x2f50 <midi_input_callbacks+0x18a>
            case MIDI_PROGCHANGE:
              func = device->input_progchange_callback;
    2f12:	d6 01       	movw	r26, r12
    2f14:	1e 96       	adiw	r26, 0x0e	; 14
    2f16:	ed 91       	ld	r30, X+
    2f18:	fc 91       	ld	r31, X
    2f1a:	1f 97       	sbiw	r26, 0x0f	; 15
              break;
    2f1c:	1b c0       	rjmp	.+54     	; 0x2f54 <midi_input_callbacks+0x18e>
            case MIDI_CHANPRESSURE:
              func = device->input_chanpressure_callback;
    2f1e:	d6 01       	movw	r26, r12
    2f20:	50 96       	adiw	r26, 0x10	; 16
    2f22:	ed 91       	ld	r30, X+
    2f24:	fc 91       	ld	r31, X
    2f26:	51 97       	sbiw	r26, 0x11	; 17
              break;
    2f28:	15 c0       	rjmp	.+42     	; 0x2f54 <midi_input_callbacks+0x18e>
            case 0xF0:
              if (byte0 == MIDI_SONGSELECT)
    2f2a:	b3 ef       	ldi	r27, 0xF3	; 243
    2f2c:	4b 17       	cp	r20, r27
    2f2e:	31 f4       	brne	.+12     	; 0x2f3c <midi_input_callbacks+0x176>
                func = device->input_songselect_callback;
    2f30:	d6 01       	movw	r26, r12
    2f32:	52 96       	adiw	r26, 0x12	; 18
    2f34:	ed 91       	ld	r30, X+
    2f36:	fc 91       	ld	r31, X
    2f38:	53 97       	sbiw	r26, 0x13	; 19
    2f3a:	0c c0       	rjmp	.+24     	; 0x2f54 <midi_input_callbacks+0x18e>
              else if (byte0 == MIDI_TC_QUARTERFRAME)
    2f3c:	b1 ef       	ldi	r27, 0xF1	; 241
    2f3e:	4b 17       	cp	r20, r27
    2f40:	09 f0       	breq	.+2      	; 0x2f44 <midi_input_callbacks+0x17e>
    2f42:	4f c0       	rjmp	.+158    	; 0x2fe2 <midi_input_callbacks+0x21c>
                func = device->input_tc_quarterframe_callback;
    2f44:	d6 01       	movw	r26, r12
    2f46:	54 96       	adiw	r26, 0x14	; 20
    2f48:	ed 91       	ld	r30, X+
    2f4a:	fc 91       	ld	r31, X
    2f4c:	55 97       	sbiw	r26, 0x15	; 21
    2f4e:	02 c0       	rjmp	.+4      	; 0x2f54 <midi_input_callbacks+0x18e>
          }
        }
        break;
      case 2:
        {
          midi_two_byte_func_t func = NULL;
    2f50:	e0 e0       	ldi	r30, 0x00	; 0
    2f52:	f0 e0       	ldi	r31, 0x00	; 0
                func = device->input_tc_quarterframe_callback;
              break;
            default:
              break;
          }
          if(func) {
    2f54:	30 97       	sbiw	r30, 0x00	; 0
    2f56:	09 f4       	brne	.+2      	; 0x2f5a <midi_input_callbacks+0x194>
    2f58:	44 c0       	rjmp	.+136    	; 0x2fe2 <midi_input_callbacks+0x21c>
            //mask off the channel
            if (byte0 == MIDI_SONGSELECT || byte0 == MIDI_TC_QUARTERFRAME)
    2f5a:	b3 ef       	ldi	r27, 0xF3	; 243
    2f5c:	fb 16       	cp	r15, r27
    2f5e:	19 f0       	breq	.+6      	; 0x2f66 <midi_input_callbacks+0x1a0>
    2f60:	81 ef       	ldi	r24, 0xF1	; 241
    2f62:	f8 16       	cp	r15, r24
    2f64:	29 f4       	brne	.+10     	; 0x2f70 <midi_input_callbacks+0x1aa>
              func(device, byte0, byte1);
    2f66:	c6 01       	movw	r24, r12
    2f68:	6f 2d       	mov	r22, r15
    2f6a:	4e 2d       	mov	r20, r14
    2f6c:	09 95       	icall
    2f6e:	29 c0       	rjmp	.+82     	; 0x2fc2 <midi_input_callbacks+0x1fc>
            else
              func(device, byte0 & 0x0F, byte1);
    2f70:	6f 2d       	mov	r22, r15
    2f72:	6f 70       	andi	r22, 0x0F	; 15
    2f74:	c6 01       	movw	r24, r12
    2f76:	4e 2d       	mov	r20, r14
    2f78:	09 95       	icall
    2f7a:	23 c0       	rjmp	.+70     	; 0x2fc2 <midi_input_callbacks+0x1fc>
        }
        break;
      case 1:
        {
          midi_one_byte_func_t func = NULL;
          if (midi_is_realtime(byte0))
    2f7c:	84 2f       	mov	r24, r20
    2f7e:	0e 94 80 14 	call	0x2900	; 0x2900 <midi_is_realtime>
    2f82:	88 23       	and	r24, r24
    2f84:	31 f0       	breq	.+12     	; 0x2f92 <midi_input_callbacks+0x1cc>
            func = device->input_realtime_callback;
    2f86:	d6 01       	movw	r26, r12
    2f88:	56 96       	adiw	r26, 0x16	; 22
    2f8a:	ed 91       	ld	r30, X+
    2f8c:	fc 91       	ld	r31, X
    2f8e:	57 97       	sbiw	r26, 0x17	; 23
    2f90:	08 c0       	rjmp	.+16     	; 0x2fa2 <midi_input_callbacks+0x1dc>
          else if (byte0 == MIDI_TUNEREQUEST)
    2f92:	b6 ef       	ldi	r27, 0xF6	; 246
    2f94:	fb 16       	cp	r15, r27
    2f96:	29 f5       	brne	.+74     	; 0x2fe2 <midi_input_callbacks+0x21c>
            func = device->input_tunerequest_callback;
    2f98:	d6 01       	movw	r26, r12
    2f9a:	58 96       	adiw	r26, 0x18	; 24
    2f9c:	ed 91       	ld	r30, X+
    2f9e:	fc 91       	ld	r31, X
    2fa0:	59 97       	sbiw	r26, 0x19	; 25
          if (func) {
    2fa2:	30 97       	sbiw	r30, 0x00	; 0
    2fa4:	f1 f0       	breq	.+60     	; 0x2fe2 <midi_input_callbacks+0x21c>
            func(device, byte0);
    2fa6:	c6 01       	movw	r24, r12
    2fa8:	6f 2d       	mov	r22, r15
    2faa:	09 95       	icall
    2fac:	0a c0       	rjmp	.+20     	; 0x2fc2 <midi_input_callbacks+0x1fc>
          }
        }
        break;
      default:
        //just in case
        if (cnt > 3)
    2fae:	64 30       	cpi	r22, 0x04	; 4
    2fb0:	71 05       	cpc	r23, r1
    2fb2:	a8 f4       	brcc	.+42     	; 0x2fde <midi_input_callbacks+0x218>
    2fb4:	16 c0       	rjmp	.+44     	; 0x2fe2 <midi_input_callbacks+0x21c>
  }

  //if there is fallthrough default callback and we haven't called a more specific one, 
  //call the fallthrough
  if (!called && device->input_fallthrough_callback)
    device->input_fallthrough_callback(device, cnt, byte0, byte1, byte2);
    2fb6:	c6 01       	movw	r24, r12
    2fb8:	b5 01       	movw	r22, r10
    2fba:	4f 2d       	mov	r20, r15
    2fbc:	2e 2d       	mov	r18, r14
    2fbe:	01 2f       	mov	r16, r17
    2fc0:	09 95       	icall
  //always call the catch all if it exists
  if (device->input_catchall_callback)
    2fc2:	d6 01       	movw	r26, r12
    2fc4:	5e 96       	adiw	r26, 0x1e	; 30
    2fc6:	ed 91       	ld	r30, X+
    2fc8:	fc 91       	ld	r31, X
    2fca:	5f 97       	sbiw	r26, 0x1f	; 31
    2fcc:	30 97       	sbiw	r30, 0x00	; 0
    2fce:	89 f0       	breq	.+34     	; 0x2ff2 <midi_input_callbacks+0x22c>
    device->input_catchall_callback(device, cnt, byte0, byte1, byte2);
    2fd0:	c6 01       	movw	r24, r12
    2fd2:	b5 01       	movw	r22, r10
    2fd4:	4f 2d       	mov	r20, r15
    2fd6:	2e 2d       	mov	r18, r14
    2fd8:	01 2f       	mov	r16, r17
    2fda:	09 95       	icall
    2fdc:	0a c0       	rjmp	.+20     	; 0x2ff2 <midi_input_callbacks+0x22c>
        }
        break;
      default:
        //just in case
        if (cnt > 3)
          cnt = 0;
    2fde:	aa 24       	eor	r10, r10
    2fe0:	bb 24       	eor	r11, r11
    }
  }

  //if there is fallthrough default callback and we haven't called a more specific one, 
  //call the fallthrough
  if (!called && device->input_fallthrough_callback)
    2fe2:	d6 01       	movw	r26, r12
    2fe4:	5c 96       	adiw	r26, 0x1c	; 28
    2fe6:	ed 91       	ld	r30, X+
    2fe8:	fc 91       	ld	r31, X
    2fea:	5d 97       	sbiw	r26, 0x1d	; 29
    2fec:	30 97       	sbiw	r30, 0x00	; 0
    2fee:	19 f7       	brne	.-58     	; 0x2fb6 <midi_input_callbacks+0x1f0>
    2ff0:	e8 cf       	rjmp	.-48     	; 0x2fc2 <midi_input_callbacks+0x1fc>
    device->input_fallthrough_callback(device, cnt, byte0, byte1, byte2);
  //always call the catch all if it exists
  if (device->input_catchall_callback)
    device->input_catchall_callback(device, cnt, byte0, byte1, byte2);
}
    2ff2:	0f 90       	pop	r0
    2ff4:	0f 90       	pop	r0
    2ff6:	0f 90       	pop	r0
    2ff8:	df 91       	pop	r29
    2ffa:	cf 91       	pop	r28
    2ffc:	1f 91       	pop	r17
    2ffe:	0f 91       	pop	r16
    3000:	ff 90       	pop	r15
    3002:	ef 90       	pop	r14
    3004:	df 90       	pop	r13
    3006:	cf 90       	pop	r12
    3008:	bf 90       	pop	r11
    300a:	af 90       	pop	r10
    300c:	08 95       	ret

0000300e <midi_process_byte>:
    midi_process_byte(device, val);
    bytequeue_remove(&device->input_queue, 1);
  }
}

void midi_process_byte(MidiDevice * device, uint8_t input) {
    300e:	ef 92       	push	r14
    3010:	ff 92       	push	r15
    3012:	0f 93       	push	r16
    3014:	cf 93       	push	r28
    3016:	df 93       	push	r29
    3018:	7c 01       	movw	r14, r24
    301a:	c6 2f       	mov	r28, r22
  if (midi_is_realtime(input)) {
    301c:	86 2f       	mov	r24, r22
    301e:	0e 94 80 14 	call	0x2900	; 0x2900 <midi_is_realtime>
    3022:	88 23       	and	r24, r24
    3024:	91 f0       	breq	.+36     	; 0x304a <midi_process_byte+0x3c>
    //call callback, store and restore state
    input_state_t state = device->input_state;
    3026:	d7 01       	movw	r26, r14
    3028:	95 96       	adiw	r26, 0x25	; 37
    302a:	dc 91       	ld	r29, X
    302c:	95 97       	sbiw	r26, 0x25	; 37
    device->input_state = ONE_BYTE_MESSAGE;
    302e:	81 e0       	ldi	r24, 0x01	; 1
    3030:	95 96       	adiw	r26, 0x25	; 37
    3032:	8c 93       	st	X, r24
    midi_input_callbacks(device, 1, input, 0, 0);
    3034:	c7 01       	movw	r24, r14
    3036:	61 e0       	ldi	r22, 0x01	; 1
    3038:	70 e0       	ldi	r23, 0x00	; 0
    303a:	4c 2f       	mov	r20, r28
    303c:	20 e0       	ldi	r18, 0x00	; 0
    303e:	00 e0       	ldi	r16, 0x00	; 0
    3040:	0e 94 e3 16 	call	0x2dc6	; 0x2dc6 <midi_input_callbacks>
    device->input_state = state;
    3044:	f7 01       	movw	r30, r14
    3046:	d5 a3       	lds	r29, 0x55
    3048:	b7 c0       	rjmp	.+366    	; 0x31b8 <midi_process_byte+0x1aa>
  } else if (midi_is_statusbyte(input)) {
    304a:	8c 2f       	mov	r24, r28
    304c:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <midi_is_statusbyte>
    3050:	88 23       	and	r24, r24
    3052:	09 f4       	brne	.+2      	; 0x3056 <midi_process_byte+0x48>
    3054:	73 c0       	rjmp	.+230    	; 0x313c <midi_process_byte+0x12e>
    //store the byte
    if (device->input_state != SYSEX_MESSAGE) {
    3056:	d7 01       	movw	r26, r14
    3058:	95 96       	adiw	r26, 0x25	; 37
    305a:	8c 91       	ld	r24, X
    305c:	95 97       	sbiw	r26, 0x25	; 37
    305e:	84 30       	cpi	r24, 0x04	; 4
    3060:	49 f0       	breq	.+18     	; 0x3074 <midi_process_byte+0x66>
      device->input_buffer[0] = input;
    3062:	92 96       	adiw	r26, 0x22	; 34
    3064:	cc 93       	st	X, r28
    3066:	92 97       	sbiw	r26, 0x22	; 34
      device->input_count = 1;
    3068:	81 e0       	ldi	r24, 0x01	; 1
    306a:	90 e0       	ldi	r25, 0x00	; 0
    306c:	97 96       	adiw	r26, 0x27	; 39
    306e:	9c 93       	st	X, r25
    3070:	8e 93       	st	-X, r24
    3072:	96 97       	sbiw	r26, 0x26	; 38
    }
    switch (midi_packet_length(input)) {
    3074:	8c 2f       	mov	r24, r28
    3076:	0e 94 86 14 	call	0x290c	; 0x290c <midi_packet_length>
    307a:	81 30       	cpi	r24, 0x01	; 1
    307c:	41 f0       	breq	.+16     	; 0x308e <midi_process_byte+0x80>
    307e:	81 30       	cpi	r24, 0x01	; 1
    3080:	00 f1       	brcs	.+64     	; 0x30c2 <midi_process_byte+0xb4>
    3082:	82 30       	cpi	r24, 0x02	; 2
    3084:	a1 f0       	breq	.+40     	; 0x30ae <midi_process_byte+0xa0>
    3086:	83 30       	cpi	r24, 0x03	; 3
    3088:	09 f0       	breq	.+2      	; 0x308c <midi_process_byte+0x7e>
    308a:	4f c0       	rjmp	.+158    	; 0x312a <midi_process_byte+0x11c>
    308c:	14 c0       	rjmp	.+40     	; 0x30b6 <midi_process_byte+0xa8>
      case ONE1:
        device->input_state = ONE_BYTE_MESSAGE;;
    308e:	81 e0       	ldi	r24, 0x01	; 1
    3090:	f7 01       	movw	r30, r14
    3092:	85 a3       	lds	r24, 0x55
        midi_input_callbacks(device, 1, input, 0, 0);
    3094:	c7 01       	movw	r24, r14
    3096:	61 e0       	ldi	r22, 0x01	; 1
    3098:	70 e0       	ldi	r23, 0x00	; 0
    309a:	4c 2f       	mov	r20, r28
    309c:	20 e0       	ldi	r18, 0x00	; 0
    309e:	00 e0       	ldi	r16, 0x00	; 0
    30a0:	0e 94 e3 16 	call	0x2dc6	; 0x2dc6 <midi_input_callbacks>
        device->input_state = IDLE;
    30a4:	d7 01       	movw	r26, r14
    30a6:	95 96       	adiw	r26, 0x25	; 37
    30a8:	1c 92       	st	X, r1
    30aa:	95 97       	sbiw	r26, 0x25	; 37
        break;
    30ac:	85 c0       	rjmp	.+266    	; 0x31b8 <midi_process_byte+0x1aa>
      case TWO2:
        device->input_state = TWO_BYTE_MESSAGE;
    30ae:	82 e0       	ldi	r24, 0x02	; 2
    30b0:	f7 01       	movw	r30, r14
    30b2:	85 a3       	lds	r24, 0x55
        break;
    30b4:	81 c0       	rjmp	.+258    	; 0x31b8 <midi_process_byte+0x1aa>
      case THREE3:
        device->input_state = THREE_BYTE_MESSAGE;
    30b6:	83 e0       	ldi	r24, 0x03	; 3
    30b8:	d7 01       	movw	r26, r14
    30ba:	95 96       	adiw	r26, 0x25	; 37
    30bc:	8c 93       	st	X, r24
    30be:	95 97       	sbiw	r26, 0x25	; 37
        break;
    30c0:	7b c0       	rjmp	.+246    	; 0x31b8 <midi_process_byte+0x1aa>
      case UNDEFINED:
        switch(input) {
    30c2:	c0 3f       	cpi	r28, 0xF0	; 240
    30c4:	19 f0       	breq	.+6      	; 0x30cc <midi_process_byte+0xbe>
    30c6:	c7 3f       	cpi	r28, 0xF7	; 247
    30c8:	59 f5       	brne	.+86     	; 0x3120 <midi_process_byte+0x112>
    30ca:	0a c0       	rjmp	.+20     	; 0x30e0 <midi_process_byte+0xd2>
          case SYSEX_BEGIN:
            device->input_state = SYSEX_MESSAGE;
    30cc:	84 e0       	ldi	r24, 0x04	; 4
    30ce:	f7 01       	movw	r30, r14
    30d0:	85 a3       	lds	r24, 0x55
            device->input_buffer[0] = input;
    30d2:	80 ef       	ldi	r24, 0xF0	; 240
    30d4:	82 a3       	lds	r24, 0x52
            device->input_count = 1;
    30d6:	81 e0       	ldi	r24, 0x01	; 1
    30d8:	90 e0       	ldi	r25, 0x00	; 0
    30da:	97 a3       	lds	r25, 0x57
    30dc:	86 a3       	lds	r24, 0x56
            break;
    30de:	6c c0       	rjmp	.+216    	; 0x31b8 <midi_process_byte+0x1aa>
          case SYSEX_END:
            //send what is left in the input buffer, set idle
            device->input_buffer[device->input_count % 3] = input;
    30e0:	d7 01       	movw	r26, r14
    30e2:	96 96       	adiw	r26, 0x26	; 38
    30e4:	2d 91       	ld	r18, X+
    30e6:	3c 91       	ld	r19, X
    30e8:	97 97       	sbiw	r26, 0x27	; 39
    30ea:	c9 01       	movw	r24, r18
    30ec:	63 e0       	ldi	r22, 0x03	; 3
    30ee:	70 e0       	ldi	r23, 0x00	; 0
    30f0:	0e 94 db 1a 	call	0x35b6	; 0x35b6 <__udivmodhi4>
    30f4:	f7 01       	movw	r30, r14
    30f6:	e8 0f       	add	r30, r24
    30f8:	f9 1f       	adc	r31, r25
    30fa:	87 ef       	ldi	r24, 0xF7	; 247
    30fc:	82 a3       	lds	r24, 0x52
            device->input_count += 1;
    30fe:	b9 01       	movw	r22, r18
    3100:	6f 5f       	subi	r22, 0xFF	; 255
    3102:	7f 4f       	sbci	r23, 0xFF	; 255
    3104:	f7 01       	movw	r30, r14
    3106:	77 a3       	lds	r23, 0x57
    3108:	66 a3       	lds	r22, 0x56
            //call the callback
            midi_input_callbacks(device, device->input_count, 
    310a:	c7 01       	movw	r24, r14
    310c:	42 a1       	lds	r20, 0x42
    310e:	23 a1       	lds	r18, 0x43
    3110:	04 a1       	lds	r16, 0x44
    3112:	0e 94 e3 16 	call	0x2dc6	; 0x2dc6 <midi_input_callbacks>
                device->input_buffer[0], device->input_buffer[1], device->input_buffer[2]);
            device->input_state = IDLE;
    3116:	d7 01       	movw	r26, r14
    3118:	95 96       	adiw	r26, 0x25	; 37
    311a:	1c 92       	st	X, r1
    311c:	95 97       	sbiw	r26, 0x25	; 37
            break;
    311e:	4c c0       	rjmp	.+152    	; 0x31b8 <midi_process_byte+0x1aa>
          default:
            device->input_state = IDLE;
    3120:	f7 01       	movw	r30, r14
    3122:	15 a2       	lds	r17, 0x95
            device->input_count = 0;
    3124:	17 a2       	lds	r17, 0x97
    3126:	16 a2       	lds	r17, 0x96
    3128:	47 c0       	rjmp	.+142    	; 0x31b8 <midi_process_byte+0x1aa>
        }

        break;
      default:
        device->input_state = IDLE;
    312a:	d7 01       	movw	r26, r14
    312c:	95 96       	adiw	r26, 0x25	; 37
    312e:	1c 92       	st	X, r1
    3130:	95 97       	sbiw	r26, 0x25	; 37
        device->input_count = 0;
    3132:	97 96       	adiw	r26, 0x27	; 39
    3134:	1c 92       	st	X, r1
    3136:	1e 92       	st	-X, r1
    3138:	96 97       	sbiw	r26, 0x26	; 38
        break;
    313a:	3e c0       	rjmp	.+124    	; 0x31b8 <midi_process_byte+0x1aa>
    }
  } else {
    if (device->input_state != IDLE) {
    313c:	f7 01       	movw	r30, r14
    313e:	25 a1       	lds	r18, 0x45
    3140:	22 23       	and	r18, r18
    3142:	d1 f1       	breq	.+116    	; 0x31b8 <midi_process_byte+0x1aa>
      //store the byte
      device->input_buffer[device->input_count % 3] = input;
    3144:	06 a0       	lds	r16, 0x86
    3146:	f7 a1       	lds	r31, 0x47
    3148:	e0 2d       	mov	r30, r0
    314a:	cf 01       	movw	r24, r30
    314c:	63 e0       	ldi	r22, 0x03	; 3
    314e:	70 e0       	ldi	r23, 0x00	; 0
    3150:	0e 94 db 1a 	call	0x35b6	; 0x35b6 <__udivmodhi4>
    3154:	ac 01       	movw	r20, r24
    3156:	8e 0d       	add	r24, r14
    3158:	9f 1d       	adc	r25, r15
    315a:	dc 01       	movw	r26, r24
    315c:	92 96       	adiw	r26, 0x22	; 34
    315e:	cc 93       	st	X, r28
    3160:	92 97       	sbiw	r26, 0x22	; 34
      //increment count
      uint16_t prev = device->input_count;
      device->input_count += 1;
    3162:	bf 01       	movw	r22, r30
    3164:	6f 5f       	subi	r22, 0xFF	; 255
    3166:	7f 4f       	sbci	r23, 0xFF	; 255
    3168:	f7 01       	movw	r30, r14
    316a:	77 a3       	lds	r23, 0x57
    316c:	66 a3       	lds	r22, 0x56

      switch(prev % 3) {
    316e:	41 30       	cpi	r20, 0x01	; 1
    3170:	51 05       	cpc	r21, r1
    3172:	91 f0       	breq	.+36     	; 0x3198 <midi_process_byte+0x18a>
    3174:	42 30       	cpi	r20, 0x02	; 2
    3176:	51 05       	cpc	r21, r1
    3178:	f9 f4       	brne	.+62     	; 0x31b8 <midi_process_byte+0x1aa>
        case 2:
          //call callback
          midi_input_callbacks(device, device->input_count,
    317a:	c7 01       	movw	r24, r14
    317c:	42 a1       	lds	r20, 0x42
    317e:	23 a1       	lds	r18, 0x43
    3180:	04 a1       	lds	r16, 0x44
    3182:	0e 94 e3 16 	call	0x2dc6	; 0x2dc6 <midi_input_callbacks>
              device->input_buffer[0], device->input_buffer[1], device->input_buffer[2]);
          if (device->input_state != SYSEX_MESSAGE) {
    3186:	f7 01       	movw	r30, r14
    3188:	85 a1       	lds	r24, 0x45
    318a:	84 30       	cpi	r24, 0x04	; 4
    318c:	a9 f0       	breq	.+42     	; 0x31b8 <midi_process_byte+0x1aa>
            //set to 1, keeping status byte, allowing for running status
            device->input_count = 1;
    318e:	81 e0       	ldi	r24, 0x01	; 1
    3190:	90 e0       	ldi	r25, 0x00	; 0
    3192:	97 a3       	lds	r25, 0x57
    3194:	86 a3       	lds	r24, 0x56
    3196:	10 c0       	rjmp	.+32     	; 0x31b8 <midi_process_byte+0x1aa>
          }
          break;
        case 1:
          if (device->input_state == TWO_BYTE_MESSAGE) {
    3198:	22 30       	cpi	r18, 0x02	; 2
    319a:	71 f4       	brne	.+28     	; 0x31b8 <midi_process_byte+0x1aa>
            //call callback
            midi_input_callbacks(device, device->input_count,
    319c:	c7 01       	movw	r24, r14
    319e:	42 a1       	lds	r20, 0x42
    31a0:	23 a1       	lds	r18, 0x43
    31a2:	00 e0       	ldi	r16, 0x00	; 0
    31a4:	0e 94 e3 16 	call	0x2dc6	; 0x2dc6 <midi_input_callbacks>
                device->input_buffer[0], device->input_buffer[1], 0);
            if (device->input_state != SYSEX_MESSAGE) {
    31a8:	f7 01       	movw	r30, r14
    31aa:	85 a1       	lds	r24, 0x45
    31ac:	84 30       	cpi	r24, 0x04	; 4
    31ae:	21 f0       	breq	.+8      	; 0x31b8 <midi_process_byte+0x1aa>
              //set to 1, keeping status byte, allowing for running status
              device->input_count = 1;
    31b0:	81 e0       	ldi	r24, 0x01	; 1
    31b2:	90 e0       	ldi	r25, 0x00	; 0
    31b4:	97 a3       	lds	r25, 0x57
    31b6:	86 a3       	lds	r24, 0x56
          //one byte messages are dealt with directly
          break;
      }
    }
  }
}
    31b8:	df 91       	pop	r29
    31ba:	cf 91       	pop	r28
    31bc:	0f 91       	pop	r16
    31be:	ff 90       	pop	r15
    31c0:	ef 90       	pop	r14
    31c2:	08 95       	ret

000031c4 <midi_device_process>:

void midi_device_set_pre_input_process_func(MidiDevice * device, midi_no_byte_func_t pre_process_func){
  device->pre_input_process_callback = pre_process_func;
}

void midi_device_process(MidiDevice * device) {
    31c4:	cf 92       	push	r12
    31c6:	df 92       	push	r13
    31c8:	ef 92       	push	r14
    31ca:	ff 92       	push	r15
    31cc:	0f 93       	push	r16
    31ce:	1f 93       	push	r17
    31d0:	cf 93       	push	r28
    31d2:	df 93       	push	r29
    31d4:	6c 01       	movw	r12, r24
  //call the pre_input_process_callback if there is one
  if(device->pre_input_process_callback)
    31d6:	dc 01       	movw	r26, r24
    31d8:	90 96       	adiw	r26, 0x20	; 32
    31da:	ed 91       	ld	r30, X+
    31dc:	fc 91       	ld	r31, X
    31de:	91 97       	sbiw	r26, 0x21	; 33
    31e0:	30 97       	sbiw	r30, 0x00	; 0
    31e2:	09 f0       	breq	.+2      	; 0x31e6 <midi_device_process+0x22>
    device->pre_input_process_callback(device);
    31e4:	09 95       	icall

  //pull stuff off the queue and process
  byteQueueIndex_t len = bytequeue_length(&device->input_queue);
    31e6:	0f 2e       	mov	r0, r31
    31e8:	f8 ee       	ldi	r31, 0xE8	; 232
    31ea:	ef 2e       	mov	r14, r31
    31ec:	ff 24       	eor	r15, r15
    31ee:	f0 2d       	mov	r31, r0
    31f0:	ec 0c       	add	r14, r12
    31f2:	fd 1c       	adc	r15, r13
    31f4:	c7 01       	movw	r24, r14
    31f6:	0e 94 37 14 	call	0x286e	; 0x286e <bytequeue_length>
  uint16_t i;
  //TODO limit number of bytes processed?
  for(i = 0; i < len; i++) {
    31fa:	c8 2f       	mov	r28, r24
    31fc:	d0 e0       	ldi	r29, 0x00	; 0
    31fe:	20 97       	sbiw	r28, 0x00	; 0
    3200:	99 f0       	breq	.+38     	; 0x3228 <midi_device_process+0x64>
    3202:	00 e0       	ldi	r16, 0x00	; 0
    3204:	10 e0       	ldi	r17, 0x00	; 0
    uint8_t val = bytequeue_get(&device->input_queue, 0);
    3206:	c7 01       	movw	r24, r14
    3208:	60 e0       	ldi	r22, 0x00	; 0
    320a:	0e 94 4c 14 	call	0x2898	; 0x2898 <bytequeue_get>
    320e:	68 2f       	mov	r22, r24
    midi_process_byte(device, val);
    3210:	c6 01       	movw	r24, r12
    3212:	0e 94 07 18 	call	0x300e	; 0x300e <midi_process_byte>
    bytequeue_remove(&device->input_queue, 1);
    3216:	c7 01       	movw	r24, r14
    3218:	61 e0       	ldi	r22, 0x01	; 1
    321a:	0e 94 5d 14 	call	0x28ba	; 0x28ba <bytequeue_remove>

  //pull stuff off the queue and process
  byteQueueIndex_t len = bytequeue_length(&device->input_queue);
  uint16_t i;
  //TODO limit number of bytes processed?
  for(i = 0; i < len; i++) {
    321e:	0f 5f       	subi	r16, 0xFF	; 255
    3220:	1f 4f       	sbci	r17, 0xFF	; 255
    3222:	0c 17       	cp	r16, r28
    3224:	1d 07       	cpc	r17, r29
    3226:	78 f3       	brcs	.-34     	; 0x3206 <midi_device_process+0x42>
    uint8_t val = bytequeue_get(&device->input_queue, 0);
    midi_process_byte(device, val);
    bytequeue_remove(&device->input_queue, 1);
  }
}
    3228:	df 91       	pop	r29
    322a:	cf 91       	pop	r28
    322c:	1f 91       	pop	r17
    322e:	0f 91       	pop	r16
    3230:	ff 90       	pop	r15
    3232:	ef 90       	pop	r14
    3234:	df 90       	pop	r13
    3236:	cf 90       	pop	r12
    3238:	08 95       	ret

0000323a <sysex_encoded_length>:
//You should have received a copy of the GNU General Public License
//along with avr-midi.  If not, see <http://www.gnu.org/licenses/>.

#include "sysex_tools.h"

uint16_t sysex_encoded_length(uint16_t decoded_length){
    323a:	9c 01       	movw	r18, r24
   uint8_t remainder = decoded_length % 7;
    323c:	67 e0       	ldi	r22, 0x07	; 7
    323e:	70 e0       	ldi	r23, 0x00	; 0
    3240:	0e 94 db 1a 	call	0x35b6	; 0x35b6 <__udivmodhi4>
    3244:	48 2f       	mov	r20, r24
   if (remainder)
    3246:	88 23       	and	r24, r24
    3248:	81 f0       	breq	.+32     	; 0x326a <sysex_encoded_length+0x30>
      return (decoded_length / 7) * 8 + remainder + 1;
    324a:	c9 01       	movw	r24, r18
    324c:	67 e0       	ldi	r22, 0x07	; 7
    324e:	70 e0       	ldi	r23, 0x00	; 0
    3250:	0e 94 db 1a 	call	0x35b6	; 0x35b6 <__udivmodhi4>
    3254:	cb 01       	movw	r24, r22
    3256:	88 0f       	add	r24, r24
    3258:	99 1f       	adc	r25, r25
    325a:	88 0f       	add	r24, r24
    325c:	99 1f       	adc	r25, r25
    325e:	88 0f       	add	r24, r24
    3260:	99 1f       	adc	r25, r25
    3262:	01 96       	adiw	r24, 0x01	; 1
    3264:	84 0f       	add	r24, r20
    3266:	91 1d       	adc	r25, r1
    3268:	08 95       	ret
   else
      return (decoded_length / 7) * 8;
    326a:	c9 01       	movw	r24, r18
    326c:	67 e0       	ldi	r22, 0x07	; 7
    326e:	70 e0       	ldi	r23, 0x00	; 0
    3270:	0e 94 db 1a 	call	0x35b6	; 0x35b6 <__udivmodhi4>
    3274:	cb 01       	movw	r24, r22
    3276:	88 0f       	add	r24, r24
    3278:	99 1f       	adc	r25, r25
    327a:	88 0f       	add	r24, r24
    327c:	99 1f       	adc	r25, r25
    327e:	88 0f       	add	r24, r24
    3280:	99 1f       	adc	r25, r25
}
    3282:	08 95       	ret

00003284 <sysex_decoded_length>:

uint16_t sysex_decoded_length(uint16_t encoded_length){
   uint8_t remainder = encoded_length % 8;
    3284:	48 2f       	mov	r20, r24
    3286:	47 70       	andi	r20, 0x07	; 7
   if (remainder)
    3288:	a1 f0       	breq	.+40     	; 0x32b2 <sysex_decoded_length+0x2e>
      return (encoded_length / 8) * 7 + remainder - 1;
    328a:	9c 01       	movw	r18, r24
    328c:	36 95       	lsr	r19
    328e:	27 95       	ror	r18
    3290:	36 95       	lsr	r19
    3292:	27 95       	ror	r18
    3294:	36 95       	lsr	r19
    3296:	27 95       	ror	r18
    3298:	c9 01       	movw	r24, r18
    329a:	88 0f       	add	r24, r24
    329c:	99 1f       	adc	r25, r25
    329e:	88 0f       	add	r24, r24
    32a0:	99 1f       	adc	r25, r25
    32a2:	88 0f       	add	r24, r24
    32a4:	99 1f       	adc	r25, r25
    32a6:	82 1b       	sub	r24, r18
    32a8:	93 0b       	sbc	r25, r19
    32aa:	01 97       	sbiw	r24, 0x01	; 1
    32ac:	84 0f       	add	r24, r20
    32ae:	91 1d       	adc	r25, r1
    32b0:	08 95       	ret
   else
      return (encoded_length / 8) * 7;
    32b2:	9c 01       	movw	r18, r24
    32b4:	36 95       	lsr	r19
    32b6:	27 95       	ror	r18
    32b8:	36 95       	lsr	r19
    32ba:	27 95       	ror	r18
    32bc:	36 95       	lsr	r19
    32be:	27 95       	ror	r18
    32c0:	c9 01       	movw	r24, r18
    32c2:	88 0f       	add	r24, r24
    32c4:	99 1f       	adc	r25, r25
    32c6:	88 0f       	add	r24, r24
    32c8:	99 1f       	adc	r25, r25
    32ca:	88 0f       	add	r24, r24
    32cc:	99 1f       	adc	r25, r25
    32ce:	82 1b       	sub	r24, r18
    32d0:	93 0b       	sbc	r25, r19
}
    32d2:	08 95       	ret

000032d4 <sysex_encode>:

uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
    32d4:	2f 92       	push	r2
    32d6:	3f 92       	push	r3
    32d8:	4f 92       	push	r4
    32da:	5f 92       	push	r5
    32dc:	6f 92       	push	r6
    32de:	7f 92       	push	r7
    32e0:	8f 92       	push	r8
    32e2:	9f 92       	push	r9
    32e4:	af 92       	push	r10
    32e6:	bf 92       	push	r11
    32e8:	cf 92       	push	r12
    32ea:	df 92       	push	r13
    32ec:	ef 92       	push	r14
    32ee:	ff 92       	push	r15
    32f0:	0f 93       	push	r16
    32f2:	1f 93       	push	r17
    32f4:	cf 93       	push	r28
    32f6:	df 93       	push	r29
    32f8:	00 d0       	rcall	.+0      	; 0x32fa <sysex_encode+0x26>
    32fa:	00 d0       	rcall	.+0      	; 0x32fc <sysex_encode+0x28>
    32fc:	00 d0       	rcall	.+0      	; 0x32fe <sysex_encode+0x2a>
    32fe:	cd b7       	in	r28, 0x3d	; 61
    3300:	de b7       	in	r29, 0x3e	; 62
    3302:	1c 01       	movw	r2, r24
    3304:	7a 83       	std	Y+2, r23	; 0x02
    3306:	69 83       	std	Y+1, r22	; 0x01
    3308:	3a 01       	movw	r6, r20
   uint16_t encoded_full = length / 7; //number of full 8 byte sections from 7 bytes of input
    330a:	ca 01       	movw	r24, r20
    330c:	67 e0       	ldi	r22, 0x07	; 7
    330e:	70 e0       	ldi	r23, 0x00	; 0
    3310:	0e 94 db 1a 	call	0x35b6	; 0x35b6 <__udivmodhi4>
    3314:	2b 01       	movw	r4, r22
    3316:	5b 01       	movw	r10, r22
   uint16_t i,j;

   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
    3318:	61 15       	cp	r22, r1
    331a:	71 05       	cpc	r23, r1
    331c:	b1 f1       	breq	.+108    	; 0x338a <sysex_encode+0xb6>
    331e:	81 01       	movw	r16, r2
    3320:	e9 80       	ldd	r14, Y+1	; 0x01
    3322:	fa 80       	ldd	r15, Y+2	; 0x02
    3324:	cc 24       	eor	r12, r12
    3326:	dd 24       	eor	r13, r13
      uint16_t encoded_msb_idx = i * 8;
      uint16_t input_start_idx = i * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < 7; j++){
    3328:	88 24       	eor	r8, r8
    332a:	99 24       	eor	r9, r9
      return (encoded_length / 8) * 7 + remainder - 1;
   else
      return (encoded_length / 8) * 7;
}

uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
    332c:	1e 83       	std	Y+6, r17	; 0x06
    332e:	0d 83       	std	Y+5, r16	; 0x05

   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t input_start_idx = i * 7;
      encoded[encoded_msb_idx] = 0;
    3330:	f8 01       	movw	r30, r16
    3332:	11 92       	st	Z+, r1
      return (encoded_length / 8) * 7 + remainder - 1;
   else
      return (encoded_length / 8) * 7;
}

uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
    3334:	fc 82       	std	Y+4, r15	; 0x04
    3336:	eb 82       	std	Y+3, r14	; 0x03
   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t input_start_idx = i * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < 7; j++){
    3338:	a4 01       	movw	r20, r8
         uint8_t current = source[input_start_idx + j];
    333a:	ab 81       	ldd	r26, Y+3	; 0x03
    333c:	bc 81       	ldd	r27, Y+4	; 0x04
    333e:	2d 91       	ld	r18, X+
    3340:	bc 83       	std	Y+4, r27	; 0x04
    3342:	ab 83       	std	Y+3, r26	; 0x03
         encoded[encoded_msb_idx] |= (0x80 & current) >> (1 + j);
    3344:	4f 5f       	subi	r20, 0xFF	; 255
    3346:	5f 4f       	sbci	r21, 0xFF	; 255
    3348:	82 2f       	mov	r24, r18
    334a:	90 e0       	ldi	r25, 0x00	; 0
    334c:	80 78       	andi	r24, 0x80	; 128
    334e:	90 70       	andi	r25, 0x00	; 0
    3350:	bc 01       	movw	r22, r24
    3352:	04 2e       	mov	r0, r20
    3354:	02 c0       	rjmp	.+4      	; 0x335a <sysex_encode+0x86>
    3356:	75 95       	asr	r23
    3358:	67 95       	ror	r22
    335a:	0a 94       	dec	r0
    335c:	e2 f7       	brpl	.-8      	; 0x3356 <sysex_encode+0x82>
    335e:	ad 81       	ldd	r26, Y+5	; 0x05
    3360:	be 81       	ldd	r27, Y+6	; 0x06
    3362:	8c 91       	ld	r24, X
    3364:	86 2b       	or	r24, r22
    3366:	8c 93       	st	X, r24
         encoded[encoded_msb_idx + 1 + j] = 0x7F & current;
    3368:	2f 77       	andi	r18, 0x7F	; 127
    336a:	21 93       	st	Z+, r18
   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t input_start_idx = i * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < 7; j++){
    336c:	47 30       	cpi	r20, 0x07	; 7
    336e:	51 05       	cpc	r21, r1
    3370:	21 f7       	brne	.-56     	; 0x333a <sysex_encode+0x66>
uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
   uint16_t encoded_full = length / 7; //number of full 8 byte sections from 7 bytes of input
   uint16_t i,j;

   //fill out the fully encoded sections
   for(i = 0; i < encoded_full; i++) {
    3372:	08 94       	sec
    3374:	c1 1c       	adc	r12, r1
    3376:	d1 1c       	adc	r13, r1
    3378:	08 5f       	subi	r16, 0xF8	; 248
    337a:	1f 4f       	sbci	r17, 0xFF	; 255
    337c:	e7 e0       	ldi	r30, 0x07	; 7
    337e:	f0 e0       	ldi	r31, 0x00	; 0
    3380:	ee 0e       	add	r14, r30
    3382:	ff 1e       	adc	r15, r31
    3384:	ca 14       	cp	r12, r10
    3386:	db 04       	cpc	r13, r11
    3388:	89 f6       	brne	.-94     	; 0x332c <sysex_encode+0x58>
         encoded[encoded_msb_idx + 1 + j] = 0x7F & current;
      }
   }

   //fill out the rest if there is any more
   uint8_t remainder = length % 7;
    338a:	c3 01       	movw	r24, r6
    338c:	67 e0       	ldi	r22, 0x07	; 7
    338e:	70 e0       	ldi	r23, 0x00	; 0
    3390:	0e 94 db 1a 	call	0x35b6	; 0x35b6 <__udivmodhi4>
   if (remainder) {
    3394:	88 23       	and	r24, r24
    3396:	d9 f1       	breq	.+118    	; 0x340e <sysex_encode+0x13a>
      uint16_t encoded_msb_idx = encoded_full * 8;
    3398:	82 01       	movw	r16, r4
    339a:	00 0f       	add	r16, r16
    339c:	11 1f       	adc	r17, r17
    339e:	00 0f       	add	r16, r16
    33a0:	11 1f       	adc	r17, r17
    33a2:	00 0f       	add	r16, r16
    33a4:	11 1f       	adc	r17, r17
      uint16_t input_start_idx = encoded_full * 7;
    33a6:	78 01       	movw	r14, r16
    33a8:	e4 18       	sub	r14, r4
    33aa:	f5 08       	sbc	r15, r5
      encoded[encoded_msb_idx] = 0;
    33ac:	d1 01       	movw	r26, r2
    33ae:	a0 0f       	add	r26, r16
    33b0:	b1 1f       	adc	r27, r17
    33b2:	1c 92       	st	X, r1
      for(j = 0; j < remainder; j++){
    33b4:	68 2f       	mov	r22, r24
    33b6:	70 e0       	ldi	r23, 0x00	; 0
    33b8:	61 15       	cp	r22, r1
    33ba:	71 05       	cpc	r23, r1
    33bc:	19 f1       	breq	.+70     	; 0x3404 <sysex_encode+0x130>
      return (encoded_length / 8) * 7 + remainder - 1;
   else
      return (encoded_length / 8) * 7;
}

uint16_t sysex_encode(uint8_t *encoded, const uint8_t *source, const uint16_t length){
    33be:	e9 81       	ldd	r30, Y+1	; 0x01
    33c0:	fa 81       	ldd	r31, Y+2	; 0x02
    33c2:	ee 0e       	add	r14, r30
    33c4:	ff 1e       	adc	r15, r31
    33c6:	c8 01       	movw	r24, r16
    33c8:	01 96       	adiw	r24, 0x01	; 1
    33ca:	28 0e       	add	r2, r24
    33cc:	39 1e       	adc	r3, r25
   uint8_t remainder = length % 7;
   if (remainder) {
      uint16_t encoded_msb_idx = encoded_full * 8;
      uint16_t input_start_idx = encoded_full * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < remainder; j++){
    33ce:	20 e0       	ldi	r18, 0x00	; 0
    33d0:	30 e0       	ldi	r19, 0x00	; 0
         uint8_t current = source[input_start_idx + j];
    33d2:	f7 01       	movw	r30, r14
    33d4:	41 91       	ld	r20, Z+
    33d6:	7f 01       	movw	r14, r30
         encoded[encoded_msb_idx] |= (0x80 & current) >> (1 + j);
    33d8:	2f 5f       	subi	r18, 0xFF	; 255
    33da:	3f 4f       	sbci	r19, 0xFF	; 255
    33dc:	84 2f       	mov	r24, r20
    33de:	90 e0       	ldi	r25, 0x00	; 0
    33e0:	80 78       	andi	r24, 0x80	; 128
    33e2:	90 70       	andi	r25, 0x00	; 0
    33e4:	02 2e       	mov	r0, r18
    33e6:	02 c0       	rjmp	.+4      	; 0x33ec <sysex_encode+0x118>
    33e8:	95 95       	asr	r25
    33ea:	87 95       	ror	r24
    33ec:	0a 94       	dec	r0
    33ee:	e2 f7       	brpl	.-8      	; 0x33e8 <sysex_encode+0x114>
    33f0:	9c 91       	ld	r25, X
    33f2:	89 2b       	or	r24, r25
    33f4:	8c 93       	st	X, r24
         encoded[encoded_msb_idx + 1 + j] = 0x7F & current;
    33f6:	4f 77       	andi	r20, 0x7F	; 127
    33f8:	f1 01       	movw	r30, r2
    33fa:	41 93       	st	Z+, r20
    33fc:	1f 01       	movw	r2, r30
   uint8_t remainder = length % 7;
   if (remainder) {
      uint16_t encoded_msb_idx = encoded_full * 8;
      uint16_t input_start_idx = encoded_full * 7;
      encoded[encoded_msb_idx] = 0;
      for(j = 0; j < remainder; j++){
    33fe:	26 17       	cp	r18, r22
    3400:	37 07       	cpc	r19, r23
    3402:	38 f3       	brcs	.-50     	; 0x33d2 <sysex_encode+0xfe>
         uint8_t current = source[input_start_idx + j];
         encoded[encoded_msb_idx] |= (0x80 & current) >> (1 + j);
         encoded[encoded_msb_idx + 1 + j] = 0x7F & current;
      }
      return encoded_msb_idx + remainder + 1;
    3404:	c8 01       	movw	r24, r16
    3406:	01 96       	adiw	r24, 0x01	; 1
    3408:	86 0f       	add	r24, r22
    340a:	97 1f       	adc	r25, r23
    340c:	07 c0       	rjmp	.+14     	; 0x341c <sysex_encode+0x148>
   } else {
      return encoded_full * 8;
    340e:	c2 01       	movw	r24, r4
    3410:	88 0f       	add	r24, r24
    3412:	99 1f       	adc	r25, r25
    3414:	88 0f       	add	r24, r24
    3416:	99 1f       	adc	r25, r25
    3418:	88 0f       	add	r24, r24
    341a:	99 1f       	adc	r25, r25
   }
}
    341c:	26 96       	adiw	r28, 0x06	; 6
    341e:	0f b6       	in	r0, 0x3f	; 63
    3420:	f8 94       	cli
    3422:	de bf       	out	0x3e, r29	; 62
    3424:	0f be       	out	0x3f, r0	; 63
    3426:	cd bf       	out	0x3d, r28	; 61
    3428:	df 91       	pop	r29
    342a:	cf 91       	pop	r28
    342c:	1f 91       	pop	r17
    342e:	0f 91       	pop	r16
    3430:	ff 90       	pop	r15
    3432:	ef 90       	pop	r14
    3434:	df 90       	pop	r13
    3436:	cf 90       	pop	r12
    3438:	bf 90       	pop	r11
    343a:	af 90       	pop	r10
    343c:	9f 90       	pop	r9
    343e:	8f 90       	pop	r8
    3440:	7f 90       	pop	r7
    3442:	6f 90       	pop	r6
    3444:	5f 90       	pop	r5
    3446:	4f 90       	pop	r4
    3448:	3f 90       	pop	r3
    344a:	2f 90       	pop	r2
    344c:	08 95       	ret

0000344e <sysex_decode>:

uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
    344e:	6f 92       	push	r6
    3450:	7f 92       	push	r7
    3452:	8f 92       	push	r8
    3454:	9f 92       	push	r9
    3456:	af 92       	push	r10
    3458:	bf 92       	push	r11
    345a:	cf 92       	push	r12
    345c:	df 92       	push	r13
    345e:	ef 92       	push	r14
    3460:	ff 92       	push	r15
    3462:	0f 93       	push	r16
    3464:	1f 93       	push	r17
    3466:	cf 93       	push	r28
    3468:	df 93       	push	r29
    346a:	3c 01       	movw	r6, r24
    346c:	4b 01       	movw	r8, r22
    346e:	5a 01       	movw	r10, r20
   uint16_t decoded_full = length / 8;
   uint16_t i,j;

   if (length < 2)
    3470:	42 30       	cpi	r20, 0x02	; 2
    3472:	51 05       	cpc	r21, r1
    3474:	08 f4       	brcc	.+2      	; 0x3478 <sysex_decode+0x2a>
    3476:	6f c0       	rjmp	.+222    	; 0x3556 <sysex_decode+0x108>
      return encoded_full * 8;
   }
}

uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
   uint16_t decoded_full = length / 8;
    3478:	7a 01       	movw	r14, r20
    347a:	f6 94       	lsr	r15
    347c:	e7 94       	ror	r14
    347e:	f6 94       	lsr	r15
    3480:	e7 94       	ror	r14
    3482:	f6 94       	lsr	r15
    3484:	e7 94       	ror	r14

   if (length < 2)
      return 0;

   //fill out the fully encoded sections
   for(i = 0; i < decoded_full; i++) {
    3486:	e1 14       	cp	r14, r1
    3488:	f1 04       	cpc	r15, r1
    348a:	29 f1       	breq	.+74     	; 0x34d6 <sysex_decode+0x88>
    348c:	eb 01       	movw	r28, r22
    348e:	b3 01       	movw	r22, r6
    3490:	00 e0       	ldi	r16, 0x00	; 0
    3492:	10 e0       	ldi	r17, 0x00	; 0
      uint16_t encoded_msb_idx = i * 8;
      uint16_t output_start_index = i * 7;
      for(j = 0; j < 7; j++){
    3494:	cc 24       	eor	r12, r12
    3496:	dd 24       	eor	r13, r13
   } else {
      return encoded_full * 8;
   }
}

uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
    3498:	de 01       	movw	r26, r28
    349a:	11 96       	adiw	r26, 0x01	; 1
    349c:	fb 01       	movw	r30, r22

   //fill out the fully encoded sections
   for(i = 0; i < decoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t output_start_index = i * 7;
      for(j = 0; j < 7; j++){
    349e:	a6 01       	movw	r20, r12
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
    34a0:	2d 91       	ld	r18, X+
    34a2:	2f 77       	andi	r18, 0x7F	; 127
    34a4:	20 83       	st	Z, r18
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
    34a6:	4f 5f       	subi	r20, 0xFF	; 255
    34a8:	5f 4f       	sbci	r21, 0xFF	; 255
    34aa:	88 81       	ld	r24, Y
    34ac:	90 e0       	ldi	r25, 0x00	; 0
    34ae:	04 2e       	mov	r0, r20
    34b0:	02 c0       	rjmp	.+4      	; 0x34b6 <sysex_decode+0x68>
    34b2:	88 0f       	add	r24, r24
    34b4:	99 1f       	adc	r25, r25
    34b6:	0a 94       	dec	r0
    34b8:	e2 f7       	brpl	.-8      	; 0x34b2 <sysex_decode+0x64>
    34ba:	80 78       	andi	r24, 0x80	; 128
    34bc:	28 2b       	or	r18, r24
    34be:	21 93       	st	Z+, r18

   //fill out the fully encoded sections
   for(i = 0; i < decoded_full; i++) {
      uint16_t encoded_msb_idx = i * 8;
      uint16_t output_start_index = i * 7;
      for(j = 0; j < 7; j++){
    34c0:	47 30       	cpi	r20, 0x07	; 7
    34c2:	51 05       	cpc	r21, r1
    34c4:	69 f7       	brne	.-38     	; 0x34a0 <sysex_decode+0x52>

   if (length < 2)
      return 0;

   //fill out the fully encoded sections
   for(i = 0; i < decoded_full; i++) {
    34c6:	0f 5f       	subi	r16, 0xFF	; 255
    34c8:	1f 4f       	sbci	r17, 0xFF	; 255
    34ca:	28 96       	adiw	r28, 0x08	; 8
    34cc:	69 5f       	subi	r22, 0xF9	; 249
    34ce:	7f 4f       	sbci	r23, 0xFF	; 255
    34d0:	0e 15       	cp	r16, r14
    34d2:	1f 05       	cpc	r17, r15
    34d4:	09 f7       	brne	.-62     	; 0x3498 <sysex_decode+0x4a>
      for(j = 0; j < 7; j++){
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
      }
   }
   uint8_t remainder = length % 8;
    34d6:	5a 2d       	mov	r21, r10
    34d8:	57 70       	andi	r21, 0x07	; 7
   if (remainder) {
    34da:	99 f1       	breq	.+102    	; 0x3542 <sysex_decode+0xf4>
      uint16_t encoded_msb_idx = decoded_full * 8;
    34dc:	e7 01       	movw	r28, r14
    34de:	cc 0f       	add	r28, r28
    34e0:	dd 1f       	adc	r29, r29
    34e2:	cc 0f       	add	r28, r28
    34e4:	dd 1f       	adc	r29, r29
    34e6:	cc 0f       	add	r28, r28
    34e8:	dd 1f       	adc	r29, r29
      uint16_t output_start_index = decoded_full * 7;
    34ea:	8e 01       	movw	r16, r28
    34ec:	0e 19       	sub	r16, r14
    34ee:	1f 09       	sbc	r17, r15
      for(j = 0; j < (remainder - 1); j++) {
    34f0:	65 2f       	mov	r22, r21
    34f2:	70 e0       	ldi	r23, 0x00	; 0
    34f4:	61 50       	subi	r22, 0x01	; 1
    34f6:	70 40       	sbci	r23, 0x00	; 0
    34f8:	f9 f0       	breq	.+62     	; 0x3538 <sysex_decode+0xea>
   } else {
      return encoded_full * 8;
   }
}

uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
    34fa:	ce 01       	movw	r24, r28
    34fc:	01 96       	adiw	r24, 0x01	; 1
    34fe:	d4 01       	movw	r26, r8
    3500:	a8 0f       	add	r26, r24
    3502:	b9 1f       	adc	r27, r25
    3504:	f3 01       	movw	r30, r6
    3506:	e0 0f       	add	r30, r16
    3508:	f1 1f       	adc	r31, r17
   }
   uint8_t remainder = length % 8;
   if (remainder) {
      uint16_t encoded_msb_idx = decoded_full * 8;
      uint16_t output_start_index = decoded_full * 7;
      for(j = 0; j < (remainder - 1); j++) {
    350a:	20 e0       	ldi	r18, 0x00	; 0
    350c:	30 e0       	ldi	r19, 0x00	; 0
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
    350e:	c8 0d       	add	r28, r8
    3510:	d9 1d       	adc	r29, r9
   uint8_t remainder = length % 8;
   if (remainder) {
      uint16_t encoded_msb_idx = decoded_full * 8;
      uint16_t output_start_index = decoded_full * 7;
      for(j = 0; j < (remainder - 1); j++) {
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
    3512:	4d 91       	ld	r20, X+
    3514:	4f 77       	andi	r20, 0x7F	; 127
    3516:	40 83       	st	Z, r20
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
    3518:	2f 5f       	subi	r18, 0xFF	; 255
    351a:	3f 4f       	sbci	r19, 0xFF	; 255
    351c:	88 81       	ld	r24, Y
    351e:	90 e0       	ldi	r25, 0x00	; 0
    3520:	02 2e       	mov	r0, r18
    3522:	02 c0       	rjmp	.+4      	; 0x3528 <sysex_decode+0xda>
    3524:	88 0f       	add	r24, r24
    3526:	99 1f       	adc	r25, r25
    3528:	0a 94       	dec	r0
    352a:	e2 f7       	brpl	.-8      	; 0x3524 <sysex_decode+0xd6>
    352c:	80 78       	andi	r24, 0x80	; 128
    352e:	48 2b       	or	r20, r24
    3530:	41 93       	st	Z+, r20
   }
   uint8_t remainder = length % 8;
   if (remainder) {
      uint16_t encoded_msb_idx = decoded_full * 8;
      uint16_t output_start_index = decoded_full * 7;
      for(j = 0; j < (remainder - 1); j++) {
    3532:	26 17       	cp	r18, r22
    3534:	37 07       	cpc	r19, r23
    3536:	68 f3       	brcs	.-38     	; 0x3512 <sysex_decode+0xc4>
         decoded[output_start_index + j] = 0x7F & source[encoded_msb_idx + j + 1];
         decoded[output_start_index + j] |= (0x80 & (source[encoded_msb_idx] << (1 + j)));
      }
      return decoded_full * 7 + remainder - 1;
    3538:	c8 01       	movw	r24, r16
    353a:	01 97       	sbiw	r24, 0x01	; 1
    353c:	85 0f       	add	r24, r21
    353e:	91 1d       	adc	r25, r1
    3540:	0c c0       	rjmp	.+24     	; 0x355a <sysex_decode+0x10c>
   } else {
      return decoded_full * 7;
    3542:	c7 01       	movw	r24, r14
    3544:	88 0f       	add	r24, r24
    3546:	99 1f       	adc	r25, r25
    3548:	88 0f       	add	r24, r24
    354a:	99 1f       	adc	r25, r25
    354c:	88 0f       	add	r24, r24
    354e:	99 1f       	adc	r25, r25
    3550:	8e 19       	sub	r24, r14
    3552:	9f 09       	sbc	r25, r15
    3554:	02 c0       	rjmp	.+4      	; 0x355a <sysex_decode+0x10c>
uint16_t sysex_decode(uint8_t *decoded, const uint8_t *source, const uint16_t length){
   uint16_t decoded_full = length / 8;
   uint16_t i,j;

   if (length < 2)
      return 0;
    3556:	80 e0       	ldi	r24, 0x00	; 0
    3558:	90 e0       	ldi	r25, 0x00	; 0
      }
      return decoded_full * 7 + remainder - 1;
   } else {
      return decoded_full * 7;
   }
}
    355a:	df 91       	pop	r29
    355c:	cf 91       	pop	r28
    355e:	1f 91       	pop	r17
    3560:	0f 91       	pop	r16
    3562:	ff 90       	pop	r15
    3564:	ef 90       	pop	r14
    3566:	df 90       	pop	r13
    3568:	cf 90       	pop	r12
    356a:	bf 90       	pop	r11
    356c:	af 90       	pop	r10
    356e:	9f 90       	pop	r9
    3570:	8f 90       	pop	r8
    3572:	7f 90       	pop	r7
    3574:	6f 90       	pop	r6
    3576:	08 95       	ret

00003578 <__mulsi3>:
    3578:	62 9f       	mul	r22, r18
    357a:	d0 01       	movw	r26, r0
    357c:	73 9f       	mul	r23, r19
    357e:	f0 01       	movw	r30, r0
    3580:	82 9f       	mul	r24, r18
    3582:	e0 0d       	add	r30, r0
    3584:	f1 1d       	adc	r31, r1
    3586:	64 9f       	mul	r22, r20
    3588:	e0 0d       	add	r30, r0
    358a:	f1 1d       	adc	r31, r1
    358c:	92 9f       	mul	r25, r18
    358e:	f0 0d       	add	r31, r0
    3590:	83 9f       	mul	r24, r19
    3592:	f0 0d       	add	r31, r0
    3594:	74 9f       	mul	r23, r20
    3596:	f0 0d       	add	r31, r0
    3598:	65 9f       	mul	r22, r21
    359a:	f0 0d       	add	r31, r0
    359c:	99 27       	eor	r25, r25
    359e:	72 9f       	mul	r23, r18
    35a0:	b0 0d       	add	r27, r0
    35a2:	e1 1d       	adc	r30, r1
    35a4:	f9 1f       	adc	r31, r25
    35a6:	63 9f       	mul	r22, r19
    35a8:	b0 0d       	add	r27, r0
    35aa:	e1 1d       	adc	r30, r1
    35ac:	f9 1f       	adc	r31, r25
    35ae:	bd 01       	movw	r22, r26
    35b0:	cf 01       	movw	r24, r30
    35b2:	11 24       	eor	r1, r1
    35b4:	08 95       	ret

000035b6 <__udivmodhi4>:
    35b6:	aa 1b       	sub	r26, r26
    35b8:	bb 1b       	sub	r27, r27
    35ba:	51 e1       	ldi	r21, 0x11	; 17
    35bc:	07 c0       	rjmp	.+14     	; 0x35cc <__udivmodhi4_ep>

000035be <__udivmodhi4_loop>:
    35be:	aa 1f       	adc	r26, r26
    35c0:	bb 1f       	adc	r27, r27
    35c2:	a6 17       	cp	r26, r22
    35c4:	b7 07       	cpc	r27, r23
    35c6:	10 f0       	brcs	.+4      	; 0x35cc <__udivmodhi4_ep>
    35c8:	a6 1b       	sub	r26, r22
    35ca:	b7 0b       	sbc	r27, r23

000035cc <__udivmodhi4_ep>:
    35cc:	88 1f       	adc	r24, r24
    35ce:	99 1f       	adc	r25, r25
    35d0:	5a 95       	dec	r21
    35d2:	a9 f7       	brne	.-22     	; 0x35be <__udivmodhi4_loop>
    35d4:	80 95       	com	r24
    35d6:	90 95       	com	r25
    35d8:	bc 01       	movw	r22, r24
    35da:	cd 01       	movw	r24, r26
    35dc:	08 95       	ret

000035de <__divmodhi4>:
    35de:	97 fb       	bst	r25, 7
    35e0:	09 2e       	mov	r0, r25
    35e2:	07 26       	eor	r0, r23
    35e4:	0a d0       	rcall	.+20     	; 0x35fa <__divmodhi4_neg1>
    35e6:	77 fd       	sbrc	r23, 7
    35e8:	04 d0       	rcall	.+8      	; 0x35f2 <__divmodhi4_neg2>
    35ea:	e5 df       	rcall	.-54     	; 0x35b6 <__udivmodhi4>
    35ec:	06 d0       	rcall	.+12     	; 0x35fa <__divmodhi4_neg1>
    35ee:	00 20       	and	r0, r0
    35f0:	1a f4       	brpl	.+6      	; 0x35f8 <__divmodhi4_exit>

000035f2 <__divmodhi4_neg2>:
    35f2:	70 95       	com	r23
    35f4:	61 95       	neg	r22
    35f6:	7f 4f       	sbci	r23, 0xFF	; 255

000035f8 <__divmodhi4_exit>:
    35f8:	08 95       	ret

000035fa <__divmodhi4_neg1>:
    35fa:	f6 f7       	brtc	.-4      	; 0x35f8 <__divmodhi4_exit>
    35fc:	90 95       	com	r25
    35fe:	81 95       	neg	r24
    3600:	9f 4f       	sbci	r25, 0xFF	; 255
    3602:	08 95       	ret

00003604 <memcpy>:
    3604:	fb 01       	movw	r30, r22
    3606:	dc 01       	movw	r26, r24
    3608:	02 c0       	rjmp	.+4      	; 0x360e <memcpy+0xa>
    360a:	01 90       	ld	r0, Z+
    360c:	0d 92       	st	X+, r0
    360e:	41 50       	subi	r20, 0x01	; 1
    3610:	50 40       	sbci	r21, 0x00	; 0
    3612:	d8 f7       	brcc	.-10     	; 0x360a <memcpy+0x6>
    3614:	08 95       	ret

00003616 <memmove>:
    3616:	68 17       	cp	r22, r24
    3618:	79 07       	cpc	r23, r25
    361a:	68 f4       	brcc	.+26     	; 0x3636 <memmove+0x20>
    361c:	fb 01       	movw	r30, r22
    361e:	dc 01       	movw	r26, r24
    3620:	e4 0f       	add	r30, r20
    3622:	f5 1f       	adc	r31, r21
    3624:	a4 0f       	add	r26, r20
    3626:	b5 1f       	adc	r27, r21
    3628:	02 c0       	rjmp	.+4      	; 0x362e <memmove+0x18>
    362a:	02 90       	ld	r0, -Z
    362c:	0e 92       	st	-X, r0
    362e:	41 50       	subi	r20, 0x01	; 1
    3630:	50 40       	sbci	r21, 0x00	; 0
    3632:	d8 f7       	brcc	.-10     	; 0x362a <memmove+0x14>
    3634:	08 95       	ret
    3636:	0c 94 02 1b 	jmp	0x3604	; 0x3604 <memcpy>

0000363a <__eerd_block_m6450a>:
    363a:	dc 01       	movw	r26, r24
    363c:	cb 01       	movw	r24, r22

0000363e <__eerd_blraw_m6450a>:
    363e:	fc 01       	movw	r30, r24
    3640:	f9 99       	sbic	0x1f, 1	; 31
    3642:	fe cf       	rjmp	.-4      	; 0x3640 <__eerd_blraw_m6450a+0x2>
    3644:	06 c0       	rjmp	.+12     	; 0x3652 <__eerd_blraw_m6450a+0x14>
    3646:	f2 bd       	out	0x22, r31	; 34
    3648:	e1 bd       	out	0x21, r30	; 33
    364a:	f8 9a       	sbi	0x1f, 0	; 31
    364c:	31 96       	adiw	r30, 0x01	; 1
    364e:	00 b4       	in	r0, 0x20	; 32
    3650:	0d 92       	st	X+, r0
    3652:	41 50       	subi	r20, 0x01	; 1
    3654:	50 40       	sbci	r21, 0x00	; 0
    3656:	b8 f7       	brcc	.-18     	; 0x3646 <__eerd_blraw_m6450a+0x8>
    3658:	08 95       	ret

0000365a <__eerd_word_m6450a>:
    365a:	a8 e1       	ldi	r26, 0x18	; 24
    365c:	b0 e0       	ldi	r27, 0x00	; 0
    365e:	42 e0       	ldi	r20, 0x02	; 2
    3660:	50 e0       	ldi	r21, 0x00	; 0
    3662:	0c 94 1f 1b 	jmp	0x363e	; 0x363e <__eerd_blraw_m6450a>

00003666 <__eeupd_block_m6450a>:
    3666:	dc 01       	movw	r26, r24
    3668:	a4 0f       	add	r26, r20
    366a:	b5 1f       	adc	r27, r21
    366c:	41 50       	subi	r20, 0x01	; 1
    366e:	50 40       	sbci	r21, 0x00	; 0
    3670:	48 f0       	brcs	.+18     	; 0x3684 <__eeupd_block_m6450a+0x1e>
    3672:	cb 01       	movw	r24, r22
    3674:	84 0f       	add	r24, r20
    3676:	95 1f       	adc	r25, r21
    3678:	2e 91       	ld	r18, -X
    367a:	0e 94 44 1b 	call	0x3688	; 0x3688 <__eeupd_r18_m6450a>
    367e:	41 50       	subi	r20, 0x01	; 1
    3680:	50 40       	sbci	r21, 0x00	; 0
    3682:	d0 f7       	brcc	.-12     	; 0x3678 <__eeupd_block_m6450a+0x12>
    3684:	08 95       	ret

00003686 <__eeupd_byte_m6450a>:
    3686:	26 2f       	mov	r18, r22

00003688 <__eeupd_r18_m6450a>:
    3688:	f9 99       	sbic	0x1f, 1	; 31
    368a:	fe cf       	rjmp	.-4      	; 0x3688 <__eeupd_r18_m6450a>
    368c:	92 bd       	out	0x22, r25	; 34
    368e:	81 bd       	out	0x21, r24	; 33
    3690:	f8 9a       	sbi	0x1f, 0	; 31
    3692:	01 97       	sbiw	r24, 0x01	; 1
    3694:	00 b4       	in	r0, 0x20	; 32
    3696:	02 16       	cp	r0, r18
    3698:	31 f0       	breq	.+12     	; 0x36a6 <__eeupd_r18_m6450a+0x1e>
    369a:	20 bd       	out	0x20, r18	; 32
    369c:	0f b6       	in	r0, 0x3f	; 63
    369e:	f8 94       	cli
    36a0:	fa 9a       	sbi	0x1f, 2	; 31
    36a2:	f9 9a       	sbi	0x1f, 1	; 31
    36a4:	0f be       	out	0x3f, r0	; 63
    36a6:	08 95       	ret

000036a8 <__eeupd_word_m6450a>:
    36a8:	01 96       	adiw	r24, 0x01	; 1
    36aa:	27 2f       	mov	r18, r23
    36ac:	0e 94 44 1b 	call	0x3688	; 0x3688 <__eeupd_r18_m6450a>
    36b0:	0c 94 43 1b 	jmp	0x3686	; 0x3686 <__eeupd_byte_m6450a>

000036b4 <_exit>:
    36b4:	f8 94       	cli

000036b6 <__stop_program>:
    36b6:	ff cf       	rjmp	.-2      	; 0x36b6 <__stop_program>
